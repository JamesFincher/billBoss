ding
                for (const [key, value] of response.headers){
                    if (!actionsForbiddenHeaders.includes(key)) {
                        res.setHeader(key, value);
                    }
                }
                return new FlightRenderResult(response.body);
            } else {
                var // Since we aren't consuming the response body, we cancel it to avoid memory leaks
                _response_body;
                (_response_body = response.body) == null ? void 0 : _response_body.cancel();
            }
        } catch (err) {
            // we couldn't stream the redirect response, so we'll just do a normal redirect
            console.error(`failed to get redirect response`, err);
        }
    }
    return RenderResult.fromStatic("{}");
}
var HostType;
/**
 * Ensures the value of the header can't create long logs.
 */ function limitUntrustedHeaderValueForLogs(value) {
    return value.length > 100 ? value.slice(0, 100) + "..." : value;
}
export async function handleAction({ req, res, ComponentMod, serverModuleMap, generateFlight, staticGenerationStore, requestStore, serverActions, ctx }) {
    const contentType = req.headers["content-type"];
    const { serverActionsManifest, page } = ctx.renderOpts;
    const { actionId, isURLEncodedAction, isMultipartAction, isFetchAction, isServerAction } = getServerActionRequestMetadata(req);
    // If it's not a Server Action, skip handling.
    if (!isServerAction) {
        return;
    }
    if (staticGenerationStore.isStaticGeneration) {
        throw new Error("Invariant: server actions can't be handled during static rendering");
    }
    // When running actions the default is no-store, you can still `cache: 'force-cache'`
    staticGenerationStore.fetchCache = "default-no-store";
    const originDomain = typeof req.headers["origin"] === "string" ? new URL(req.headers["origin"]).host : undefined;
    const forwardedHostHeader = req.headers["x-forwarded-host"];
    const hostHeader = req.headers["host"];
    const host = forwardedHostHeader ? {
        type: "x-forwarded-host",
        value: forwardedHostHeader
    } : hostHeader ? {
        type: "host",
        value: hostHeader
    } : undefined;
    let warning = undefined;
    function warnBadServerActionRequest() {
        if (warning) {
            warn(warning);
        }
    }
    // This is to prevent CSRF attacks. If `x-forwarded-host` is set, we need to
    // ensure that the request is coming from the same host.
    if (!originDomain) {
        // This might be an old browser that doesn't send `host` header. We ignore
        // this case.
        warning = "Missing `origin` header from a forwarded Server Actions request.";
    } else if (!host || originDomain !== host.value) {
        // If the customer sets a list of allowed origins, we'll allow the request.
        // These are considered safe but might be different from forwarded host set
        // by the infra (i.e. reverse proxies).
        if (isCsrfOriginAllowed(originDomain, serverActions == null ? void 0 : serverActions.allowedOrigins)) {
        // Ignore it
        } else {
            if (host) {
                // This seems to be an CSRF attack. We should not proceed the action.
                console.error(`\`${host.type}\` header with value \`${limitUntrustedHeaderValueForLogs(host.value)}\` does not match \`origin\` header with value \`${limitUntrustedHeaderValueForLogs(originDomain)}\` from a forwarded Server Actions request. Aborting the action.`);
            } else {
                // This is an attack. We should not proceed the action.
                console.error(`\`x-forwarded-host\` or \`host\` headers are not provided. One of these is needed to compare the \`origin\` header from a forwarded Server Actions request. Aborting the action.`);
            }
            const error = new Error("Invalid Server Actions request.");
            if (isFetchAction) {
                res.statusCode = 500;
                await Promise.all(Object.values(staticGenerationStore.pendingRevalidates || []));
                const promise = Promise.reject(error);
                try {
                    // we need to await the promise to trigger the rejection early
                    // so that it's already handled by the time we call
                    // the RSC runtime. Otherwise, it will throw an unhandled
                    // promise rejection error in the renderer.
                    await promise;
                } catch  {
                // swallow error, it's gonna be handled on the client
                }
                return {
                    type: "done",
                    result: await generateFlight(ctx, {
                        actionResult: promise,
                        // if the page was not revalidated, we can skip the rendering the flight tree
                        skipFlight: !staticGenerationStore.pathWasRevalidated
                    })
                };
            }
            throw error;
        }
    }
    // ensure we avoid caching server actions unexpectedly
    res.setHeader("Cache-Control", "no-cache, no-store, max-age=0, must-revalidate");
    let bound = [];
    const { actionAsyncStorage } = ComponentMod;
    let actionResult;
    let formState;
    let actionModId;
    const actionWasForwarded = Boolean(req.headers["x-action-forwarded"]);
    if (actionId) {
        const forwardedWorker = selectWorkerForForwarding(actionId, page, serverActionsManifest);
        // If forwardedWorker is truthy, it means there isn't a worker for the action
        // in the current handler, so we forward the request to a worker that has the action.
        if (forwardedWorker) {
            return {
                type: "done",
                result: await createForwardedActionResponse(req, res, host, forwardedWorker, ctx.renderOpts.basePath, staticGenerationStore)
            };
        }
    }
    try {
        await actionAsyncStorage.run({
            isAction: true
        }, async ()=>{
            if (process.env.NEXT_RUNTIME === "edge") {
                // Use react-server-dom-webpack/server.edge
                const { decodeReply, decodeAction, decodeFormState } = ComponentMod;
                const webRequest = req;
                if (!webRequest.body) {
                    throw new Error("invariant: Missing request body.");
                }
                if (isMultipartAction) {
                    // TODO-APP: Add streaming support
                    const formData = await webRequest.request.formData();
                    if (isFetchAction) {
                        bound = await decodeReply(formData, serverModuleMap);
                    } else {
                        const action = await decodeAction(formData, serverModuleMap);
                        if (typeof action === "function") {
                            // Only warn if it's a server action, otherwise skip for other post requests
                            warnBadServerActionRequest();
                            const actionReturnedState = await action();
                            formState = decodeFormState(actionReturnedState, formData);
                        }
                        // Skip the fetch path
                        return;
                    }
                } else {
                    try {
                        actionModId = getActionModIdOrError(actionId, serverModuleMap);
                    } catch (err) {
                        if (actionId !== null) {
                            console.error(err);
                        }
                        return {
                            type: "not-found"
                        };
                    }
                    let actionData = "";
                    const reader = webRequest.body.getReader();
                    while(true){
                        const { done, value } = await reader.read();
                        if (done) {
                            break;
                        }
                        actionData += new TextDecoder().decode(value);
                    }
                    if (isURLEncodedAction) {
                        const formData = formDataFromSearchQueryString(actionData);
                        bound = await decodeReply(formData, serverModuleMap);
                    } else {
                        bound = await decodeReply(actionData, serverModuleMap);
                    }
                }
            } else {
                // Use react-server-dom-webpack/server.node which supports streaming
                const { decodeReply, decodeReplyFromBusboy, decodeAction, decodeFormState } = require(`./react-server.node`);
                if (isMultipartAction) {
                    if (isFetchAction) {
                        const readableLimit = (serverActions == null ? void 0 : serverActions.bodySizeLimit) ?? "1 MB";
                        const limit = require("next/dist/compiled/bytes").parse(readableLimit);
                        const busboy = require("busboy");
                        const bb = busboy({
                            headers: req.headers,
                            limits: {
                                fieldSize: limit
                            }
                        });
                        req.pipe(bb);
                        bound = await decodeReplyFromBusboy(bb, serverModuleMap);
                    } else {
                        // Convert the Node.js readable stream to a Web Stream.
                        const readableStream = new ReadableStream({
                            start (controller) {
                                req.on("data", (chunk)=>{
                                    controller.enqueue(new Uint8Array(chunk));
                                });
                                req.on("end", ()=>{
                                    controller.close();
                                });
                                req.on("error", (err)=>{
                                    controller.error(err);
                                });
                            }
                        });
                        // React doesn't yet publish a busboy version of decodeAction
                        // so we polyfill the parsing of FormData.
                        const fakeRequest = new Request("http://localhost", {
                            method: "POST",
                            // @ts-expect-error
                            headers: {
                                "Content-Type": contentType
                            },
                            body: readableStream,
                            duplex: "half"
                        });
                        const formData = await fakeRequest.formData();
                        const action = await decodeAction(formData, serverModuleMap);
                        if (typeof action === "function") {
                            // Only warn if it's a server action, otherwise skip for other post requests
                            warnBadServerActionRequest();
                            const actionReturnedState = await action();
                            formState = await decodeFormState(actionReturnedState, formData);
                        }
                        // Skip the fetch path
                        return;
                    }
                } else {
                    try {
                        actionModId = getActionModIdOrError(actionId, serverModuleMap);
                    } catch (err) {
                        if (actionId !== null) {
                            console.error(err);
                        }
                        return {
                            type: "not-found"
                        };
                    }
                    const chunks = [];
                    for await (const chunk of req){
                        chunks.push(Buffer.from(chunk));
                    }
                    const actionData = Buffer.concat(chunks).toString("utf-8");
                    const readableLimit = (serverActions == null ? void 0 : serverActions.bodySizeLimit) ?? "1 MB";
                    const limit = require("next/dist/compiled/bytes").parse(readableLimit);
                    if (actionData.length > limit) {
                        const { ApiError } = require("../api-utils");
                        throw new ApiError(413, `Body exceeded ${readableLimit} limit.
To configure the body size limit for Server Actions, see: https://nextjs.org/docs/app/api-reference/next-config-js/serverActions#bodysizelimit`);
                    }
                    if (isURLEncodedAction) {
                        const formData = formDataFromSearchQueryString(actionData);
                        bound = await decodeReply(formData, serverModuleMap);
                    } else {
                        bound = await decodeReply(actionData, serverModuleMap);
                    }
                }
            }
            // actions.js
            // app/page.js
            //   action worker1
            //     appRender1
            // app/foo/page.js
            //   action worker2
            //     appRender
            // / -> fire action -> POST / -> appRender1 -> modId for the action file
            // /foo -> fire action -> POST /foo -> appRender2 -> modId for the action file
            try {
                actionModId = actionModId ?? getActionModIdOrError(actionId, serverModuleMap);
            } catch (err) {
                if (actionId !== null) {
                    console.error(err);
                }
                return {
                    type: "not-found"
                };
            }
            const actionHandler = (await ComponentMod.__next_app__.require(actionModId))[// `actionId` must exist if we got here, as otherwise we would have thrown an error above
            actionId];
            const returnVal = await actionHandler.apply(null, bound);
            // For form actions, we need to continue rendering the page.
            if (isFetchAction) {
                await addRevalidationHeader(res, {
                    staticGenerationStore,
                    requestStore
                });
                actionResult = await generateFlight(ctx, {
                    actionResult: Promise.resolve(returnVal),
                    // if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree
                    skipFlight: !staticGenerationStore.pathWasRevalidated || actionWasForwarded
                });
            }
        });
        return {
            type: "done",
            result: actionResult,
            formState
        };
    } catch (err) {
        if (isRedirectError(err)) {
            const redirectUrl = getURLFromRedirectError(err);
            const statusCode = getRedirectStatusCodeFromError(err);
            await addRevalidationHeader(res, {
                staticGenerationStore,
                requestStore
            });
            // if it's a fetch action, we'll set the status code for logging/debugging purposes
            // but we won't set a Location header, as the redirect will be handled by the client router
            res.statusCode = statusCode;
            if (isFetchAction) {
                return {
                    type: "done",
                    result: await createRedirectRenderResult(req, res, host, redirectUrl, ctx.renderOpts.basePath, staticGenerationStore)
                };
            }
            if (err.mutableCookies) {
                const headers = new Headers();
                // If there were mutable cookies set, we need to set them on the
                // response.
                if (appendMutableCookies(headers, err.mutableCookies)) {
                    res.setHeader("set-cookie", Array.from(headers.values()));
                }
            }
            res.setHeader("Location", redirectUrl);
            return {
                type: "done",
                result: RenderResult.fromStatic("")
            };
        } else if (isNotFoundError(err)) {
            res.statusCode = 404;
            await addRevalidationHeader(res, {
                staticGenerationStore,
                requestStore
            });
            if (isFetchAction) {
                const promise = Promise.reject(err);
                try {
                    // we need to await the promise to trigger the rejection early
                    // so that it's already handled by the time we call
                    // the RSC runtime. Otherwise, it will throw an unhandled
                    // promise rejection error in the renderer.
                    await promise;
                } catch  {
                // swallow error, it's gonna be handled on the client
                }
                return {
                    type: "done",
                    result: await generateFlight(ctx, {
                        skipFlight: false,
                        actionResult: promise,
                        asNotFound: true
                    })
                };
            }
            return {
                type: "not-found"
            };
        }
        if (isFetchAction) {
            res.statusCode = 500;
            await Promise.all(Object.values(staticGenerationStore.pendingRevalidates || []));
            const promise = Promise.reject(err);
            try {
                // we need to await the promise to trigger the rejection early
                // so that it's already handled by the time we call
                // the RSC runtime. Otherwise, it will throw an unhandled
                // promise rejection error in the renderer.
                await promise;
            } catch  {
            // swallow error, it's gonna be handled on the client
            }
            return {
                type: "done",
                result: await generateFlight(ctx, {
                    actionResult: promise,
                    // if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree
                    skipFlight: !staticGenerationStore.pathWasRevalidated || actionWasForwarded
                })
            };
        }
        throw err;
    }
}
/**
 * Attempts to find the module ID for the action from the module map. When this fails, it could be a deployment skew where
 * the action came from a different deployment. It could also simply be an invalid POST request that is not a server action.
 * In either case, we'll throw an error to be handled by the caller.
 */ function getActionModIdOrError(actionId, serverModuleMap) {
    try {
        var _serverModuleMap_actionId;
        // if we're missing the action ID header, we can't do any further processing
        if (!actionId) {
            throw new Error("Invariant: Missing 'next-action' header.");
        }
        const actionModId = serverModuleMap == null ? void 0 : (_serverModuleMap_actionId = serverModuleMap[actionId]) == null ? void 0 : _serverModuleMap_actionId.id;
        if (!actionModId) {
            throw new Error("Invariant: Couldn't find action module ID from module map.");
        }
        return actionModId;
    } catch (err) {
        throw new Error(`Failed to find Server Action "${actionId}". This request might be from an older or newer deployment. ${err instanceof Error ? `Original error: ${err.message}` : ""}`);
    }
}

//# sourceMappingURL=action-handler.js.map  // Provider for the `useServerInsertedHTML` API to register callbacks to insert
// elements into the HTML stream.
import { jsx as _jsx } from "react/jsx-runtime";
import React from "react";
import { ServerInsertedHTMLContext } from "../../shared/lib/server-inserted-html.shared-runtime";
export function createServerInsertedHTML() {
    const serverInsertedHTMLCallbacks = [];
    const addInsertedHtml = (handler)=>{
        serverInsertedHTMLCallbacks.push(handler);
    };
    return {
        ServerInsertedHTMLProvider ({ children }) {
            return /*#__PURE__*/ _jsx(ServerInsertedHTMLContext.Provider, {
                value: addInsertedHtml,
                children: children
            });
        },
        renderServerInsertedHTML () {
            return serverInsertedHTMLCallbacks.map((callback, index)=>/*#__PURE__*/ _jsx(React.Fragment, {
                    children: callback()
                }, "__next_server_inserted__" + index));
        }
    };
}

//# sourceMappingURL=server-inserted-html.js.map:  import { encodeURIPath } from "../../shared/lib/encode-uri-path";
import ReactDOM from "react-dom";
export function getRequiredScripts(buildManifest, assetPrefix, crossOrigin, SRIManifest, qs, nonce) {
    let preinitScripts;
    let preinitScriptCommands = [];
    const bootstrapScript = {
        src: "",
        crossOrigin
    };
    const files = buildManifest.rootMainFiles.map(encodeURIPath);
    if (files.length === 0) {
        throw new Error("Invariant: missing bootstrap script. This is a bug in Next.js");
    }
    if (SRIManifest) {
        bootstrapScript.src = `${assetPrefix}/_next/` + files[0] + qs;
        bootstrapScript.integrity = SRIManifest[files[0]];
        for(let i = 1; i < files.length; i++){
            const src = `${assetPrefix}/_next/` + files[i] + qs;
            const integrity = SRIManifest[files[i]];
            preinitScriptCommands.push(src, integrity);
        }
        preinitScripts = ()=>{
            // preinitScriptCommands is a double indexed array of src/integrity pairs
            for(let i = 0; i < preinitScriptCommands.length; i += 2){
                ReactDOM.preinit(preinitScriptCommands[i], {
                    as: "script",
                    integrity: preinitScriptCommands[i + 1],
                    crossOrigin,
                    nonce
                });
            }
        };
    } else {
        bootstrapScript.src = `${assetPrefix}/_next/` + files[0] + qs;
        for(let i = 1; i < files.length; i++){
            const src = `${assetPrefix}/_next/` + files[i] + qs;
            preinitScriptCommands.push(src);
        }
        preinitScripts = ()=>{
            // preinitScriptCommands is a singled indexed array of src values
            for(let i = 0; i < preinitScriptCommands.length; i++){
                ReactDOM.preinit(preinitScriptCommands[i], {
                    as: "script",
                    nonce,
                    crossOrigin
                });
            }
        };
    }
    return [
        preinitScripts,
        bootstrapScript
    ];
}

//# sourceMappingURL=required-scripts.js.map  import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React from "react";
import { isNotFoundError } from "../../client/components/not-found";
import { getURLFromRedirectError, isRedirectError, getRedirectStatusCodeFromError } from "../../client/components/redirect";
import { renderToReadableStream } from "react-dom/server.edge";
import { streamToString } from "../stream-utils/node-web-streams-helper";
import { RedirectStatusCode } from "../../client/components/redirect-status-code";
import { addPathPrefix } from "../../shared/lib/router/utils/add-path-prefix";
export function makeGetServerInsertedHTML({ polyfills, renderServerInsertedHTML, serverCapturedErrors, basePath }) {
    let flushedErrorMetaTagsUntilIndex = 0;
    let hasUnflushedPolyfills = polyfills.length !== 0;
    return async function getServerInsertedHTML() {
        // Loop through all the errors that have been captured but not yet
        // flushed.
        const errorMetaTags = [];
        while(flushedErrorMetaTagsUntilIndex < serverCapturedErrors.length){
            const error = serverCapturedErrors[flushedErrorMetaTagsUntilIndex];
            flushedErrorMetaTagsUntilIndex++;
            if (isNotFoundError(error)) {
                errorMetaTags.push(/*#__PURE__*/ _jsx("meta", {
                    name: "robots",
                    content: "noindex"
                }, error.digest), process.env.NODE_ENV === "development" ? /*#__PURE__*/ _jsx("meta", {
                    name: "next-error",
                    content: "not-found"
                }, "next-error") : null);
            } else if (isRedirectError(error)) {
                const redirectUrl = addPathPrefix(getURLFromRedirectError(error), basePath);
                const statusCode = getRedirectStatusCodeFromError(error);
                const isPermanent = statusCode === RedirectStatusCode.PermanentRedirect ? true : false;
                if (redirectUrl) {
                    errorMetaTags.push(/*#__PURE__*/ _jsx("meta", {
                        id: "__next-page-redirect",
                        httpEquiv: "refresh",
                        content: `${isPermanent ? 0 : 1};url=${redirectUrl}`
                    }, error.digest));
                }
            }
        }
        const serverInsertedHTML = renderServerInsertedHTML();
        // Skip React rendering if we know the content is empty.
        if (!hasUnflushedPolyfills && errorMetaTags.length === 0 && Array.isArray(serverInsertedHTML) && serverInsertedHTML.length === 0) {
            return "";
        }
        const stream = await renderToReadableStream(/*#__PURE__*/ _jsxs(_Fragment, {
            children: [
                /* Insert the polyfills if they haven't been flushed yet. */ hasUnflushedPolyfills && polyfills.map((polyfill)=>{
                    return /*#__PURE__*/ _jsx("script", {
                        ...polyfill
                    }, polyfill.src);
                }),
                serverInsertedHTML,
                errorMetaTags
            ]
        }), {
            // Larger chunk because this isn't sent over the network.
            // Let's set it to 1MB.
            progressiveChunkSize: 1024 * 1024
        });
        hasUnflushedPolyfills = false;
        // There's no need to wait for the stream to be ready
        // e.g. calling `await stream.allReady` because `streamToString` will
        // wait and decode the stream progressively with better parallelism.
        return streamToString(stream);
    };
}

//# sourceMappingURL=make-get-server-inserted-html.js.mapu  /**
 * Get external stylesheet link hrefs based on server CSS manifest.
 */ export function getLinkAndScriptTags(clientReferenceManifest, filePath, injectedCSS, injectedScripts, collectNewImports) {
    var _clientReferenceManifest_entryJSFiles;
    const filePathWithoutExt = filePath.replace(/\.[^.]+$/, "");
    const cssChunks = new Set();
    const jsChunks = new Set();
    const entryCSSFiles = clientReferenceManifest.entryCSSFiles[filePathWithoutExt];
    const entryJSFiles = ((_clientReferenceManifest_entryJSFiles = clientReferenceManifest.entryJSFiles) == null ? void 0 : _clientReferenceManifest_entryJSFiles[filePathWithoutExt]) ?? [];
    if (entryCSSFiles) {
        for (const file of entryCSSFiles){
            if (!injectedCSS.has(file)) {
                if (collectNewImports) {
                    injectedCSS.add(file);
                }
                cssChunks.add(file);
            }
        }
    }
    if (entryJSFiles) {
        for (const file of entryJSFiles){
            if (!injectedScripts.has(file)) {
                if (collectNewImports) {
                    injectedScripts.add(file);
                }
                jsChunks.add(file);
            }
        }
    }
    return {
        styles: [
            ...cssChunks
        ],
        scripts: [
            ...jsChunks
        ]
    };
}

//# sourceMappingURL=get-css-inlined-link-tags.js.map  /**
 * Get hrefs for fonts to preload
 * Returns null if there are no fonts at all.
 * Returns string[] if there are fonts to preload (font paths)
 * Returns empty string[] if there are fonts but none to preload and no other fonts have been preloaded
 * Returns null if there are fonts but none to preload and at least some were previously preloaded
 */ export function getPreloadableFonts(nextFontManifest, filePath, injectedFontPreloadTags) {
    if (!nextFontManifest || !filePath) {
        return null;
    }
    const filepathWithoutExtension = filePath.replace(/\.[^.]+$/, "");
    const fontFiles = new Set();
    let foundFontUsage = false;
    const preloadedFontFiles = nextFontManifest.app[filepathWithoutExtension];
    if (preloadedFontFiles) {
        foundFontUsage = true;
        for (const fontFile of preloadedFontFiles){
            if (!injectedFontPreloadTags.has(fontFile)) {
                fontFiles.add(fontFile);
                injectedFontPreloadTags.add(fontFile);
            }
        }
    }
    if (fontFiles.size) {
        return [
            ...fontFiles
        ].sort();
    } else if (foundFontUsage && injectedFontPreloadTags.size === 0) {
        return [];
    } else {
        return null;
    }
}

//# sourceMappingURL=get-preloadable-fonts.js.mapÊ  import { DEFAULT_SEGMENT_KEY } from "../../shared/lib/segment";
export function parseLoaderTree(tree) {
    const [segment, parallelRoutes, components] = tree;
    const { layout } = components;
    let { page } = components;
    // a __DEFAULT__ segment means that this route didn't match any of the
    // segments in the route, so we should use the default page
    page = segment === DEFAULT_SEGMENT_KEY ? components.defaultPage : page;
    const layoutOrPagePath = (layout == null ? void 0 : layout[1]) || (page == null ? void 0 : page[1]);
    return {
        page,
        segment,
        components,
        layoutOrPagePath,
        parallelRoutes
    };
}

//# sourceMappingURL=parse-loader-tree.js.mapÑ  const isDev = process.env.NODE_ENV === "development";
const isTurbopack = !!process.env.TURBOPACK;
export function getAssetQueryString(ctx, addTimestamp) {
    let qs = "";
    // In development we add the request timestamp to allow react to
    // reload assets when a new RSC response is received.
    // Turbopack handles HMR of assets itself and react doesn't need to reload them
    // so this approach is not needed for Turbopack.
    if (isDev && !isTurbopack && addTimestamp) {
        qs += `?v=${ctx.requestTimestamp}`;
    }
    if (ctx.renderOpts.deploymentId) {
        qs += `${isDev ? "&" : "?"}dpl=${ctx.renderOpts.deploymentId}`;
    }
    return qs;
}

//# sourceMappingURL=get-asset-query-string.js.map   import { jsx as _jsx } from "react/jsx-runtime";
import React from "react";
import { getLinkAndScriptTags } from "./get-css-inlined-link-tags";
import { getPreloadableFonts } from "./get-preloadable-fonts";
import { getAssetQueryString } from "./get-asset-query-string";
import { encodeURIPath } from "../../shared/lib/encode-uri-path";
export function getLayerAssets({ ctx, layoutOrPagePath, injectedCSS: injectedCSSWithCurrentLayout, injectedJS: injectedJSWithCurrentLayout, injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout }) {
    const { styles: styleTags, scripts: scriptTags } = layoutOrPagePath ? getLinkAndScriptTags(ctx.clientReferenceManifest, layoutOrPagePath, injectedCSSWithCurrentLayout, injectedJSWithCurrentLayout, true) : {
        styles: [],
        scripts: []
    };
    const preloadedFontFiles = layoutOrPagePath ? getPreloadableFonts(ctx.renderOpts.nextFontManifest, layoutOrPagePath, injectedFontPreloadTagsWithCurrentLayout) : null;
    if (preloadedFontFiles) {
        if (preloadedFontFiles.length) {
            for(let i = 0; i < preloadedFontFiles.length; i++){
                const fontFilename = preloadedFontFiles[i];
                const ext = /\.(woff|woff2|eot|ttf|otf)$/.exec(fontFilename)[1];
                const type = `font/${ext}`;
                const href = `${ctx.assetPrefix}/_next/${encodeURIPath(fontFilename)}`;
                ctx.componentMod.preloadFont(href, type, ctx.renderOpts.crossOrigin);
            }
        } else {
            try {
                let url = new URL(ctx.assetPrefix);
                ctx.componentMod.preconnect(url.origin, "anonymous");
            } catch (error) {
                // assetPrefix must not be a fully qualified domain name. We assume
                // we should preconnect to same origin instead
                ctx.componentMod.preconnect("/", "anonymous");
            }
        }
    }
    const styles = styleTags ? styleTags.map((href, index)=>{
        // In dev, Safari and Firefox will cache the resource during HMR:
        // - https://github.com/vercel/next.js/issues/5860
        // - https://bugs.webkit.org/show_bug.cgi?id=187726
        // Because of this, we add a `?v=` query to bypass the cache during
        // development. We need to also make sure that the number is always
        // increasing.
        const fullHref = `${ctx.assetPrefix}/_next/${encodeURIPath(href)}${getAssetQueryString(ctx, true)}`;
        // `Precedence` is an opt-in signal for React to handle resource
        // loading and deduplication, etc. It's also used as the key to sort
        // resources so they will be injected in the correct order.
        // During HMR, it's critical to use different `precedence` values
        // for different stylesheets, so their order will be kept.
        // https://github.com/facebook/react/pull/25060
        const precedence = process.env.NODE_ENV === "development" ? "next_" + href : "next";
        ctx.componentMod.preloadStyle(fullHref, ctx.renderOpts.crossOrigin);
        return /*#__PURE__*/ _jsx("link", {
            rel: "stylesheet",
            href: fullHref,
            // @ts-ignore
            precedence: precedence,
            crossOrigin: ctx.renderOpts.crossOrigin
        }, index);
    }) : [];
    const scripts = scriptTags ? scriptTags.map((href, index)=>{
        const fullSrc = `${ctx.assetPrefix}/_next/${encodeURIPath(href)}${getAssetQueryString(ctx, true)}`;
        return /*#__PURE__*/ _jsx("script", {
            src: fullSrc,
            async: true
        }, `script-${index}`);
    }) : [];
    return styles.length || scripts.length ? [
        ...styles,
        ...scripts
    ] : null;
}

//# sourceMappingURL=get-layer-assets.js.map8  export function hasLoadingComponentInTree(tree) {
    const [, parallelRoutes, { loading }] = tree;
    if (loading) {
        return true;
    }
    return Object.values(parallelRoutes).some((parallelRoute)=>hasLoadingComponentInTree(parallelRoute));
}

//# sourceMappingURL=has-loading-component-in-tree.js.mapµ   /**
 * Interop between "export default" and "module.exports".
 */ export function interopDefault(mod) {
    return mod.default || mod;
}

//# sourceMappingURL=interop-default.js.map~  import { jsx as _jsx } from "react/jsx-runtime";
import React from "react";
import { interopDefault } from "./interop-default";
import { getLinkAndScriptTags } from "./get-css-inlined-link-tags";
import { getAssetQueryString } from "./get-asset-query-string";
import { encodeURIPath } from "../../shared/lib/encode-uri-path";
export async function createComponentStylesAndScripts({ filePath, getComponent, injectedCSS, injectedJS, ctx }) {
    const { styles: cssHrefs, scripts: jsHrefs } = getLinkAndScriptTags(ctx.clientReferenceManifest, filePath, injectedCSS, injectedJS);
    const styles = cssHrefs ? cssHrefs.map((href, index)=>{
        const fullHref = `${ctx.assetPrefix}/_next/${encodeURIPath(href)}${getAssetQueryString(ctx, true)}`;
        // `Precedence` is an opt-in signal for React to handle resource
        // loading and deduplication, etc. It's also used as the key to sort
        // resources so they will be injected in the correct order.
        // During HMR, it's critical to use different `precedence` values
        // for different stylesheets, so their order will be kept.
        // https://github.com/facebook/react/pull/25060
        const precedence = process.env.NODE_ENV === "development" ? "next_" + href : "next";
        return /*#__PURE__*/ _jsx("link", {
            rel: "stylesheet",
            href: fullHref,
            // @ts-ignore
            precedence: precedence,
            crossOrigin: ctx.renderOpts.crossOrigin
        }, index);
    }) : null;
    const scripts = jsHrefs ? jsHrefs.map((href)=>/*#__PURE__*/ _jsx("script", {
            src: `${ctx.assetPrefix}/_next/${encodeURIPath(href)}${getAssetQueryString(ctx, true)}`,
            async: true
        })) : null;
    const Comp = interopDefault(await getComponent());
    return [
        Comp,
        styles,
        scripts
    ];
}

//# sourceMappingURL=create-component-styles-and-scripts.js.map
Z  import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React from "react";
import { isClientReference } from "../../lib/client-reference";
import { getLayoutOrPageModule } from "../lib/app-dir-module";
import { interopDefault } from "./interop-default";
import { parseLoaderTree } from "./parse-loader-tree";
import { createComponentStylesAndScripts } from "./create-component-styles-and-scripts";
import { getLayerAssets } from "./get-layer-assets";
import { hasLoadingComponentInTree } from "./has-loading-component-in-tree";
import { validateRevalidate } from "../lib/patch-fetch";
import { PARALLEL_ROUTE_DEFAULT_PATH } from "../../client/components/parallel-route-default";
import { getTracer } from "../lib/trace/tracer";
import { NextNodeServerSpan } from "../lib/trace/constants";
import { StaticGenBailoutError } from "../../client/components/static-generation-bailout";
/**
 * Use the provided loader tree to create the React Component tree.
 */ export function createComponentTree(props) {
    return getTracer().trace(NextNodeServerSpan.createComponentTree, {
        spanName: "build component tree"
    }, ()=>createComponentTreeInternal(props));
}
async function createComponentTreeInternal({ createSegmentPath, loaderTree: tree, parentParams, firstItem, rootLayoutIncluded, injectedCSS, injectedJS, injectedFontPreloadTags, asNotFound, metadataOutlet, ctx, missingSlots }) {
    const { renderOpts: { nextConfigOutput, experimental }, staticGenerationStore, componentMod: { NotFoundBoundary, LayoutRouter, RenderFromTemplateContext, ClientPageRoot, createUntrackedSearchParams, createDynamicallyTrackedSearchParams, serverHooks: { DynamicServerError }, Postpone }, pagePath, getDynamicParamFromSegment, isPrefetch, query } = ctx;
    const { page, layoutOrPagePath, segment, components, parallelRoutes } = parseLoaderTree(tree);
    const { layout, template, error, loading, "not-found": notFound } = components;
    const injectedCSSWithCurrentLayout = new Set(injectedCSS);
    const injectedJSWithCurrentLayout = new Set(injectedJS);
    const injectedFontPreloadTagsWithCurrentLayout = new Set(injectedFontPreloadTags);
    const layerAssets = getLayerAssets({
        ctx,
        layoutOrPagePath,
        injectedCSS: injectedCSSWithCurrentLayout,
        injectedJS: injectedJSWithCurrentLayout,
        injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout
    });
    const [Template, templateStyles, templateScripts] = template ? await createComponentStylesAndScripts({
        ctx,
        filePath: template[1],
        getComponent: template[0],
        injectedCSS: injectedCSSWithCurrentLayout,
        injectedJS: injectedJSWithCurrentLayout
    }) : [
        React.Fragment
    ];
    const [ErrorComponent, errorStyles, errorScripts] = error ? await createComponentStylesAndScripts({
        ctx,
        filePath: error[1],
        getComponent: error[0],
        injectedCSS: injectedCSSWithCurrentLayout,
        injectedJS: injectedJSWithCurrentLayout
    }) : [];
    const [Loading, loadingStyles, loadingScripts] = loading ? await createComponentStylesAndScripts({
        ctx,
        filePath: loading[1],
        getComponent: loading[0],
        injectedCSS: injectedCSSWithCurrentLayout,
        injectedJS: injectedJSWithCurrentLayout
    }) : [];
    const isLayout = typeof layout !== "undefined";
    const isPage = typeof page !== "undefined";
    const [layoutOrPageMod] = await getTracer().trace(NextNodeServerSpan.getLayoutOrPageModule, {
        hideSpan: !(isLayout || isPage),
        spanName: "resolve segment modules",
        attributes: {
            "next.segment": segment
        }
    }, ()=>getLayoutOrPageModule(tree));
    /**
   * Checks if the current segment is a root layout.
   */ const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded;
    /**
   * Checks if the current segment or any level above it has a root layout.
   */ const rootLayoutIncludedAtThisLevelOrAbove = rootLayoutIncluded || rootLayoutAtThisLevel;
    const [NotFound, notFoundStyles] = notFound ? await createComponentStylesAndScripts({
        ctx,
        filePath: notFound[1],
        getComponent: notFound[0],
        injectedCSS: injectedCSSWithCurrentLayout,
        injectedJS: injectedJSWithCurrentLayout
    }) : [];
    let dynamic = layoutOrPageMod == null ? void 0 : layoutOrPageMod.dynamic;
    if (nextConfigOutput === "export") {
        if (!dynamic || dynamic === "auto") {
            dynamic = "error";
        } else if (dynamic === "force-dynamic") {
            // force-dynamic is always incompatible with 'export'. We must interrupt the build
            throw new StaticGenBailoutError(`Page with \`dynamic = "force-dynamic"\` couldn't be exported. \`output: "export"\` requires all pages be renderable statically because there is not runtime server to dynamic render routes in this output format. Learn more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports`);
        }
    }
    if (typeof dynamic === "string") {
        // the nested most config wins so we only force-static
        // if it's configured above any parent that configured
        // otherwise
        if (dynamic === "error") {
            staticGenerationStore.dynamicShouldError = true;
        } else if (dynamic === "force-dynamic") {
            staticGenerationStore.forceDynamic = true;
            // TODO: (PPR) remove this bailout once PPR is the default
            if (staticGenerationStore.isStaticGeneration && !staticGenerationStore.prerenderState) {
                // If the postpone API isn't available, we can't postpone the render and
                // therefore we can't use the dynamic API.
                const err = new DynamicServerError(`Page with \`dynamic = "force-dynamic"\` won't be rendered statically.`);
                staticGenerationStore.dynamicUsageDescription = err.message;
                staticGenerationStore.dynamicUsageStack = err.stack;
                throw err;
            }
        } else {
            staticGenerationStore.dynamicShouldError = false;
            staticGenerationStore.forceStatic = dynamic === "force-static";
        }
    }
    if (typeof (layoutOrPageMod == null ? void 0 : layoutOrPageMod.fetchCache) === "string") {
        staticGenerationStore.fetchCache = layoutOrPageMod == null ? void 0 : layoutOrPageMod.fetchCache;
    }
    if (typeof (layoutOrPageMod == null ? void 0 : layoutOrPageMod.revalidate) !== "undefined") {
        validateRevalidate(layoutOrPageMod == null ? void 0 : layoutOrPageMod.revalidate, staticGenerationStore.urlPathname);
    }
    if (typeof (layoutOrPageMod == null ? void 0 : layoutOrPageMod.revalidate) === "number") {
        ctx.defaultRevalidate = layoutOrPageMod.revalidate;
        if (typeof staticGenerationStore.revalidate === "undefined" || typeof staticGenerationStore.revalidate === "number" && staticGenerationStore.revalidate > ctx.defaultRevalidate) {
            staticGenerationStore.revalidate = ctx.defaultRevalidate;
        }
        if (!staticGenerationStore.forceStatic && staticGenerationStore.isStaticGeneration && ctx.defaultRevalidate === 0 && // If the postpone API isn't available, we can't postpone the render and
        // therefore we can't use the dynamic API.
        !staticGenerationStore.prerenderState) {
            const dynamicUsageDescription = `revalidate: 0 configured ${segment}`;
            staticGenerationStore.dynamicUsageDescription = dynamicUsageDescription;
            throw new DynamicServerError(dynamicUsageDescription);
        }
    }
    // If there's a dynamic usage error attached to the store, throw it.
    if (staticGenerationStore.dynamicUsageErr) {
        throw staticGenerationStore.dynamicUsageErr;
    }
    const LayoutOrPage = layoutOrPageMod ? interopDefault(layoutOrPageMod) : undefined;
    /**
   * The React Component to render.
   */ let Component = LayoutOrPage;
    const parallelKeys = Object.keys(parallelRoutes);
    const hasSlotKey = parallelKeys.length > 1;
    // TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`.
    // This ensures that a `NotFoundBoundary` is available for when that happens,
    // but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.
    // We should instead look into handling the fallback behavior differently in development mode so that it doesn't
    // rely on the `NotFound` behavior.
    if (hasSlotKey && rootLayoutAtThisLevel && LayoutOrPage) {
        Component = (componentProps)=>{
            const NotFoundComponent = NotFound;
            const RootLayoutComponent = LayoutOrPage;
            return /*#__PURE__*/ _jsx(NotFoundBoundary, {
                notFound: NotFoundComponent ? /*#__PURE__*/ _jsxs(_Fragment, {
                    children: [
                        layerAssets,
                        /*#__PURE__*/ _jsxs(RootLayoutComponent, {
                            params: componentProps.params,
                            children: [
                                notFoundStyles,
                                /*#__PURE__*/ _jsx(NotFoundComponent, {})
                            ]
                        })
                    ]
                }) : undefined,
                children: /*#__PURE__*/ _jsx(RootLayoutComponent, {
                    ...componentProps
                })
            });
        };
    }
    if (process.env.NODE_ENV === "development") {
        const { isValidElementType } = require("next/dist/compiled/react-is");
        if ((isPage || typeof Component !== "undefined") && !isValidElementType(Component)) {
            throw new Error(`The default export is not a React Component in page: "${pagePath}"`);
        }
        if (typeof ErrorComponent !== "undefined" && !isValidElementType(ErrorComponent)) {
            throw new Error(`The default export of error is not a React Component in page: ${segment}`);
        }
        if (typeof Loading !== "undefined" && !isValidElementType(Loading)) {
            throw new Error(`The default export of loading is not a React Component in ${segment}`);
        }
        if (typeof NotFound !== "undefined" && !isValidElementType(NotFound)) {
            throw new Error(`The default export of notFound is not a React Component in ${segment}`);
        }
    }
    // Handle dynamic segment params.
    const segmentParam = getDynamicParamFromSegment(segment);
    /**
   * Create object holding the parent params and current params
   */ const currentParams = // Handle null case where dynamic param is optional
    segmentParam && segmentParam.value !== null ? {
        ...parentParams,
        [segmentParam.param]: segmentParam.value
    } : parentParams;
    // Resolve the segment param
    const actualSegment = segmentParam ? segmentParam.treeSegment : segment;
    //
    // TODO: Combine this `map` traversal with the loop below that turns the array
    // into an object.
    const parallelRouteMap = await Promise.all(Object.keys(parallelRoutes).map(async (parallelRouteKey)=>{
        const isChildrenRouteKey = parallelRouteKey === "children";
        const currentSegmentPath = firstItem ? [
            parallelRouteKey
        ] : [
            actualSegment,
            parallelRouteKey
        ];
        const parallelRoute = parallelRoutes[parallelRouteKey];
        const notFoundComponent = NotFound && isChildrenRouteKey ? /*#__PURE__*/ _jsx(NotFound, {}) : undefined;
        // if we're prefetching and that there's a Loading component, we bail out
        // otherwise we keep rendering for the prefetch.
        // We also want to bail out if there's no Loading component in the tree.
        let currentStyles = undefined;
        let childCacheNodeSeedData = null;
        if (// Before PPR, the way instant navigations work in Next.js is we
        // prefetch everything up to the first route segment that defines a
        // loading.tsx boundary. (We do the same if there's no loading
        // boundary in the entire tree, because we don't want to prefetch too
        // much) The rest of the tree is defered until the actual navigation.
        // It does not take into account whether the data is dynamic â€” even if
        // the tree is completely static, it will still defer everything
        // inside the loading boundary.
        //
        // This behavior predates PPR and is only relevant if the
        // PPR flag is not enabled.
        isPrefetch && (Loading || !hasLoadingComponentInTree(parallelRoute)) && // The approach with PPR is different â€” loading.tsx behaves like a
        // regular Suspense boundary and has no special behavior.
        //
        // With PPR, we prefetch as deeply as possible, and only defer when
        // dynamic data is accessed. If so, we only defer the nearest parent
        // Suspense boundary of the dynamic data access, regardless of whether
        // the boundary is defined by loading.tsx or a normal <Suspense>
        // component in userspace.
        //
        // NOTE: In practice this usually means we'll end up prefetching more
        // than we were before PPR, which may or may not be considered a
        // performance regression by some apps. The plan is to address this
        // before General Availability of PPR by introducing granular
        // per-segment fetching, so we can reuse as much of the tree as
        // possible during both prefetches and dynamic navigations. But during
        // the beta period, we should be clear about this trade off in our
        // communications.
        !experimental.ppr) {
        // Don't prefetch this child. This will trigger a lazy fetch by the
        // client router.
        } else {
            // Create the child component
            if (process.env.NODE_ENV === "development" && missingSlots) {
                var _parsedTree_layoutOrPagePath;
                // When we detect the default fallback (which triggers a 404), we collect the missing slots
                // to provide more helpful debug information during development mode.
                const parsedTree = parseLoaderTree(parallelRoute);
                if ((_parsedTree_layoutOrPagePath = parsedTree.layoutOrPagePath) == null ? void 0 : _parsedTree_layoutOrPagePath.endsWith(PARALLEL_ROUTE_DEFAULT_PATH)) {
                    missingSlots.add(parallelRouteKey);
                }
            }
            const { seedData, styles: childComponentStyles } = await createComponentTreeInternal({
                createSegmentPath: (child)=>{
                    return createSegmentPath([
                        ...currentSegmentPath,
                        ...child
                    ]);
                },
                loaderTree: parallelRoute,
                parentParams: currentParams,
                rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,
                injectedCSS: injectedCSSWithCurrentLayout,
                injectedJS: injectedJSWithCurrentLayout,
                injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,
                asNotFound,
                metadataOutlet,
                ctx,
                missingSlots
            });
            currentStyles = childComponentStyles;
            childCacheNodeSeedData = seedData;
        }
        // This is turned back into an object below.
        return [
            parallelRouteKey,
            /*#__PURE__*/ _jsx(LayoutRouter, {
                parallelRouterKey: parallelRouteKey,
                segmentPath: createSegmentPath(currentSegmentPath),
                // TODO-APP: Add test for loading returning `undefined`. This currently can't be tested as the `webdriver()` tab will wait for the full page to load before returning.
                error: ErrorComponent,
                errorStyles: errorStyles,
                errorScripts: errorScripts,
                template: /*#__PURE__*/ _jsx(Template, {
                    children: /*#__PURE__*/ _jsx(RenderFromTemplateContext, {})
                }),
                templateStyles: templateStyles,
                templateScripts: templateScripts,
                notFound: notFoundComponent,
                notFoundStyles: notFoundStyles,
                styles: currentStyles
            }),
            childCacheNodeSeedData
        ];
    }));
    // Convert the parallel route map into an object after all promises have been resolved.
    let parallelRouteProps = {};
    let parallelRouteCacheNodeSeedData = {};
    for (const parallelRoute of parallelRouteMap){
        const [parallelRouteKey, parallelRouteProp, flightData] = parallelRoute;
        parallelRouteProps[parallelRouteKey] = parallelRouteProp;
        parallelRouteCacheNodeSeedData[parallelRouteKey] = flightData;
    }
    const loadingData = Loading ? [
        /*#__PURE__*/ _jsx(Loading, {}),
        loadingStyles,
        loadingScripts
    ] : null;
    // When the segment does not have a layout or page we still have to add the layout router to ensure the path holds the loading component
    if (!Component) {
        return {
            seedData: [
                actualSegment,
                parallelRouteCacheNodeSeedData,
                // TODO: I don't think the extra fragment is necessary. React treats top
                // level fragments as transparent, i.e. the runtime behavior should be
                // identical even without it. But maybe there's some findDOMNode-related
                // reason that I'm not aware of, so I'm leaving it as-is out of extreme
                // caution, for now.
                /*#__PURE__*/ _jsx(_Fragment, {
                    children: parallelRouteProps.children
                }),
                loadingData
            ],
            styles: layerAssets
        };
    }
    // If force-dynamic is used and the current render supports postponing, we
    // replace it with a node that will postpone the render. This ensures that the
    // postpone is invoked during the react render phase and not during the next
    // render phase.
    // @TODO this does not actually do what it seems like it would or should do. The idea is that
    // if we are rendering in a force-dynamic mode and we can postpone we should only make the segments
    // that ask for force-dynamic to be dynamic, allowing other segments to still prerender. However
    // because this comes after the children traversal and the static generation store is mutated every segment
    // along the parent path of a force-dynamic segment will hit this condition effectively making the entire
    // render force-dynamic. We should refactor this function so that we can correctly track which segments
    // need to be dynamic
    if (staticGenerationStore.forceDynamic && staticGenerationStore.prerenderState) {
        return {
            seedData: [
                actualSegment,
                parallelRouteCacheNodeSeedData,
                /*#__PURE__*/ _jsx(Postpone, {
                    prerenderState: staticGenerationStore.prerenderState,
                    reason: 'dynamic = "force-dynamic" was used',
                    pathname: staticGenerationStore.urlPathname
                }),
                loadingData
            ],
            styles: layerAssets
        };
    }
    const isClientComponent = isClientReference(layoutOrPageMod);
    // We avoid cloning this object because it gets consumed here exclusively.
    const props = parallelRouteProps;
    // If it's a not found route, and we don't have any matched parallel
    // routes, we try to render the not found component if it exists.
    if (NotFound && asNotFound && // In development, it could hit the parallel-route-default not found, so we only need to check the segment.
    // Or if there's no parallel routes means it reaches the end.
    !parallelRouteMap.length) {
        props.children = /*#__PURE__*/ _jsxs(_Fragment, {
            children: [
                /*#__PURE__*/ _jsx("meta", {
                    name: "robots",
                    content: "noindex"
                }),
                process.env.NODE_ENV === "development" && /*#__PURE__*/ _jsx("meta", {
                    name: "next-error",
                    content: "not-found"
                }),
                notFoundStyles,
                /*#__PURE__*/ _jsx(NotFound, {})
            ]
        });
    }
    // Assign params to props
    if (process.env.NODE_ENV === "development" && "params" in parallelRouteProps) {
        // @TODO consider making this an error and running the check in build as well
        console.error(`"params" is a reserved prop in Layouts and Pages and cannot be used as the name of a parallel route in ${segment}`);
    }
    props.params = currentParams;
    let segmentElement;
    if (isPage) {
        // Assign searchParams to props if this is a page
        if (isClientComponent) {
            // When we are passing searchParams to a client component Page we don't want to track the dynamic access
            // here in the RSC layer because the serialization will trigger a dynamic API usage.
            // Instead we pass the searchParams untracked but we wrap the Page in a root client component
            // which can among other things adds the dynamic tracking before rendering the page.
            // @TODO make the root wrapper part of next-app-loader so we don't need the extra client component
            props.searchParams = createUntrackedSearchParams(query);
            segmentElement = /*#__PURE__*/ _jsxs(_Fragment, {
                children: [
                    metadataOutlet,
                    /*#__PURE__*/ _jsx(ClientPageRoot, {
                        props: props,
                        Component: Component
                    })
                ]
            });
        } else {
            // If we are passing searchParams to a server component Page we need to track their usage in case
            // the current render mode tracks dynamic API usage.
            props.searchParams = createDynamicallyTrackedSearchParams(query);
            segmentElement = /*#__PURE__*/ _jsxs(_Fragment, {
                children: [
                    metadataOutlet,
                    /*#__PURE__*/ _jsx(Component, {
                        ...props
                    })
                ]
            });
        }
    } else {
        // For layouts we just render the component
        segmentElement = /*#__PURE__*/ _jsx(Component, {
            ...props
        });
    }
    return {
        seedData: [
            actualSegment,
            parallelRouteCacheNodeSeedData,
            /*#__PURE__*/ _jsxs(_Fragment, {
                children: [
                    segmentElement,
                    null
                ]
            }),
            loadingData
        ],
        styles: layerAssets
    };
}

//# sourceMappingURL=create-component-tree.js.mapY   import { jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React from "react";
import { canSegmentBeOverridden, matchSegment } from "../../client/components/match-segments";
import { getLinkAndScriptTags } from "./get-css-inlined-link-tags";
import { getPreloadableFonts } from "./get-preloadable-fonts";
import { addSearchParamsIfPageSegment, createFlightRouterStateFromLoaderTree } from "./create-flight-router-state-from-loader-tree";
import { parseLoaderTree } from "./parse-loader-tree";
import { getLayerAssets } from "./get-layer-assets";
import { hasLoadingComponentInTree } from "./has-loading-component-in-tree";
import { createComponentTree } from "./create-component-tree";
import { DEFAULT_SEGMENT_KEY } from "../../shared/lib/segment";
/**
 * Use router state to decide at what common layout to render the page.
 * This can either be the common layout between two pages or a specific place to start rendering from using the "refetch" marker in the tree.
 */ export async function walkTreeWithFlightRouterState({ createSegmentPath, loaderTreeToFilter, parentParams, isFirst, flightRouterState, parentRendered, rscPayloadHead, injectedCSS, injectedJS, injectedFontPreloadTags, rootLayoutIncluded, asNotFound, metadataOutlet, ctx }) {
    const { renderOpts: { nextFontManifest, experimental }, query, isPrefetch, getDynamicParamFromSegment, componentMod: { tree: loaderTree } } = ctx;
    const [segment, parallelRoutes, components] = loaderTreeToFilter;
    const parallelRoutesKeys = Object.keys(parallelRoutes);
    const { layout } = components;
    const isLayout = typeof layout !== "undefined";
    /**
   * Checks if the current segment is a root layout.
   */ const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded;
    /**
   * Checks if the current segment or any level above it has a root layout.
   */ const rootLayoutIncludedAtThisLevelOrAbove = rootLayoutIncluded || rootLayoutAtThisLevel;
    // Because this function walks to a deeper point in the tree to start rendering we have to track the dynamic parameters up to the point where rendering starts
    const segmentParam = getDynamicParamFromSegment(segment);
    const currentParams = // Handle null case where dynamic param is optional
    segmentParam && segmentParam.value !== null ? {
        ...parentParams,
        [segmentParam.param]: segmentParam.value
    } : parentParams;
    const actualSegment = addSearchParamsIfPageSegment(segmentParam ? segmentParam.treeSegment : segment, query);
    /**
   * Decide if the current segment is where rendering has to start.
   */ const renderComponentsOnThisLevel = // No further router state available
    !flightRouterState || // Segment in router state does not match current segment
    !matchSegment(actualSegment, flightRouterState[0]) || // Last item in the tree
    parallelRoutesKeys.length === 0 || // Explicit refresh
    flightRouterState[3] === "refetch";
    const shouldSkipComponentTree = // loading.tsx has no effect on prefetching when PPR is enabled
    !experimental.ppr && isPrefetch && !Boolean(components.loading) && (flightRouterState || // If there is no flightRouterState, we need to check the entire loader tree, as otherwise we'll be only checking the root
    !hasLoadingComponentInTree(loaderTree));
    if (!parentRendered && renderComponentsOnThisLevel) {
        const overriddenSegment = flightRouterState && canSegmentBeOverridden(actualSegment, flightRouterState[0]) ? flightRouterState[0] : actualSegment;
        const routerState = createFlightRouterStateFromLoaderTree(// Create router state using the slice of the loaderTree
        loaderTreeToFilter, getDynamicParamFromSegment, query);
        if (shouldSkipComponentTree) {
            // Send only the router state
            return [
                [
                    overriddenSegment,
                    routerState,
                    null,
                    null
                ]
            ];
        } else {
            // Create component tree using the slice of the loaderTree
            const { seedData } = await createComponentTree(// This ensures flightRouterPath is valid and filters down the tree
            {
                ctx,
                createSegmentPath,
                loaderTree: loaderTreeToFilter,
                parentParams: currentParams,
                firstItem: isFirst,
                injectedCSS,
                injectedJS,
                injectedFontPreloadTags,
                // This is intentionally not "rootLayoutIncludedAtThisLevelOrAbove" as createComponentTree starts at the current level and does a check for "rootLayoutAtThisLevel" too.
                rootLayoutIncluded,
                asNotFound,
                metadataOutlet
            });
            // Create head
            const { layoutOrPagePath } = parseLoaderTree(loaderTreeToFilter);
            const layerAssets = getLayerAssets({
                ctx,
                layoutOrPagePath,
                injectedCSS: new Set(injectedCSS),
                injectedJS: new Set(injectedJS),
                injectedFontPreloadTags: new Set(injectedFontPreloadTags)
            });
            const head = /*#__PURE__*/ _jsxs(_Fragment, {
                children: [
                    layerAssets,
                    rscPayloadHead
                ]
            });
            return [
                [
                    overriddenSegment,
                    routerState,
                    seedData,
                    head
                ]
            ];
        }
    }
    // If we are not rendering on this level we need to check if the current
    // segment has a layout. If so, we need to track all the used CSS to make
    // the result consistent.
    const layoutPath = layout == null ? void 0 : layout[1];
    const injectedCSSWithCurrentLayout = new Set(injectedCSS);
    const injectedJSWithCurrentLayout = new Set(injectedJS);
    const injectedFontPreloadTagsWithCurrentLayout = new Set(injectedFontPreloadTags);
    if (layoutPath) {
        getLinkAndScriptTags(ctx.clientReferenceManifest, layoutPath, injectedCSSWithCurrentLayout, injectedJSWithCurrentLayout, true);
        getPreloadableFonts(nextFontManifest, layoutPath, injectedFontPreloadTagsWithCurrentLayout);
    }
    // Walk through all parallel routes.
    const paths = (await Promise.all(parallelRoutesKeys.map(async (parallelRouteKey)=>{
        // for (const parallelRouteKey of parallelRoutesKeys) {
        const parallelRoute = parallelRoutes[parallelRouteKey];
        const currentSegmentPath = isFirst ? [
            parallelRouteKey
        ] : [
            actualSegment,
            parallelRouteKey
        ];
        const path = await walkTreeWithFlightRouterState({
            ctx,
            createSegmentPath: (child)=>{
                return createSegmentPath([
                    ...currentSegmentPath,
                    ...child
                ]);
            },
            loaderTreeToFilter: parallelRoute,
            parentParams: currentParams,
            flightRouterState: flightRouterState && flightRouterState[1][parallelRouteKey],
            parentRendered: parentRendered || renderComponentsOnThisLevel,
            isFirst: false,
            rscPayloadHead,
            injectedCSS: injectedCSSWithCurrentLayout,
            injectedJS: injectedJSWithCurrentLayout,
            injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,
            rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,
            asNotFound,
            metadataOutlet
        });
        return path.map((item)=>{
            // we don't need to send over default routes in the flight data
            // because they are always ignored by the client, unless it's a refetch
            if (item[0] === DEFAULT_SEGMENT_KEY && flightRouterState && !!flightRouterState[1][parallelRouteKey][0] && flightRouterState[1][parallelRouteKey][3] !== "refetch") {
                return null;
            }
            return [
                actualSegment,
                parallelRouteKey,
                ...item
            ];
        }).filter(Boolean);
    }))).flat();
    return paths;
}

//# sourceMappingURL=walk-tree-with-flight-router-state.js.map›  class StaticRenderer {
    constructor(options){
        this.options = options;
        this.prerender = process.env.__NEXT_EXPERIMENTAL_REACT ? require("react-dom/static.edge").prerender : null;
    }
    async render(children) {
        const { prelude, postponed } = await this.prerender(children, this.options);
        return {
            stream: prelude,
            postponed
        };
    }
}
class StaticResumeRenderer {
    constructor(postponed, options){
        this.postponed = postponed;
        this.options = options;
        this.resume = require("react-dom/server.edge").resume;
    }
    async render(children) {
        const stream = await this.resume(children, this.postponed, this.options);
        return {
            stream,
            resumed: true
        };
    }
}
export class ServerRenderer {
    constructor(options){
        this.options = options;
        this.renderToReadableStream = require("react-dom/server.edge").renderToReadableStream;
    }
    async render(children) {
        const stream = await this.renderToReadableStream(children, this.options);
        return {
            stream
        };
    }
}
export class VoidRenderer {
    async render(_children) {
        return {
            stream: new ReadableStream({
                start (controller) {
                    // Close the stream immediately
                    controller.close();
                }
            }),
            resumed: false
        };
    }
}
export const DYNAMIC_DATA = 1;
export const DYNAMIC_HTML = 2;
export function getDynamicHTMLPostponedState(data) {
    return [
        DYNAMIC_HTML,
        data
    ];
}
export function getDynamicDataPostponedState() {
    return DYNAMIC_DATA;
}
export function createStaticRenderer({ ppr, isStaticGeneration, postponed, streamOptions: { signal, onError, onPostpone, onHeaders, maxHeadersLength, nonce, bootstrapScripts, formState } }) {
    if (ppr) {
        if (isStaticGeneration) {
            // This is a Prerender
            return new StaticRenderer({
                signal,
                onError,
                onPostpone,
                // We want to capture headers because we may not end up with a shell
                // and being able to send headers is the next best thing
                onHeaders,
                maxHeadersLength,
                bootstrapScripts
            });
        } else {
            // This is a Resume
            if (postponed === DYNAMIC_DATA) {
                // The HTML was complete, we don't actually need to render anything
                return new VoidRenderer();
            } else if (postponed) {
                const reactPostponedState = postponed[1];
                // The HTML had dynamic holes and we need to resume it
                return new StaticResumeRenderer(reactPostponedState, {
                    signal,
                    onError,
                    onPostpone,
                    nonce
                });
            }
        }
    }
    if (isStaticGeneration) {
        // This is a static render (without PPR)
        return new ServerRenderer({
            signal,
            onError,
            // We don't pass onHeaders. In static builds we will either have no output
            // or the entire page. In either case preload headers aren't necessary and could
            // alter the prioritiy of relative loading of resources so we opt to keep them
            // as tags exclusively.
            nonce,
            bootstrapScripts,
            formState
        });
    }
    // This is a dynamic render (without PPR)
    return new ServerRenderer({
        signal,
        onError,
        // Static renders are streamed in realtime so sending headers early is
        // generally good because it will likely go out before the shell is ready.
        onHeaders,
        maxHeadersLength,
        nonce,
        bootstrapScripts,
        formState
    });
}

//# sourceMappingURL=static-renderer.js.map¾  import { htmlEscapeJsonString } from "../htmlescape";
const isEdgeRuntime = process.env.NEXT_RUNTIME === "edge";
const INLINE_FLIGHT_PAYLOAD_BOOTSTRAP = 0;
const INLINE_FLIGHT_PAYLOAD_DATA = 1;
const INLINE_FLIGHT_PAYLOAD_FORM_STATE = 2;
const flightResponses = new WeakMap();
const encoder = new TextEncoder();
/**
 * Render Flight stream.
 * This is only used for renderToHTML, the Flight response does not need additional wrappers.
 */ export function useFlightStream(flightStream, clientReferenceManifest, nonce) {
    const response = flightResponses.get(flightStream);
    if (response) {
        return response;
    }
    // react-server-dom-webpack/client.edge must not be hoisted for require cache clearing to work correctly
    let createFromReadableStream;
    // @TODO: investigate why the aliasing for turbopack doesn't pick this up, requiring this runtime check
    if (process.env.TURBOPACK) {
        createFromReadableStream = // eslint-disable-next-line import/no-extraneous-dependencies
        require("react-server-dom-turbopack/client.edge").createFromReadableStream;
    } else {
        createFromReadableStream = // eslint-disable-next-line import/no-extraneous-dependencies
        require("react-server-dom-webpack/client.edge").createFromReadableStream;
    }
    const newResponse = createFromReadableStream(flightStream, {
        ssrManifest: {
            moduleLoading: clientReferenceManifest.moduleLoading,
            moduleMap: isEdgeRuntime ? clientReferenceManifest.edgeSSRModuleMapping : clientReferenceManifest.ssrModuleMapping
        },
        nonce
    });
    flightResponses.set(flightStream, newResponse);
    return newResponse;
}
/**
 * There are times when an SSR render may be finished but the RSC render
 * is ongoing and we need to wait for it to complete to make some determination
 * about how to handle the render. This function will drain the RSC reader and
 * resolve when completed. This will generally require teeing the RSC stream and it
 * should be noted that it will cause all the RSC chunks to queue in the underlying
 * ReadableStream however given Flight currently is a push stream that doesn't respond
 * to backpressure this shouldn't change how much memory is maximally consumed
 */ export async function flightRenderComplete(flightStream) {
    const flightReader = flightStream.getReader();
    while(true){
        const { done } = await flightReader.read();
        if (done) {
            return;
        }
    }
}
/**
 * Creates a ReadableStream provides inline script tag chunks for writing hydration
 * data to the client outside the React render itself.
 *
 * @param flightStream The RSC render stream
 * @param nonce optionally a nonce used during this particular render
 * @param formState optionally the formState used with this particular render
 * @returns a ReadableStream without the complete property. This signifies a lazy ReadableStream
 */ export function createInlinedDataReadableStream(flightStream, nonce, formState) {
    const startScriptTag = nonce ? `<script nonce=${JSON.stringify(nonce)}>` : "<script>";
    const decoder = new TextDecoder("utf-8", {
        fatal: true
    });
    const decoderOptions = {
        stream: true
    };
    const flightReader = flightStream.getReader();
    const readable = new ReadableStream({
        type: "bytes",
        start (controller) {
            try {
                writeInitialInstructions(controller, startScriptTag, formState);
            } catch (error) {
                // during encoding or enqueueing forward the error downstream
                controller.error(error);
            }
        },
        async pull (controller) {
            try {
                const { done, value } = await flightReader.read();
                if (done) {
                    const tail = decoder.decode(value, {
                        stream: false
                    });
                    if (tail.length) {
                        writeFlightDataInstruction(controller, startScriptTag, tail);
                    }
                    controller.close();
                } else {
                    const chunkAsString = decoder.decode(value, decoderOptions);
                    writeFlightDataInstruction(controller, startScriptTag, chunkAsString);
                }
            } catch (error) {
                // There was a problem in the upstream reader or during decoding or enqueuing
                // forward the error downstream
                controller.error(error);
            }
        }
    });
    return readable;
}
function writeInitialInstructions(controller, scriptStart, formState) {
    controller.enqueue(encoder.encode(`${scriptStart}(self.__next_f=self.__next_f||[]).push(${htmlEscapeJsonString(JSON.stringify([
        INLINE_FLIGHT_PAYLOAD_BOOTSTRAP
    ]))});self.__next_f.push(${htmlEscapeJsonString(JSON.stringify([
        INLINE_FLIGHT_PAYLOAD_FORM_STATE,
        formState
    ]))})</script>`));
}
function writeFlightDataInstruction(controller, scriptStart, chunkAsString) {
    controller.enqueue(encoder.encode(`${scriptStart}self.__next_f.push(${htmlEscapeJsonString(JSON.stringify([
        INLINE_FLIGHT_PAYLOAD_DATA,
        chunkAsString
    ]))})</script>`));
}

//# sourceMappingURL=use-flight-response.js.map«¼  import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React from "react";
import RenderResult from "../render-result";
import { chainStreams, renderToInitialFizzStream, continueFizzStream, continueDynamicPrerender, continueStaticPrerender, continueDynamicHTMLResume, continueDynamicDataResume } from "../stream-utils/node-web-streams-helper";
import { canSegmentBeOverridden } from "../../client/components/match-segments";
import { stripInternalQueries } from "../internal-utils";
import { NEXT_ROUTER_PREFETCH_HEADER, NEXT_ROUTER_STATE_TREE, NEXT_URL, RSC_HEADER } from "../../client/components/app-router-headers";
import { createMetadataComponents } from "../../lib/metadata/metadata";
import { RequestAsyncStorageWrapper } from "../async-storage/request-async-storage-wrapper";
import { StaticGenerationAsyncStorageWrapper } from "../async-storage/static-generation-async-storage-wrapper";
import { isNotFoundError } from "../../client/components/not-found";
import { getURLFromRedirectError, isRedirectError, getRedirectStatusCodeFromError } from "../../client/components/redirect";
import { addImplicitTags } from "../lib/patch-fetch";
import { AppRenderSpan, NextNodeServerSpan } from "../lib/trace/constants";
import { getTracer } from "../lib/trace/tracer";
import { FlightRenderResult } from "./flight-render-result";
import { createErrorHandler, ErrorHandlerSource } from "./create-error-handler";
import { getShortDynamicParamType, dynamicParamTypes } from "./get-short-dynamic-param-type";
import { getSegmentParam } from "./get-segment-param";
import { getScriptNonceFromHeader } from "./get-script-nonce-from-header";
import { parseAndValidateFlightRouterState } from "./parse-and-validate-flight-router-state";
import { validateURL } from "./validate-url";
import { createFlightRouterStateFromLoaderTree } from "./create-flight-router-state-from-loader-tree";
import { handleAction } from "./action-handler";
import { isBailoutToCSRError } from "../../shared/lib/lazy-dynamic/bailout-to-csr";
import { warn, error } from "../../build/output/log";
import { appendMutableCookies } from "../web/spec-extension/adapters/request-cookies";
import { createServerInsertedHTML } from "./server-inserted-html";
import { getRequiredScripts } from "./required-scripts";
import { addPathPrefix } from "../../shared/lib/router/utils/add-path-prefix";
import { makeGetServerInsertedHTML } from "./make-get-server-inserted-html";
import { walkTreeWithFlightRouterState } from "./walk-tree-with-flight-router-state";
import { createComponentTree } from "./create-component-tree";
import { getAssetQueryString } from "./get-asset-query-string";
import { setReferenceManifestsSingleton } from "./encryption-utils";
import { createStaticRenderer, getDynamicDataPostponedState, getDynamicHTMLPostponedState } from "./static/static-renderer";
import { isDynamicServerError } from "../../client/components/hooks-server-context";
import { useFlightStream, createInlinedDataReadableStream, flightRenderComplete } from "./use-flight-response";
import { StaticGenBailoutError, isStaticGenBailoutError } from "../../client/components/static-generation-bailout";
import { isInterceptionRouteAppPath } from "../future/helpers/interception-routes";
import { getStackWithoutErrorMessage } from "../../lib/format-server-error";
import { usedDynamicAPIs, createPostponedAbortSignal, formatDynamicAPIAccesses } from "./dynamic-rendering";
import { getClientComponentLoaderMetrics, wrapClientComponentLoader } from "../client-component-renderer-logger";
import { createServerModuleMap } from "./action-utils";
function createNotFoundLoaderTree(loaderTree) {
    // Align the segment with parallel-route-default in next-app-loader
    return [
        "",
        {},
        loaderTree[2]
    ];
}
/* This method is important for intercepted routes to function:
 * when a route is intercepted, e.g. /blog/[slug], it will be rendered
 * with the layout of the previous page, e.g. /profile/[id]. The problem is
 * that the loader tree needs to know the dynamic param in order to render (id and slug in the example).
 * Normally they are read from the path but since we are intercepting the route, the path would not contain id,
 * so we need to read it from the router state.
 */ function findDynamicParamFromRouterState(flightRouterState, segment) {
    if (!flightRouterState) {
        return null;
    }
    const treeSegment = flightRouterState[0];
    if (canSegmentBeOverridden(segment, treeSegment)) {
        if (!Array.isArray(treeSegment) || Array.isArray(segment)) {
            return null;
        }
        return {
            param: treeSegment[0],
            value: treeSegment[1],
            treeSegment: treeSegment,
            type: treeSegment[2]
        };
    }
    for (const parallelRouterState of Object.values(flightRouterState[1])){
        const maybeDynamicParam = findDynamicParamFromRouterState(parallelRouterState, segment);
        if (maybeDynamicParam) {
            return maybeDynamicParam;
        }
    }
    return null;
}
/**
 * Returns a function that parses the dynamic segment and return the associated value.
 */ function makeGetDynamicParamFromSegment(params, flightRouterState) {
    return function getDynamicParamFromSegment(// [slug] / [[slug]] / [...slug]
    segment) {
        const segmentParam = getSegmentParam(segment);
        if (!segmentParam) {
            return null;
        }
        const key = segmentParam.param;
        let value = params[key];
        // this is a special marker that will be present for interception routes
        if (value === "__NEXT_EMPTY_PARAM__") {
            value = undefined;
        }
        if (Array.isArray(value)) {
            value = value.map((i)=>encodeURIComponent(i));
        } else if (typeof value === "string") {
            value = encodeURIComponent(value);
        }
        if (!value) {
            // Handle case where optional catchall does not have a value, e.g. `/dashboard/[...slug]` when requesting `/dashboard`
            if (segmentParam.type === "optional-catchall") {
                const type = dynamicParamTypes[segmentParam.type];
                return {
                    param: key,
                    value: null,
                    type: type,
                    // This value always has to be a string.
                    treeSegment: [
                        key,
                        "",
                        type
                    ]
                };
            }
            return findDynamicParamFromRouterState(flightRouterState, segment);
        }
        const type = getShortDynamicParamType(segmentParam.type);
        return {
            param: key,
            // The value that is passed to user code.
            value: value,
            // The value that is rendered in the router tree.
            treeSegment: [
                key,
                Array.isArray(value) ? value.join("/") : value,
                type
            ],
            type: type
        };
    };
}
function NonIndex({ ctx }) {
    const is404Page = ctx.pagePath === "/404";
    const isInvalidStatusCode = typeof ctx.res.statusCode === "number" && ctx.res.statusCode > 400;
    if (is404Page || isInvalidStatusCode) {
        return /*#__PURE__*/ _jsx("meta", {
            name: "robots",
            content: "noindex"
        });
    }
    return null;
}
// Handle Flight render request. This is only used when client-side navigating. E.g. when you `router.push('/dashboard')` or `router.reload()`.
async function generateFlight(ctx, options) {
    // Flight data that is going to be passed to the browser.
    // Currently a single item array but in the future multiple patches might be combined in a single request.
    let flightData = null;
    const { componentMod: { tree: loaderTree, renderToReadableStream, createDynamicallyTrackedSearchParams }, getDynamicParamFromSegment, appUsingSizeAdjustment, staticGenerationStore: { urlPathname }, query, requestId, flightRouterState } = ctx;
    if (!(options == null ? void 0 : options.skipFlight)) {
        const [MetadataTree, MetadataOutlet] = createMetadataComponents({
            tree: loaderTree,
            pathname: urlPathname,
            trailingSlash: ctx.renderOpts.trailingSlash,
            query,
            getDynamicParamFromSegment,
            appUsingSizeAdjustment,
            createDynamicallyTrackedSearchParams
        });
        flightData = (await walkTreeWithFlightRouterState({
            ctx,
            createSegmentPath: (child)=>child,
            loaderTreeToFilter: loaderTree,
            parentParams: {},
            flightRouterState,
            isFirst: true,
            // For flight, render metadata inside leaf page
            rscPayloadHead: /*#__PURE__*/ _jsxs(_Fragment, {
                children: [
                    /*#__PURE__*/ _jsx(NonIndex, {
                        ctx: ctx
                    }),
                    /*#__PURE__*/ _jsx(MetadataTree, {}, requestId)
                ]
            }),
            injectedCSS: new Set(),
            injectedJS: new Set(),
            injectedFontPreloadTags: new Set(),
            rootLayoutIncluded: false,
            asNotFound: ctx.isNotFoundPath || (options == null ? void 0 : options.asNotFound),
            metadataOutlet: /*#__PURE__*/ _jsx(MetadataOutlet, {})
        })).map((path)=>path.slice(1)) // remove the '' (root) segment
        ;
    }
    const buildIdFlightDataPair = [
        ctx.renderOpts.buildId,
        flightData
    ];
    // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)
    // which contains the subset React.
    const flightReadableStream = renderToReadableStream(options ? [
        options.actionResult,
        buildIdFlightDataPair
    ] : buildIdFlightDataPair, ctx.clientReferenceManifest.clientModules, {
        onError: ctx.flightDataRendererErrorHandler
    });
    return new FlightRenderResult(flightReadableStream);
}
/**
 * Creates a resolver that eagerly generates a flight payload that is then
 * resolved when the resolver is called.
 */ function createFlightDataResolver(ctx) {
    // Generate the flight data and as soon as it can, convert it into a string.
    const promise = generateFlight(ctx).then(async (result)=>({
            flightData: await result.toUnchunkedString(true)
        }))// Otherwise if it errored, return the error.
    .catch((err)=>({
            err
        }));
    return async ()=>{
        // Resolve the promise to get the flight data or error.
        const result = await promise;
        // If the flight data failed to render due to an error, re-throw the error
        // here.
        if ("err" in result) {
            throw result.err;
        }
        // Otherwise, return the flight data.
        return result.flightData;
    };
}
// This is the root component that runs in the RSC context
async function ReactServerApp({ tree, ctx, asNotFound }) {
    // Create full component tree from root to leaf.
    const injectedCSS = new Set();
    const injectedJS = new Set();
    const injectedFontPreloadTags = new Set();
    const missingSlots = new Set();
    const { getDynamicParamFromSegment, query, appUsingSizeAdjustment, componentMod: { AppRouter, GlobalError, createDynamicallyTrackedSearchParams }, staticGenerationStore: { urlPathname } } = ctx;
    const initialTree = createFlightRouterStateFromLoaderTree(tree, getDynamicParamFromSegment, query);
    const [MetadataTree, MetadataOutlet] = createMetadataComponents({
        tree,
        errorType: asNotFound ? "not-found" : undefined,
        pathname: urlPathname,
        trailingSlash: ctx.renderOpts.trailingSlash,
        query,
        getDynamicParamFromSegment: getDynamicParamFromSegment,
        appUsingSizeAdjustment: appUsingSizeAdjustment,
        createDynamicallyTrackedSearchParams
    });
    const { seedData, styles } = await createComponentTree({
        ctx,
        createSegmentPath: (child)=>child,
        loaderTree: tree,
        parentParams: {},
        firstItem: true,
        injectedCSS,
        injectedJS,
        injectedFontPreloadTags,
        rootLayoutIncluded: false,
        asNotFound: asNotFound,
        metadataOutlet: /*#__PURE__*/ _jsx(MetadataOutlet, {}),
        missingSlots
    });
    // When the `vary` response header is present with `Next-URL`, that means there's a chance
    // it could respond differently if there's an interception route. We provide this information
    // to `AppRouter` so that it can properly seed the prefetch cache with a prefix, if needed.
    const varyHeader = ctx.res.getHeader("vary");
    const couldBeIntercepted = typeof varyHeader === "string" && varyHeader.includes(NEXT_URL);
    return /*#__PURE__*/ _jsxs(_Fragment, {
        children: [
            styles,
            /*#__PURE__*/ _jsx(AppRouter, {
                buildId: ctx.renderOpts.buildId,
                assetPrefix: ctx.assetPrefix,
                initialCanonicalUrl: urlPathname,
                // This is the router state tree.
                initialTree: initialTree,
                // This is the tree of React nodes that are seeded into the cache
                initialSeedData: seedData,
                couldBeIntercepted: couldBeIntercepted,
                initialHead: /*#__PURE__*/ _jsxs(_Fragment, {
                    children: [
                        /*#__PURE__*/ _jsx(NonIndex, {
                            ctx: ctx
                        }),
                        /*#__PURE__*/ _jsx(MetadataTree, {}, ctx.requestId)
                    ]
                }),
                globalErrorComponent: GlobalError,
                // This is used to provide debug information (when in development mode)
                // about which slots were not filled by page components while creating the component tree.
                missingSlots: missingSlots
            })
        ]
    });
}
// This is the root component that runs in the RSC context
async function ReactServerError({ tree, ctx, errorType }) {
    const { getDynamicParamFromSegment, query, appUsingSizeAdjustment, componentMod: { AppRouter, GlobalError, createDynamicallyTrackedSearchParams }, staticGenerationStore: { urlPathname }, requestId } = ctx;
    const [MetadataTree] = createMetadataComponents({
        tree,
        pathname: urlPathname,
        trailingSlash: ctx.renderOpts.trailingSlash,
        errorType,
        query,
        getDynamicParamFromSegment,
        appUsingSizeAdjustment,
        createDynamicallyTrackedSearchParams
    });
    const head = /*#__PURE__*/ _jsxs(_Fragment, {
        children: [
            /*#__PURE__*/ _jsx(NonIndex, {
                ctx: ctx
            }),
            /*#__PURE__*/ _jsx(MetadataTree, {}, requestId),
            process.env.NODE_ENV === "development" && /*#__PURE__*/ _jsx("meta", {
                name: "next-error",
                content: "not-found"
            })
        ]
    });
    const initialTree = createFlightRouterStateFromLoaderTree(tree, getDynamicParamFromSegment, query);
    // For metadata notFound error there's no global not found boundary on top
    // so we create a not found page with AppRouter
    const initialSeedData = [
        initialTree[0],
        {},
        /*#__PURE__*/ _jsxs("html", {
            id: "__next_error__",
            children: [
                /*#__PURE__*/ _jsx("head", {}),
                /*#__PURE__*/ _jsx("body", {})
            ]
        }),
        null
    ];
    return /*#__PURE__*/ _jsx(AppRouter, {
        buildId: ctx.renderOpts.buildId,
        assetPrefix: ctx.assetPrefix,
        initialCanonicalUrl: urlPathname,
        initialTree: initialTree,
        initialHead: head,
        globalErrorComponent: GlobalError,
        initialSeedData: initialSeedData,
        missingSlots: new Set()
    });
}
// This component must run in an SSR context. It will render the RSC root component
function ReactServerEntrypoint({ reactServerStream, preinitScripts, clientReferenceManifest, nonce }) {
    preinitScripts();
    const response = useFlightStream(reactServerStream, clientReferenceManifest, nonce);
    return React.use(response);
}
async function renderToHTMLOrFlightImpl(req, res, pagePath, query, renderOpts, baseCtx, requestEndedState) {
    var _getTracer_getRootSpanAttributes, _staticGenerationStore_prerenderState;
    const isNotFoundPath = pagePath === "/404";
    // A unique request timestamp used by development to ensure that it's
    // consistent and won't change during this request. This is important to
    // avoid that resources can be deduped by React Float if the same resource is
    // rendered or preloaded multiple times: `<link href="a.css?v={Date.now()}"/>`.
    const requestTimestamp = Date.now();
    const { buildManifest, subresourceIntegrityManifest, serverActionsManifest, ComponentMod, dev, nextFontManifest, supportsDynamicHTML, serverActions, appDirDevErrorLogger, assetPrefix = "", enableTainting } = renderOpts;
    // We need to expose the bundled `require` API globally for
    // react-server-dom-webpack. This is a hack until we find a better way.
    if (ComponentMod.__next_app__) {
        const instrumented = wrapClientComponentLoader(ComponentMod);
        // @ts-ignore
        globalThis.__next_require__ = instrumented.require;
        // @ts-ignore
        globalThis.__next_chunk_load__ = instrumented.loadChunk;
    }
    if (typeof req.on === "function") {
        req.on("end", ()=>{
            requestEndedState.ended = true;
            if ("performance" in globalThis) {
                const metrics = getClientComponentLoaderMetrics({
                    reset: true
                });
                if (metrics) {
                    getTracer().startSpan(NextNodeServerSpan.clientComponentLoading, {
                        startTime: metrics.clientComponentLoadStart,
                        attributes: {
                            "next.clientComponentLoadCount": metrics.clientComponentLoadCount
                        }
                    }).end(metrics.clientComponentLoadStart + metrics.clientComponentLoadTimes);
                }
            }
        });
    }
    const metadata = {};
    const appUsingSizeAdjustment = !!(nextFontManifest == null ? void 0 : nextFontManifest.appUsingSizeAdjust);
    // TODO: fix this typescript
    const clientReferenceManifest = renderOpts.clientReferenceManifest;
    const serverModuleMap = createServerModuleMap({
        serverActionsManifest,
        pageName: renderOpts.page
    });
    setReferenceManifestsSingleton({
        clientReferenceManifest,
        serverActionsManifest,
        serverModuleMap
    });
    const digestErrorsMap = new Map();
    const allCapturedErrors = [];
    const isNextExport = !!renderOpts.nextExport;
    const { staticGenerationStore, requestStore } = baseCtx;
    const { isStaticGeneration } = staticGenerationStore;
    // when static generation fails during PPR, we log the errors separately. We intentionally
    // silence the error logger in this case to avoid double logging.
    const silenceStaticGenerationErrors = renderOpts.experimental.ppr && isStaticGeneration;
    const serverComponentsErrorHandler = createErrorHandler({
        source: ErrorHandlerSource.serverComponents,
        dev,
        isNextExport,
        errorLogger: appDirDevErrorLogger,
        digestErrorsMap,
        silenceLogger: silenceStaticGenerationErrors
    });
    const flightDataRendererErrorHandler = createErrorHandler({
        source: ErrorHandlerSource.flightData,
        dev,
        isNextExport,
        errorLogger: appDirDevErrorLogger,
        digestErrorsMap,
        silenceLogger: silenceStaticGenerationErrors
    });
    const htmlRendererErrorHandler = createErrorHandler({
        source: ErrorHandlerSource.html,
        dev,
        isNextExport,
        errorLogger: appDirDevErrorLogger,
        digestErrorsMap,
        allCapturedErrors,
        silenceLogger: silenceStaticGenerationErrors
    });
    ComponentMod.patchFetch();
    /**
   * Rules of Static & Dynamic HTML:
   *
   *    1.) We must generate static HTML unless the caller explicitly opts
   *        in to dynamic HTML support.
   *
   *    2.) If dynamic HTML support is requested, we must honor that request
   *        or throw an error. It is the sole responsibility of the caller to
   *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.
   *
   * These rules help ensure that other existing features like request caching,
   * coalescing, and ISR continue working as intended.
   */ const generateStaticHTML = supportsDynamicHTML !== true;
    // Pull out the hooks/references from the component.
    const { tree: loaderTree, taintObjectReference } = ComponentMod;
    if (enableTainting) {
        taintObjectReference("Do not pass process.env to client components since it will leak sensitive data", process.env);
    }
    staticGenerationStore.fetchMetrics = [];
    metadata.fetchMetrics = staticGenerationStore.fetchMetrics;
    // don't modify original query object
    query = {
        ...query
    };
    stripInternalQueries(query);
    const isRSCRequest = req.headers[RSC_HEADER.toLowerCase()] !== undefined;
    const isPrefetchRSCRequest = isRSCRequest && req.headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] !== undefined;
    /**
   * Router state provided from the client-side router. Used to handle rendering
   * from the common layout down. This value will be undefined if the request
   * is not a client-side navigation request or if the request is a prefetch
   * request (except when it's a prefetch request for an interception route
   * which is always dynamic).
   */ const shouldProvideFlightRouterState = isRSCRequest && (!isPrefetchRSCRequest || !renderOpts.experimental.ppr || // Interception routes currently depend on the flight router state to
    // extract dynamic params.
    isInterceptionRouteAppPath(pagePath));
    const parsedFlightRouterState = parseAndValidateFlightRouterState(req.headers[NEXT_ROUTER_STATE_TREE.toLowerCase()]);
    /**
   * The metadata items array created in next-app-loader with all relevant information
   * that we need to resolve the final metadata.
   */ let requestId;
    if (process.env.NEXT_RUNTIME === "edge") {
        requestId = crypto.randomUUID();
    } else {
        requestId = require("next/dist/compiled/nanoid").nanoid();
    }
    /**
   * Dynamic parameters. E.g. when you visit `/dashboard/vercel` which is rendered by `/dashboard/[slug]` the value will be {"slug": "vercel"}.
   */ const params = renderOpts.params ?? {};
    const getDynamicParamFromSegment = makeGetDynamicParamFromSegment(params, // `FlightRouterState` is unconditionally provided here because this method uses it
    // to extract dynamic params as a fallback if they're not present in the path.
    parsedFlightRouterState);
    const ctx = {
        ...baseCtx,
        getDynamicParamFromSegment,
        query,
        isPrefetch: isPrefetchRSCRequest,
        requestTimestamp,
        appUsingSizeAdjustment,
        flightRouterState: shouldProvideFlightRouterState ? parsedFlightRouterState : undefined,
        requestId,
        defaultRevalidate: false,
        pagePath,
        clientReferenceManifest,
        assetPrefix,
        flightDataRendererErrorHandler,
        serverComponentsErrorHandler,
        isNotFoundPath,
        res
    };
    if (isRSCRequest && !isStaticGeneration) {
        return generateFlight(ctx);
    }
    // Create the resolver that can get the flight payload when it's ready or
    // throw the error if it occurred. If we are not generating static HTML, we
    // don't need to generate the flight payload because it's a dynamic request
    // which means we're either getting the flight payload only or just the
    // regular HTML.
    const flightDataResolver = isStaticGeneration ? createFlightDataResolver(ctx) : null;
    // Get the nonce from the incoming request if it has one.
    const csp = req.headers["content-security-policy"] || req.headers["content-security-policy-report-only"];
    let nonce;
    if (csp && typeof csp === "string") {
        nonce = getScriptNonceFromHeader(csp);
    }
    const validateRootLayout = dev;
    const { HeadManagerContext } = require("../../shared/lib/head-manager-context.shared-runtime");
    // On each render, create a new `ServerInsertedHTML` context to capture
    // injected nodes from user code (`useServerInsertedHTML`).
    const { ServerInsertedHTMLProvider, renderServerInsertedHTML } = createServerInsertedHTML();
    (_getTracer_getRootSpanAttributes = getTracer().getRootSpanAttributes()) == null ? void 0 : _getTracer_getRootSpanAttributes.set("next.route", pagePath);
    const renderToStream = getTracer().wrap(AppRenderSpan.getBodyResult, {
        spanName: `render route (app) ${pagePath}`,
        attributes: {
            "next.route": pagePath
        }
    }, async ({ asNotFound, tree, formState })=>{
        const polyfills = buildManifest.polyfillFiles.filter((polyfill)=>polyfill.endsWith(".js") && !polyfill.endsWith(".module.js")).map((polyfill)=>({
                src: `${assetPrefix}/_next/${polyfill}${getAssetQueryString(ctx, false)}`,
                integrity: subresourceIntegrityManifest == null ? void 0 : subresourceIntegrityManifest[polyfill],
                crossOrigin: renderOpts.crossOrigin,
                noModule: true,
                nonce
            }));
        const [preinitScripts, bootstrapScript] = getRequiredScripts(buildManifest, assetPrefix, renderOpts.crossOrigin, subresourceIntegrityManifest, getAssetQueryString(ctx, true), nonce);
        // We kick off the Flight Request (render) here. It is ok to initiate the render in an arbitrary
        // place however it is critical that we only construct the Flight Response inside the SSR
        // render so that directives like preloads are correctly piped through
        const serverStream = ComponentMod.renderToReadableStream(/*#__PURE__*/ _jsx(ReactServerApp, {
            tree: tree,
            ctx: ctx,
            asNotFound: asNotFound
        }), clientReferenceManifest.clientModules, {
            onError: serverComponentsErrorHandler
        });
        // We are going to consume this render both for SSR and for inlining the flight data
        let [renderStream, dataStream] = serverStream.tee();
        const children = /*#__PURE__*/ _jsx(HeadManagerContext.Provider, {
            value: {
                appDir: true,
                nonce
            },
            children: /*#__PURE__*/ _jsx(ServerInsertedHTMLProvider, {
                children: /*#__PURE__*/ _jsx(ReactServerEntrypoint, {
                    reactServerStream: renderStream,
                    preinitScripts: preinitScripts,
                    clientReferenceManifest: clientReferenceManifest,
                    nonce: nonce
                })
            })
        });
        const isResume = !!renderOpts.postponed;
        const onHeaders = staticGenerationStore.prerenderState ? (headers)=>{
            headers.forEach((value, key)=>{
                metadata.headers ??= {};
                metadata.headers[key] = value;
            });
        } : isStaticGeneration || isResume ? // ask React to emit headers. For Resume this is just not supported
        // For static generation we know there will be an entire HTML document
        // output and so moving from tag to header for preloading can only
        // server to alter preloading priorities in unwanted ways
        undefined : // early headers to the response
        (headers)=>{
            headers.forEach((value, key)=>{
                res.appendHeader(key, value);
            });
        };
        const getServerInsertedHTML = makeGetServerInsertedHTML({
            polyfills,
            renderServerInsertedHTML,
            serverCapturedErrors: allCapturedErrors,
            basePath: renderOpts.basePath
        });
        const renderer = createStaticRenderer({
            ppr: renderOpts.experimental.ppr,
            isStaticGeneration,
            // If provided, the postpone state should be parsed as JSON so it can be
            // provided to React.
            postponed: typeof renderOpts.postponed === "string" ? JSON.parse(renderOpts.postponed) : null,
            streamOptions: {
                onError: htmlRendererErrorHandler,
                onHeaders,
                maxHeadersLength: 600,
                nonce,
                bootstrapScripts: [
                    bootstrapScript
                ],
                formState
            }
        });
        try {
            let { stream, postponed, resumed } = await renderer.render(children);
            const prerenderState = staticGenerationStore.prerenderState;
            if (prerenderState) {
                /**
           * When prerendering there are three outcomes to consider
           *
           *   Dynamic HTML:      The prerender has dynamic holes (caused by using Next.js Dynamic Rendering APIs)
           *                      We will need to resume this result when requests are handled and we don't include
           *                      any server inserted HTML or inlined flight data in the static HTML
           *
           *   Dynamic Data:      The prerender has no dynamic holes but dynamic APIs were used. We will not
           *                      resume this render when requests are handled but we will generate new inlined
           *                      flight data since it is dynamic and differences may end up reconciling on the client
           *
           *   Static:            The prerender has no dynamic holes and no dynamic APIs were used. We statically encode
           *                      all server inserted HTML and flight data
           */ // First we check if we have any dynamic holes in our HTML prerender
                if (usedDynamicAPIs(prerenderState)) {
                    if (postponed != null) {
                        // This is the Dynamic HTML case.
                        metadata.postponed = JSON.stringify(getDynamicHTMLPostponedState(postponed));
                    } else {
                        // This is the Dynamic Data case
                        metadata.postponed = JSON.stringify(getDynamicDataPostponedState());
                    }
                    // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include
                    // server inserted html in the static response because the html that is part of the prerender may depend on it
                    // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states
                    // require the same set so we unify the code path here
                    return {
                        stream: await continueDynamicPrerender(stream, {
                            getServerInsertedHTML
                        })
                    };
                } else {
                    // We may still be rendering the RSC stream even though the HTML is finished.
                    // We wait for the RSC stream to complete and check again if dynamic was used
                    const [original, flightSpy] = dataStream.tee();
                    dataStream = original;
                    await flightRenderComplete(flightSpy);
                    if (usedDynamicAPIs(prerenderState)) {
                        // This is the same logic above just repeated after ensuring the RSC stream itself has completed
                        if (postponed != null) {
                            // This is the Dynamic HTML case.
                            metadata.postponed = JSON.stringify(getDynamicHTMLPostponedState(postponed));
                        } else {
                            // This is the Dynamic Data case
                            metadata.postponed = JSON.stringify(getDynamicDataPostponedState());
                        }
                        // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include
                        // server inserted html in the static response because the html that is part of the prerender may depend on it
                        // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states
                        // require the same set so we unify the code path here
                        return {
                            stream: await continueDynamicPrerender(stream, {
                                getServerInsertedHTML
                            })
                        };
                    } else {
                        // This is the Static case
                        // We still have not used any dynamic APIs. At this point we can produce an entirely static prerender response
                        let renderedHTMLStream = stream;
                        if (staticGenerationStore.forceDynamic) {
                            throw new StaticGenBailoutError('Invariant: a Page with `dynamic = "force-dynamic"` did not trigger the dynamic pathway. This is a bug in Next.js');
                        }
                        if (postponed != null) {
                            // We postponed but nothing dynamic was used. We resume the render now and immediately abort it
                            // so we can set all the postponed boundaries to client render mode before we store the HTML response
                            const resumeRenderer = createStaticRenderer({
                                ppr: true,
                                isStaticGeneration: false,
                                postponed: getDynamicHTMLPostponedState(postponed),
                                streamOptions: {
                                    signal: createPostponedAbortSignal("static prerender resume"),
                                    onError: htmlRendererErrorHandler,
                                    nonce
                                }
                            });
                            // We don't actually want to render anything so we just pass a stream
                            // that never resolves. The resume call is going to abort immediately anyway
                            const foreverStream = new ReadableStream();
                            const resumeChildren = /*#__PURE__*/ _jsx(HeadManagerContext.Provider, {
                                value: {
                                    appDir: true,
                                    nonce
                                },
                                children: /*#__PURE__*/ _jsx(ServerInsertedHTMLProvider, {
                                    children: /*#__PURE__*/ _jsx(ReactServerEntrypoint, {
                                        reactServerStream: foreverStream,
                                        preinitScripts: ()=>{},
                                        clientReferenceManifest: clientReferenceManifest,
                                        nonce: nonce
                                    })
                                })
                            });
                            const { stream: resumeStream } = await resumeRenderer.render(resumeChildren);
                            // First we write everything from the prerender, then we write everything from the aborted resume render
                            renderedHTMLStream = chainStreams(stream, resumeStream);
                        }
                        return {
                            stream: await continueStaticPrerender(renderedHTMLStream, {
                                inlinedDataStream: createInlinedDataReadableStream(dataStream, nonce, formState),
                                getServerInsertedHTML
                            })
                        };
                    }
                }
            } else if (renderOpts.postponed) {
                // This is a continuation of either an Incomplete or Dynamic Data Prerender.
                const inlinedDataStream = createInlinedDataReadableStream(dataStream, nonce, formState);
                if (resumed) {
                    // We have new HTML to stream and we also need to include server inserted HTML
                    return {
                        stream: await continueDynamicHTMLResume(stream, {
                            inlinedDataStream,
                            getServerInsertedHTML
                        })
                    };
                } else {
                    // We are continuing a Dynamic Data Prerender and simply need to append new inlined flight data
                    return {
                        stream: await continueDynamicDataResume(stream, {
                            inlinedDataStream
                        })
                    };
                }
            } else {
                // This may be a static render or a dynamic render
                // @TODO factor this further to make the render types more clearly defined and remove
                // the deluge of optional params that passed to configure the various behaviors
                return {
                    stream: await continueFizzStream(stream, {
                        inlinedDataStream: createInlinedDataReadableStream(dataStream, nonce, formState),
                        isStaticGeneration: isStaticGeneration || generateStaticHTML,
                        getServerInsertedHTML,
                        serverInsertedHTMLToHead: true,
                        validateRootLayout
                    })
                };
            }
        } catch (err) {
            if (isStaticGenBailoutError(err) || typeof err === "object" && err !== null && "message" in err && typeof err.message === "string" && err.message.includes("https://nextjs.org/docs/advanced-features/static-html-export")) {
                // Ensure that "next dev" prints the red error overlay
                throw err;
            }
            // If this is a static generation error, we need to throw it so that it
            // can be handled by the caller if we're in static generation mode.
            if (isStaticGeneration && isDynamicServerError(err)) {
                throw err;
            }
            // If a bailout made it to this point, it means it wasn't wrapped inside
            // a suspense boundary.
            const shouldBailoutToCSR = isBailoutToCSRError(err);
            if (shouldBailoutToCSR) {
                const stack = getStackWithoutErrorMessage(err);
                if (renderOpts.experimental.missingSuspenseWithCSRBailout) {
                    error(`${err.reason} should be wrapped in a suspense boundary at page "${pagePath}". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\n${stack}`);
                    throw err;
                }
                warn(`Entire page "${pagePath}" deopted into client-side rendering due to "${err.reason}". Read more: https://nextjs.org/docs/messages/deopted-into-client-rendering\n${stack}`);
            }
            if (isNotFoundError(err)) {
                res.statusCode = 404;
            }
            let hasRedirectError = false;
            if (isRedirectError(err)) {
                hasRedirectError = true;
                res.statusCode = getRedirectStatusCodeFromError(err);
                if (err.mutableCookies) {
                    const headers = new Headers();
                    // If there were mutable cookies set, we need to set them on the
                    // response.
                    if (appendMutableCookies(headers, err.mutableCookies)) {
                        res.setHeader("set-cookie", Array.from(headers.values()));
                    }
                }
                const redirectUrl = addPathPrefix(getURLFromRedirectError(err), renderOpts.basePath);
                res.setHeader("Location", redirectUrl);
            }
            const is404 = ctx.res.statusCode === 404;
            if (!is404 && !hasRedirectError && !shouldBailoutToCSR) {
                res.statusCode = 500;
            }
            const errorType = is404 ? "not-found" : hasRedirectError ? "redirect" : undefined;
            const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(buildManifest, assetPrefix, renderOpts.crossOrigin, subresourceIntegrityManifest, getAssetQueryString(ctx, false), nonce);
            const errorServerStream = ComponentMod.renderToReadableStream(/*#__PURE__*/ _jsx(ReactServerError, {
                tree: tree,
                ctx: ctx,
                errorType: errorType
            }), clientReferenceManifest.clientModules, {
                onError: serverComponentsErrorHandler
            });
            try {
                const fizzStream = await renderToInitialFizzStream({
                    ReactDOMServer: require("react-dom/server.edge"),
                    element: /*#__PURE__*/ _jsx(ReactServerEntrypoint, {
                        reactServerStream: errorServerStream,
                        preinitScripts: errorPreinitScripts,
                        clientReferenceManifest: clientReferenceManifest,
                        nonce: nonce
                    }),
                    streamOptions: {
                        nonce,
                        // Include hydration scripts in the HTML
                        bootstrapScripts: [
                            errorBootstrapScript
                        ],
                        formState
                    }
                });
                return {
                    // Returning the error that was thrown so it can be used to handle
                    // the response in the caller.
                    err,
                    stream: await continueFizzStream(fizzStream, {
                        inlinedDataStream: createInlinedDataReadableStream(// This is intentionally using the readable datastream from the
                        // main render rather than the flight data from the error page
                        // render
                        dataStream, nonce, formState),
                        isStaticGeneration,
                        getServerInsertedHTML: makeGetServerInsertedHTML({
                            polyfills,
                            renderServerInsertedHTML,
                            serverCapturedErrors: [],
                            basePath: renderOpts.basePath
                        }),
                        serverInsertedHTMLToHead: true,
                        validateRootLayout
                    })
                };
            } catch (finalErr) {
                if (process.env.NODE_ENV === "development" && isNotFoundError(finalErr)) {
                    const bailOnNotFound = require("../../client/components/dev-root-not-found-boundary").bailOnNotFound;
                    bailOnNotFound();
                }
                throw finalErr;
            }
        }
    });
    // For action requests, we handle them differently with a special render result.
    const actionRequestResult = await handleAction({
        req,
        res,
        ComponentMod,
        serverModuleMap,
        generateFlight,
        staticGenerationStore,
        requestStore,
        serverActions,
        ctx
    });
    let formState = null;
    if (actionRequestResult) {
        if (actionRequestResult.type === "not-found") {
            const notFoundLoaderTree = createNotFoundLoaderTree(loaderTree);
            const response = await renderToStream({
                asNotFound: true,
                tree: notFoundLoaderTree,
                formState
            });
            return new RenderResult(response.stream, {
                metadata
            });
        } else if (actionRequestResult.type === "done") {
            if (actionRequestResult.result) {
                actionRequestResult.result.assignMetadata(metadata);
                return actionRequestResult.result;
            } else if (actionRequestResult.formState) {
                formState = actionRequestResult.formState;
            }
        }
    }
    const options = {
        metadata
    };
    let response = await renderToStream({
        asNotFound: isNotFoundPath,
        tree: loaderTree,
        formState
    });
    // If we have pending revalidates, wait until they are all resolved.
    if (staticGenerationStore.pendingRevalidates) {
        options.waitUntil = Promise.all(Object.values(staticGenerationStore.pendingRevalidates));
    }
    addImplicitTags(staticGenerationStore);
    if (staticGenerationStore.tags) {
        metadata.fetchTags = staticGenerationStore.tags.join(",");
    }
    // Create the new render result for the response.
    const result = new RenderResult(response.stream, options);
    // If we aren't performing static generation, we can return the result now.
    if (!isStaticGeneration) {
        return result;
    }
    // If this is static generation, we should read this in now rather than
    // sending it back to be sent to the client.
    response.stream = await result.toUnchunkedString(true);
    const buildFailingError = digestErrorsMap.size > 0 ? digestErrorsMap.values().next().value : null;
    // If we're debugging partial prerendering, print all the dynamic API accesses
    // that occurred during the render.
    if (staticGenerationStore.prerenderState && usedDynamicAPIs(staticGenerationStore.prerenderState) && ((_staticGenerationStore_prerenderState = staticGenerationStore.prerenderState) == null ? void 0 : _staticGenerationStore_prerenderState.isDebugSkeleton)) {
        warn("The following dynamic usage was detected:");
        for (const access of formatDynamicAPIAccesses(staticGenerationStore.prerenderState)){
            warn(access);
        }
    }
    if (!flightDataResolver) {
        throw new Error("Invariant: Flight data resolver is missing when generating static HTML");
    }
    // If we encountered any unexpected errors during build we fail the
    // prerendering phase and the build.
    if (buildFailingError) {
        throw buildFailingError;
    }
    // Wait for and collect the flight payload data if we don't have it
    // already
    const flightData = await flightDataResolver();
    if (flightData) {
        metadata.flightData = flightData;
    }
    // If force static is specifically set to false, we should not revalidate
    // the page.
    if (staticGenerationStore.forceStatic === false) {
        staticGenerationStore.revalidate = 0;
    }
    // Copy the revalidation value onto the render result metadata.
    metadata.revalidate = staticGenerationStore.revalidate ?? ctx.defaultRevalidate;
    // provide bailout info for debugging
    if (metadata.revalidate === 0) {
        metadata.staticBailoutInfo = {
            description: staticGenerationStore.dynamicUsageDescription,
            stack: staticGenerationStore.dynamicUsageStack
        };
    }
    return new RenderResult(response.stream, options);
}
export const renderToHTMLOrFlight = (req, res, pagePath, query, renderOpts)=>{
    // TODO: this includes query string, should it?
    const pathname = validateURL(req.url);
    return RequestAsyncStorageWrapper.wrap(renderOpts.ComponentMod.requestAsyncStorage, {
        req,
        res,
        renderOpts
    }, (requestStore)=>StaticGenerationAsyncStorageWrapper.wrap(renderOpts.ComponentMod.staticGenerationAsyncStorage, {
            urlPathname: pathname,
            renderOpts,
            requestEndedState: {
                ended: false
            }
        }, (staticGenerationStore)=>renderToHTMLOrFlightImpl(req, res, pagePath, query, renderOpts, {
                requestStore,
                staticGenerationStore,
                componentMod: renderOpts.ComponentMod,
                renderOpts
            }, staticGenerationStore.requestEndedState || {})));
};

//# sourceMappingURL=app-render.js.map` invalidServerComponentReactHooksŠsetMessage…error‡message…stack…lines…split„join›getStackWithoutErrorMessage‡replace‘formatServerErrorˆincludesŒaddedMessageŠclientHook…regex†RegExp„testencodeURIPath}ÿÿÿyÿÿÿp’encodeURIComponent@C     ConcatSourceRawSourceD  
// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  f: () => (/* binding */ renderToHTMLOrFlight)
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5486);
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__(2428);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/render-result.js
var render_result = __webpack_require__(8317);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/stream-utils/node-web-streams-helper.js + 3 modules
var node_web_streams_helper = __webpack_require__(4894);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/match-segments.js
var match_segments = __webpack_require__(393);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/internal-utils.js
var internal_utils = __webpack_require__(9879);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/app-router-headers.js
var app_router_headers = __webpack_require__(3185);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/non-nullable.js
   ReplaceSource   ReplaceSourceOriginalSource±  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/non-nullable.js|ssr06undefined	   RawSourceU   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/generate/meta.js
ûü¯’  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/generate/meta.js|ssr047undefined4974undefined76124undefined126132undefined294297__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined603609undefined761771__WEBPACK_MODULE_REFERENCE__7_5b226e6f6e4e756c6c61626c65225d_directImport_asiSafe1__._undefined795805__WEBPACK_MODULE_REFERENCE__7_5b226e6f6e4e756c6c61626c65225d_call_directImport_asiSafe1__._undefined19851991undefined_   164238(0,jsx_runtime.jsx)undefined695780nonNullableundefined804894nonNullableundefinedRawSourceQ   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/constants.js
øù­)  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/constants.js|ssr06undefined296302undefinedúV   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/generate/basic.js
ö÷¬†  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/generate/basic.js|ssr047undefined4974undefined76128undefined130177undefined415430__WEBPACK_MODULE_REFERENCE__9_5b2256696577706f72744d6574614b657973225d_directImport_asiSafe1__._undefined731746__WEBPACK_MODULE_REFERENCE__9_5b2256696577706f72744d6574614b657973225d_directImport_asiSafe1__._undefined826832undefined882891__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefined903906__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined10761079__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined12331236__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined13371343undefined14551464__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefined14901493__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined16211624__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined17101713__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined18121815__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined20212024__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined21622165__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined23282331__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined24902493__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined25882591__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined27552758__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined28512854__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined29452948__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined30433046__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined31983201__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined33623365__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined35283531__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined37003703__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined38773880__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined39873990__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined40834086__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined43594362__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined45104513__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined46314637undefined48884891__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined50725078undefined53935396__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined54775483undefined56485657__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefined56795682__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined57905793__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined59475950__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined61296132__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined62596265undefined63596368__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefined63806388__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined65066514__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined66126620__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined67336741__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined69126920__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefinedS  240335ViewportMetaKeysundefined636731ViewportMetaKeysundefined860948MetaFilterundefined9601036Metaundefined12061282Metaundefined14361512Metaundefined17241812MetaFilterundefined18381912(0,jsx_runtime.jsx)undefined20402114(0,jsx_runtime.jsx)undefined22002276Metaundefined23752451Metaundefined26572731(0,jsx_runtime.jsx)undefined28692945Metaundefined31083182(0,jsx_runtime.jsx)undefined33413417Metaundefined35123588Metaundefined37523828Metaundefined39213997Metaundefined40884164Metaundefined42594335Metaundefined44874563Metaundefined47244800Metaundefined49635037(0,jsx_runtime.jsx)undefined52065280(0,jsx_runtime.jsx)undefined54545528(0,jsx_runtime.jsx)undefined56355711Metaundefined58045880Metaundefined61536229Metaundefined63776453Metaundefined68216895(0,jsx_runtime.jsx)undefined73907464(0,jsx_runtime.jsx)undefined77097797MetaFilterundefined78197895Metaundefined80038079Metaundefined82338307(0,jsx_runtime.jsx)undefined84868562Metaundefined87828870MetaFilterundefined88828968MultiMetaundefined90869172MultiMetaundefined92709356MultiMetaundefined94699555MultiMetaundefined97269812MultiMetaundefinedRawSourceZ   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/generate/alternate.js
óôª  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/generate/alternate.js|ssr047undefined4974undefined76111undefined227230__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined390396undefined551560__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefinedD   117191(0,jsx_runtime.jsx)undefined505593MetaFilterundefinedRawSourceZ   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/generate/opengraph.js
ðñ¨Í#  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/generate/opengraph.js|ssr052undefined5460undefined427430__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined768771__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined907910__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined11591162__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined14071410__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined16631671__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined18291832__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined19841992__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined22452248__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined23812384__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined25272530__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined26882696__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined28512859__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined31123115__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined32513254__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined34113414__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined35693572__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined37263729__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined40274030__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined41694172__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined43984406__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined45604568__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined48364839__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined49794987__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined51395147__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined53075310__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined55805583__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined57265734__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined58865894__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined61686171__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined63196327__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined65936596__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined67366744__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined68986906__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined70667074__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined72307233__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined73857388__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined75477555__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined78157818__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined79607968__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined81228130__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined82908298__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined84548457__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined86098612__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined87718779__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined89298932__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined91909193__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined94439446__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined97919800__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefined98129815__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined99209923__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1008410087__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1019410197__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1035210355__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1045710460__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1055710560__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1066810671__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1082610834__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1093710945__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1104811056__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1115811166__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1126911277__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1139311401__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1151311521__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1178911792__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1189211895__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1199712000__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1220712213undefined1235012359__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefined1237112374__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1245812461__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1255312556__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1265312656__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1275412757__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1286012863__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1301913022__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1312813136__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1331313316__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1345713460__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1360813611__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1374313746__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1427014276undefined1435814367__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefined1437914387__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1448414492__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1459514603__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1470214710__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1481514823__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1494014948__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1505315061__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1518615194__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined|  367443Metaundefined781857Metaundefined9931069Metaundefined13181394Metaundefined16391715Metaundefined19682054MultiMetaundefined22122288Metaundefined24402526MultiMetaundefined27792855Metaundefined29883064Metaundefined32073283Metaundefined34413527MultiMetaundefined36823768MultiMetaundefined40214097Metaundefined42334309Metaundefined44664542Metaundefined46974773Metaundefined49275003Metaundefined53015377Metaundefined55165592Metaundefined58185904MultiMetaundefined60586144MultiMetaundefined64126488Metaundefined66286714MultiMetaundefined68666952MultiMetaundefined71127188Metaundefined74587534Metaundefined76777763MultiMetaundefined79158001MultiMetaundefined82758351Metaundefined84998585MultiMetaundefined88518927Metaundefined90679153MultiMetaundefined93079393MultiMetaundefined95539639MultiMetaundefined97959871Metaundefined1002310099Metaundefined1025810344MultiMetaundefined1060410680Metaundefined1082210908MultiMetaundefined1106211148MultiMetaundefined1130811394MultiMetaundefined1155011626Metaundefined1177811854Metaundefined1201312099MultiMetaundefined1224912325Metaundefined1258312659Metaundefined1290912985Metaundefined1333013418MetaFilterundefined1343013506Metaundefined1361113687Metaundefined1384813924Metaundefined1403114107Metaundefined1426214338Metaundefined1444014516Metaundefined1461314689Metaundefined1479714873Metaundefined1502815114MultiMetaundefined1521715303MultiMetaundefined1540615492MultiMetaundefined1559415680MultiMetaundefined1578315869MultiMetaundefined1598516071MultiMetaundefined1618316269MultiMetaundefined1653716613Metaundefined1671316789Metaundefined1689116967Metaundefined1731017398MetaFilterundefined1741017486Metaundefined1757017646Metaundefined1773817814Metaundefined1791117987Metaundefined1808518161Metaundefined1826418340Metaundefined1849618572Metaundefined1867818764MultiMetaundefined1894119017Metaundefined1915819234Metaundefined1938219458Metaundefined1959019666Metaundefined2027120359MetaFilterundefined2037120457MultiMetaundefined2055420640MultiMetaundefined2074320829MultiMetaundefined2092821014MultiMetaundefined2111921205MultiMetaundefined2132221408MultiMetaundefined2151321599MultiMetaundefined2172421810MultiMetaundefinedRawSourceV   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/generate/icons.js
íî¦f  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/generate/icons.js|ssr047undefined4974undefined76111undefined228231__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined606609__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined686692undefined913922__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefinedg   118192(0,jsx_runtime.jsx)undefined567641(0,jsx_runtime.jsx)undefined9381026MetaFilterundefinedRawSourceX   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/default-metadata.js
êë¤0  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/default-metadata.js|ssr06undefined224230undefinedìV   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/generate/utils.js
èé£#  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/generate/utils.js|ssr295345undefinedê  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/isomorphic/path.js
var path = __webpack_require__(7652);
var path_default = /*#__PURE__*/__webpack_require__.n(path);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-url.js
æç¢V  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-url.js|ssr054undefined741747undefined10801117falseundefined11201178{}undefined12181254 trueundefined19681977__WEBPACK_MODULE_REFERENCE__16_5b2264656661756c74222c22706f736978225d_call_asiSafe1__._undefined22232232__WEBPACK_MODULE_REFERENCE__16_5b2264656661756c74222c22706f736978225d_call_asiSafe1__._undefined41994289undefinedS   17841870path_default().posixundefined21162202path_default().posixundefinedRawSource_   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-title.js
ãä ,  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-title.js|ssr113119undefinedå-  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/lib/url.js
var url = __webpack_require__(8890);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/build/output/log.js
var log = __webpack_require__(292);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-opengraph.js
áâŸc  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-opengraph.js|ssr061undefined63188undefined190236undefined238281undefined283335undefined946958__WEBPACK_MODULE_REFERENCE__17_5b226973537472696e674f7255524c225d_call_directImport_asiSafe1__._undefined11691178__WEBPACK_MODULE_REFERENCE__17_5b227265736f6c766555726c225d_call_directImport_asiSafe1__._undefined12831292__WEBPACK_MODULE_REFERENCE__17_5b227265736f6c766555726c225d_call_directImport_asiSafe1__._undefined13271333undefined14081432__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined15511584__WEBPACK_MODULE_REFERENCE__17_5b22676574536f6369616c496d61676546616c6c6261636b4d6574616461746142617365225d_call_directImport_asiSafe1__._undefined26282642__WEBPACK_MODULE_REFERENCE__19_5b22697346756c6c537472696e6755726c225d_call_directImport_asiSafe1__._undefined26902697__WEBPACK_MODULE_REFERENCE__20_5b227761726e4f6e6365225d_call_directImport_asiSafe1__._undefined29412947undefined34313455__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined36833694__WEBPACK_MODULE_REFERENCE__18_5b227265736f6c76655469746c65225d_call_directImport_asiSafe1__._undefined38093838__WEBPACK_MODULE_REFERENCE__17_5b227265736f6c76654162736f6c75746555726c57697468506174686e616d65225d_call_directImport_asiSafe1__._undefined40284034undefined42764287__WEBPACK_MODULE_REFERENCE__18_5b227265736f6c76655469746c65225d_call_directImport_asiSafe1__._undefined48134837__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefinedÌ  614709isStringOrURLundefined9201009resolveUrlundefined11141203resolveUrlundefined13121431resolveAsArrayOrUndefinedundefined15501687getSocialImageFallbackMetadataBaseundefined27312830(0,url/* isFullStringUrl */.N)undefined28782963(0,log/* warnOnce */.O4)undefined36903809resolveAsArrayOrUndefinedundefined40374130resolveTitleundefined42454374resolveAbsoluteUrlWithPathnameundefined48054898resolveTitleundefined54245543resolveAsArrayOrUndefinedundefinedRawSourceO   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/client-reference.js
Þß  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/client-reference.js|ssr06undefinedàÈ   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/segment.js
var lib_segment = __webpack_require__(8478);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/lib/app-dir-module.js
ÜÝœ°  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/lib/app-dir-module.js|ssr062undefined6470undefined361379__WEBPACK_MODULE_REFERENCE__23_5b2244454641554c545f5345474d454e545f4b4559225d_directImport_asiSafe1__._undefined762768undefined?   291393lib_segment/* DEFAULT_SEGMENT_KEY */.avundefinedRawSourceN   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/interop-default.js
ÙÚš  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/interop-default.js|ssr06undefinedÛ`   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-basics.js
×Ø™é  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-basics.js|ssr061undefined63125undefined409438__WEBPACK_MODULE_REFERENCE__17_5b227265736f6c76654162736f6c75746555726c57697468506174686e616d65225d_call_directImport_asiSafe1__._undefined479485undefined670694__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined22932299undefined37633769undefined40854091undefined44624486__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined46374661__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined47064712undefined49955019__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined54135419undefined55885612__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined56605666undefined  284413resolveAbsoluteUrlWithPathnameundefined638757resolveAsArrayOrUndefinedundefined45044623resolveAsArrayOrUndefinedundefined47744893resolveAsArrayOrUndefinedundefined52205339resolveAsArrayOrUndefinedundefined59016020resolveAsArrayOrUndefinedundefinedRawSource_   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-icons.js
ÔÕ—(  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-icons.js|ssr061undefined63108undefined110149undefined151157undefined195207__WEBPACK_MODULE_REFERENCE__17_5b226973537472696e674f7255524c225d_call_directImport_asiSafe1__._undefined316322undefined577589__WEBPACK_MODULE_REFERENCE__17_5b226973537472696e674f7255524c225d_call_directImport_asiSafe1__._undefined708715__WEBPACK_MODULE_REFERENCE__9_5b2249636f6e4b657973225d_directImport_asiSafe1__._undefined746770__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined   40135isStringOrURLundefined498593isStringOrURLundefined712791IconKeysundefined822941resolveAsArrayOrUndefinedundefinedRawSourceF  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/lib/trace/tracer.js
var tracer = __webpack_require__(8844);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/lib/trace/constants.js
var constants = __webpack_require__(6236);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/resolve-metadata.js
ÑÒ•¡  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/resolve-metadata.js|ssr081undefined83163undefined165221undefined223283undefined285340undefined342437undefined439490undefined492661undefined663719undefined721778undefined780850undefined852911undefined913958undefined23952408__WEBPACK_MODULE_REFERENCE__21_5b227265736f6c766554776974746572225d_call_directImport_asiSafe1__._undefined28652880__WEBPACK_MODULE_REFERENCE__21_5b227265736f6c76654f70656e4772617068225d_call_directImport_asiSafe1__._undefined37223733__WEBPACK_MODULE_REFERENCE__18_5b227265736f6c76655469746c65225d_call_directImport_asiSafe1__._undefined39063922__WEBPACK_MODULE_REFERENCE__26_5b227265736f6c7665416c7465726e61746573225d_call_directImport_asiSafe1__._undefined41074122__WEBPACK_MODULE_REFERENCE__21_5b227265736f6c76654f70656e4772617068225d_call_directImport_asiSafe1__._undefined43284341__WEBPACK_MODULE_REFERENCE__21_5b227265736f6c766554776974746572225d_call_directImport_asiSafe1__._undefined45144532__WEBPACK_MODULE_REFERENCE__26_5b227265736f6c7665566572696669636174696f6e225d_call_directImport_asiSafe1__._undefined46584669__WEBPACK_MODULE_REFERENCE__27_5b227265736f6c766549636f6e73225d_call_directImport_asiSafe1__._undefined48004817__WEBPACK_MODULE_REFERENCE__26_5b227265736f6c76654170706c65576562417070225d_call_directImport_asiSafe1__._undefined49264940__WEBPACK_MODULE_REFERENCE__26_5b227265736f6c76654170704c696e6b73225d_call_directImport_asiSafe1__._undefined50645076__WEBPACK_MODULE_REFERENCE__26_5b227265736f6c7665526f626f7473225d_call_directImport_asiSafe1__._undefined53065330__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined54715495__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined56385650__WEBPACK_MODULE_REFERENCE__26_5b227265736f6c76654974756e6573225d_call_directImport_asiSafe1__._undefined73277343__WEBPACK_MODULE_REFERENCE__26_5b227265736f6c76655468656d65436f6c6f72225d_call_directImport_asiSafe1__._undefined78397855__WEBPACK_MODULE_REFERENCE__22_5b226973436c69656e745265666572656e6365225d_call_directImport_asiSafe1__._undefined80118019__WEBPACK_MODULE_REFERENCE__28_5b22676574547261636572225d_call_directImport_asiSafe1__._undefined80298047__WEBPACK_MODULE_REFERENCE__29_5b225265736f6c76654d657461646174615370616e225d_asiSafe1__._undefined85448560__WEBPACK_MODULE_REFERENCE__22_5b226973436c69656e745265666572656e6365225d_call_directImport_asiSafe1__._undefined87168724__WEBPACK_MODULE_REFERENCE__28_5b22676574547261636572225d_call_directImport_asiSafe1__._undefined87348752__WEBPACK_MODULE_REFERENCE__29_5b225265736f6c76654d657461646174615370616e225d_asiSafe1__._undefined92329245__WEBPACK_MODULE_REFERENCE__25_5b22696e7465726f7044656661756c74225d_call_directImport_asiSafe1__._undefined1013910145undefined1042510446__WEBPACK_MODULE_REFERENCE__24_5b22676574436f6d706f6e656e74547970654d6f64756c65225d_call_directImport_asiSafe1__._undefined1054410564__WEBPACK_MODULE_REFERENCE__24_5b226765744c61796f75744f72506167654d6f64756c65225d_call_directImport_asiSafe1__._undefined1111311134__WEBPACK_MODULE_REFERENCE__24_5b22676574436f6d706f6e656e74547970654d6f64756c65225d_call_directImport_asiSafe1__._undefined1158011586undefined1280312818__WEBPACK_MODULE_REFERENCE__23_5b22504147455f5345474d454e545f4b4559225d_directImport_asiSafe1__._undefined1401714016(/* unused pure expression or super */ null && (undefined1406514064))undefined1514915162__WEBPACK_MODULE_REFERENCE__21_5b227265736f6c766554776974746572225d_call_directImport_asiSafe1__._undefined1820618243 falseundefined18247183200undefined1918319189undefined1928719307__WEBPACK_MODULE_REFERENCE__14_5b2263726561746544656661756c744d65746164617461225d_call_directImport_asiSafe1__._undefined2130121308__WEBPACK_MODULE_REFERENCE__20_5b227761726e225d_call_asiSafe1__._undefined2140421410undefined2149121511__WEBPACK_MODULE_REFERENCE__14_5b2263726561746544656661756c7456696577706f7274225d_call_directImport_asiSafe1__._undefined2200022006undefined2244722467__WEBPACK_MODULE_REFERENCE__14_5b2263726561746544656661756c744d65746164617461225d_call_directImport_asiSafe1__._undefined2249122511__WEBPACK_MODULE_REFERENCE__14_5b2263726561746544656661756c7456696577706f7274225d_call_directImport_asiSafe1__._undefined¾  14481545resolveTwitterundefined20022103resolveOpenGraphundefined29453038resolveTitleundefined32113314resolveAlternatesundefined34993600resolveOpenGraphundefined38063903resolveTwitterundefined40764183resolveVerificationundefined43094402resolveIconsundefined45334638resolveAppleWebAppundefined47474846resolveAppLinksundefined49705065resolveRobotsundefined52955414resolveAsArrayOrUndefinedundefined55555674resolveAsArrayOrUndefinedundefined58175912resolveItunesundefined75897692resolveThemeColorundefined81888291isClientReferenceundefined84478534(0,tracer/* getTracer */.Yz)undefined85448633constants/* ResolveMetadataSpan */._sundefined91309233isClientReferenceundefined93899476(0,tracer/* getTracer */.Yz)undefined94869575constants/* ResolveMetadataSpan */._sundefined1005510152interopDefaultundefined1132511438getComponentTypeModuleundefined1153611647getLayoutOrPageModuleundefined1219612309getComponentTypeModuleundefined1397114067lib_segment/* PAGE_SEGMENT_KEY */.GCundefined1644816545resolveTwitterundefined2055820669createDefaultMetadataundefined2266322727log/* warn */.ZKundefined2290323014createDefaultViewportundefined2394324054createDefaultMetadataundefined2407824189createDefaultViewportundefinedRawSourceË   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/not-found.js
var not_found = __webpack_require__(5254);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/metadata.js
ÎÏ“ý
  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/metadata.js|ssr070undefined7297undefined99225undefined227284undefined286373undefined375423undefined425477undefined479523undefined525606undefined608675undefined11641170undefined17451765__WEBPACK_MODULE_REFERENCE__14_5b2263726561746544656661756c744d65746164617461225d_call_directImport_asiSafe1__._undefined18021822__WEBPACK_MODULE_REFERENCE__14_5b2263726561746544656661756c7456696577706f7274225d_call_directImport_asiSafe1__._undefined22562270__WEBPACK_MODULE_REFERENCE__30_5b227265736f6c76654d65746164617461225d_call_directImport_asiSafe1__._undefined30223036__WEBPACK_MODULE_REFERENCE__31_5b2269734e6f74466f756e644572726f72225d_call_directImport_asiSafe1__._undefined31463160__WEBPACK_MODULE_REFERENCE__30_5b227265736f6c76654d65746164617461225d_call_directImport_asiSafe1__._undefined37173726__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefined37423753__WEBPACK_MODULE_REFERENCE__10_5b2256696577706f72744d657461225d_call_directImport_asiSafe1__._undefined38203828__WEBPACK_MODULE_REFERENCE__10_5b2242617369634d657461225d_call_directImport_asiSafe1__._undefined38853902__WEBPACK_MODULE_REFERENCE__11_5b22416c7465726e617465734d65746164617461225d_call_directImport_asiSafe1__._undefined39823991__WEBPACK_MODULE_REFERENCE__10_5b224974756e65734d657461225d_call_directImport_asiSafe1__._undefined40634081__WEBPACK_MODULE_REFERENCE__10_5b22466f726d6174446574656374696f6e4d657461225d_call_directImport_asiSafe1__._undefined41714186__WEBPACK_MODULE_REFERENCE__10_5b22566572696669636174696f6e4d657461225d_call_directImport_asiSafe1__._undefined42704284__WEBPACK_MODULE_REFERENCE__10_5b224170706c655765624170704d657461225d_call_directImport_asiSafe1__._undefined43664382__WEBPACK_MODULE_REFERENCE__12_5b224f70656e47726170684d65746164617461225d_call_directImport_asiSafe1__._undefined44604474__WEBPACK_MODULE_REFERENCE__12_5b22547769747465724d65746164617461225d_call_directImport_asiSafe1__._undefined45484559__WEBPACK_MODULE_REFERENCE__12_5b224170704c696e6b734d657461225d_call_directImport_asiSafe1__._undefined46354647__WEBPACK_MODULE_REFERENCE__13_5b2249636f6e734d65746164617461225d_call_directImport_asiSafe1__._undefined47804783__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined48744877__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined48794887__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined49794996__WEBPACK_MODULE_REFERENCE__1_5b2264656661756c74222c22636c6f6e65456c656d656e74225d_call_asiSafe1__._undefinedÌ  10711182createDefaultMetadataundefined12191330createDefaultViewportundefined17641863resolveMetadataundefined26152714(0,not_found/* isNotFoundError */.X)undefined28242923resolveMetadataundefined34803568MetaFilterundefined35843677ViewportMetaundefined37443831BasicMetaundefined38883993AlternatesMetadataundefined40734162ItunesMetaundefined42344341FormatDetectionMetaundefined44314532VerificationMetaundefined46164715AppleWebAppMetaundefined47974900OpenGraphMetadataundefined49785077TwitterMetadataundefined51515244AppLinksMetaundefined53205415IconsMetadataundefined55485622(0,jsx_runtime.jsx)undefined57135787(0,jsx_runtime.jsx)undefined57895868jsx_runtime.Fragmentundefined59606059react.cloneElementundefinedRawSource´  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/async-storage/request-async-storage-wrapper.js + 1 modules
var request_async_storage_wrapper = __webpack_require__(4569);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/app-render/dynamic-rendering.js
var dynamic_rendering = __webpack_require__(8255);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/async-storage/static-generation-async-storage-wrapper.js
ËÌ‘Í  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/async-storage/static-generation-async-storage-wrapper.js|ssr080undefined8288undefined11621181__WEBPACK_MODULE_REFERENCE__34_5b2263726561746550726572656e6465725374617465225d_call_directImport_asiSafe1__._undefinedL   10741183(0,dynamic_rendering/* createPrerenderState */.FI)undefinedRawSource;  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/redirect.js
var redirect = __webpack_require__(3925);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/lib/constants.js
var lib_constants = __webpack_require__(4410);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/lib/patch-fetch.js
ÈÆL   /* provided dependency */ var Buffer = __webpack_require__(6195)["Buffer"];
ÈŽZ  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/lib/patch-fetch.js|ssr069undefined71123undefined125258undefined260305undefined307374undefined398397(/* unused pure expression or super */ null && (undefined398421"edge"undefined433432))undefined539545undefined13921398undefined32753281undefined36963721__WEBPACK_MODULE_REFERENCE__37_5b224e4558545f43414348455f494d504c494349545f5441475f4944225d_directImport_asiSafe1__._undefined41514176__WEBPACK_MODULE_REFERENCE__37_5b224e4558545f43414348455f494d504c494349545f5441475f4944225d_directImport_asiSafe1__._undefined47494768"production"undefined1900519010Bufferundefined2308223087Bufferundefined2741027416undefined‹   34123528lib_constants/* NEXT_CACHE_IMPLICIT_TAG_ID */.ztundefined39584074lib_constants/* NEXT_CACHE_IMPLICIT_TAG_ID */.ztundefinedRawSourcea   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/flight-render-result.js
ÄÅŒ"  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/flight-render-result.js|ssr084undefined86129undefined246252undefined286297__WEBPACK_MODULE_REFERENCE__2_5b2264656661756c74225d_directImport_asiSafe1__._undefined379401__WEBPACK_MODULE_REFERENCE__6_5b225253435f434f4e54454e545f545950455f484541444552225d_directImport_asiSafe1__._undefinedu   150227render_result/* default */.Zundefined309418app_router_headers/* RSC_CONTENT_TYPE_HEADER */.eYundefinedRawSource  
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/string-hash/index.js
var string_hash = __webpack_require__(1252);
var string_hash_default = /*#__PURE__*/__webpack_require__.n(string_hash);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/format-server-error.js
Á   ReplaceSourceSourceMapSourceg	  const invalidServerComponentReactHooks = [
    "useDeferredValue",
    "useEffect",
    "useImperativeHandle",
    "useInsertionEffect",
    "useLayoutEffect",
    "useReducer",
    "useRef",
    "useState",
    "useSyncExternalStore",
    "useTransition",
    "experimental_useOptimistic",
    "useOptimistic"
];
function setMessage(error, message) {
    error.message = message;
    if (error.stack) {
        const lines = error.stack.split("\n");
        lines[0] = message;
        error.stack = lines.join("\n");
    }
}
/**
 * Input:
 * Error: Something went wrong
    at funcName (/path/to/file.js:10:5)
    at anotherFunc (/path/to/file.js:15:10)
 
 * Output:
    at funcName (/path/to/file.js:10:5)
    at anotherFunc (/path/to/file.js:15:10) 
 */ export function getStackWithoutErrorMessage(error) {
    const stack = error.stack;
    if (!stack) return "";
    return stack.replace(/^[^\n]*\n/, "");
}
export function formatServerError(error) {
    if (typeof (error == null ? void 0 : error.message) !== "string") return;
    if (error.message.includes("Class extends value undefined is not a constructor or null")) {
        const addedMessage = "This might be caused by a React Class Component being rendered in a Server Component, React Class Components only works in Client Components. Read more: https://nextjs.org/docs/messages/class-component-in-server-component";
        // If this error instance already has the message, don't add it again
        if (error.message.includes(addedMessage)) return;
        setMessage(error, `${error.message}

${addedMessage}`);
        return;
    }
    if (error.message.includes("createContext is not a function")) {
        setMessage(error, 'createContext only works in Client Components. Add the "use client" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/context-in-server-component');
        return;
    }
    for (const clientHook of invalidServerComponentReactHooks){
        const regex = new RegExp(`\\b${clientHook}\\b.*is not a function`);
        if (regex.test(error.message)) {
            setMessage(error, `${clientHook} only works in Client Components. Add the "use client" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/react-client-hook-in-server-component`);
            return;
        }
    }
} //# sourceMappingURL=format-server-error.js.map
8  {"version":3,"sources":["webpack://../../src/lib/format-server-error.ts"],"names":["invalidServerComponentReactHooks","setMessage","error","message","stack","lines","split","join","getStackWithoutErrorMessage","replace","formatServerError","includes","addedMessage","clientHook","regex","RegExp","test"],"mappings":"AAAA,MAAMA,mCAAmC;IACvC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,SAASC,WAAWC,KAAY,EAAEC,OAAe;IAC/CD,MAAMC,OAAO,GAAGA;IAChB,IAAID,MAAME,KAAK,EAAE;QACf,MAAMC,QAAQH,MAAME,KAAK,CAACE,KAAK,CAAC;QAChCD,KAAK,CAAC,EAAE,GAAGF;QACXD,MAAME,KAAK,GAAGC,MAAME,IAAI,CAAC;IAC3B;AACF;AAEA;;;;;;;;;CASC,GACD,OAAO,SAASC,4BAA4BN,KAAY;IACtD,MAAME,QAAQF,MAAME,KAAK;IACzB,IAAI,CAACA,OAAO,OAAO;IACnB,OAAOA,MAAMK,OAAO,CAAC,aAAa;AACpC;AAEA,OAAO,SAASC,kBAAkBR,KAAY;IAC5C,IAAI,OAAOA,CAAAA,SAAAA,OAAAA,KAAAA,IAAAA,MAAOC,OAAO,AAAPA,MAAY,UAAU;IAExC,IACED,MAAMC,OAAO,CAACQ,QAAQ,CACpB,+DAEF;QACA,MAAMC,eACJ;QAEF,qEAAqE;QACrE,IAAIV,MAAMC,OAAO,CAACQ,QAAQ,CAACC,eAAe;QAE1CX,WACEC,OACA,CAAC,EAAEA,MAAMC,OAAO,CAAC;;AAEvB,EAAES,aAAa,CAAC;QAEZ;IACF;IAEA,IAAIV,MAAMC,OAAO,CAACQ,QAAQ,CAAC,oCAAoC;QAC7DV,WACEC,OACA;QAEF;IACF;IAEA,KAAK,MAAMW,cAAcb,iCAAkC;QACzD,MAAMc,QAAQ,IAAIC,OAAO,CAAC,GAAG,EAAEF,WAAW,sBAAsB,CAAC;QACjE,IAAIC,MAAME,IAAI,CAACd,MAAMC,OAAO,GAAG;YAC7BF,WACEC,OACA,CAAC,EAAEW,WAAW,oLAAoL,CAAC;YAErM;QACF;IACF;AACF","file":"x"}#   false758764undefined914920undefinedÀø  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/pipe-readable.js
var pipe_readable = __webpack_require__(7515);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/hooks-server-context.js
var hooks_server_context = __webpack_require__(2726);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/lazy-dynamic/bailout-to-csr.js
var bailout_to_csr = __webpack_require__(1192);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/export/helpers/is-navigation-signal-error.js
¼½…1  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/export/helpers/is-navigation-signal-error.js|ssr067undefined69135undefined312318undefined358372__WEBPACK_MODULE_REFERENCE__31_5b2269734e6f74466f756e644572726f72225d_call_directImport_asiSafe1__._undefined382396__WEBPACK_MODULE_REFERENCE__36_5b22697352656469726563744572726f72225d_call_directImport_asiSafe1__._undefinedo   216315(0,not_found/* isNotFoundError */.X)undefined325424(0,redirect/* isRedirectError */.eo)undefinedRawSource`   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/export/helpers/is-dynamic-usage-error.js
¹ºƒÑ  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/export/helpers/is-dynamic-usage-error.js|ssr083undefined85167undefined169239undefined241247undefined283302__WEBPACK_MODULE_REFERENCE__43_5b22697344796e616d69635365727665724572726f72225d_call_directImport_asiSafe1__._undefined312330__WEBPACK_MODULE_REFERENCE__44_5b2269734261696c6f7574546f4353524572726f72225d_call_directImport_asiSafe1__._undefined340362__WEBPACK_MODULE_REFERENCE__45_5b2269734e617669676174696f6e5369676e616c4572726f72225d_call_directImport_asiSafe1__._undefined­   38147(0,hooks_server_context/* isDynamicServerError */.j)undefined157264(0,bailout_to_csr/* isBailoutToCSRError */.D)undefined274389isNavigationSignalErrorundefinedRawSourcea   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/create-error-handler.js
¶·  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/create-error-handler.js|ssr055undefined57122undefined124187undefined189236undefined238319undefined321327undefined603609undefined11091118__WEBPACK_MODULE_REFERENCE__40_5b2264656661756c74225d_call_directImport_asiSafe1__._undefined14401458__WEBPACK_MODULE_REFERENCE__46_5b22697344796e616d696355736167654572726f72225d_call_directImport_asiSafe1__._undefined15681579__WEBPACK_MODULE_REFERENCE__42_5b22697341626f72744572726f72225d_call_directImport_asiSafe1__._undefined20752091__WEBPACK_MODULE_REFERENCE__41_5b22666f726d61745365727665724572726f72225d_call_directImport_asiSafe1__._undefined25572565__WEBPACK_MODULE_REFERENCE__28_5b22676574547261636572225d_call_directImport_asiSafe1__._undefined27172730__WEBPACK_MODULE_REFERENCE__28_5b225370616e537461747573436f6465225d_asiSafe1__._undefined  779862string_hash_default()undefined11841291isDynamicUsageErrorundefined14011494(0,pipe_readable/* isAbortError */.D)undefined19902093formatServerErrorundefined25592646(0,tracer/* getTracer */.Yz)undefined27982877tracer/* SpanStatusCode */.QnundefinedRawSourcei   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/get-short-dynamic-param-type.js
³´ÿÿÿA  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-short-dynamic-param-type.js|ssr06undefined270276undefinedµ×   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/app-render/get-segment-param.js
var get_segment_param = __webpack_require__(7126);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/htmlescape.js
±²~ÿÿÿ(  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/htmlescape.js|ssr306312undefined356362undefined³i   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/get-script-nonce-from-header.js
¯°}ÿÿÿ¢  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-script-nonce-from-header.js|ssr044undefined4652undefined13341345__WEBPACK_MODULE_REFERENCE__50_5b224553434150455f5245474558225d_call_asiSafe1__._undefined&   12821362ESCAPE_REGEXundefinedRawSource  
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/superstruct/index.cjs
var superstruct = __webpack_require__(6466);
var superstruct_default = /*#__PURE__*/__webpack_require__.n(superstruct);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/types.js
¬­{ÿÿÿU	  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/types.js|ssr046undefined8086__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c22656e756d73225d_call_asiSafe1__._undefined163169__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c22756e696f6e225d_call_asiSafe1__._undefined177184__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c22737472696e67225d_call_asiSafe1__._undefined193199__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c227475706c65225d_call_asiSafe1__._undefined211218__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c22737472696e67225d_call_asiSafe1__._undefined231238__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c22737472696e67225d_call_asiSafe1__._undefined474480undefined513519__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c227475706c65225d_call_asiSafe1__._undefined546553__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c227265636f7264225d_call_asiSafe1__._undefined555562__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c22737472696e67225d_call_asiSafe1__._undefined567572__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c226c617a79225d_call_asiSafe1__._undefined609618__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c226f7074696f6e616c225d_call_asiSafe1__._undefined620629__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c226e756c6c61626c65225d_call_asiSafe1__._undefined631638__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c22737472696e67225d_call_asiSafe1__._undefined649658__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c226f7074696f6e616c225d_call_asiSafe1__._undefined660669__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c226e756c6c61626c65225d_call_asiSafe1__._undefined671677__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c22756e696f6e225d_call_asiSafe1__._undefined689697__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c226c69746572616c225d_call_asiSafe1__._undefined719727__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c226c69746572616c225d_call_asiSafe1__._undefined754763__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c226f7074696f6e616c225d_call_asiSafe1__._undefined765773__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c22626f6f6c65616e225d_call_asiSafe1__._undefined…  33119superstruct_default().enumsundefined196282superstruct_default().unionundefined290378superstruct_default().stringundefined387473superstruct_default().tupleundefined485573superstruct_default().stringundefined586674superstruct_default().stringundefined9421028superstruct_default().tupleundefined10551143superstruct_default().recordundefined11451233superstruct_default().stringundefined12381322superstruct_default().lazyundefined13591451superstruct_default().optionalundefined14531545superstruct_default().nullableundefined15471635superstruct_default().stringundefined16461738superstruct_default().optionalundefined17401832superstruct_default().nullableundefined18341920superstruct_default().unionundefined19322022superstruct_default().literalundefined20442134superstruct_default().literalundefined21612253superstruct_default().optionalundefined22552345superstruct_default().booleanundefinedRawSources   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/parse-and-validate-flight-router-state.js
©ªyÿÿÿ9  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/parse-and-validate-flight-router-state.js|ssr049undefined51106undefined108114undefined896901__WEBPACK_MODULE_REFERENCE__52_5b22617373657274225d_call_directImport_asiSafe1__._undefined910932__WEBPACK_MODULE_REFERENCE__53_5b22666c69676874526f757465725374617465536368656d61225d_directImport_asiSafe1__._undefinedT   783864(0,superstruct.assert)undefined873983flightRouterStateSchemaundefinedRawSourceY   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/validate-url.js
¦§wÿÿÿ$  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/validate-url.js|ssr8490undefined¨x   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/create-flight-router-state-from-loader-tree.js
¤¥vÿÿÿÎ  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/create-flight-router-state-from-loader-tree.js|ssr059undefined6167undefined169184__WEBPACK_MODULE_REFERENCE__23_5b22504147455f5345474d454e545f4b4559225d_directImport_asiSafe1__._undefined390396undefined<   102198lib_segment/* PAGE_SEGMENT_KEY */.GCundefinedRawSourceV   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/lib/server-ipc/utils.js
¡¢tÿÿÿ=  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/lib/server-ipc/utils.js|ssr06undefined374380undefined485491undefined£Š  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/adapters/request-cookies.js
var request_cookies = __webpack_require__(4488);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/lib/server-action-request-meta.js
var server_action_request_meta = __webpack_require__(5627);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/csrf-protection.js
Ÿ sÿÿÿ+  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/csrf-protection.js|ssr28992905undefined¡M  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/cookies.js
var cookies = __webpack_require__(9474);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/adapters/headers.js
var headers = __webpack_require__(3581);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/utils.js
var utils = __webpack_require__(3541);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/app-render/action-utils.js
var action_utils = __webpack_require__(12);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/action-handler.js
žrÿÿÿe  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/action-handler.js|ssr096undefined98165undefined167290undefined292335undefined337396undefined398481undefined483593undefined595707undefined709791undefined793848undefined850895undefined897976undefined9781049undefined10511109undefined11111169undefined18441857__WEBPACK_MODULE_REFERENCE__61_5b2252657175657374436f6f6b696573225d_directImport_asiSafe1__._undefined18591872__WEBPACK_MODULE_REFERENCE__62_5b224865616465727341646170746572225d_call_asiSafe1__._undefined20152029__WEBPACK_MODULE_REFERENCE__61_5b22526573706f6e7365436f6f6b696573225d_directImport_asiSafe1__._undefined20312057__WEBPACK_MODULE_REFERENCE__63_5b2266726f6d4e6f64654f7574676f696e674874747048656164657273225d_call_directImport_asiSafe1__._undefined21462161__WEBPACK_MODULE_REFERENCE__57_5b2266696c74657252657148656164657273225d_call_directImport_asiSafe1__._undefined22682290__WEBPACK_MODULE_REFERENCE__57_5b22616374696f6e73466f7262696464656e48656164657273225d_directImport_asiSafe1__._undefined40154037__WEBPACK_MODULE_REFERENCE__58_5b226765744d6f646966696564436f6f6b696556616c756573225d_call_directImport_asiSafe1__._undefined54925526trueundefined57476307{}undefined66936715__WEBPACK_MODULE_REFERENCE__6_5b225253435f434f4e54454e545f545950455f484541444552225d_directImport_asiSafe1__._undefined68886910__WEBPACK_MODULE_REFERENCE__57_5b22616374696f6e73466f7262696464656e48656164657273225d_call_asiSafe1__._undefined70317048__WEBPACK_MODULE_REFERENCE__39_5b22466c6967687452656e646572526573756c74225d_directImport_asiSafe1__._undefined85338542__WEBPACK_MODULE_REFERENCE__6_5b225253435f484541444552225d_directImport_asiSafe1__._undefined93649397__WEBPACK_MODULE_REFERENCE__37_5b224e4558545f43414348455f524556414c4944415445445f544147535f484541444552225d_directImport_asiSafe1__._undefined94839520__WEBPACK_MODULE_REFERENCE__37_5b224e4558545f43414348455f524556414c49444154455f5441475f544f4b454e5f484541444552225d_directImport_asiSafe1__._undefined1050410526__WEBPACK_MODULE_REFERENCE__6_5b225253435f434f4e54454e545f545950455f484541444552225d_directImport_asiSafe1__._undefined1071110733__WEBPACK_MODULE_REFERENCE__57_5b22616374696f6e73466f7262696464656e48656164657273225d_call_asiSafe1__._undefined1087010887__WEBPACK_MODULE_REFERENCE__39_5b22466c6967687452656e646572526573756c74225d_directImport_asiSafe1__._undefined1137811389__WEBPACK_MODULE_REFERENCE__2_5b2264656661756c74225d_call_asiSafe1__._undefined1161411620undefined1197712006__WEBPACK_MODULE_REFERENCE__59_5b22676574536572766572416374696f6e526571756573744d65746164617461225d_call_directImport_asiSafe1__._undefined1295112954__WEBPACK_MODULE_REFERENCE__20_5b227761726e225d_call_directImport_asiSafe1__._undefined1362313641__WEBPACK_MODULE_REFERENCE__60_5b226973437372664f726967696e416c6c6f776564225d_call_directImport_asiSafe1__._undefined1607716101__WEBPACK_MODULE_REFERENCE__64_5b2273656c656374576f726b6572466f72466f7277617264696e67225d_call_directImport_asiSafe1__._undefined1669216726trueundefined1916023719{}undefined2552025534__WEBPACK_MODULE_REFERENCE__36_5b22697352656469726563744572726f72225d_call_directImport_asiSafe1__._undefined2557625598__WEBPACK_MODULE_REFERENCE__36_5b2267657455524c46726f6d52656469726563744572726f72225d_call_directImport_asiSafe1__._undefined2563725666__WEBPACK_MODULE_REFERENCE__36_5b226765745265646972656374537461747573436f646546726f6d4572726f72225d_call_directImport_asiSafe1__._undefined2652426543__WEBPACK_MODULE_REFERENCE__58_5b22617070656e644d757461626c65436f6f6b696573225d_call_directImport_asiSafe1__._undefined2681526826__WEBPACK_MODULE_REFERENCE__2_5b2264656661756c74225d_call_asiSafe1__._undefined2687726891__WEBPACK_MODULE_REFERENCE__31_5b2269734e6f74466f756e644572726f72225d_call_directImport_asiSafe1__._undefinedÂ  688780cookies/* RequestCookies */.qundefined782866headers/* HeadersAdapter */.hundefined10091103cookies/* ResponseCookies */.nundefined11051228(0,utils/* fromNodeOutgoingHttpHeaders */.EK)undefined13171418filterReqHeadersundefined15251635actionsForbiddenHeadersundefined33603475(0,request_cookies/* getModifiedCookieValues */.fB)undefined55415650app_router_headers/* RSC_CONTENT_TYPE_HEADER */.eYundefined58235925actionsForbiddenHeadersundefined60466146FlightRenderResultundefined76317714app_router_headers/* RSC_HEADER */.Aundefined85368668lib_constants/* NEXT_CACHE_REVALIDATED_TAGS_HEADER */.ofundefined87548894lib_constants/* NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER */.X_undefined98789987app_router_headers/* RSC_CONTENT_TYPE_HEADER */.eYundefined1017210274actionsForbiddenHeadersundefined1041110511FlightRenderResultundefined1100211071render_result/* default */.Zundefined1165211781(0,server_action_request_meta/* getServerActionRequestMetadata */.G)undefined1272612803(0,log/* warn */.ZK)undefined1347213579isCsrfOriginAllowedundefined1601516134(0,action_utils/* selectWorkerForForwarding */.k)undefined2096421063(0,redirect/* isRedirectError */.eo)undefined2110521220(0,redirect/* getURLFromRedirectError */.M6)undefined2125921388(0,redirect/* getRedirectStatusCodeFromError */.j2)undefined2224622355(0,request_cookies/* appendMutableCookies */._5)undefined2262722696render_result/* default */.Zundefined2274722846(0,not_found/* isNotFoundError */.X)undefinedRawSource	  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/server-inserted-html.shared-runtime.js
var server_inserted_html_shared_runtime = __webpack_require__(3234);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/server-inserted-html.js
š›pÿÿÿê  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/server-inserted-html.js|ssr114161undefined163188undefined190286undefined288294undefined574577__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined579603__WEBPACK_MODULE_REFERENCE__66_5b22536572766572496e73657274656448544d4c436f6e74657874225d_asiSafe1__._undefined841844__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined846859__WEBPACK_MODULE_REFERENCE__1_5b2264656661756c74222c22467261676d656e74225d_asiSafe1__._undefined¶   396470(0,jsx_runtime.jsx)undefined472573server_inserted_html_shared_runtime.ServerInsertedHTMLContextundefined811885(0,jsx_runtime.jsx)undefined887973react.FragmentundefinedRawSourceU   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/shared/lib/encode-uri-path.js
—Öš   export function encodeURIPath(file) {
    return file.split("/").map((p)=>encodeURIComponent(p)).join("/");
} //# sourceMappingURL=encode-uri-path.js.map
(  {"version":3,"sources":["webpack://../../../src/shared/lib/encode-uri-path.ts"],"names":["encodeURIPath","file","split","map","p","encodeURIComponent","join"],"mappings":"AAAA,OAAO,SAASA,cAAcC,IAAY;IACxC,OAAOA,KACJC,KAAK,CAAC,KACNC,GAAG,CAAC,CAACC,IAAMC,mBAAmBD,IAC9BE,IAAI,CAAC;AACV","file":"x"}   false06undefined—í   
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react-dom/server-rendering-stub.js
var server_rendering_stub = __webpack_require__(8754);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/required-scripts.js
“”jÿÿÿ…  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/required-scripts.js|ssr064undefined6698undefined100106undefined386398__WEBPACK_MODULE_REFERENCE__68_5b22656e636f646555524950617468225d_directImport_asiSafe1__._undefined11151130__WEBPACK_MODULE_REFERENCE__69_5b2264656661756c74222c22707265696e6974225d_call_asiSafe1__._undefined18021817__WEBPACK_MODULE_REFERENCE__69_5b2264656661756c74222c22707265696e6974225d_call_asiSafe1__._undefined   281371encodeURIPathundefined10881178server_rendering_stub.preinitundefined18501940server_rendering_stub.preinitundefinedRawSource  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/add-path-prefix.js
var add_path_prefix = __webpack_require__(7253);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/build/webpack/alias/react-dom-server-edge.js
var react_dom_server_edge = __webpack_require__(9183);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/redirect-status-code.js
var redirect_status_code = __webpack_require__(3207);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/make-get-server-inserted-html.js
‘hÿÿÿx  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/make-get-server-inserted-html.js|ssr085undefined87112undefined114181undefined183306undefined308370undefined372444undefined446527undefined529606undefined608614undefined12251239__WEBPACK_MODULE_REFERENCE__31_5b2269734e6f74466f756e644572726f72225d_call_directImport_asiSafe1__._undefined13001303__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined14241461 falseundefined147916060undefined16401654__WEBPACK_MODULE_REFERENCE__36_5b22697352656469726563744572726f72225d_call_directImport_asiSafe1__._undefined17021714__WEBPACK_MODULE_REFERENCE__71_5b2261646450617468507265666978225d_call_directImport_asiSafe1__._undefined17161738__WEBPACK_MODULE_REFERENCE__36_5b2267657455524c46726f6d52656469726563744572726f72225d_call_directImport_asiSafe1__._undefined17941823__WEBPACK_MODULE_REFERENCE__36_5b226765745265646972656374537461747573436f646546726f6d4572726f72225d_call_directImport_asiSafe1__._undefined18841901__WEBPACK_MODULE_REFERENCE__73_5b225265646972656374537461747573436f6465225d_asiSafe1__._undefined20252028__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined26262647__WEBPACK_MODULE_REFERENCE__72_5b2272656e646572546f5265616461626c6553747265616d225d_call_directImport_asiSafe1__._undefined26632667__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined26692677__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined28772880__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined35173530__WEBPACK_MODULE_REFERENCE__3_5b2273747265616d546f537472696e67225d_call_directImport_asiSafe1__._undefined¢  618717(0,not_found/* isNotFoundError */.X)undefined778852(0,jsx_runtime.jsx)undefined10301129(0,redirect/* isRedirectError */.eo)undefined11771272(0,add_path_prefix/* addPathPrefix */.V)undefined12741389(0,redirect/* getURLFromRedirectError */.M6)undefined14451574(0,redirect/* getRedirectStatusCodeFromError */.j2)undefined16351722redirect_status_code/* RedirectStatusCode */.Xundefined18461920(0,jsx_runtime.jsx)undefined25182631(0,react_dom_server_edge.renderToReadableStream)undefined26472723(0,jsx_runtime.jsxs)undefined27252804jsx_runtime.Fragmentundefined30043078(0,jsx_runtime.jsx)undefined37153811(0,node_web_streams_helper/* streamToString */.PN)undefinedRawSourcef   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/get-css-inlined-link-tags.js
Žfÿÿÿ1  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-css-inlined-link-tags.js|ssr7682undefinedb   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/get-preloadable-fonts.js
‹Œeÿÿÿ/  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-preloadable-fonts.js|ssr354360undefined^   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/parse-loader-tree.js
‰Šdÿÿÿ«  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/parse-loader-tree.js|ssr062undefined6470undefined388406__WEBPACK_MODULE_REFERENCE__23_5b2244454641554c545f5345474d454e545f4b4559225d_directImport_asiSafe1__._undefined?   318420lib_segment/* DEFAULT_SEGMENT_KEY */.avundefinedRawSourcec   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/get-asset-query-string.js
†‡bÿÿÿZ  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-asset-query-string.js|ssr1433"production"undefined7696falseundefined99105undefinedˆ]   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/get-layer-assets.js
„…aÿÿÿ¤  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-layer-assets.js|ssr047undefined4974undefined76142undefined144205undefined207269undefined271335undefined337343undefined622641__WEBPACK_MODULE_REFERENCE__75_5b226765744c696e6b416e6453637269707454616773225d_call_directImport_asiSafe1__._undefined856874__WEBPACK_MODULE_REFERENCE__76_5b226765745072656c6f616461626c65466f6e7473225d_call_directImport_asiSafe1__._undefined13541366__WEBPACK_MODULE_REFERENCE__68_5b22656e636f646555524950617468225d_call_directImport_asiSafe1__._undefined23952407__WEBPACK_MODULE_REFERENCE__68_5b22656e636f646555524950617468225d_call_directImport_asiSafe1__._undefined24172435__WEBPACK_MODULE_REFERENCE__78_5b2267657441737365745175657279537472696e67225d_call_directImport_asiSafe1__._undefined28932930 falseundefined293429470undefined30653068__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined34023414__WEBPACK_MODULE_REFERENCE__68_5b22656e636f646555524950617468225d_call_directImport_asiSafe1__._undefined34243442__WEBPACK_MODULE_REFERENCE__78_5b2267657441737365745175657279537472696e67225d_call_directImport_asiSafe1__._undefined34873490__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined8  284393getLinkAndScriptTagsundefined608715getPreloadableFontsundefined11951290encodeURIPathundefined23192414encodeURIPathundefined24242531getAssetQueryStringundefined31163190(0,jsx_runtime.jsx)undefined35243619encodeURIPathundefined36293736getAssetQueryStringundefined37813855(0,jsx_runtime.jsx)undefinedRawSourcej   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/has-loading-component-in-tree.js
‚_ÿÿÿ3  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/has-loading-component-in-tree.js|ssr06undefinedƒ\   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/interop-default.js
ÿÿÿ€^ÿÿÿ'  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/interop-default.js|ssr6672undefined4   7588interop_default_interopDefaultundefinedRawSourcep   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/create-component-styles-and-scripts.js
|ÿÿÿ}ÿÿÿ\ÿÿÿ:  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/create-component-styles-and-scripts.js|ssr047undefined4974undefined76126undefined128194undefined196258undefined260324undefined326332undefined491510__WEBPACK_MODULE_REFERENCE__75_5b226765744c696e6b416e6453637269707454616773225d_call_directImport_asiSafe1__._undefined690702__WEBPACK_MODULE_REFERENCE__68_5b22656e636f646555524950617468225d_call_directImport_asiSafe1__._undefined712730__WEBPACK_MODULE_REFERENCE__78_5b2267657441737365745175657279537472696e67225d_call_directImport_asiSafe1__._undefined11881225 falseundefined122912420undefined12831286__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined15691572__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined16311643__WEBPACK_MODULE_REFERENCE__68_5b22656e636f646555524950617468225d_call_directImport_asiSafe1__._undefined16531671__WEBPACK_MODULE_REFERENCE__78_5b2267657441737365745175657279537472696e67225d_call_directImport_asiSafe1__._undefined17481761__WEBPACK_MODULE_REFERENCE__81_5b22696e7465726f7044656661756c74225d_call_directImport_asiSafe1__._undefined#  164273getLinkAndScriptTagsundefined453548encodeURIPathundefined558665getAssetQueryStringundefined11731247(0,jsx_runtime.jsx)undefined15301604(0,jsx_runtime.jsx)undefined16631758encodeURIPathundefined17681875getAssetQueryStringundefined19522049interop_default_interopDefaultundefinedRawSourceý   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/static-generation-bailout.js
var static_generation_bailout = __webpack_require__(7997);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/create-component-tree.js
yÿÿÿzÿÿÿZÿÿÿ  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/create-component-tree.js|ssr085undefined87112undefined114176undefined178239undefined241291undefined293346undefined348435undefined437488undefined490565undefined567622undefined624716undefined718765undefined767826undefined828917undefined9951001undefined10511059__WEBPACK_MODULE_REFERENCE__28_5b22676574547261636572225d_call_directImport_asiSafe1__._undefined10691086__WEBPACK_MODULE_REFERENCE__29_5b224e6578744e6f64655365727665725370616e225d_asiSafe1__._undefined18611875__WEBPACK_MODULE_REFERENCE__77_5b2270617273654c6f6164657254726565225d_call_directImport_asiSafe1__._undefined22032216__WEBPACK_MODULE_REFERENCE__79_5b226765744c61796572417373657473225d_call_directImport_asiSafe1__._undefined25142544__WEBPACK_MODULE_REFERENCE__82_5b22637265617465436f6d706f6e656e745374796c6573416e6453637269707473225d_call_directImport_asiSafe1__._undefined27452758__WEBPACK_MODULE_REFERENCE__1_5b2264656661756c74222c22467261676d656e74225d_asiSafe1__._undefined28372867__WEBPACK_MODULE_REFERENCE__82_5b22637265617465436f6d706f6e656e745374796c6573416e6453637269707473225d_call_directImport_asiSafe1__._undefined31253155__WEBPACK_MODULE_REFERENCE__82_5b22637265617465436f6d706f6e656e745374796c6573416e6453637269707473225d_call_directImport_asiSafe1__._undefined34843492__WEBPACK_MODULE_REFERENCE__28_5b22676574547261636572225d_call_directImport_asiSafe1__._undefined35023519__WEBPACK_MODULE_REFERENCE__29_5b224e6578744e6f64655365727665725370616e225d_asiSafe1__._undefined37113731__WEBPACK_MODULE_REFERENCE__24_5b226765744c61796f75744f72506167654d6f64756c65225d_call_directImport_asiSafe1__._undefined41074137__WEBPACK_MODULE_REFERENCE__82_5b22637265617465436f6d706f6e656e745374796c6573416e6453637269707473225d_call_directImport_asiSafe1__._undefined46954715__WEBPACK_MODULE_REFERENCE__83_5b2253746174696347656e4261696c6f75744572726f72225d_directImport_asiSafe1__._undefined65426559__WEBPACK_MODULE_REFERENCE__38_5b2276616c6964617465526576616c6964617465225d_call_directImport_asiSafe1__._undefined78617874__WEBPACK_MODULE_REFERENCE__81_5b22696e7465726f7044656661756c74225d_call_directImport_asiSafe1__._undefined87798782__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined88648868__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined88708878__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined89908994__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined92129215__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined93919394__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined95179554falseundefined955710433{}undefined1153711540__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1259112615__WEBPACK_MODULE_REFERENCE__80_5b226861734c6f6164696e67436f6d706f6e656e74496e54726565225d_call_directImport_asiSafe1__._undefined1388713940falseundefined1394314512{ var _parsedTree_layoutOrPagePath; }undefined1554915552__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1603916042__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1610016103__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1695916962__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1774117744__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1774617754__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined1908819091__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1945119467__WEBPACK_MODULE_REFERENCE__22_5b226973436c69656e745265666572656e6365225d_call_directImport_asiSafe1__._undefined2002620030__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined2003220040__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined2009920102__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2022520262 falseundefined20281203940undefined2045920462__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2054820619falseundefined2062220854{}undefined2166321667__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined2166921677__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined2178021783__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2225622260__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined2226222270__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined2237322376__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2259522598__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2278222786__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined2278822796__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefinedú  139226(0,tracer/* getTracer */.Yz)undefined236323constants/* NextNodeServerSpan */.Xyundefined10981197parseLoaderTreeundefined15251622getLayerAssetsundefined19202051createComponentStylesAndScriptsundefined22522338react.Fragmentundefined24172548createComponentStylesAndScriptsundefined28062937createComponentStylesAndScriptsundefined32663353(0,tracer/* getTracer */.Yz)undefined33633450constants/* NextNodeServerSpan */.Xyundefined36423753getLayoutOrPageModuleundefined41294260createComponentStylesAndScriptsundefined48184924static_generation_bailout/* StaticGenBailoutError */.Gundefined67516856validateRevalidateundefined81588255interop_default_interopDefaultundefined91609234(0,jsx_runtime.jsx)undefined93169392(0,jsx_runtime.jsxs)undefined93949473jsx_runtime.Fragmentundefined95859661(0,jsx_runtime.jsxs)undefined98799953(0,jsx_runtime.jsx)undefined1012910203(0,jsx_runtime.jsx)undefined1143811512(0,jsx_runtime.jsx)undefined1256312682hasLoadingComponentInTreeundefined1503415108(0,jsx_runtime.jsx)undefined1559515669(0,jsx_runtime.jsx)undefined1572715801(0,jsx_runtime.jsx)undefined1665716731(0,jsx_runtime.jsx)undefined1751017584(0,jsx_runtime.jsx)undefined1758617665jsx_runtime.Fragmentundefined1899919073(0,jsx_runtime.jsx)undefined1943319536isClientReferenceundefined2009520171(0,jsx_runtime.jsxs)undefined2017320252jsx_runtime.Fragmentundefined2031120385(0,jsx_runtime.jsx)undefined2059720671(0,jsx_runtime.jsx)undefined2157421650(0,jsx_runtime.jsxs)undefined2165221731jsx_runtime.Fragmentundefined2183421908(0,jsx_runtime.jsx)undefined2238122457(0,jsx_runtime.jsxs)undefined2245922538jsx_runtime.Fragmentundefined2264122715(0,jsx_runtime.jsx)undefined2293423008(0,jsx_runtime.jsx)undefined2319223268(0,jsx_runtime.jsxs)undefined2327023349jsx_runtime.FragmentundefinedRawSourceo   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/walk-tree-with-flight-router-state.js
vÿÿÿwÿÿÿXÿÿÿ  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/walk-tree-with-flight-router-state.js|ssr072undefined7499undefined101194undefined196262undefined264325undefined327458undefined460513undefined515566undefined568643undefined645706undefined708770undefined9941000undefined24232450__WEBPACK_MODULE_REFERENCE__56_5b22616464536561726368506172616d734966506167655365676d656e74225d_call_directImport_asiSafe1__._undefined27552766__WEBPACK_MODULE_REFERENCE__4_5b226d617463685365676d656e74225d_call_directImport_asiSafe1__._undefined32533277__WEBPACK_MODULE_REFERENCE__80_5b226861734c6f6164696e67436f6d706f6e656e74496e54726565225d_call_directImport_asiSafe1__._undefined34063427__WEBPACK_MODULE_REFERENCE__4_5b2263616e5365676d656e7442654f76657272696464656e225d_call_directImport_asiSafe1__._undefined35343570__WEBPACK_MODULE_REFERENCE__56_5b22637265617465466c69676874526f75746572537461746546726f6d4c6f6164657254726565225d_call_directImport_asiSafe1__._undefined40964114__WEBPACK_MODULE_REFERENCE__84_5b22637265617465436f6d706f6e656e7454726565225d_call_directImport_asiSafe1__._undefined48454859__WEBPACK_MODULE_REFERENCE__77_5b2270617273654c6f6164657254726565225d_call_directImport_asiSafe1__._undefined49144927__WEBPACK_MODULE_REFERENCE__79_5b226765744c61796572417373657473225d_call_directImport_asiSafe1__._undefined52155219__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined52215229__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined60656084__WEBPACK_MODULE_REFERENCE__75_5b226765744c696e6b416e6453637269707454616773225d_call_directImport_asiSafe1__._undefined62016219__WEBPACK_MODULE_REFERENCE__76_5b226765745072656c6f616461626c65466f6e7473225d_call_directImport_asiSafe1__._undefined78357853__WEBPACK_MODULE_REFERENCE__23_5b2244454641554c545f5345474d454e545f4b4559225d_directImport_asiSafe1__._undefined<  16551780addSearchParamsIfPageSegmentundefined20852177(0,match_segments/* matchSegment */.j)undefined26642783hasLoadingComponentInTreeundefined29123024(0,match_segments/* canSegmentBeOverridden */.W)undefined31313274createFlightRouterStateFromLoaderTreeundefined38003907createComponentTreeundefined46384737parseLoaderTreeundefined47924889getLayerAssetsundefined51775253(0,jsx_runtime.jsxs)undefined52555334jsx_runtime.Fragmentundefined61706279getLinkAndScriptTagsundefined63966503getPreloadableFontsundefined81198221lib_segment/* DEFAULT_SEGMENT_KEY */.avundefinedRawSourceì   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/app-render/encryption-utils.js
var encryption_utils = __webpack_require__(1318);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/static/static-renderer.js
sÿÿÿtÿÿÿVÿÿÿ-  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/static/static-renderer.js|ssr106142 falseundefined1461870undefined560598(__webpack_require__(9183).resume)undefined800806undefined926980(__webpack_require__(9183).renderToReadableStream)undefined11551161undefined14801486undefined15111517undefined15421548undefined16521658undefined17281734undefineduÿÿÿ`   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/use-flight-response.js
qÿÿÿrÿÿÿUÿÿÿV  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/use-flight-response.js|ssr052undefined7699"edge"undefined439445undefined885905falseundefined9081095{}undefined12091280(__webpack_require__(1502).createFromReadableStream)undefined22552261undefined29322938undefined47574776__WEBPACK_MODULE_REFERENCE__50_5b2268746d6c4573636170654a736f6e537472696e67225d_call_directImport_asiSafe1__._undefined48664885__WEBPACK_MODULE_REFERENCE__50_5b2268746d6c4573636170654a736f6e537472696e67225d_call_directImport_asiSafe1__._undefined51415160__WEBPACK_MODULE_REFERENCE__50_5b2268746d6c4573636170654a736f6e537472696e67225d_call_directImport_asiSafe1__._undefined×   719use_flight_response_isEdgeRuntimeundefined11661178use_flight_response_isEdgeRuntimeundefined44434552htmlEscapeJsonStringundefined46424751htmlEscapeJsonStringundefined50075116htmlEscapeJsonStringundefinedRawSource‡  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/future/helpers/interception-routes.js
var interception_routes = __webpack_require__(117);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/client-component-renderer-logger.js
var client_component_renderer_logger = __webpack_require__(9031);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/app-render.js
nÿÿÿoÿÿÿSÿÿÿ?  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/app-render.js|ssr085undefined87112undefined114157undefined159381undefined383462undefined464520undefined522656undefined658728undefined730821undefined823933undefined9351002undefined10041127undefined11291181undefined11831257undefined12591306undefined13081367undefined13691448undefined14501542undefined15441597undefined15991672undefined16741766undefined17681812undefined18141915undefined19171964undefined19662048undefined20502102undefined21042189undefined21912256undefined22582313undefined23152392undefined23942469undefined24712555undefined25572618undefined26202682undefined26842751undefined27532876undefined28782961undefined29633073undefined30753189undefined31913273undefined32753350undefined33523459undefined34613573undefined35753629undefined44814502__WEBPACK_MODULE_REFERENCE__4_5b2263616e5365676d656e7442654f76657272696464656e225d_call_directImport_asiSafe1__._undefined53755389__WEBPACK_MODULE_REFERENCE__49_5b226765745365676d656e74506172616d225d_call_directImport_asiSafe1__._undefined61516167__WEBPACK_MODULE_REFERENCE__48_5b2264796e616d6963506172616d5479706573225d_directImport_asiSafe1__._undefined66596682__WEBPACK_MODULE_REFERENCE__48_5b2267657453686f727444796e616d6963506172616d54797065225d_call_directImport_asiSafe1__._undefined73277330__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined81828205__WEBPACK_MODULE_REFERENCE__32_5b226372656174654d65746164617461436f6d706f6e656e7473225d_call_directImport_asiSafe1__._undefined85158543__WEBPACK_MODULE_REFERENCE__85_5b2277616c6b5472656557697468466c69676874526f757465725374617465225d_call_directImport_asiSafe1__._undefined88458849__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined88518859__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined89268929__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined90349037__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined93979400__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1001710034__WEBPACK_MODULE_REFERENCE__39_5b22466c6967687452656e646572526573756c74225d_directImport_asiSafe1__._undefined1147011506__WEBPACK_MODULE_REFERENCE__56_5b22637265617465466c69676874526f75746572537461746546726f6d4c6f6164657254726565225d_call_directImport_asiSafe1__._undefined1159311616__WEBPACK_MODULE_REFERENCE__32_5b226372656174654d65746164617461436f6d706f6e656e7473225d_call_directImport_asiSafe1__._undefined1200212020__WEBPACK_MODULE_REFERENCE__84_5b22637265617465436f6d706f6e656e7454726565225d_call_directImport_asiSafe1__._undefined1233612339__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1281512822__WEBPACK_MODULE_REFERENCE__6_5b224e4558545f55524c225d_directImport_asiSafe1__._undefined1285112855__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined1285712865__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined1293612939__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1341513419__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined1342113429__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined1350413507__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1362413627__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1438414407__WEBPACK_MODULE_REFERENCE__32_5b226372656174654d65746164617461436f6d706f6e656e7473225d_call_directImport_asiSafe1__._undefined1469514699__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined1470114709__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined1476014763__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1484414847__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1489114928 falseundefined14947150480undefined1509215128__WEBPACK_MODULE_REFERENCE__56_5b22637265617465466c69676874526f75746572537461746546726f6d4c6f6164657254726565225d_call_directImport_asiSafe1__._undefined1539115395__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined1549515498__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1554315546__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1563115634__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1618916203__WEBPACK_MODULE_REFERENCE__88_5b22757365466c6967687453747265616d225d_call_directImport_asiSafe1__._undefined1626816276__WEBPACK_MODULE_REFERENCE__1_5b2264656661756c74222c22757365225d_call_asiSafe1__._undefined1731717341__WEBPACK_MODULE_REFERENCE__90_5b2277726170436c69656e74436f6d706f6e656e744c6f61646572225d_call_directImport_asiSafe1__._undefined1772417754__WEBPACK_MODULE_REFERENCE__90_5b22676574436c69656e74436f6d706f6e656e744c6f616465724d657472696373225d_call_directImport_asiSafe1__._undefined1786117869__WEBPACK_MODULE_REFERENCE__28_5b22676574547261636572225d_call_directImport_asiSafe1__._undefined1788317900__WEBPACK_MODULE_REFERENCE__29_5b224e6578744e6f64655365727665725370616e225d_asiSafe1__._undefined1857218592__WEBPACK_MODULE_REFERENCE__64_5b226372656174655365727665724d6f64756c654d6170225d_call_directImport_asiSafe1__._undefined1867318702__WEBPACK_MODULE_REFERENCE__86_5b227365745265666572656e63654d616e69666573747353696e676c65746f6e225d_call_directImport_asiSafe1__._undefined1934319360__WEBPACK_MODULE_REFERENCE__47_5b226372656174654572726f7248616e646c6572225d_call_directImport_asiSafe1__._undefined1938019397__WEBPACK_MODULE_REFERENCE__47_5b224572726f7248616e646c6572536f75726365225d_asiSafe1__._undefined1962419641__WEBPACK_MODULE_REFERENCE__47_5b226372656174654572726f7248616e646c6572225d_call_directImport_asiSafe1__._undefined1966119678__WEBPACK_MODULE_REFERENCE__47_5b224572726f7248616e646c6572536f75726365225d_asiSafe1__._undefined1989319910__WEBPACK_MODULE_REFERENCE__47_5b226372656174654572726f7248616e646c6572225d_call_directImport_asiSafe1__._undefined1993019947__WEBPACK_MODULE_REFERENCE__47_5b224572726f7248616e646c6572536f75726365225d_asiSafe1__._undefined2125821277__WEBPACK_MODULE_REFERENCE__5_5b227374726970496e7465726e616c51756572696573225d_call_directImport_asiSafe1__._undefined2132421333__WEBPACK_MODULE_REFERENCE__6_5b225253435f484541444552225d_call_asiSafe1__._undefined2142621452__WEBPACK_MODULE_REFERENCE__6_5b224e4558545f524f555445525f50524546455443485f484541444552225d_call_asiSafe1__._undefined2205922084__WEBPACK_MODULE_REFERENCE__89_5b226973496e74657263657074696f6e526f75746541707050617468225d_call_directImport_asiSafe1__._undefined2213422166__WEBPACK_MODULE_REFERENCE__54_5b227061727365416e6456616c6964617465466c69676874526f757465725374617465225d_call_directImport_asiSafe1__._undefined2218022201__WEBPACK_MODULE_REFERENCE__6_5b224e4558545f524f555445525f53544154455f54524545225d_call_asiSafe1__._undefined2239322427trueundefined2248422557{}undefined2432324346__WEBPACK_MODULE_REFERENCE__51_5b226765745363726970744e6f6e636546726f6d486561646572225d_call_directImport_asiSafe1__._undefined2443124437__webpack_require__undefined24439244924190undefined2470524728__WEBPACK_MODULE_REFERENCE__67_5b22637265617465536572766572496e73657274656448544d4c225d_call_directImport_asiSafe1__._undefined2477324781__WEBPACK_MODULE_REFERENCE__28_5b22676574547261636572225d_call_directImport_asiSafe1__._undefined2491824926__WEBPACK_MODULE_REFERENCE__28_5b22676574547261636572225d_call_directImport_asiSafe1__._undefined2493524947__WEBPACK_MODULE_REFERENCE__29_5b2241707052656e6465725370616e225d_asiSafe1__._undefined2534525363__WEBPACK_MODULE_REFERENCE__78_5b2267657441737365745175657279537472696e67225d_call_directImport_asiSafe1__._undefined2566925686__WEBPACK_MODULE_REFERENCE__70_5b22676574526571756972656453637269707473225d_call_directImport_asiSafe1__._undefined2577025788__WEBPACK_MODULE_REFERENCE__78_5b2267657441737365745175657279537472696e67225d_call_directImport_asiSafe1__._undefined2617126174__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2658326586__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2674326746__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2681826821__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2793927963__WEBPACK_MODULE_REFERENCE__74_5b226d616b65476574536572766572496e73657274656448544d4c225d_call_directImport_asiSafe1__._undefined2816028179__WEBPACK_MODULE_REFERENCE__87_5b2263726561746553746174696352656e6465726572225d_call_directImport_asiSafe1__._undefined3010030114__WEBPACK_MODULE_REFERENCE__34_5b227573656444796e616d696341504973225d_call_directImport_asiSafe1__._undefined3029830325__WEBPACK_MODULE_REFERENCE__87_5b2267657444796e616d696348544d4c506f7374706f6e65645374617465225d_call_directImport_asiSafe1__._undefined3048630513__WEBPACK_MODULE_REFERENCE__87_5b2267657444796e616d696344617461506f7374706f6e65645374617465225d_call_directImport_asiSafe1__._undefined3107431097__WEBPACK_MODULE_REFERENCE__3_5b22636f6e74696e756544796e616d696350726572656e646572225d_call_directImport_asiSafe1__._undefined3156731586__WEBPACK_MODULE_REFERENCE__88_5b22666c6967687452656e646572436f6d706c657465225d_call_directImport_asiSafe1__._undefined3162431638__WEBPACK_MODULE_REFERENCE__34_5b227573656444796e616d696341504973225d_call_directImport_asiSafe1__._undefined3195531982__WEBPACK_MODULE_REFERENCE__87_5b2267657444796e616d696348544d4c506f7374706f6e65645374617465225d_call_directImport_asiSafe1__._undefined3215532182__WEBPACK_MODULE_REFERENCE__87_5b2267657444796e616d696344617461506f7374706f6e65645374617465225d_call_directImport_asiSafe1__._undefined3277132794__WEBPACK_MODULE_REFERENCE__3_5b22636f6e74696e756544796e616d696350726572656e646572225d_call_directImport_asiSafe1__._undefined3329433314__WEBPACK_MODULE_REFERENCE__83_5b2253746174696347656e4261696c6f75744572726f72225d_directImport_asiSafe1__._undefined3381333832__WEBPACK_MODULE_REFERENCE__87_5b2263726561746553746174696352656e6465726572225d_call_directImport_asiSafe1__._undefined3398134008__WEBPACK_MODULE_REFERENCE__87_5b2267657444796e616d696348544d4c506f7374706f6e65645374617465225d_call_directImport_asiSafe1__._undefined3411534140__WEBPACK_MODULE_REFERENCE__34_5b22637265617465506f7374706f6e656441626f72745369676e616c225d_call_directImport_asiSafe1__._undefined3468934692__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined3494934952__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined3504435047__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined3574935760__WEBPACK_MODULE_REFERENCE__3_5b22636861696e53747265616d73225d_call_directImport_asiSafe1__._undefined3588635908__WEBPACK_MODULE_REFERENCE__3_5b22636f6e74696e756553746174696350726572656e646572225d_call_directImport_asiSafe1__._undefined3598336013__WEBPACK_MODULE_REFERENCE__88_5b22637265617465496e6c696e6564446174615265616461626c6553747265616d225d_call_directImport_asiSafe1__._undefined3638036410__WEBPACK_MODULE_REFERENCE__88_5b22637265617465496e6c696e6564446174615265616461626c6553747265616d225d_call_directImport_asiSafe1__._undefined3664036664__WEBPACK_MODULE_REFERENCE__3_5b22636f6e74696e756544796e616d696348544d4c526573756d65225d_call_directImport_asiSafe1__._undefined3703137055__WEBPACK_MODULE_REFERENCE__3_5b22636f6e74696e756544796e616d696344617461526573756d65225d_call_directImport_asiSafe1__._undefined3752637543__WEBPACK_MODULE_REFERENCE__3_5b22636f6e74696e756546697a7a53747265616d225d_call_directImport_asiSafe1__._undefined3759837628__WEBPACK_MODULE_REFERENCE__88_5b22637265617465496e6c696e6564446174615265616461626c6553747265616d225d_call_directImport_asiSafe1__._undefined3798938011__WEBPACK_MODULE_REFERENCE__83_5b22697353746174696347656e4261696c6f75744572726f72225d_call_directImport_asiSafe1__._undefined3852138540__WEBPACK_MODULE_REFERENCE__43_5b22697344796e616d69635365727665724572726f72225d_call_directImport_asiSafe1__._undefined3875138769__WEBPACK_MODULE_REFERENCE__44_5b2269734261696c6f7574546f4353524572726f72225d_call_directImport_asiSafe1__._undefined3884538871__WEBPACK_MODULE_REFERENCE__41_5b22676574537461636b576974686f75744572726f724d657373616765225d_call_directImport_asiSafe1__._undefined3897638980__WEBPACK_MODULE_REFERENCE__20_5b226572726f72225d_call_directImport_asiSafe1__._undefined3921739220__WEBPACK_MODULE_REFERENCE__20_5b227761726e225d_call_directImport_asiSafe1__._undefined3942539439__WEBPACK_MODULE_REFERENCE__31_5b2269734e6f74466f756e644572726f72225d_call_directImport_asiSafe1__._undefined3955939573__WEBPACK_MODULE_REFERENCE__36_5b22697352656469726563744572726f72225d_call_directImport_asiSafe1__._undefined3965739686__WEBPACK_MODULE_REFERENCE__36_5b226765745265646972656374537461747573436f646546726f6d4572726f72225d_call_directImport_asiSafe1__._undefined3992939948__WEBPACK_MODULE_REFERENCE__58_5b22617070656e644d757461626c65436f6f6b696573225d_call_directImport_asiSafe1__._undefined4014140153__WEBPACK_MODULE_REFERENCE__71_5b2261646450617468507265666978225d_call_directImport_asiSafe1__._undefined4015540177__WEBPACK_MODULE_REFERENCE__36_5b2267657455524c46726f6d52656469726563744572726f72225d_call_directImport_asiSafe1__._undefined4061240629__WEBPACK_MODULE_REFERENCE__70_5b22676574526571756972656453637269707473225d_call_directImport_asiSafe1__._undefined4071340731__WEBPACK_MODULE_REFERENCE__78_5b2267657441737365745175657279537472696e67225d_call_directImport_asiSafe1__._undefined4084240845__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined4114441168__WEBPACK_MODULE_REFERENCE__3_5b2272656e646572546f496e697469616c46697a7a53747265616d225d_call_directImport_asiSafe1__._undefined4120841214__webpack_require__undefined41216412389183undefined4128541288__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined4212442141__WEBPACK_MODULE_REFERENCE__3_5b22636f6e74696e756546697a7a53747265616d225d_call_directImport_asiSafe1__._undefined4220042230__WEBPACK_MODULE_REFERENCE__88_5b22637265617465496e6c696e6564446174615265616461626c6553747265616d225d_call_directImport_asiSafe1__._undefined4256342587__WEBPACK_MODULE_REFERENCE__74_5b226d616b65476574536572766572496e73657274656448544d4c225d_call_directImport_asiSafe1__._undefined4301843084falseundefined4308743265{}undefined4345443465__WEBPACK_MODULE_REFERENCE__65_5b2268616e646c65416374696f6e225d_call_directImport_asiSafe1__._undefined4404544056__WEBPACK_MODULE_REFERENCE__2_5b2264656661756c74225d_directImport_asiSafe1__._undefined4489644910__WEBPACK_MODULE_REFERENCE__38_5b22616464496d706c6963697454616773225d_call_directImport_asiSafe1__._undefined4512445135__WEBPACK_MODULE_REFERENCE__2_5b2264656661756c74225d_directImport_asiSafe1__._undefined4576345777__WEBPACK_MODULE_REFERENCE__34_5b227573656444796e616d696341504973225d_call_directImport_asiSafe1__._undefined4598545988__WEBPACK_MODULE_REFERENCE__20_5b227761726e225d_call_directImport_asiSafe1__._undefined4606546088__WEBPACK_MODULE_REFERENCE__34_5b22666f726d617444796e616d69634150494163636573736573225d_call_directImport_asiSafe1__._undefined4614246145__WEBPACK_MODULE_REFERENCE__20_5b227761726e225d_call_directImport_asiSafe1__._undefined4733347344__WEBPACK_MODULE_REFERENCE__2_5b2264656661756c74225d_directImport_asiSafe1__._undefined4737547381undefined4752747537__WEBPACK_MODULE_REFERENCE__55_5b2276616c696461746555524c225d_call_directImport_asiSafe1__._undefined4756047585__WEBPACK_MODULE_REFERENCE__33_5b22526571756573744173796e6353746f7261676557726170706572225d_call_asiSafe1__._undefined4770747741__WEBPACK_MODULE_REFERENCE__35_5b2253746174696347656e65726174696f6e4173796e6353746f7261676557726170706572225d_call_asiSafe1__._undefined8  8941006(0,match_segments/* canSegmentBeOverridden */.W)undefined18791978(0,get_segment_param/* getSegmentParam */.R)undefined27402838dynamicParamTypesundefined33303447getShortDynamicParamTypeundefined40924166(0,jsx_runtime.jsx)undefined50185135createMetadataComponentsundefined54455572walkTreeWithFlightRouterStateundefined58745950(0,jsx_runtime.jsxs)undefined59526031jsx_runtime.Fragmentundefined60986172(0,jsx_runtime.jsx)undefined62776351(0,jsx_runtime.jsx)undefined67116785(0,jsx_runtime.jsx)undefined74027502FlightRenderResultundefined89389081createFlightRouterStateFromLoaderTreeundefined91689285createMetadataComponentsundefined96719778createComponentTreeundefined1009410168(0,jsx_runtime.jsx)undefined1064410723app_router_headers/* NEXT_URL */.TPundefined1075210828(0,jsx_runtime.jsxs)undefined1083010909jsx_runtime.Fragmentundefined1098011054(0,jsx_runtime.jsx)undefined1153011606(0,jsx_runtime.jsxs)undefined1160811687jsx_runtime.Fragmentundefined1176211836(0,jsx_runtime.jsx)undefined1195312027(0,jsx_runtime.jsx)undefined1278412901createMetadataComponentsundefined1318913265(0,jsx_runtime.jsxs)undefined1326713346jsx_runtime.Fragmentundefined1339713471(0,jsx_runtime.jsx)undefined1355213626(0,jsx_runtime.jsx)undefined1373813881createFlightRouterStateFromLoaderTreeundefined1414414220(0,jsx_runtime.jsxs)undefined1432014394(0,jsx_runtime.jsx)undefined1443914513(0,jsx_runtime.jsx)undefined1459814672(0,jsx_runtime.jsx)undefined1522715326useFlightStreamundefined1539115472react.useundefined1651316632(0,client_component_renderer_logger/* wrapClientComponentLoader */.B)undefined1701517146(0,client_component_renderer_logger/* getClientComponentLoaderMetrics */.R)undefined1725317340(0,tracer/* getTracer */.Yz)undefined1735417441constants/* NextNodeServerSpan */.Xyundefined1811318224(0,action_utils/* createServerModuleMap */.w)undefined1830518434(0,encryption_utils/* setReferenceManifestsSingleton */.Mo)undefined1907519180createErrorHandlerundefined1920019287ErrorHandlerSourceundefined1951419619createErrorHandlerundefined1963919726ErrorHandlerSourceundefined1994120046createErrorHandlerundefined2006620153ErrorHandlerSourceundefined2146421572(0,internal_utils/* stripInternalQueries */.Q3)undefined2161921694app_router_headers/* RSC_HEADER */.Aundefined2178721896app_router_headers/* NEXT_ROUTER_PREFETCH_HEADER */.qwundefined2250322624(0,interception_routes/* isInterceptionRouteAppPath */.Ag)undefined2267422809parseAndValidateFlightRouterStateundefined2282322922app_router_headers/* NEXT_ROUTER_STATE_TREE */.phundefined2494125058getScriptNonceFromHeaderundefined2537925496createServerInsertedHTMLundefined2554125628(0,tracer/* getTracer */.Yz)undefined2576525852(0,tracer/* getTracer */.Yz)undefined2586125938constants/* AppRenderSpan */.k0undefined2633626443getAssetQueryStringundefined2674926854getRequiredScriptsundefined2693827045getAssetQueryStringundefined2742827502(0,jsx_runtime.jsx)undefined2791127985(0,jsx_runtime.jsx)undefined2814228216(0,jsx_runtime.jsx)undefined2828828362(0,jsx_runtime.jsx)undefined2948029599makeGetServerInsertedHTMLundefined2979629905createStaticRendererundefined3182631925(0,dynamic_rendering/* usedDynamicAPIs */.tK)undefined3210932234getDynamicHTMLPostponedStateundefined3239532520getDynamicDataPostponedStateundefined3308133197(0,node_web_streams_helper/* continueDynamicPrerender */._W)undefined3366733776flightRenderCompleteundefined3381433913(0,dynamic_rendering/* usedDynamicAPIs */.tK)undefined3423034355getDynamicHTMLPostponedStateundefined3452834653getDynamicDataPostponedStateundefined3524235358(0,node_web_streams_helper/* continueDynamicPrerender */._W)undefined3585835964static_generation_bailout/* StaticGenBailoutError */.Gundefined3646336572createStaticRendererundefined3672136846getDynamicHTMLPostponedStateundefined3695337074(0,dynamic_rendering/* createPostponedAbortSignal */.Su)undefined3762337697(0,jsx_runtime.jsx)undefined3795438028(0,jsx_runtime.jsx)undefined3812038194(0,jsx_runtime.jsx)undefined3889638988(0,node_web_streams_helper/* chainStreams */.QW)undefined3911439228(0,node_web_streams_helper/* continueStaticPrerender */.Jm)undefined3930339434createInlinedDataReadableStreamundefined3980139932createInlinedDataReadableStreamundefined4016240280(0,node_web_streams_helper/* continueDynamicHTMLResume */.Bb)undefined4064740765(0,node_web_streams_helper/* continueDynamicDataResume */.J$)undefined4123641340(0,node_web_streams_helper/* continueFizzStream */.eN)undefined4139541526createInlinedDataReadableStreamundefined4188742002(0,static_generation_bailout/* isStaticGenBailoutError */.q)undefined4251242621(0,hooks_server_context/* isDynamicServerError */.j)undefined4283242939(0,bailout_to_csr/* isBailoutToCSRError */.D)undefined4301543138getStackWithoutErrorMessageundefined4324343322(0,log/* error */.vU)undefined4355943636(0,log/* warn */.ZK)undefined4384143940(0,not_found/* isNotFoundError */.X)undefined4406044159(0,redirect/* isRedirectError */.eo)undefined4424344372(0,redirect/* getRedirectStatusCodeFromError */.j2)undefined4461544724(0,request_cookies/* appendMutableCookies */._5)undefined4491745012(0,add_path_prefix/* addPathPrefix */.V)undefined4501445129(0,redirect/* getURLFromRedirectError */.M6)undefined4556445669getRequiredScriptsundefined4575345860getAssetQueryStringundefined4597146045(0,jsx_runtime.jsx)undefined4634446462(0,node_web_streams_helper/* renderToInitialFizzStream */.MY)undefined4657246646(0,jsx_runtime.jsx)undefined4748247586(0,node_web_streams_helper/* continueFizzStream */.eN)undefined4764547776createInlinedDataReadableStreamundefined4810948228makeGetServerInsertedHTMLundefined4885648949handleActionundefined4952949606render_result/* default */.Zundefined5044650545addImplicitTagsundefined5075950836render_result/* default */.Zundefined5146451563(0,dynamic_rendering/* usedDynamicAPIs */.tK)undefined5177151848(0,log/* warn */.ZK)undefined5192552042(0,dynamic_rendering/* formatDynamicAPIAccesses */.gS)undefined5209652173(0,log/* warn */.ZK)undefined5336153438render_result/* default */.Zundefined5361453705validateURLundefined5372853836request_async_storage_wrapper/* RequestAsyncStorageWrapper */.Bundefined5395854084StaticGenerationAsyncStorageWrapperundefined
   

/***/ })Íôÿÿlå /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  f: () => (/* binding */ renderToHTMLOrFlight)
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5486);
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__(2428);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/render-result.js
var render_result = __webpack_require__(8317);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/stream-utils/node-web-streams-helper.js + 3 modules
var node_web_streams_helper = __webpack_require__(4894);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/match-segments.js
var match_segments = __webpack_require__(393);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/internal-utils.js
var internal_utils = __webpack_require__(9879);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/app-router-headers.js
var app_router_headers = __webpack_require__(3185);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/non-nullable.js
function nonNullable(value) {
    return value !== null && value !== undefined;
}

//# sourceMappingURL=non-nullable.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/generate/meta.js



function Meta({ name, property, content, media }) {
    if (typeof content !== "undefined" && content !== null && content !== "") {
        return /*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
            ...name ? {
                name
            } : {
                property
            },
            ...media ? {
                media
            } : undefined,
            content: typeof content === "string" ? content : content.toString()
        });
    }
    return null;
}
function MetaFilter(items) {
    const acc = [];
    for (const item of items){
        if (Array.isArray(item)) {
            acc.push(...item.filter(nonNullable));
        } else if (nonNullable(item)) {
            acc.push(item);
        }
    }
    return acc;
}
function camelToSnake(camelCaseStr) {
    return camelCaseStr.replace(/([A-Z])/g, function(match) {
        return "_" + match.toLowerCase();
    });
}
function getMetaKey(prefix, key) {
    // Use `twitter:image` and `og:image` instead of `twitter:image:url` and `og:image:url`
    // to be more compatible as it's a more common format
    if ((prefix === "og:image" || prefix === "twitter:image") && key === "url") {
        return prefix;
    }
    if (prefix.startsWith("og:") || prefix.startsWith("twitter:")) {
        key = camelToSnake(key);
    }
    return prefix + ":" + key;
}
function ExtendMeta({ content, namePrefix, propertyPrefix }) {
    if (!content) return null;
    return MetaFilter(Object.entries(content).map(([k, v])=>{
        return typeof v === "undefined" ? null : Meta({
            ...propertyPrefix && {
                property: getMetaKey(propertyPrefix, k)
            },
            ...namePrefix && {
                name: getMetaKey(namePrefix, k)
            },
            content: typeof v === "string" ? v : v == null ? void 0 : v.toString()
        });
    }));
}
function MultiMeta({ propertyPrefix, namePrefix, contents }) {
    if (typeof contents === "undefined" || contents === null) {
        return null;
    }
    return MetaFilter(contents.map((content)=>{
        if (typeof content === "string" || typeof content === "number" || content instanceof URL) {
            return Meta({
                ...propertyPrefix ? {
                    property: propertyPrefix
                } : {
                    name: namePrefix
                },
                content
            });
        } else {
            return ExtendMeta({
                namePrefix,
                propertyPrefix,
                content
            });
        }
    }));
}

//# sourceMappingURL=meta.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/constants.js
const ViewportMetaKeys = {
    width: "width",
    height: "height",
    initialScale: "initial-scale",
    minimumScale: "minimum-scale",
    maximumScale: "maximum-scale",
    viewportFit: "viewport-fit",
    userScalable: "user-scalable",
    interactiveWidget: "interactive-widget"
};
const IconKeys = [
    "icon",
    "shortcut",
    "apple",
    "other"
];

//# sourceMappingURL=constants.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/generate/basic.js




// convert viewport object to string for viewport meta tag
function resolveViewportLayout(viewport) {
    let resolved = null;
    if (viewport && typeof viewport === "object") {
        resolved = "";
        for(const viewportKey_ in ViewportMetaKeys){
            const viewportKey = viewportKey_;
            if (viewportKey in viewport) {
                let value = viewport[viewportKey];
                if (typeof value === "boolean") value = value ? "yes" : "no";
                if (resolved) resolved += ", ";
                resolved += `${ViewportMetaKeys[viewportKey]}=${value}`;
            }
        }
    }
    return resolved;
}
function ViewportMeta({ viewport }) {
    return MetaFilter([
        Meta({
            name: "viewport",
            content: resolveViewportLayout(viewport)
        }),
        ...viewport.themeColor ? viewport.themeColor.map((themeColor)=>Meta({
                name: "theme-color",
                content: themeColor.color,
                media: themeColor.media
            })) : [],
        Meta({
            name: "color-scheme",
            content: viewport.colorScheme
        })
    ]);
}
function BasicMeta({ metadata }) {
    var _metadata_keywords, _metadata_robots, _metadata_robots1;
    return MetaFilter([
        /*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
            charSet: "utf-8"
        }),
        metadata.title !== null && metadata.title.absolute ? /*#__PURE__*/ (0,jsx_runtime.jsx)("title", {
            children: metadata.title.absolute
        }) : null,
        Meta({
            name: "description",
            content: metadata.description
        }),
        Meta({
            name: "application-name",
            content: metadata.applicationName
        }),
        ...metadata.authors ? metadata.authors.map((author)=>[
                author.url ? /*#__PURE__*/ (0,jsx_runtime.jsx)("link", {
                    rel: "author",
                    href: author.url.toString()
                }) : null,
                Meta({
                    name: "author",
                    content: author.name
                })
            ]) : [],
        metadata.manifest ? /*#__PURE__*/ (0,jsx_runtime.jsx)("link", {
            rel: "manifest",
            href: metadata.manifest.toString(),
            crossOrigin: "use-credentials"
        }) : null,
        Meta({
            name: "generator",
            content: metadata.generator
        }),
        Meta({
            name: "keywords",
            content: (_metadata_keywords = metadata.keywords) == null ? void 0 : _metadata_keywords.join(",")
        }),
        Meta({
            name: "referrer",
            content: metadata.referrer
        }),
        Meta({
            name: "creator",
            content: metadata.creator
        }),
        Meta({
            name: "publisher",
            content: metadata.publisher
        }),
        Meta({
            name: "robots",
            content: (_metadata_robots = metadata.robots) == null ? void 0 : _metadata_robots.basic
        }),
        Meta({
            name: "googlebot",
            content: (_metadata_robots1 = metadata.robots) == null ? void 0 : _metadata_robots1.googleBot
        }),
        Meta({
            name: "abstract",
            content: metadata.abstract
        }),
        ...metadata.archives ? metadata.archives.map((archive)=>/*#__PURE__*/ (0,jsx_runtime.jsx)("link", {
                rel: "archives",
                href: archive
            })) : [],
        ...metadata.assets ? metadata.assets.map((asset)=>/*#__PURE__*/ (0,jsx_runtime.jsx)("link", {
                rel: "assets",
                href: asset
            })) : [],
        ...metadata.bookmarks ? metadata.bookmarks.map((bookmark)=>/*#__PURE__*/ (0,jsx_runtime.jsx)("link", {
                rel: "bookmarks",
                href: bookmark
            })) : [],
        Meta({
            name: "category",
            content: metadata.category
        }),
        Meta({
            name: "classification",
            content: metadata.classification
        }),
        ...metadata.other ? Object.entries(metadata.other).map(([name, content])=>{
            if (Array.isArray(content)) {
                return content.map((contentItem)=>Meta({
                        name,
                        content: contentItem
                    }));
            } else {
                return Meta({
                    name,
                    content
                });
            }
        }) : []
    ]);
}
function ItunesMeta({ itunes }) {
    if (!itunes) return null;
    const { appId, appArgument } = itunes;
    let content = `app-id=${appId}`;
    if (appArgument) {
        content += `, app-argument=${appArgument}`;
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
        name: "apple-itunes-app",
        content: content
    });
}
const formatDetectionKeys = [
    "telephone",
    "date",
    "address",
    "email",
    "url"
];
function FormatDetectionMeta({ formatDetection }) {
    if (!formatDetection) return null;
    let content = "";
    for (const key of formatDetectionKeys){
        if (key in formatDetection) {
            if (content) content += ", ";
            content += `${key}=no`;
        }
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
        name: "format-detection",
        content: content
    });
}
function AppleWebAppMeta({ appleWebApp }) {
    if (!appleWebApp) return null;
    const { capable, title, startupImage, statusBarStyle } = appleWebApp;
    return MetaFilter([
        capable ? Meta({
            name: "apple-mobile-web-app-capable",
            content: "yes"
        }) : null,
        Meta({
            name: "apple-mobile-web-app-title",
            content: title
        }),
        startupImage ? startupImage.map((image)=>/*#__PURE__*/ (0,jsx_runtime.jsx)("link", {
                href: image.url,
                media: image.media,
                rel: "apple-touch-startup-image"
            })) : null,
        statusBarStyle ? Meta({
            name: "apple-mobile-web-app-status-bar-style",
            content: statusBarStyle
        }) : null
    ]);
}
function VerificationMeta({ verification }) {
    if (!verification) return null;
    return MetaFilter([
        MultiMeta({
            namePrefix: "google-site-verification",
            contents: verification.google
        }),
        MultiMeta({
            namePrefix: "y_key",
            contents: verification.yahoo
        }),
        MultiMeta({
            namePrefix: "yandex-verification",
            contents: verification.yandex
        }),
        MultiMeta({
            namePrefix: "me",
            contents: verification.me
        }),
        ...verification.other ? Object.entries(verification.other).map(([key, value])=>MultiMeta({
                namePrefix: key,
                contents: value
            })) : []
    ]);
}

//# sourceMappingURL=basic.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/generate/alternate.js



function AlternateLink({ descriptor, ...props }) {
    if (!descriptor.url) return null;
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("link", {
        ...props,
        ...descriptor.title && {
            title: descriptor.title
        },
        href: descriptor.url.toString()
    });
}
function AlternatesMetadata({ alternates }) {
    if (!alternates) return null;
    const { canonical, languages, media, types } = alternates;
    return MetaFilter([
        canonical ? AlternateLink({
            rel: "canonical",
            descriptor: canonical
        }) : null,
        languages ? Object.entries(languages).flatMap(([locale, descriptors])=>descriptors == null ? void 0 : descriptors.map((descriptor)=>AlternateLink({
                    rel: "alternate",
                    hrefLang: locale,
                    descriptor
                }))) : null,
        media ? Object.entries(media).flatMap(([mediaName, descriptors])=>descriptors == null ? void 0 : descriptors.map((descriptor)=>AlternateLink({
                    rel: "alternate",
                    media: mediaName,
                    descriptor
                }))) : null,
        types ? Object.entries(types).flatMap(([type, descriptors])=>descriptors == null ? void 0 : descriptors.map((descriptor)=>AlternateLink({
                    rel: "alternate",
                    type,
                    descriptor
                }))) : null
    ]);
}

//# sourceMappingURL=alternate.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/generate/opengraph.js

function OpenGraphMetadata({ openGraph }) {
    var _openGraph_title, _openGraph_url, _openGraph_ttl;
    if (!openGraph) {
        return null;
    }
    let typedOpenGraph;
    if ("type" in openGraph) {
        const openGraphType = openGraph.type;
        switch(openGraphType){
            case "website":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "website"
                    })
                ];
                break;
            case "article":
                var _openGraph_publishedTime, _openGraph_modifiedTime, _openGraph_expirationTime;
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "article"
                    }),
                    Meta({
                        property: "article:published_time",
                        content: (_openGraph_publishedTime = openGraph.publishedTime) == null ? void 0 : _openGraph_publishedTime.toString()
                    }),
                    Meta({
                        property: "article:modified_time",
                        content: (_openGraph_modifiedTime = openGraph.modifiedTime) == null ? void 0 : _openGraph_modifiedTime.toString()
                    }),
                    Meta({
                        property: "article:expiration_time",
                        content: (_openGraph_expirationTime = openGraph.expirationTime) == null ? void 0 : _openGraph_expirationTime.toString()
                    }),
                    MultiMeta({
                        propertyPrefix: "article:author",
                        contents: openGraph.authors
                    }),
                    Meta({
                        property: "article:section",
                        content: openGraph.section
                    }),
                    MultiMeta({
                        propertyPrefix: "article:tag",
                        contents: openGraph.tags
                    })
                ];
                break;
            case "book":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "book"
                    }),
                    Meta({
                        property: "book:isbn",
                        content: openGraph.isbn
                    }),
                    Meta({
                        property: "book:release_date",
                        content: openGraph.releaseDate
                    }),
                    MultiMeta({
                        propertyPrefix: "book:author",
                        contents: openGraph.authors
                    }),
                    MultiMeta({
                        propertyPrefix: "book:tag",
                        contents: openGraph.tags
                    })
                ];
                break;
            case "profile":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "profile"
                    }),
                    Meta({
                        property: "profile:first_name",
                        content: openGraph.firstName
                    }),
                    Meta({
                        property: "profile:last_name",
                        content: openGraph.lastName
                    }),
                    Meta({
                        property: "profile:username",
                        content: openGraph.username
                    }),
                    Meta({
                        property: "profile:gender",
                        content: openGraph.gender
                    })
                ];
                break;
            case "music.song":
                var _openGraph_duration;
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "music.song"
                    }),
                    Meta({
                        property: "music:duration",
                        content: (_openGraph_duration = openGraph.duration) == null ? void 0 : _openGraph_duration.toString()
                    }),
                    MultiMeta({
                        propertyPrefix: "music:album",
                        contents: openGraph.albums
                    }),
                    MultiMeta({
                        propertyPrefix: "music:musician",
                        contents: openGraph.musicians
                    })
                ];
                break;
            case "music.album":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "music.album"
                    }),
                    MultiMeta({
                        propertyPrefix: "music:song",
                        contents: openGraph.songs
                    }),
                    MultiMeta({
                        propertyPrefix: "music:musician",
                        contents: openGraph.musicians
                    }),
                    Meta({
                        property: "music:release_date",
                        content: openGraph.releaseDate
                    })
                ];
                break;
            case "music.playlist":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "music.playlist"
                    }),
                    MultiMeta({
                        propertyPrefix: "music:song",
                        contents: openGraph.songs
                    }),
                    MultiMeta({
                        propertyPrefix: "music:creator",
                        contents: openGraph.creators
                    })
                ];
                break;
            case "music.radio_station":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "music.radio_station"
                    }),
                    MultiMeta({
                        propertyPrefix: "music:creator",
                        contents: openGraph.creators
                    })
                ];
                break;
            case "video.movie":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "video.movie"
                    }),
                    MultiMeta({
                        propertyPrefix: "video:actor",
                        contents: openGraph.actors
                    }),
                    MultiMeta({
                        propertyPrefix: "video:director",
                        contents: openGraph.directors
                    }),
                    MultiMeta({
                        propertyPrefix: "video:writer",
                        contents: openGraph.writers
                    }),
                    Meta({
                        property: "video:duration",
                        content: openGraph.duration
                    }),
                    Meta({
                        property: "video:release_date",
                        content: openGraph.releaseDate
                    }),
                    MultiMeta({
                        propertyPrefix: "video:tag",
                        contents: openGraph.tags
                    })
                ];
                break;
            case "video.episode":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "video.episode"
                    }),
                    MultiMeta({
                        propertyPrefix: "video:actor",
                        contents: openGraph.actors
                    }),
                    MultiMeta({
                        propertyPrefix: "video:director",
                        contents: openGraph.directors
                    }),
                    MultiMeta({
                        propertyPrefix: "video:writer",
                        contents: openGraph.writers
                    }),
                    Meta({
                        property: "video:duration",
                        content: openGraph.duration
                    }),
                    Meta({
                        property: "video:release_date",
                        content: openGraph.releaseDate
                    }),
                    MultiMeta({
                        propertyPrefix: "video:tag",
                        contents: openGraph.tags
                    }),
                    Meta({
                        property: "video:series",
                        content: openGraph.series
                    })
                ];
                break;
            case "video.tv_show":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "video.tv_show"
                    })
                ];
                break;
            case "video.other":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "video.other"
                    })
                ];
                break;
            default:
                const _exhaustiveCheck = openGraphType;
                throw new Error(`Invalid OpenGraph type: ${_exhaustiveCheck}`);
        }
    }
    return MetaFilter([
        Meta({
            property: "og:determiner",
            content: openGraph.determiner
        }),
        Meta({
            property: "og:title",
            content: (_openGraph_title = openGraph.title) == null ? void 0 : _openGraph_title.absolute
        }),
        Meta({
            property: "og:description",
            content: openGraph.description
        }),
        Meta({
            property: "og:url",
            content: (_openGraph_url = openGraph.url) == null ? void 0 : _openGraph_url.toString()
        }),
        Meta({
            property: "og:site_name",
            content: openGraph.siteName
        }),
        Meta({
            property: "og:locale",
            content: openGraph.locale
        }),
        Meta({
            property: "og:country_name",
            content: openGraph.countryName
        }),
        Meta({
            property: "og:ttl",
            content: (_openGraph_ttl = openGraph.ttl) == null ? void 0 : _openGraph_ttl.toString()
        }),
        MultiMeta({
            propertyPrefix: "og:image",
            contents: openGraph.images
        }),
        MultiMeta({
            propertyPrefix: "og:video",
            contents: openGraph.videos
        }),
        MultiMeta({
            propertyPrefix: "og:audio",
            contents: openGraph.audio
        }),
        MultiMeta({
            propertyPrefix: "og:email",
            contents: openGraph.emails
        }),
        MultiMeta({
            propertyPrefix: "og:phone_number",
            contents: openGraph.phoneNumbers
        }),
        MultiMeta({
            propertyPrefix: "og:fax_number",
            contents: openGraph.faxNumbers
        }),
        MultiMeta({
            propertyPrefix: "og:locale:alternate",
            contents: openGraph.alternateLocale
        }),
        ...typedOpenGraph ? typedOpenGraph : []
    ]);
}
function TwitterAppItem({ app, type }) {
    var _app_url_type, _app_url;
    return [
        Meta({
            name: `twitter:app:name:${type}`,
            content: app.name
        }),
        Meta({
            name: `twitter:app:id:${type}`,
            content: app.id[type]
        }),
        Meta({
            name: `twitter:app:url:${type}`,
            content: (_app_url = app.url) == null ? void 0 : (_app_url_type = _app_url[type]) == null ? void 0 : _app_url_type.toString()
        })
    ];
}
function TwitterMetadata({ twitter }) {
    var _twitter_title;
    if (!twitter) return null;
    const { card } = twitter;
    return MetaFilter([
        Meta({
            name: "twitter:card",
            content: card
        }),
        Meta({
            name: "twitter:site",
            content: twitter.site
        }),
        Meta({
            name: "twitter:site:id",
            content: twitter.siteId
        }),
        Meta({
            name: "twitter:creator",
            content: twitter.creator
        }),
        Meta({
            name: "twitter:creator:id",
            content: twitter.creatorId
        }),
        Meta({
            name: "twitter:title",
            content: (_twitter_title = twitter.title) == null ? void 0 : _twitter_title.absolute
        }),
        Meta({
            name: "twitter:description",
            content: twitter.description
        }),
        MultiMeta({
            namePrefix: "twitter:image",
            contents: twitter.images
        }),
        ...card === "player" ? twitter.players.flatMap((player)=>[
                Meta({
                    name: "twitter:player",
                    content: player.playerUrl.toString()
                }),
                Meta({
                    name: "twitter:player:stream",
                    content: player.streamUrl.toString()
                }),
                Meta({
                    name: "twitter:player:width",
                    content: player.width
                }),
                Meta({
                    name: "twitter:player:height",
                    content: player.height
                })
            ]) : [],
        ...card === "app" ? [
            TwitterAppItem({
                app: twitter.app,
                type: "iphone"
            }),
            TwitterAppItem({
                app: twitter.app,
                type: "ipad"
            }),
            TwitterAppItem({
                app: twitter.app,
                type: "googleplay"
            })
        ] : []
    ]);
}
function AppLinksMeta({ appLinks }) {
    if (!appLinks) return null;
    return MetaFilter([
        MultiMeta({
            propertyPrefix: "al:ios",
            contents: appLinks.ios
        }),
        MultiMeta({
            propertyPrefix: "al:iphone",
            contents: appLinks.iphone
        }),
        MultiMeta({
            propertyPrefix: "al:ipad",
            contents: appLinks.ipad
        }),
        MultiMeta({
            propertyPrefix: "al:android",
            contents: appLinks.android
        }),
        MultiMeta({
            propertyPrefix: "al:windows_phone",
            contents: appLinks.windows_phone
        }),
        MultiMeta({
            propertyPrefix: "al:windows",
            contents: appLinks.windows
        }),
        MultiMeta({
            propertyPrefix: "al:windows_universal",
            contents: appLinks.windows_universal
        }),
        MultiMeta({
            propertyPrefix: "al:web",
            contents: appLinks.web
        })
    ]);
}

//# sourceMappingURL=opengraph.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/generate/icons.js



function IconDescriptorLink({ icon }) {
    const { url, rel = "icon", ...props } = icon;
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("link", {
        rel: rel,
        href: url.toString(),
        ...props
    });
}
function IconLink({ rel, icon }) {
    if (typeof icon === "object" && !(icon instanceof URL)) {
        if (!icon.rel && rel) icon.rel = rel;
        return IconDescriptorLink({
            icon
        });
    } else {
        const href = icon.toString();
        return /*#__PURE__*/ (0,jsx_runtime.jsx)("link", {
            rel: rel,
            href: href
        });
    }
}
function IconsMetadata({ icons }) {
    if (!icons) return null;
    const shortcutList = icons.shortcut;
    const iconList = icons.icon;
    const appleList = icons.apple;
    const otherList = icons.other;
    return MetaFilter([
        shortcutList ? shortcutList.map((icon)=>IconLink({
                rel: "shortcut icon",
                icon
            })) : null,
        iconList ? iconList.map((icon)=>IconLink({
                rel: "icon",
                icon
            })) : null,
        appleList ? appleList.map((icon)=>IconLink({
                rel: "apple-touch-icon",
                icon
            })) : null,
        otherList ? otherList.map((icon)=>IconDescriptorLink({
                icon
            })) : null
    ]);
}

//# sourceMappingURL=icons.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/default-metadata.js
function createDefaultViewport() {
    return {
        // name=viewport
        width: "device-width",
        initialScale: 1,
        // visual metadata
        themeColor: null,
        colorScheme: null
    };
}
function createDefaultMetadata() {
    return {
        // Deprecated ones
        viewport: null,
        themeColor: null,
        colorScheme: null,
        metadataBase: null,
        // Other values are all null
        title: null,
        description: null,
        applicationName: null,
        authors: null,
        generator: null,
        keywords: null,
        referrer: null,
        creator: null,
        publisher: null,
        robots: null,
        manifest: null,
        alternates: {
            canonical: null,
            languages: null,
            media: null,
            types: null
        },
        icons: null,
        openGraph: null,
        twitter: null,
        verification: {},
        appleWebApp: null,
        formatDetection: null,
        itunes: null,
        abstract: null,
        appLinks: null,
        archives: null,
        assets: null,
        bookmarks: null,
        category: null,
        classification: null,
        other: {}
    };
}

//# sourceMappingURL=default-metadata.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/generate/utils.js
function resolveArray(value) {
    if (Array.isArray(value)) {
        return value;
    }
    return [
        value
    ];
}
function resolveAsArrayOrUndefined(value) {
    if (typeof value === "undefined" || value === null) {
        return undefined;
    }
    return resolveArray(value);
}


//# sourceMappingURL=utils.js.map
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/isomorphic/path.js
var path = __webpack_require__(7652);
var path_default = /*#__PURE__*/__webpack_require__.n(path);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-url.js

function isStringOrURL(icon) {
    return typeof icon === "string" || icon instanceof URL;
}
function createLocalMetadataBase() {
    return new URL(`http://localhost:${process.env.PORT || 3000}`);
}
function getPreviewDeploymentUrl() {
    const origin = process.env.VERCEL_BRANCH_URL || process.env.VERCEL_URL;
    return origin ? new URL(`https://${origin}`) : undefined;
}
function getProductionDeploymentUrl() {
    const origin = process.env.VERCEL_PROJECT_PRODUCTION_URL;
    return origin ? new URL(`https://${origin}`) : undefined;
}
// For deployment url for metadata routes, prefer to use the deployment url if possible
// as these routes are unique to the deployments url.
function getSocialImageFallbackMetadataBase(metadataBase) {
    const isMetadataBaseMissing = !metadataBase;
    const defaultMetadataBase = createLocalMetadataBase();
    const previewDeploymentUrl = getPreviewDeploymentUrl();
    const productionDeploymentUrl = getProductionDeploymentUrl();
    let fallbackMetadataBase;
    if (false) {} else {
        fallbackMetadataBase =  true && previewDeploymentUrl && process.env.VERCEL_ENV === "preview" ? previewDeploymentUrl : metadataBase || productionDeploymentUrl || defaultMetadataBase;
    }
    return {
        fallbackMetadataBase,
        isMetadataBaseMissing
    };
}
function resolveUrl(url, metadataBase) {
    if (url instanceof URL) return url;
    if (!url) return null;
    try {
        // If we can construct a URL instance from url, ignore metadataBase
        const parsedUrl = new URL(url);
        return parsedUrl;
    } catch  {}
    if (!metadataBase) {
        metadataBase = createLocalMetadataBase();
    }
    // Handle relative or absolute paths
    const basePath = metadataBase.pathname || "";
    const joinedPath = path_default().posix.join(basePath, url);
    return new URL(joinedPath, metadataBase);
}
// Resolve with `pathname` if `url` is a relative path.
function resolveRelativeUrl(url, pathname) {
    if (typeof url === "string" && url.startsWith("./")) {
        return path_default().posix.resolve(pathname, url);
    }
    return url;
}
// The regex is matching logic from packages/next/src/lib/load-custom-routes.ts
const FILE_REGEX = /^(?:\/((?!\.well-known(?:\/.*)?)(?:[^/]+\/)*[^/]+\.\w+))(\/?|$)/i;
function isFilePattern(pathname) {
    return FILE_REGEX.test(pathname);
}
// Resolve `pathname` if `url` is a relative path the compose with `metadataBase`.
function resolveAbsoluteUrlWithPathname(url, metadataBase, { trailingSlash, pathname }) {
    // Resolve url with pathname that always starts with `/`
    url = resolveRelativeUrl(url, pathname);
    // Convert string url or URL instance to absolute url string,
    // if there's case needs to be resolved with metadataBase
    let resolvedUrl = "";
    const result = metadataBase ? resolveUrl(url, metadataBase) : url;
    if (typeof result === "string") {
        resolvedUrl = result;
    } else {
        resolvedUrl = result.pathname === "/" ? result.origin : result.href;
    }
    // Add trailing slash if it's enabled for urls matches the condition
    // - Not external, same origin with metadataBase
    // - Doesn't have query
    if (trailingSlash && !resolvedUrl.endsWith("/")) {
        let isRelative = resolvedUrl.startsWith("/");
        let hasQuery = resolvedUrl.includes("?");
        let isExternal = false;
        let isFileUrl = false;
        if (!isRelative) {
            try {
                const parsedUrl = new URL(resolvedUrl);
                isExternal = metadataBase != null && parsedUrl.origin !== metadataBase.origin;
                isFileUrl = isFilePattern(parsedUrl.pathname);
            } catch  {
                // If it's not a valid URL, treat it as external
                isExternal = true;
            }
            if (// Do not apply trailing slash for file like urls, aligning with the behavior with `trailingSlash`
            !isFileUrl && !isExternal && !hasQuery) return `${resolvedUrl}/`;
        }
    }
    return resolvedUrl;
}


//# sourceMappingURL=resolve-url.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-title.js
function resolveTitleTemplate(template, title) {
    return template ? template.replace(/%s/g, title) : title;
}
function resolveTitle(title, stashedTemplate) {
    let resolved;
    const template = typeof title !== "string" && title && "template" in title ? title.template : null;
    if (typeof title === "string") {
        resolved = resolveTitleTemplate(stashedTemplate, title);
    } else if (title) {
        if ("default" in title) {
            resolved = resolveTitleTemplate(stashedTemplate, title.default);
        }
        if ("absolute" in title && title.absolute) {
            resolved = title.absolute;
        }
    }
    if (title && typeof title !== "string") {
        return {
            template,
            absolute: resolved || ""
        };
    } else {
        return {
            absolute: resolved || title || "",
            template
        };
    }
}

//# sourceMappingURL=resolve-title.js.map
// EXTERNAL MODULE: ./node_modules/next/dist/esm/lib/url.js
var url = __webpack_require__(8890);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/build/output/log.js
var log = __webpack_require__(292);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-opengraph.js





const OgTypeFields = {
    article: [
        "authors",
        "tags"
    ],
    song: [
        "albums",
        "musicians"
    ],
    playlist: [
        "albums",
        "musicians"
    ],
    radio: [
        "creators"
    ],
    video: [
        "actors",
        "directors",
        "writers",
        "tags"
    ],
    basic: [
        "emails",
        "phoneNumbers",
        "faxNumbers",
        "alternateLocale",
        "audio",
        "videos"
    ]
};
function resolveAndValidateImage(item, metadataBase, isMetadataBaseMissing) {
    if (!item) return undefined;
    const isItemUrl = isStringOrURL(item);
    const inputUrl = isItemUrl ? item : item.url;
    if (!inputUrl) return undefined;
    validateResolvedImageUrl(inputUrl, metadataBase, isMetadataBaseMissing);
    return isItemUrl ? {
        url: resolveUrl(inputUrl, metadataBase)
    } : {
        ...item,
        // Update image descriptor url
        url: resolveUrl(inputUrl, metadataBase)
    };
}
function resolveImages(images, metadataBase) {
    const resolvedImages = resolveAsArrayOrUndefined(images);
    if (!resolvedImages) return resolvedImages;
    const { isMetadataBaseMissing, fallbackMetadataBase } = getSocialImageFallbackMetadataBase(metadataBase);
    const nonNullableImages = [];
    for (const item of resolvedImages){
        const resolvedItem = resolveAndValidateImage(item, fallbackMetadataBase, isMetadataBaseMissing);
        if (!resolvedItem) continue;
        nonNullableImages.push(resolvedItem);
    }
    return nonNullableImages;
}
const ogTypeToFields = {
    article: OgTypeFields.article,
    book: OgTypeFields.article,
    "music.song": OgTypeFields.song,
    "music.album": OgTypeFields.song,
    "music.playlist": OgTypeFields.playlist,
    "music.radio_station": OgTypeFields.radio,
    "video.movie": OgTypeFields.video,
    "video.episode": OgTypeFields.video
};
function getFieldsByOgType(ogType) {
    if (!ogType || !(ogType in ogTypeToFields)) return OgTypeFields.basic;
    return ogTypeToFields[ogType].concat(OgTypeFields.basic);
}
function validateResolvedImageUrl(inputUrl, fallbackMetadataBase, isMetadataBaseMissing) {
    // Only warn on the image url that needs to be resolved with metadataBase
    if (typeof inputUrl === "string" && !(0,url/* isFullStringUrl */.N)(inputUrl) && isMetadataBaseMissing) {
        (0,log/* warnOnce */.O4)(`metadataBase property in metadata export is not set for resolving social open graph or twitter images, using "${fallbackMetadataBase.origin}". See https://nextjs.org/docs/app/api-reference/functions/generate-metadata#metadatabase`);
    }
}
const resolveOpenGraph = (openGraph, metadataBase, metadataContext, titleTemplate)=>{
    if (!openGraph) return null;
    function resolveProps(target, og) {
        const ogType = og && "type" in og ? og.type : undefined;
        const keys = getFieldsByOgType(ogType);
        for (const k of keys){
            const key = k;
            if (key in og && key !== "url") {
                const value = og[key];
                if (value) {
                    const arrayValue = resolveAsArrayOrUndefined(value);
                    target[key] = arrayValue;
                }
            }
        }
        target.images = resolveImages(og.images, metadataBase);
    }
    const resolved = {
        ...openGraph,
        title: resolveTitle(openGraph.title, titleTemplate)
    };
    resolveProps(resolved, openGraph);
    resolved.url = openGraph.url ? resolveAbsoluteUrlWithPathname(openGraph.url, metadataBase, metadataContext) : null;
    return resolved;
};
const TwitterBasicInfoKeys = [
    "site",
    "siteId",
    "creator",
    "creatorId",
    "description"
];
const resolveTwitter = (twitter, metadataBase, titleTemplate)=>{
    var _resolved_images;
    if (!twitter) return null;
    let card = "card" in twitter ? twitter.card : undefined;
    const resolved = {
        ...twitter,
        title: resolveTitle(twitter.title, titleTemplate)
    };
    for (const infoKey of TwitterBasicInfoKeys){
        resolved[infoKey] = twitter[infoKey] || null;
    }
    resolved.images = resolveImages(twitter.images, metadataBase);
    card = card || (((_resolved_images = resolved.images) == null ? void 0 : _resolved_images.length) ? "summary_large_image" : "summary");
    resolved.card = card;
    if ("card" in resolved) {
        switch(resolved.card){
            case "player":
                {
                    resolved.players = resolveAsArrayOrUndefined(resolved.players) || [];
                    break;
                }
            case "app":
                {
                    resolved.app = resolved.app || {};
                    break;
                }
            default:
                break;
        }
    }
    return resolved;
};

//# sourceMappingURL=resolve-opengraph.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/client-reference.js
function isClientReference(reference) {
    return (reference == null ? void 0 : reference.$$typeof) === Symbol.for("react.client.reference");
}

//# sourceMappingURL=client-reference.js.map
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/segment.js
var lib_segment = __webpack_require__(8478);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/lib/app-dir-module.js

async function getLayoutOrPageModule(loaderTree) {
    const { layout, page, defaultPage } = loaderTree[2];
    const isLayout = typeof layout !== "undefined";
    const isPage = typeof page !== "undefined";
    const isDefaultPage = typeof defaultPage !== "undefined" && loaderTree[0] === lib_segment/* DEFAULT_SEGMENT_KEY */.av;
    let value = undefined;
    let modType = undefined;
    if (isLayout) {
        value = await layout[0]();
        modType = "layout";
    } else if (isPage) {
        value = await page[0]();
        modType = "page";
    } else if (isDefaultPage) {
        value = await defaultPage[0]();
        modType = "page";
    }
    return [
        value,
        modType
    ];
}
async function getComponentTypeModule(loaderTree, componentType) {
    const { [componentType]: component } = loaderTree[2];
    if (typeof component !== "undefined") {
        return await component[0]();
    }
    return undefined;
}

//# sourceMappingURL=app-dir-module.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/interop-default.js
function interopDefault(mod) {
    return mod.default || mod;
}

//# sourceMappingURL=interop-default.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-basics.js


function resolveAlternateUrl(url, metadataBase, metadataContext) {
    // If alter native url is an URL instance,
    // we treat it as a URL base and resolve with current pathname
    if (url instanceof URL) {
        url = new URL(metadataContext.pathname, url);
    }
    return resolveAbsoluteUrlWithPathname(url, metadataBase, metadataContext);
}
const resolveThemeColor = (themeColor)=>{
    var _resolveAsArrayOrUndefined;
    if (!themeColor) return null;
    const themeColorDescriptors = [];
    (_resolveAsArrayOrUndefined = resolveAsArrayOrUndefined(themeColor)) == null ? void 0 : _resolveAsArrayOrUndefined.forEach((descriptor)=>{
        if (typeof descriptor === "string") themeColorDescriptors.push({
            color: descriptor
        });
        else if (typeof descriptor === "object") themeColorDescriptors.push({
            color: descriptor.color,
            media: descriptor.media
        });
    });
    return themeColorDescriptors;
};
function resolveUrlValuesOfObject(obj, metadataBase, metadataContext) {
    if (!obj) return null;
    const result = {};
    for (const [key, value] of Object.entries(obj)){
        if (typeof value === "string" || value instanceof URL) {
            result[key] = [
                {
                    url: resolveAlternateUrl(value, metadataBase, metadataContext)
                }
            ];
        } else {
            result[key] = [];
            value == null ? void 0 : value.forEach((item, index)=>{
                const url = resolveAlternateUrl(item.url, metadataBase, metadataContext);
                result[key][index] = {
                    url,
                    title: item.title
                };
            });
        }
    }
    return result;
}
function resolveCanonicalUrl(urlOrDescriptor, metadataBase, metadataContext) {
    if (!urlOrDescriptor) return null;
    const url = typeof urlOrDescriptor === "string" || urlOrDescriptor instanceof URL ? urlOrDescriptor : urlOrDescriptor.url;
    // Return string url because structureClone can't handle URL instance
    return {
        url: resolveAlternateUrl(url, metadataBase, metadataContext)
    };
}
const resolveAlternates = (alternates, metadataBase, context)=>{
    if (!alternates) return null;
    const canonical = resolveCanonicalUrl(alternates.canonical, metadataBase, context);
    const languages = resolveUrlValuesOfObject(alternates.languages, metadataBase, context);
    const media = resolveUrlValuesOfObject(alternates.media, metadataBase, context);
    const types = resolveUrlValuesOfObject(alternates.types, metadataBase, context);
    const result = {
        canonical,
        languages,
        media,
        types
    };
    return result;
};
const robotsKeys = [
    "noarchive",
    "nosnippet",
    "noimageindex",
    "nocache",
    "notranslate",
    "indexifembedded",
    "nositelinkssearchbox",
    "unavailable_after",
    "max-video-preview",
    "max-image-preview",
    "max-snippet"
];
const resolveRobotsValue = (robots)=>{
    if (!robots) return null;
    if (typeof robots === "string") return robots;
    const values = [];
    if (robots.index) values.push("index");
    else if (typeof robots.index === "boolean") values.push("noindex");
    if (robots.follow) values.push("follow");
    else if (typeof robots.follow === "boolean") values.push("nofollow");
    for (const key of robotsKeys){
        const value = robots[key];
        if (typeof value !== "undefined" && value !== false) {
            values.push(typeof value === "boolean" ? key : `${key}:${value}`);
        }
    }
    return values.join(", ");
};
const resolveRobots = (robots)=>{
    if (!robots) return null;
    return {
        basic: resolveRobotsValue(robots),
        googleBot: typeof robots !== "string" ? resolveRobotsValue(robots.googleBot) : null
    };
};
const VerificationKeys = [
    "google",
    "yahoo",
    "yandex",
    "me",
    "other"
];
const resolveVerification = (verification)=>{
    if (!verification) return null;
    const res = {};
    for (const key of VerificationKeys){
        const value = verification[key];
        if (value) {
            if (key === "other") {
                res.other = {};
                for(const otherKey in verification.other){
                    const otherValue = resolveAsArrayOrUndefined(verification.other[otherKey]);
                    if (otherValue) res.other[otherKey] = otherValue;
                }
            } else res[key] = resolveAsArrayOrUndefined(value);
        }
    }
    return res;
};
const resolveAppleWebApp = (appWebApp)=>{
    var _resolveAsArrayOrUndefined;
    if (!appWebApp) return null;
    if (appWebApp === true) {
        return {
            capable: true
        };
    }
    const startupImages = appWebApp.startupImage ? (_resolveAsArrayOrUndefined = resolveAsArrayOrUndefined(appWebApp.startupImage)) == null ? void 0 : _resolveAsArrayOrUndefined.map((item)=>typeof item === "string" ? {
            url: item
        } : item) : null;
    return {
        capable: "capable" in appWebApp ? !!appWebApp.capable : true,
        title: appWebApp.title || null,
        startupImage: startupImages,
        statusBarStyle: appWebApp.statusBarStyle || "default"
    };
};
const resolveAppLinks = (appLinks)=>{
    if (!appLinks) return null;
    for(const key in appLinks){
        // @ts-ignore // TODO: type infer
        appLinks[key] = resolveAsArrayOrUndefined(appLinks[key]);
    }
    return appLinks;
};
const resolveItunes = (itunes, metadataBase, context)=>{
    if (!itunes) return null;
    return {
        appId: itunes.appId,
        appArgument: itunes.appArgument ? resolveAlternateUrl(itunes.appArgument, metadataBase, context) : undefined
    };
};

//# sourceMappingURL=resolve-basics.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-icons.js



function resolveIcon(icon) {
    if (isStringOrURL(icon)) return {
        url: icon
    };
    else if (Array.isArray(icon)) return icon;
    return icon;
}
const resolveIcons = (icons)=>{
    if (!icons) {
        return null;
    }
    const resolved = {
        icon: [],
        apple: []
    };
    if (Array.isArray(icons)) {
        resolved.icon = icons.map(resolveIcon).filter(Boolean);
    } else if (isStringOrURL(icons)) {
        resolved.icon = [
            resolveIcon(icons)
        ];
    } else {
        for (const key of IconKeys){
            const values = resolveAsArrayOrUndefined(icons[key]);
            if (values) resolved[key] = values.map(resolveIcon);
        }
    }
    return resolved;
};

//# sourceMappingURL=resolve-icons.js.map
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/lib/trace/tracer.js
var tracer = __webpack_require__(8844);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/lib/trace/constants.js
var constants = __webpack_require__(6236);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/resolve-metadata.js













function hasIconsProperty(icons, prop) {
    if (!icons) return false;
    if (prop === "icon") {
        // Detect if icons.icon will be presented, icons array and icons string will all be merged into icons.icon
        return !!(typeof icons === "string" || icons instanceof URL || Array.isArray(icons) || prop in icons && icons[prop]);
    } else {
        // Detect if icons.apple will be presented, only icons.apple will be merged into icons.apple
        return !!(typeof icons === "object" && prop in icons && icons[prop]);
    }
}
function mergeStaticMetadata(source, target, staticFilesMetadata, metadataContext, titleTemplates) {
    var _source_twitter, _source_openGraph;
    if (!staticFilesMetadata) return;
    const { icon, apple, openGraph, twitter, manifest } = staticFilesMetadata;
    // file based metadata is specified and current level metadata icons is not specified
    if (icon && !hasIconsProperty(source == null ? void 0 : source.icons, "icon") || apple && !hasIconsProperty(source == null ? void 0 : source.icons, "apple")) {
        target.icons = {
            icon: icon || [],
            apple: apple || []
        };
    }
    // file based metadata is specified and current level metadata twitter.images is not specified
    if (twitter && !(source == null ? void 0 : (_source_twitter = source.twitter) == null ? void 0 : _source_twitter.hasOwnProperty("images"))) {
        const resolvedTwitter = resolveTwitter({
            ...target.twitter,
            images: twitter
        }, target.metadataBase, titleTemplates.twitter);
        target.twitter = resolvedTwitter;
    }
    // file based metadata is specified and current level metadata openGraph.images is not specified
    if (openGraph && !(source == null ? void 0 : (_source_openGraph = source.openGraph) == null ? void 0 : _source_openGraph.hasOwnProperty("images"))) {
        const resolvedOpenGraph = resolveOpenGraph({
            ...target.openGraph,
            images: openGraph
        }, target.metadataBase, metadataContext, titleTemplates.openGraph);
        target.openGraph = resolvedOpenGraph;
    }
    if (manifest) {
        target.manifest = manifest;
    }
    return target;
}
// Merge the source metadata into the resolved target metadata.
function mergeMetadata({ source, target, staticFilesMetadata, titleTemplates, metadataContext, buildState }) {
    // If there's override metadata, prefer it otherwise fallback to the default metadata.
    const metadataBase = typeof (source == null ? void 0 : source.metadataBase) !== "undefined" ? source.metadataBase : target.metadataBase;
    for(const key_ in source){
        const key = key_;
        switch(key){
            case "title":
                {
                    target.title = resolveTitle(source.title, titleTemplates.title);
                    break;
                }
            case "alternates":
                {
                    target.alternates = resolveAlternates(source.alternates, metadataBase, metadataContext);
                    break;
                }
            case "openGraph":
                {
                    target.openGraph = resolveOpenGraph(source.openGraph, metadataBase, metadataContext, titleTemplates.openGraph);
                    break;
                }
            case "twitter":
                {
                    target.twitter = resolveTwitter(source.twitter, metadataBase, titleTemplates.twitter);
                    break;
                }
            case "verification":
                target.verification = resolveVerification(source.verification);
                break;
            case "icons":
                {
                    target.icons = resolveIcons(source.icons);
                    break;
                }
            case "appleWebApp":
                target.appleWebApp = resolveAppleWebApp(source.appleWebApp);
                break;
            case "appLinks":
                target.appLinks = resolveAppLinks(source.appLinks);
                break;
            case "robots":
                {
                    target.robots = resolveRobots(source.robots);
                    break;
                }
            case "archives":
            case "assets":
            case "bookmarks":
            case "keywords":
                {
                    target[key] = resolveAsArrayOrUndefined(source[key]);
                    break;
                }
            case "authors":
                {
                    target[key] = resolveAsArrayOrUndefined(source.authors);
                    break;
                }
            case "itunes":
                {
                    target[key] = resolveItunes(source.itunes, metadataBase, metadataContext);
                    break;
                }
            // directly assign fields that fallback to null
            case "applicationName":
            case "description":
            case "generator":
            case "creator":
            case "publisher":
            case "category":
            case "classification":
            case "referrer":
            case "formatDetection":
            case "manifest":
                // @ts-ignore TODO: support inferring
                target[key] = source[key] || null;
                break;
            case "other":
                target.other = Object.assign({}, target.other, source.other);
                break;
            case "metadataBase":
                target.metadataBase = metadataBase;
                break;
            default:
                {
                    if ((key === "viewport" || key === "themeColor" || key === "colorScheme") && source[key] != null) {
                        buildState.warnings.add(`Unsupported metadata ${key} is configured in metadata export in ${metadataContext.pathname}. Please move it to viewport export instead.\nRead more: https://nextjs.org/docs/app/api-reference/functions/generate-viewport`);
                    }
                    break;
                }
        }
    }
    mergeStaticMetadata(source, target, staticFilesMetadata, metadataContext, titleTemplates);
}
function mergeViewport({ target, source }) {
    if (!source) return;
    for(const key_ in source){
        const key = key_;
        switch(key){
            case "themeColor":
                {
                    target.themeColor = resolveThemeColor(source.themeColor);
                    break;
                }
            case "colorScheme":
                target.colorScheme = source.colorScheme || null;
                break;
            default:
                if (typeof source[key] !== "undefined") {
                    // @ts-ignore viewport properties
                    target[key] = source[key];
                }
                break;
        }
    }
}
async function getDefinedViewport(mod, props, tracingProps) {
    if (isClientReference(mod)) {
        return null;
    }
    if (typeof mod.generateViewport === "function") {
        const { route } = tracingProps;
        return (parent)=>(0,tracer/* getTracer */.Yz)().trace(constants/* ResolveMetadataSpan */._s.generateViewport, {
                spanName: `generateViewport ${route}`,
                attributes: {
                    "next.page": route
                }
            }, ()=>mod.generateViewport(props, parent));
    }
    return mod.viewport || null;
}
async function getDefinedMetadata(mod, props, tracingProps) {
    // Layer is a client component, we just skip it. It can't have metadata exported.
    // Return early to avoid accessing properties error for client references.
    if (isClientReference(mod)) {
        return null;
    }
    if (typeof mod.generateMetadata === "function") {
        const { route } = tracingProps;
        return (parent)=>(0,tracer/* getTracer */.Yz)().trace(constants/* ResolveMetadataSpan */._s.generateMetadata, {
                spanName: `generateMetadata ${route}`,
                attributes: {
                    "next.page": route
                }
            }, ()=>mod.generateMetadata(props, parent));
    }
    return mod.metadata || null;
}
async function collectStaticImagesFiles(metadata, props, type) {
    var _this;
    if (!(metadata == null ? void 0 : metadata[type])) return undefined;
    const iconPromises = metadata[type].map(async (imageModule)=>interopDefault(await imageModule(props)));
    return (iconPromises == null ? void 0 : iconPromises.length) > 0 ? (_this = await Promise.all(iconPromises)) == null ? void 0 : _this.flat() : undefined;
}
async function resolveStaticMetadata(components, props) {
    const { metadata } = components;
    if (!metadata) return null;
    const [icon, apple, openGraph, twitter] = await Promise.all([
        collectStaticImagesFiles(metadata, props, "icon"),
        collectStaticImagesFiles(metadata, props, "apple"),
        collectStaticImagesFiles(metadata, props, "openGraph"),
        collectStaticImagesFiles(metadata, props, "twitter")
    ]);
    const staticMetadata = {
        icon,
        apple,
        openGraph,
        twitter,
        manifest: metadata.manifest
    };
    return staticMetadata;
}
// [layout.metadata, static files metadata] -> ... -> [page.metadata, static files metadata]
async function collectMetadata({ tree, metadataItems, errorMetadataItem, props, route, errorConvention }) {
    let mod;
    let modType;
    const hasErrorConventionComponent = Boolean(errorConvention && tree[2][errorConvention]);
    if (errorConvention) {
        mod = await getComponentTypeModule(tree, "layout");
        modType = errorConvention;
    } else {
        [mod, modType] = await getLayoutOrPageModule(tree);
    }
    if (modType) {
        route += `/${modType}`;
    }
    const staticFilesMetadata = await resolveStaticMetadata(tree[2], props);
    const metadataExport = mod ? await getDefinedMetadata(mod, props, {
        route
    }) : null;
    const viewportExport = mod ? await getDefinedViewport(mod, props, {
        route
    }) : null;
    metadataItems.push([
        metadataExport,
        staticFilesMetadata,
        viewportExport
    ]);
    if (hasErrorConventionComponent && errorConvention) {
        const errorMod = await getComponentTypeModule(tree, errorConvention);
        const errorViewportExport = errorMod ? await getDefinedViewport(errorMod, props, {
            route
        }) : null;
        const errorMetadataExport = errorMod ? await getDefinedMetadata(errorMod, props, {
            route
        }) : null;
        errorMetadataItem[0] = errorMetadataExport;
        errorMetadataItem[1] = staticFilesMetadata;
        errorMetadataItem[2] = errorViewportExport;
    }
}
async function resolveMetadataItems({ tree, parentParams, metadataItems, errorMetadataItem, treePrefix = [], getDynamicParamFromSegment, searchParams, errorConvention }) {
    const [segment, parallelRoutes, { page }] = tree;
    const currentTreePrefix = [
        ...treePrefix,
        segment
    ];
    const isPage = typeof page !== "undefined";
    // Handle dynamic segment params.
    const segmentParam = getDynamicParamFromSegment(segment);
    /**
   * Create object holding the parent params and current params
   */ const currentParams = // Handle null case where dynamic param is optional
    segmentParam && segmentParam.value !== null ? {
        ...parentParams,
        [segmentParam.param]: segmentParam.value
    } : parentParams;
    let layerProps;
    if (isPage) {
        layerProps = {
            params: currentParams,
            searchParams
        };
    } else {
        layerProps = {
            params: currentParams
        };
    }
    await collectMetadata({
        tree,
        metadataItems,
        errorMetadataItem,
        errorConvention,
        props: layerProps,
        route: currentTreePrefix// __PAGE__ shouldn't be shown in a route
        .filter((s)=>s !== lib_segment/* PAGE_SEGMENT_KEY */.GC).join("/")
    });
    for(const key in parallelRoutes){
        const childTree = parallelRoutes[key];
        await resolveMetadataItems({
            tree: childTree,
            metadataItems,
            errorMetadataItem,
            parentParams: currentParams,
            treePrefix: currentTreePrefix,
            searchParams,
            getDynamicParamFromSegment,
            errorConvention
        });
    }
    if (Object.keys(parallelRoutes).length === 0 && errorConvention) {
        // If there are no parallel routes, place error metadata as the last item.
        // e.g. layout -> layout -> not-found
        metadataItems.push(errorMetadataItem);
    }
    return metadataItems;
}
const isTitleTruthy = (title)=>!!(title == null ? void 0 : title.absolute);
const hasTitle = (metadata)=>isTitleTruthy(metadata == null ? void 0 : metadata.title);
function inheritFromMetadata(target, metadata) {
    if (target) {
        if (!hasTitle(target) && hasTitle(metadata)) {
            target.title = metadata.title;
        }
        if (!target.description && metadata.description) {
            target.description = metadata.description;
        }
    }
}
const commonOgKeys = (/* unused pure expression or super */ null && ([
    "title",
    "description",
    "images"
]));
function postProcessMetadata(metadata, titleTemplates) {
    const { openGraph, twitter } = metadata;
    if (openGraph) {
        // If there's openGraph information but not configured in twitter,
        // inherit them from openGraph metadata.
        let autoFillProps = {};
        const hasTwTitle = hasTitle(twitter);
        const hasTwDescription = twitter == null ? void 0 : twitter.description;
        const hasTwImages = Boolean((twitter == null ? void 0 : twitter.hasOwnProperty("images")) && twitter.images);
        if (!hasTwTitle) {
            if (isTitleTruthy(openGraph.title)) {
                autoFillProps.title = openGraph.title;
            } else if (metadata.title && isTitleTruthy(metadata.title)) {
                autoFillProps.title = metadata.title;
            }
        }
        if (!hasTwDescription) autoFillProps.description = openGraph.description || metadata.description || undefined;
        if (!hasTwImages) autoFillProps.images = openGraph.images;
        if (Object.keys(autoFillProps).length > 0) {
            const partialTwitter = resolveTwitter(autoFillProps, metadata.metadataBase, titleTemplates.twitter);
            if (metadata.twitter) {
                metadata.twitter = Object.assign({}, metadata.twitter, {
                    ...!hasTwTitle && {
                        title: partialTwitter == null ? void 0 : partialTwitter.title
                    },
                    ...!hasTwDescription && {
                        description: partialTwitter == null ? void 0 : partialTwitter.description
                    },
                    ...!hasTwImages && {
                        images: partialTwitter == null ? void 0 : partialTwitter.images
                    }
                });
            } else {
                metadata.twitter = partialTwitter;
            }
        }
    }
    // If there's no title and description configured in openGraph or twitter,
    // use the title and description from metadata.
    inheritFromMetadata(openGraph, metadata);
    inheritFromMetadata(twitter, metadata);
    return metadata;
}
function collectMetadataExportPreloading(results, dynamicMetadataExportFn, resolvers) {
    const result = dynamicMetadataExportFn(new Promise((resolve)=>{
        resolvers.push(resolve);
    }));
    if (result instanceof Promise) {
        // since we eager execute generateMetadata and
        // they can reject at anytime we need to ensure
        // we attach the catch handler right away to
        // prevent unhandled rejections crashing the process
        result.catch((err)=>{
            return {
                __nextError: err
            };
        });
    }
    results.push(result);
}
async function getMetadataFromExport(getPreloadMetadataExport, dynamicMetadataResolveState, metadataItems, currentIndex, resolvedMetadata, metadataResults) {
    const metadataExport = getPreloadMetadataExport(metadataItems[currentIndex]);
    const dynamicMetadataResolvers = dynamicMetadataResolveState.resolvers;
    let metadata = null;
    if (typeof metadataExport === "function") {
        // Only preload at the beginning when resolves are empty
        if (!dynamicMetadataResolvers.length) {
            for(let j = currentIndex; j < metadataItems.length; j++){
                const preloadMetadataExport = getPreloadMetadataExport(metadataItems[j]) // metadataItems[j][0]
                ;
                // call each `generateMetadata function concurrently and stash their resolver
                if (typeof preloadMetadataExport === "function") {
                    collectMetadataExportPreloading(metadataResults, preloadMetadataExport, dynamicMetadataResolvers);
                }
            }
        }
        const resolveParent = dynamicMetadataResolvers[dynamicMetadataResolveState.resolvingIndex];
        const metadataResult = metadataResults[dynamicMetadataResolveState.resolvingIndex++];
        // In dev we clone and freeze to prevent relying on mutating resolvedMetadata directly.
        // In prod we just pass resolvedMetadata through without any copying.
        const currentResolvedMetadata =  false ? 0 : resolvedMetadata;
        // This resolve should unblock the generateMetadata function if it awaited the parent
        // argument. If it didn't await the parent argument it might already have a value since it was
        // called concurrently. Regardless we await the return value before continuing on to the next layer
        resolveParent(currentResolvedMetadata);
        metadata = metadataResult instanceof Promise ? await metadataResult : metadataResult;
        if (metadata && typeof metadata === "object" && "__nextError" in metadata) {
            // re-throw caught metadata error from preloading
            throw metadata["__nextError"];
        }
    } else if (metadataExport !== null && typeof metadataExport === "object") {
        // This metadataExport is the object form
        metadata = metadataExport;
    }
    return metadata;
}
async function accumulateMetadata(metadataItems, metadataContext) {
    const resolvedMetadata = createDefaultMetadata();
    const metadataResults = [];
    let titleTemplates = {
        title: null,
        twitter: null,
        openGraph: null
    };
    // Loop over all metadata items again, merging synchronously any static object exports,
    // awaiting any static promise exports, and resolving parent metadata and awaiting any generated metadata
    const dynamicMetadataResolvers = {
        resolvers: [],
        resolvingIndex: 0
    };
    const buildState = {
        warnings: new Set()
    };
    for(let i = 0; i < metadataItems.length; i++){
        const staticFilesMetadata = metadataItems[i][1];
        const metadata = await getMetadataFromExport((metadataItem)=>metadataItem[0], dynamicMetadataResolvers, metadataItems, i, resolvedMetadata, metadataResults);
        mergeMetadata({
            target: resolvedMetadata,
            source: metadata,
            metadataContext,
            staticFilesMetadata,
            titleTemplates,
            buildState
        });
        // If the layout is the same layer with page, skip the leaf layout and leaf page
        // The leaf layout and page are the last two items
        if (i < metadataItems.length - 2) {
            var _resolvedMetadata_title, _resolvedMetadata_openGraph, _resolvedMetadata_twitter;
            titleTemplates = {
                title: ((_resolvedMetadata_title = resolvedMetadata.title) == null ? void 0 : _resolvedMetadata_title.template) || null,
                openGraph: ((_resolvedMetadata_openGraph = resolvedMetadata.openGraph) == null ? void 0 : _resolvedMetadata_openGraph.title.template) || null,
                twitter: ((_resolvedMetadata_twitter = resolvedMetadata.twitter) == null ? void 0 : _resolvedMetadata_twitter.title.template) || null
            };
        }
    }
    // Only log warnings if there are any, and only once after the metadata resolving process is finished
    if (buildState.warnings.size > 0) {
        for (const warning of buildState.warnings){
            log/* warn */.ZK(warning);
        }
    }
    return postProcessMetadata(resolvedMetadata, titleTemplates);
}
async function accumulateViewport(metadataItems) {
    const resolvedViewport = createDefaultViewport();
    const viewportResults = [];
    const dynamicMetadataResolvers = {
        resolvers: [],
        resolvingIndex: 0
    };
    for(let i = 0; i < metadataItems.length; i++){
        const viewport = await getMetadataFromExport((metadataItem)=>metadataItem[2], dynamicMetadataResolvers, metadataItems, i, resolvedViewport, viewportResults);
        mergeViewport({
            target: resolvedViewport,
            source: viewport
        });
    }
    return resolvedViewport;
}
async function resolveMetadata({ tree, parentParams, metadataItems, errorMetadataItem, getDynamicParamFromSegment, searchParams, errorConvention, metadataContext }) {
    const resolvedMetadataItems = await resolveMetadataItems({
        tree,
        parentParams,
        metadataItems,
        errorMetadataItem,
        getDynamicParamFromSegment,
        searchParams,
        errorConvention
    });
    let error;
    let metadata = createDefaultMetadata();
    let viewport = createDefaultViewport();
    try {
        viewport = await accumulateViewport(resolvedMetadataItems);
        metadata = await accumulateMetadata(resolvedMetadataItems, metadataContext);
    } catch (err) {
        error = err;
    }
    return [
        error,
        metadata,
        viewport
    ];
}

//# sourceMappingURL=resolve-metadata.js.map
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/not-found.js
var not_found = __webpack_require__(5254);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/metadata.js










// Use a promise to share the status of the metadata resolving,
// returning two components `MetadataTree` and `MetadataOutlet`
// `MetadataTree` is the one that will be rendered at first in the content sequence for metadata tags.
// `MetadataOutlet` is the one that will be rendered under error boundaries for metadata resolving errors.
// In this way we can let the metadata tags always render successfully,
// and the error will be caught by the error boundary and trigger fallbacks.
function createMetadataComponents({ tree, pathname, trailingSlash, query, getDynamicParamFromSegment, appUsingSizeAdjustment, errorType, createDynamicallyTrackedSearchParams }) {
    const metadataContext = {
        // Make sure the pathname without query string
        pathname: pathname.split("?")[0],
        trailingSlash
    };
    let resolve;
    // Only use promise.resolve here to avoid unhandled rejections
    const metadataErrorResolving = new Promise((res)=>{
        resolve = res;
    });
    async function MetadataTree() {
        const defaultMetadata = createDefaultMetadata();
        const defaultViewport = createDefaultViewport();
        let metadata = defaultMetadata;
        let viewport = defaultViewport;
        let error;
        const errorMetadataItem = [
            null,
            null,
            null
        ];
        const errorConvention = errorType === "redirect" ? undefined : errorType;
        const searchParams = createDynamicallyTrackedSearchParams(query);
        const [resolvedError, resolvedMetadata, resolvedViewport] = await resolveMetadata({
            tree,
            parentParams: {},
            metadataItems: [],
            errorMetadataItem,
            searchParams,
            getDynamicParamFromSegment,
            errorConvention,
            metadataContext
        });
        if (!resolvedError) {
            viewport = resolvedViewport;
            metadata = resolvedMetadata;
            resolve(undefined);
        } else {
            error = resolvedError;
            // If the error triggers in initial metadata resolving, re-resolve with proper error type.
            // They'll be saved for flight data, when hydrates, it will replaces the SSR'd metadata with this.
            // for not-found error: resolve not-found metadata
            if (!errorType && (0,not_found/* isNotFoundError */.X)(resolvedError)) {
                const [notFoundMetadataError, notFoundMetadata, notFoundViewport] = await resolveMetadata({
                    tree,
                    parentParams: {},
                    metadataItems: [],
                    errorMetadataItem,
                    searchParams,
                    getDynamicParamFromSegment,
                    errorConvention: "not-found",
                    metadataContext
                });
                viewport = notFoundViewport;
                metadata = notFoundMetadata;
                error = notFoundMetadataError || error;
            }
            resolve(error);
        }
        const elements = MetaFilter([
            ViewportMeta({
                viewport: viewport
            }),
            BasicMeta({
                metadata
            }),
            AlternatesMetadata({
                alternates: metadata.alternates
            }),
            ItunesMeta({
                itunes: metadata.itunes
            }),
            FormatDetectionMeta({
                formatDetection: metadata.formatDetection
            }),
            VerificationMeta({
                verification: metadata.verification
            }),
            AppleWebAppMeta({
                appleWebApp: metadata.appleWebApp
            }),
            OpenGraphMetadata({
                openGraph: metadata.openGraph
            }),
            TwitterMetadata({
                twitter: metadata.twitter
            }),
            AppLinksMeta({
                appLinks: metadata.appLinks
            }),
            IconsMetadata({
                icons: metadata.icons
            })
        ]);
        if (appUsingSizeAdjustment) elements.push(/*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
            name: "next-size-adjust"
        }));
        return /*#__PURE__*/ (0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
            children: elements.map((el, index)=>{
                return /*#__PURE__*/ react.cloneElement(el, {
                    key: index
                });
            })
        });
    }
    async function MetadataOutlet() {
        const error = await metadataErrorResolving;
        if (error) {
            throw error;
        }
        return null;
    }
    return [
        MetadataTree,
        MetadataOutlet
    ];
}

//# sourceMappingURL=metadata.js.map
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/async-storage/request-async-storage-wrapper.js + 1 modules
var request_async_storage_wrapper = __webpack_require__(4569);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/app-render/dynamic-rendering.js
var dynamic_rendering = __webpack_require__(8255);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/async-storage/static-generation-async-storage-wrapper.js

const StaticGenerationAsyncStorageWrapper = {
    wrap (storage, { urlPathname, renderOpts, requestEndedState }, callback) {
        /**
     * Rules of Static & Dynamic HTML:
     *
     *    1.) We must generate static HTML unless the caller explicitly opts
     *        in to dynamic HTML support.
     *
     *    2.) If dynamic HTML support is requested, we must honor that request
     *        or throw an error. It is the sole responsibility of the caller to
     *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.
     *
     *    3.) If the request is in draft mode, we must generate dynamic HTML.
     *
     *    4.) If the request is a server action, we must generate dynamic HTML.
     *
     * These rules help ensure that other existing features like request caching,
     * coalescing, and ISR continue working as intended.
     */ const isStaticGeneration = !renderOpts.supportsDynamicHTML && !renderOpts.isDraftMode && !renderOpts.isServerAction;
        const prerenderState = isStaticGeneration && renderOpts.experimental.ppr ? (0,dynamic_rendering/* createPrerenderState */.FI)(renderOpts.isDebugPPRSkeleton) : null;
        const store = {
            isStaticGeneration,
            urlPathname,
            pagePath: renderOpts.originalPathname,
            incrementalCache: // we fallback to a global incremental cache for edge-runtime locally
            // so that it can access the fs cache without mocks
            renderOpts.incrementalCache || globalThis.__incrementalCache,
            isRevalidate: renderOpts.isRevalidate,
            isPrerendering: renderOpts.nextExport,
            fetchCache: renderOpts.fetchCache,
            isOnDemandRevalidate: renderOpts.isOnDemandRevalidate,
            isDraftMode: renderOpts.isDraftMode,
            prerenderState,
            requestEndedState
        };
        // TODO: remove this when we resolve accessing the store outside the execution context
        renderOpts.store = store;
        return storage.run(store, callback, store);
    }
};

//# sourceMappingURL=static-generation-async-storage-wrapper.js.map
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/redirect.js
var redirect = __webpack_require__(3925);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/lib/constants.js
var lib_constants = __webpack_require__(4410);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/lib/patch-fetch.js
/* provided dependency */ var Buffer = __webpack_require__(6195)["Buffer"];





const isEdgeRuntime = (/* unused pure expression or super */ null && ("edge" === "edge"));
function isPatchedFetch(fetch) {
    return "__nextPatched" in fetch && fetch.__nextPatched === true;
}
function validateRevalidate(revalidateVal, pathname) {
    try {
        let normalizedRevalidate = undefined;
        if (revalidateVal === false) {
            normalizedRevalidate = revalidateVal;
        } else if (typeof revalidateVal === "number" && !isNaN(revalidateVal) && revalidateVal > -1) {
            normalizedRevalidate = revalidateVal;
        } else if (typeof revalidateVal !== "undefined") {
            throw new Error(`Invalid revalidate value "${revalidateVal}" on "${pathname}", must be a non-negative number or "false"`);
        }
        return normalizedRevalidate;
    } catch (err) {
        // handle client component error from attempting to check revalidate value
        if (err instanceof Error && err.message.includes("Invalid revalidate")) {
            throw err;
        }
        return undefined;
    }
}
function validateTags(tags, description) {
    const validTags = [];
    const invalidTags = [];
    for(let i = 0; i < tags.length; i++){
        const tag = tags[i];
        if (typeof tag !== "string") {
            invalidTags.push({
                tag,
                reason: "invalid type, must be a string"
            });
        } else if (tag.length > NEXT_CACHE_TAG_MAX_LENGTH) {
            invalidTags.push({
                tag,
                reason: `exceeded max length of ${NEXT_CACHE_TAG_MAX_LENGTH}`
            });
        } else {
            validTags.push(tag);
        }
        if (validTags.length > NEXT_CACHE_TAG_MAX_ITEMS) {
            console.warn(`Warning: exceeded max tag count for ${description}, dropped tags:`, tags.slice(i).join(", "));
            break;
        }
    }
    if (invalidTags.length > 0) {
        console.warn(`Warning: invalid tags passed to ${description}: `);
        for (const { tag, reason } of invalidTags){
            console.log(`tag: "${tag}" ${reason}`);
        }
    }
    return validTags;
}
const getDerivedTags = (pathname)=>{
    const derivedTags = [
        `/layout`
    ];
    // we automatically add the current path segments as tags
    // for revalidatePath handling
    if (pathname.startsWith("/")) {
        const pathnameParts = pathname.split("/");
        for(let i = 1; i < pathnameParts.length + 1; i++){
            let curPathname = pathnameParts.slice(0, i).join("/");
            if (curPathname) {
                // all derived tags other than the page are layout tags
                if (!curPathname.endsWith("/page") && !curPathname.endsWith("/route")) {
                    curPathname = `${curPathname}${!curPathname.endsWith("/") ? "/" : ""}layout`;
                }
                derivedTags.push(curPathname);
            }
        }
    }
    return derivedTags;
};
function addImplicitTags(staticGenerationStore) {
    const newTags = [];
    const { pagePath, urlPathname } = staticGenerationStore;
    if (!Array.isArray(staticGenerationStore.tags)) {
        staticGenerationStore.tags = [];
    }
    if (pagePath) {
        const derivedTags = getDerivedTags(pagePath);
        for (let tag of derivedTags){
            var _staticGenerationStore_tags;
            tag = `${lib_constants/* NEXT_CACHE_IMPLICIT_TAG_ID */.zt}${tag}`;
            if (!((_staticGenerationStore_tags = staticGenerationStore.tags) == null ? void 0 : _staticGenerationStore_tags.includes(tag))) {
                staticGenerationStore.tags.push(tag);
            }
            newTags.push(tag);
        }
    }
    if (urlPathname) {
        var _staticGenerationStore_tags1;
        const parsedPathname = new URL(urlPathname, "http://n").pathname;
        const tag = `${lib_constants/* NEXT_CACHE_IMPLICIT_TAG_ID */.zt}${parsedPathname}`;
        if (!((_staticGenerationStore_tags1 = staticGenerationStore.tags) == null ? void 0 : _staticGenerationStore_tags1.includes(tag))) {
            staticGenerationStore.tags.push(tag);
        }
        newTags.push(tag);
    }
    return newTags;
}
function trackFetchMetric(staticGenerationStore, ctx) {
    var _staticGenerationStore_requestEndedState;
    if (!staticGenerationStore || ((_staticGenerationStore_requestEndedState = staticGenerationStore.requestEndedState) == null ? void 0 : _staticGenerationStore_requestEndedState.ended) || "production" !== "development") {
        return;
    }
    staticGenerationStore.fetchMetrics ??= [];
    const dedupeFields = [
        "url",
        "status",
        "method"
    ];
    // don't add metric if one already exists for the fetch
    if (staticGenerationStore.fetchMetrics.some((metric)=>dedupeFields.every((field)=>metric[field] === ctx[field]))) {
        return;
    }
    staticGenerationStore.fetchMetrics.push({
        ...ctx,
        end: Date.now(),
        idx: staticGenerationStore.nextFetchId || 0
    });
    // only store top 10 metrics to avoid storing too many
    if (staticGenerationStore.fetchMetrics.length > 10) {
        // sort slowest first as these should be highlighted
        staticGenerationStore.fetchMetrics.sort((a, b)=>{
            const aDur = a.end - a.start;
            const bDur = b.end - b.start;
            if (aDur < bDur) {
                return 1;
            } else if (aDur > bDur) {
                return -1;
            }
            return 0;
        });
        // now grab top 10
        staticGenerationStore.fetchMetrics = staticGenerationStore.fetchMetrics.slice(0, 10);
    }
}
function createPatchedFetcher(originFetch, { serverHooks: { DynamicServerError }, staticGenerationAsyncStorage }) {
    // Create the patched fetch function. We don't set the type here, as it's
    // verified as the return value of this function.
    const patched = async (input, init)=>{
        var _init_method, _init_next;
        let url;
        try {
            url = new URL(input instanceof Request ? input.url : input);
            url.username = "";
            url.password = "";
        } catch  {
            // Error caused by malformed URL should be handled by native fetch
            url = undefined;
        }
        const fetchUrl = (url == null ? void 0 : url.href) ?? "";
        const fetchStart = Date.now();
        const method = (init == null ? void 0 : (_init_method = init.method) == null ? void 0 : _init_method.toUpperCase()) || "GET";
        // Do create a new span trace for internal fetches in the
        // non-verbose mode.
        const isInternal = (init == null ? void 0 : (_init_next = init.next) == null ? void 0 : _init_next.internal) === true;
        const hideSpan = process.env.NEXT_OTEL_FETCH_DISABLED === "1";
        return getTracer().trace(isInternal ? NextNodeServerSpan.internalFetch : AppRenderSpan.fetch, {
            hideSpan,
            kind: SpanKind.CLIENT,
            spanName: [
                "fetch",
                method,
                fetchUrl
            ].filter(Boolean).join(" "),
            attributes: {
                "http.url": fetchUrl,
                "http.method": method,
                "net.peer.name": url == null ? void 0 : url.hostname,
                "net.peer.port": (url == null ? void 0 : url.port) || undefined
            }
        }, async ()=>{
            var _getRequestMeta;
            // If this is an internal fetch, we should not do any special treatment.
            if (isInternal) return originFetch(input, init);
            const staticGenerationStore = staticGenerationAsyncStorage.getStore();
            // If the staticGenerationStore is not available, we can't do any
            // special treatment of fetch, therefore fallback to the original
            // fetch implementation.
            if (!staticGenerationStore || staticGenerationStore.isDraftMode) {
                return originFetch(input, init);
            }
            const isRequestInput = input && typeof input === "object" && typeof input.method === "string";
            const getRequestMeta = (field)=>{
                // If request input is present but init is not, retrieve from input first.
                const value = init == null ? void 0 : init[field];
                return value || (isRequestInput ? input[field] : null);
            };
            let revalidate = undefined;
            const getNextField = (field)=>{
                var _init_next, _init_next1, _input_next;
                return typeof (init == null ? void 0 : (_init_next = init.next) == null ? void 0 : _init_next[field]) !== "undefined" ? init == null ? void 0 : (_init_next1 = init.next) == null ? void 0 : _init_next1[field] : isRequestInput ? (_input_next = input.next) == null ? void 0 : _input_next[field] : undefined;
            };
            // RequestInit doesn't keep extra fields e.g. next so it's
            // only available if init is used separate
            let curRevalidate = getNextField("revalidate");
            const tags = validateTags(getNextField("tags") || [], `fetch ${input.toString()}`);
            if (Array.isArray(tags)) {
                if (!staticGenerationStore.tags) {
                    staticGenerationStore.tags = [];
                }
                for (const tag of tags){
                    if (!staticGenerationStore.tags.includes(tag)) {
                        staticGenerationStore.tags.push(tag);
                    }
                }
            }
            const implicitTags = addImplicitTags(staticGenerationStore);
            const fetchCacheMode = staticGenerationStore.fetchCache;
            const isUsingNoStore = !!staticGenerationStore.isUnstableNoStore;
            let _cache = getRequestMeta("cache");
            let cacheReason = "";
            if (typeof _cache === "string" && typeof curRevalidate !== "undefined") {
                // when providing fetch with a Request input, it'll automatically set a cache value of 'default'
                // we only want to warn if the user is explicitly setting a cache value
                if (!(isRequestInput && _cache === "default")) {
                    Log.warn(`fetch for ${fetchUrl} on ${staticGenerationStore.urlPathname} specified "cache: ${_cache}" and "revalidate: ${curRevalidate}", only one should be specified.`);
                }
                _cache = undefined;
            }
            if (_cache === "force-cache") {
                curRevalidate = false;
            } else if (_cache === "no-cache" || _cache === "no-store" || fetchCacheMode === "force-no-store" || fetchCacheMode === "only-no-store") {
                curRevalidate = 0;
            }
            if (_cache === "no-cache" || _cache === "no-store") {
                cacheReason = `cache: ${_cache}`;
            }
            revalidate = validateRevalidate(curRevalidate, staticGenerationStore.urlPathname);
            const _headers = getRequestMeta("headers");
            const initHeaders = typeof (_headers == null ? void 0 : _headers.get) === "function" ? _headers : new Headers(_headers || {});
            const hasUnCacheableHeader = initHeaders.get("authorization") || initHeaders.get("cookie");
            const isUnCacheableMethod = ![
                "get",
                "head"
            ].includes(((_getRequestMeta = getRequestMeta("method")) == null ? void 0 : _getRequestMeta.toLowerCase()) || "get");
            // if there are authorized headers or a POST method and
            // dynamic data usage was present above the tree we bail
            // e.g. if cookies() is used before an authed/POST fetch
            const autoNoCache = (hasUnCacheableHeader || isUnCacheableMethod) && staticGenerationStore.revalidate === 0;
            switch(fetchCacheMode){
                case "force-no-store":
                    {
                        cacheReason = "fetchCache = force-no-store";
                        break;
                    }
                case "only-no-store":
                    {
                        if (_cache === "force-cache" || typeof revalidate !== "undefined" && (revalidate === false || revalidate > 0)) {
                            throw new Error(`cache: 'force-cache' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-no-store'`);
                        }
                        cacheReason = "fetchCache = only-no-store";
                        break;
                    }
                case "only-cache":
                    {
                        if (_cache === "no-store") {
                            throw new Error(`cache: 'no-store' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-cache'`);
                        }
                        break;
                    }
                case "force-cache":
                    {
                        if (typeof curRevalidate === "undefined" || curRevalidate === 0) {
                            cacheReason = "fetchCache = force-cache";
                            revalidate = false;
                        }
                        break;
                    }
                default:
            }
            if (typeof revalidate === "undefined") {
                if (fetchCacheMode === "default-cache") {
                    revalidate = false;
                    cacheReason = "fetchCache = default-cache";
                } else if (autoNoCache) {
                    revalidate = 0;
                    cacheReason = "auto no cache";
                } else if (fetchCacheMode === "default-no-store") {
                    revalidate = 0;
                    cacheReason = "fetchCache = default-no-store";
                } else if (isUsingNoStore) {
                    revalidate = 0;
                    cacheReason = "noStore call";
                } else {
                    cacheReason = "auto cache";
                    revalidate = typeof staticGenerationStore.revalidate === "boolean" || typeof staticGenerationStore.revalidate === "undefined" ? false : staticGenerationStore.revalidate;
                }
            } else if (!cacheReason) {
                cacheReason = `revalidate: ${revalidate}`;
            }
            if (// when force static is configured we don't bail from
            // `revalidate: 0` values
            !(staticGenerationStore.forceStatic && revalidate === 0) && // we don't consider autoNoCache to switch to dynamic during
            // revalidate although if it occurs during build we do
            !autoNoCache && // If the revalidate value isn't currently set or the value is less
            // than the current revalidate value, we should update the revalidate
            // value.
            (typeof staticGenerationStore.revalidate === "undefined" || typeof revalidate === "number" && (staticGenerationStore.revalidate === false || typeof staticGenerationStore.revalidate === "number" && revalidate < staticGenerationStore.revalidate))) {
                // If we were setting the revalidate value to 0, we should try to
                // postpone instead first.
                if (revalidate === 0) {
                    trackDynamicFetch(staticGenerationStore, "revalidate: 0");
                }
                staticGenerationStore.revalidate = revalidate;
            }
            const isCacheableRevalidate = typeof revalidate === "number" && revalidate > 0 || revalidate === false;
            let cacheKey;
            if (staticGenerationStore.incrementalCache && isCacheableRevalidate) {
                try {
                    cacheKey = await staticGenerationStore.incrementalCache.fetchCacheKey(fetchUrl, isRequestInput ? input : init);
                } catch (err) {
                    console.error(`Failed to generate cache key for`, input);
                }
            }
            const fetchIdx = staticGenerationStore.nextFetchId ?? 1;
            staticGenerationStore.nextFetchId = fetchIdx + 1;
            const normalizedRevalidate = typeof revalidate !== "number" ? CACHE_ONE_YEAR : revalidate;
            const doOriginalFetch = async (isStale, cacheReasonOverride)=>{
                const requestInputFields = [
                    "cache",
                    "credentials",
                    "headers",
                    "integrity",
                    "keepalive",
                    "method",
                    "mode",
                    "redirect",
                    "referrer",
                    "referrerPolicy",
                    "window",
                    "duplex",
                    // don't pass through signal when revalidating
                    ...isStale ? [] : [
                        "signal"
                    ]
                ];
                if (isRequestInput) {
                    const reqInput = input;
                    const reqOptions = {
                        body: reqInput._ogBody || reqInput.body
                    };
                    for (const field of requestInputFields){
                        // @ts-expect-error custom fields
                        reqOptions[field] = reqInput[field];
                    }
                    input = new Request(reqInput.url, reqOptions);
                } else if (init) {
                    const { _ogBody, body, signal, ...otherInput } = init;
                    init = {
                        ...otherInput,
                        body: _ogBody || body,
                        signal: isStale ? undefined : signal
                    };
                }
                // add metadata to init without editing the original
                const clonedInit = {
                    ...init,
                    next: {
                        ...init == null ? void 0 : init.next,
                        fetchType: "origin",
                        fetchIdx
                    }
                };
                return originFetch(input, clonedInit).then(async (res)=>{
                    if (!isStale) {
                        trackFetchMetric(staticGenerationStore, {
                            start: fetchStart,
                            url: fetchUrl,
                            cacheReason: cacheReasonOverride || cacheReason,
                            cacheStatus: revalidate === 0 || cacheReasonOverride ? "skip" : "miss",
                            status: res.status,
                            method: clonedInit.method || "GET"
                        });
                    }
                    if (res.status === 200 && staticGenerationStore.incrementalCache && cacheKey && isCacheableRevalidate) {
                        const bodyBuffer = Buffer.from(await res.arrayBuffer());
                        try {
                            await staticGenerationStore.incrementalCache.set(cacheKey, {
                                kind: "FETCH",
                                data: {
                                    headers: Object.fromEntries(res.headers.entries()),
                                    body: bodyBuffer.toString("base64"),
                                    status: res.status,
                                    url: res.url
                                },
                                revalidate: normalizedRevalidate
                            }, {
                                fetchCache: true,
                                revalidate,
                                fetchUrl,
                                fetchIdx,
                                tags
                            });
                        } catch (err) {
                            console.warn(`Failed to set fetch cache`, input, err);
                        }
                        const response = new Response(bodyBuffer, {
                            headers: new Headers(res.headers),
                            status: res.status
                        });
                        Object.defineProperty(response, "url", {
                            value: res.url
                        });
                        return response;
                    }
                    return res;
                });
            };
            let handleUnlock = ()=>Promise.resolve();
            let cacheReasonOverride;
            let isForegroundRevalidate = false;
            if (cacheKey && staticGenerationStore.incrementalCache) {
                handleUnlock = await staticGenerationStore.incrementalCache.lock(cacheKey);
                const entry = staticGenerationStore.isOnDemandRevalidate ? null : await staticGenerationStore.incrementalCache.get(cacheKey, {
                    kindHint: "fetch",
                    revalidate,
                    fetchUrl,
                    fetchIdx,
                    tags,
                    softTags: implicitTags
                });
                if (entry) {
                    await handleUnlock();
                } else {
                    // in dev, incremental cache response will be null in case the browser adds `cache-control: no-cache` in the request headers
                    cacheReasonOverride = "cache-control: no-cache (hard refresh)";
                }
                if ((entry == null ? void 0 : entry.value) && entry.value.kind === "FETCH") {
                    // when stale and is revalidating we wait for fresh data
                    // so the revalidated entry has the updated data
                    if (staticGenerationStore.isRevalidate && entry.isStale) {
                        isForegroundRevalidate = true;
                    } else {
                        if (entry.isStale) {
                            staticGenerationStore.pendingRevalidates ??= {};
                            if (!staticGenerationStore.pendingRevalidates[cacheKey]) {
                                staticGenerationStore.pendingRevalidates[cacheKey] = doOriginalFetch(true).catch(console.error).finally(()=>{
                                    staticGenerationStore.pendingRevalidates ??= {};
                                    delete staticGenerationStore.pendingRevalidates[cacheKey || ""];
                                });
                            }
                        }
                        const resData = entry.value.data;
                        trackFetchMetric(staticGenerationStore, {
                            start: fetchStart,
                            url: fetchUrl,
                            cacheReason,
                            cacheStatus: "hit",
                            status: resData.status || 200,
                            method: (init == null ? void 0 : init.method) || "GET"
                        });
                        const response = new Response(Buffer.from(resData.body, "base64"), {
                            headers: resData.headers,
                            status: resData.status
                        });
                        Object.defineProperty(response, "url", {
                            value: entry.value.data.url
                        });
                        return response;
                    }
                }
            }
            if (staticGenerationStore.isStaticGeneration && init && typeof init === "object") {
                const { cache } = init;
                // Delete `cache` property as Cloudflare Workers will throw an error
                if (isEdgeRuntime) delete init.cache;
                if (!staticGenerationStore.forceStatic && cache === "no-store") {
                    const dynamicUsageReason = `no-store fetch ${input}${staticGenerationStore.urlPathname ? ` ${staticGenerationStore.urlPathname}` : ""}`;
                    // If enabled, we should bail out of static generation.
                    trackDynamicFetch(staticGenerationStore, dynamicUsageReason);
                    // PPR is not enabled, or React postpone is not available, we
                    // should set the revalidate to 0.
                    staticGenerationStore.revalidate = 0;
                    const err = new DynamicServerError(dynamicUsageReason);
                    staticGenerationStore.dynamicUsageErr = err;
                    staticGenerationStore.dynamicUsageDescription = dynamicUsageReason;
                    throw err;
                }
                const hasNextConfig = "next" in init;
                const { next = {} } = init;
                if (typeof next.revalidate === "number" && (typeof staticGenerationStore.revalidate === "undefined" || typeof staticGenerationStore.revalidate === "number" && next.revalidate < staticGenerationStore.revalidate)) {
                    if (!staticGenerationStore.forceDynamic && !staticGenerationStore.forceStatic && next.revalidate === 0) {
                        const dynamicUsageReason = `revalidate: 0 fetch ${input}${staticGenerationStore.urlPathname ? ` ${staticGenerationStore.urlPathname}` : ""}`;
                        // If enabled, we should bail out of static generation.
                        trackDynamicFetch(staticGenerationStore, dynamicUsageReason);
                        const err = new DynamicServerError(dynamicUsageReason);
                        staticGenerationStore.dynamicUsageErr = err;
                        staticGenerationStore.dynamicUsageDescription = dynamicUsageReason;
                        throw err;
                    }
                    if (!staticGenerationStore.forceStatic || next.revalidate !== 0) {
                        staticGenerationStore.revalidate = next.revalidate;
                    }
                }
                if (hasNextConfig) delete init.next;
            }
            // if we are revalidating the whole page via time or on-demand and
            // the fetch cache entry is stale we should still de-dupe the
            // origin hit if it's a cache-able entry
            if (cacheKey && isForegroundRevalidate) {
                staticGenerationStore.pendingRevalidates ??= {};
                const pendingRevalidate = staticGenerationStore.pendingRevalidates[cacheKey];
                if (pendingRevalidate) {
                    const res = await pendingRevalidate;
                    return res.clone();
                }
                return staticGenerationStore.pendingRevalidates[cacheKey] = doOriginalFetch(true, cacheReasonOverride).finally(async ()=>{
                    staticGenerationStore.pendingRevalidates ??= {};
                    delete staticGenerationStore.pendingRevalidates[cacheKey || ""];
                    await handleUnlock();
                });
            } else {
                return doOriginalFetch(false, cacheReasonOverride).finally(handleUnlock);
            }
        });
    };
    // Attach the necessary properties to the patched fetch function.
    patched.__nextPatched = true;
    patched.__nextGetStaticStore = ()=>staticGenerationAsyncStorage;
    patched._nextOriginalFetch = originFetch;
    return patched;
}
// we patch fetch to collect cache information used for
// determining if a page is static or not
function patchFetch(options) {
    // If we've already patched fetch, we should not patch it again.
    if (isPatchedFetch(globalThis.fetch)) return;
    // Grab the original fetch function. We'll attach this so we can use it in
    // the patched fetch function.
    const original = globalThis.fetch;
    // Set the global fetch to the patched fetch.
    globalThis.fetch = createPatchedFetcher(original, options);
}

//# sourceMappingURL=patch-fetch.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/flight-render-result.js


/**
 * Flight Response is always set to RSC_CONTENT_TYPE_HEADER to ensure it does not get interpreted as HTML.
 */ class FlightRenderResult extends render_result/* default */.Z {
    constructor(response){
        super(response, {
            contentType: app_router_headers/* RSC_CONTENT_TYPE_HEADER */.eY,
            metadata: {}
        });
    }
}

//# sourceMappingURL=flight-render-result.js.map
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/string-hash/index.js
var string_hash = __webpack_require__(1252);
var string_hash_default = /*#__PURE__*/__webpack_require__.n(string_hash);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/format-server-error.js
const invalidServerComponentReactHooks = [
    "useDeferredValue",
    "useEffect",
    "useImperativeHandle",
    "useInsertionEffect",
    "useLayoutEffect",
    "useReducer",
    "useRef",
    "useState",
    "useSyncExternalStore",
    "useTransition",
    "experimental_useOptimistic",
    "useOptimistic"
];
function setMessage(error, message) {
    error.message = message;
    if (error.stack) {
        const lines = error.stack.split("\n");
        lines[0] = message;
        error.stack = lines.join("\n");
    }
}
/**
 * Input:
 * Error: Something went wrong
    at funcName (/path/to/file.js:10:5)
    at anotherFunc (/path/to/file.js:15:10)
 
 * Output:
    at funcName (/path/to/file.js:10:5)
    at anotherFunc (/path/to/file.js:15:10) 
 */ function getStackWithoutErrorMessage(error) {
    const stack = error.stack;
    if (!stack) return "";
    return stack.replace(/^[^\n]*\n/, "");
}
function formatServerError(error) {
    if (typeof (error == null ? void 0 : error.message) !== "string") return;
    if (error.message.includes("Class extends value undefined is not a constructor or null")) {
        const addedMessage = "This might be caused by a React Class Component being rendered in a Server Component, React Class Components only works in Client Components. Read more: https://nextjs.org/docs/messages/class-component-in-server-component";
        // If this error instance already has the message, don't add it again
        if (error.message.includes(addedMessage)) return;
        setMessage(error, `${error.message}

${addedMessage}`);
        return;
    }
    if (error.message.includes("createContext is not a function")) {
        setMessage(error, 'createContext only works in Client Components. Add the "use client" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/context-in-server-component');
        return;
    }
    for (const clientHook of invalidServerComponentReactHooks){
        const regex = new RegExp(`\\b${clientHook}\\b.*is not a function`);
        if (regex.test(error.message)) {
            setMessage(error, `${clientHook} only works in Client Components. Add the "use client" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/react-client-hook-in-server-component`);
            return;
        }
    }
} //# sourceMappingURL=format-server-error.js.map

// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/pipe-readable.js
var pipe_readable = __webpack_require__(7515);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/hooks-server-context.js
var hooks_server_context = __webpack_require__(2726);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/lazy-dynamic/bailout-to-csr.js
var bailout_to_csr = __webpack_require__(1192);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/export/helpers/is-navigation-signal-error.js


/**
 * Returns true if the error is a navigation signal error. These errors are
 * thrown by user code to perform navigation operations and interrupt the React
 * render.
 */ const isNavigationSignalError = (err)=>(0,not_found/* isNotFoundError */.X)(err) || (0,redirect/* isRedirectError */.eo)(err);

//# sourceMappingURL=is-navigation-signal-error.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/export/helpers/is-dynamic-usage-error.js



const isDynamicUsageError = (err)=>(0,hooks_server_context/* isDynamicServerError */.j)(err) || (0,bailout_to_csr/* isBailoutToCSRError */.D)(err) || isNavigationSignalError(err);

//# sourceMappingURL=is-dynamic-usage-error.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/create-error-handler.js





const ErrorHandlerSource = {
    serverComponents: "serverComponents",
    flightData: "flightData",
    html: "html"
};
/**
 * Create error handler for renderers.
 * Tolerate dynamic server errors during prerendering so console
 * isn't spammed with unactionable errors
 */ function createErrorHandler({ /**
   * Used for debugging
   */ source, dev, isNextExport, errorLogger, digestErrorsMap, allCapturedErrors, silenceLogger }) {
    return (err, errorInfo)=>{
        var _err_message;
        // If the error already has a digest, respect the original digest,
        // so it won't get re-generated into another new error.
        if (!err.digest) {
            // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.
            err.digest = string_hash_default()(err.message + ((errorInfo == null ? void 0 : errorInfo.stack) || err.stack || "")).toString();
        }
        const digest = err.digest;
        if (allCapturedErrors) allCapturedErrors.push(err);
        // These errors are expected. We return the digest
        // so that they can be properly handled.
        if (isDynamicUsageError(err)) return err.digest;
        // If the response was closed, we don't need to log the error.
        if ((0,pipe_readable/* isAbortError */.D)(err)) return;
        if (!digestErrorsMap.has(digest)) {
            digestErrorsMap.set(digest, err);
        } else if (source === ErrorHandlerSource.html) {
            // For SSR errors, if we have the existing digest in errors map,
            // we should use the existing error object to avoid duplicate error logs.
            err = digestErrorsMap.get(digest);
        }
        // Format server errors in development to add more helpful error messages
        if (dev) {
            formatServerError(err);
        }
        // Used for debugging error source
        // console.error(source, err)
        // Don't log the suppressed error during export
        if (!(isNextExport && (err == null ? void 0 : (_err_message = err.message) == null ? void 0 : _err_message.includes("The specific message is omitted in production builds to avoid leaking sensitive details.")))) {
            // Record exception in an active span, if available.
            const span = (0,tracer/* getTracer */.Yz)().getActiveScopeSpan();
            if (span) {
                span.recordException(err);
                span.setStatus({
                    code: tracer/* SpanStatusCode */.Qn.ERROR,
                    message: err.message
                });
            }
            if (!silenceLogger) {
                if (errorLogger) {
                    errorLogger(err).catch(()=>{});
                } else {
                    // The error logger is currently not provided in the edge runtime.
                    // Use the exposed `__next_log_error__` instead.
                    // This will trace error traces to the original source code.
                    if (typeof __next_log_error__ === "function") {
                        __next_log_error__(err);
                    } else {
                        console.error(err);
                    }
                }
            }
        }
        return err.digest;
    };
}

//# sourceMappingURL=create-error-handler.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/get-short-dynamic-param-type.js
const dynamicParamTypes = {
    catchall: "c",
    "catchall-intercepted": "ci",
    "optional-catchall": "oc",
    dynamic: "d",
    "dynamic-intercepted": "di"
};
/**
 * Shorten the dynamic param in order to make it smaller when transmitted to the browser.
 */ function getShortDynamicParamType(type) {
    const short = dynamicParamTypes[type];
    if (!short) {
        throw new Error("Unknown dynamic param type");
    }
    return short;
}

//# sourceMappingURL=get-short-dynamic-param-type.js.map
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/app-render/get-segment-param.js
var get_segment_param = __webpack_require__(7126);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/htmlescape.js
// This utility is based on https://github.com/zertosh/htmlescape
// License: https://github.com/zertosh/htmlescape/blob/0527ca7156a524d256101bb310a9f970f63078ad/LICENSE
const ESCAPE_LOOKUP = {
    "&": "\\u0026",
    ">": "\\u003e",
    "<": "\\u003c",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
};
const ESCAPE_REGEX = /[&><\u2028\u2029]/g;
function htmlEscapeJsonString(str) {
    return str.replace(ESCAPE_REGEX, (match)=>ESCAPE_LOOKUP[match]);
}

//# sourceMappingURL=htmlescape.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/get-script-nonce-from-header.js

function getScriptNonceFromHeader(cspHeaderValue) {
    var _directive_split_slice_map_find;
    const directives = cspHeaderValue// Directives are split by ';'.
    .split(";").map((directive)=>directive.trim());
    // First try to find the directive for the 'script-src', otherwise try to
    // fallback to the 'default-src'.
    const directive = directives.find((dir)=>dir.startsWith("script-src")) || directives.find((dir)=>dir.startsWith("default-src"));
    // If no directive could be found, then we're done.
    if (!directive) {
        return;
    }
    // Extract the nonce from the directive
    const nonce = (_directive_split_slice_map_find = directive.split(" ")// Remove the 'strict-src'/'default-src' string, this can't be the nonce.
    .slice(1).map((source)=>source.trim())// Find the first source with the 'nonce-' prefix.
    .find((source)=>source.startsWith("'nonce-") && source.length > 8 && source.endsWith("'"))) == null ? void 0 : _directive_split_slice_map_find.slice(7, -1);
    // If we could't find the nonce, then we're done.
    if (!nonce) {
        return;
    }
    // Don't accept the nonce value if it contains HTML escape characters.
    // Technically, the spec requires a base64'd value, but this is just an
    // extra layer.
    if (ESCAPE_REGEX.test(nonce)) {
        throw new Error("Nonce value from Content-Security-Policy contained HTML escape characters.\nLearn more: https://nextjs.org/docs/messages/nonce-contained-invalid-characters");
    }
    return nonce;
}

//# sourceMappingURL=get-script-nonce-from-header.js.map
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/superstruct/index.cjs
var superstruct = __webpack_require__(6466);
var superstruct_default = /*#__PURE__*/__webpack_require__.n(superstruct);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/types.js

const dynamicParamTypesSchema = superstruct_default().enums([
    "c",
    "ci",
    "oc",
    "d",
    "di"
]);
const segmentSchema = superstruct_default().union([
    superstruct_default().string(),
    superstruct_default().tuple([
        superstruct_default().string(),
        superstruct_default().string(),
        dynamicParamTypesSchema
    ])
]);
// unfortunately the tuple is not understood well by Describe so we have to
// use any here. This does not have any impact on the runtime type since the validation
// does work correctly.
const flightRouterStateSchema = superstruct_default().tuple([
    segmentSchema,
    superstruct_default().record(superstruct_default().string(), superstruct_default().lazy(()=>flightRouterStateSchema)),
    superstruct_default().optional(superstruct_default().nullable(superstruct_default().string())),
    superstruct_default().optional(superstruct_default().nullable(superstruct_default().union([
        superstruct_default().literal("refetch"),
        superstruct_default().literal("refresh")
    ]))),
    superstruct_default().optional(superstruct_default().boolean())
]);

//# sourceMappingURL=types.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/parse-and-validate-flight-router-state.js


function parseAndValidateFlightRouterState(stateHeader) {
    if (typeof stateHeader === "undefined") {
        return undefined;
    }
    if (Array.isArray(stateHeader)) {
        throw new Error("Multiple router state headers were sent. This is not allowed.");
    }
    // We limit the size of the router state header to ~40kb. This is to prevent
    // a malicious user from sending a very large header and slowing down the
    // resolving of the router state.
    // This is around 2,000 nested or parallel route segment states:
    // '{"children":["",{}]}'.length === 20.
    if (stateHeader.length > 20 * 2000) {
        throw new Error("The router state header was too large.");
    }
    try {
        const state = JSON.parse(decodeURIComponent(stateHeader));
        (0,superstruct.assert)(state, flightRouterStateSchema);
        return state;
    } catch  {
        throw new Error("The router state header was sent but could not be parsed.");
    }
}

//# sourceMappingURL=parse-and-validate-flight-router-state.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/validate-url.js
const DUMMY_ORIGIN = "http://n";
const INVALID_URL_MESSAGE = "Invalid request URL";
function validateURL(url) {
    if (!url) {
        throw new Error(INVALID_URL_MESSAGE);
    }
    try {
        const parsed = new URL(url, DUMMY_ORIGIN);
        // Avoid origin change by extra slashes in pathname
        if (parsed.origin !== DUMMY_ORIGIN) {
            throw new Error(INVALID_URL_MESSAGE);
        }
        return url;
    } catch  {
        throw new Error(INVALID_URL_MESSAGE);
    }
}

//# sourceMappingURL=validate-url.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/create-flight-router-state-from-loader-tree.js

function addSearchParamsIfPageSegment(segment, searchParams) {
    const isPageSegment = segment === lib_segment/* PAGE_SEGMENT_KEY */.GC;
    if (isPageSegment) {
        const stringifiedQuery = JSON.stringify(searchParams);
        return stringifiedQuery !== "{}" ? segment + "?" + stringifiedQuery : segment;
    }
    return segment;
}
function createFlightRouterStateFromLoaderTree([segment, parallelRoutes, { layout }], getDynamicParamFromSegment, searchParams, rootLayoutIncluded = false) {
    const dynamicParam = getDynamicParamFromSegment(segment);
    const treeSegment = dynamicParam ? dynamicParam.treeSegment : segment;
    const segmentTree = [
        addSearchParamsIfPageSegment(treeSegment, searchParams),
        {}
    ];
    if (!rootLayoutIncluded && typeof layout !== "undefined") {
        rootLayoutIncluded = true;
        segmentTree[4] = true;
    }
    segmentTree[1] = Object.keys(parallelRoutes).reduce((existingValue, currentValue)=>{
        existingValue[currentValue] = createFlightRouterStateFromLoaderTree(parallelRoutes[currentValue], getDynamicParamFromSegment, searchParams, rootLayoutIncluded);
        return existingValue;
    }, {});
    return segmentTree;
}

//# sourceMappingURL=create-flight-router-state-from-loader-tree.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/lib/server-ipc/utils.js
const ipcForbiddenHeaders = [
    "accept-encoding",
    "keepalive",
    "keep-alive",
    "content-encoding",
    "transfer-encoding",
    // https://github.com/nodejs/undici/issues/1470
    "connection",
    // marked as unsupported by undici: https://github.com/nodejs/undici/blob/c83b084879fa0bb8e0469d31ec61428ac68160d5/lib/core/request.js#L354
    "expect"
];
const actionsForbiddenHeaders = [
    ...ipcForbiddenHeaders,
    "content-length",
    "set-cookie"
];
const filterReqHeaders = (headers, forbiddenHeaders)=>{
    // Some browsers are not matching spec and sending Content-Length: 0. This causes issues in undici
    // https://github.com/nodejs/undici/issues/2046
    if (headers["content-length"] && headers["content-length"] === "0") {
        delete headers["content-length"];
    }
    for (const [key, value] of Object.entries(headers)){
        if (forbiddenHeaders.includes(key) || !(Array.isArray(value) || typeof value === "string")) {
            delete headers[key];
        }
    }
    return headers;
};

//# sourceMappingURL=utils.js.map
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/adapters/request-cookies.js
var request_cookies = __webpack_require__(4488);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/lib/server-action-request-meta.js
var server_action_request_meta = __webpack_require__(5627);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/csrf-protection.js
// micromatch is only available at node runtime, so it cannot be used here since the code path that calls this function
// can be run from edge. This is a simple implementation that safely achieves the required functionality.
// the goal is to match the functionality for remotePatterns as defined here -
// https://nextjs.org/docs/app/api-reference/components/image#remotepatterns
// TODO - retrofit micromatch to work in edge and use that instead
function matchWildcardDomain(domain, pattern) {
    const domainParts = domain.split(".");
    const patternParts = pattern.split(".");
    if (patternParts.length < 1) {
        // pattern is empty and therefore invalid to match against
        return false;
    }
    if (domainParts.length < patternParts.length) {
        // domain has too few segments and thus cannot match
        return false;
    }
    let depth = 0;
    while(patternParts.length && depth++ < 2){
        const patternPart = patternParts.pop();
        const domainPart = domainParts.pop();
        switch(patternPart){
            case "":
            case "*":
            case "**":
                {
                    // invalid pattern. pattern segments must be non empty
                    // Additionally wildcards are only supported below the domain level
                    return false;
                }
            default:
                {
                    if (domainPart !== patternPart) {
                        return false;
                    }
                }
        }
    }
    while(patternParts.length){
        const patternPart = patternParts.pop();
        const domainPart = domainParts.pop();
        switch(patternPart){
            case "":
                {
                    // invalid pattern. pattern segments must be non empty
                    return false;
                }
            case "*":
                {
                    // wildcard matches anything so we continue if the domain part is non-empty
                    if (domainPart) {
                        continue;
                    } else {
                        return false;
                    }
                }
            case "**":
                {
                    // if this is not the last item in the pattern the pattern is invalid
                    if (patternParts.length > 0) {
                        return false;
                    }
                    // recursive wildcard matches anything so we terminate here if the domain part is non empty
                    return domainPart !== undefined;
                }
            default:
                {
                    if (domainPart !== patternPart) {
                        return false;
                    }
                }
        }
    }
    // We exhausted the pattern. If we also exhausted the domain we have a match
    return domainParts.length === 0;
}
const isCsrfOriginAllowed = (originDomain, allowedOrigins = [])=>{
    return allowedOrigins.some((allowedOrigin)=>allowedOrigin && (allowedOrigin === originDomain || matchWildcardDomain(originDomain, allowedOrigin)));
};

//# sourceMappingURL=csrf-protection.js.map
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/cookies.js
var cookies = __webpack_require__(9474);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/adapters/headers.js
var headers = __webpack_require__(3581);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/utils.js
var utils = __webpack_require__(3541);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/app-render/action-utils.js
var action_utils = __webpack_require__(12);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/action-handler.js















function formDataFromSearchQueryString(query) {
    const searchParams = new URLSearchParams(query);
    const formData = new FormData();
    for (const [key, value] of searchParams){
        formData.append(key, value);
    }
    return formData;
}
function nodeHeadersToRecord(headers) {
    const record = {};
    for (const [key, value] of Object.entries(headers)){
        if (value !== undefined) {
            record[key] = Array.isArray(value) ? value.join(", ") : `${value}`;
        }
    }
    return record;
}
function getForwardedHeaders(req, res) {
    // Get request headers and cookies
    const requestHeaders = req.headers;
    const requestCookies = new cookies/* RequestCookies */.q(headers/* HeadersAdapter */.h.from(requestHeaders));
    // Get response headers and cookies
    const responseHeaders = res.getHeaders();
    const responseCookies = new cookies/* ResponseCookies */.n((0,utils/* fromNodeOutgoingHttpHeaders */.EK)(responseHeaders));
    // Merge request and response headers
    const mergedHeaders = filterReqHeaders({
        ...nodeHeadersToRecord(requestHeaders),
        ...nodeHeadersToRecord(responseHeaders)
    }, actionsForbiddenHeaders);
    // Merge cookies into requestCookies, so responseCookies always take precedence
    // and overwrite/delete those from requestCookies.
    responseCookies.getAll().forEach((cookie)=>{
        if (typeof cookie.value === "undefined") {
            requestCookies.delete(cookie.name);
        } else {
            requestCookies.set(cookie);
        }
    });
    // Update the 'cookie' header with the merged cookies
    mergedHeaders["cookie"] = requestCookies.toString();
    // Remove headers that should not be forwarded
    delete mergedHeaders["transfer-encoding"];
    return new Headers(mergedHeaders);
}
async function addRevalidationHeader(res, { staticGenerationStore, requestStore }) {
    var _staticGenerationStore_revalidatedTags;
    await Promise.all(Object.values(staticGenerationStore.pendingRevalidates || []));
    // If a tag was revalidated, the client router needs to invalidate all the
    // client router cache as they may be stale. And if a path was revalidated, the
    // client needs to invalidate all subtrees below that path.
    // To keep the header size small, we use a tuple of
    // [[revalidatedPaths], isTagRevalidated ? 1 : 0, isCookieRevalidated ? 1 : 0]
    // instead of a JSON object.
    // TODO-APP: Currently the prefetch cache doesn't have subtree information,
    // so we need to invalidate the entire cache if a path was revalidated.
    // TODO-APP: Currently paths are treated as tags, so the second element of the tuple
    // is always empty.
    const isTagRevalidated = ((_staticGenerationStore_revalidatedTags = staticGenerationStore.revalidatedTags) == null ? void 0 : _staticGenerationStore_revalidatedTags.length) ? 1 : 0;
    const isCookieRevalidated = (0,request_cookies/* getModifiedCookieValues */.fB)(requestStore.mutableCookies).length ? 1 : 0;
    res.setHeader("x-action-revalidated", JSON.stringify([
        [],
        isTagRevalidated,
        isCookieRevalidated
    ]));
}
/**
 * Forwards a server action request to a separate worker. Used when the requested action is not available in the current worker.
 */ async function createForwardedActionResponse(req, res, host, workerPathname, basePath, staticGenerationStore) {
    var _staticGenerationStore_incrementalCache;
    if (!host) {
        throw new Error("Invariant: Missing `host` header from a forwarded Server Actions request.");
    }
    const forwardedHeaders = getForwardedHeaders(req, res);
    // indicate that this action request was forwarded from another worker
    // we use this to skip rendering the flight tree so that we don't update the UI
    // with the response from the forwarded worker
    forwardedHeaders.set("x-action-forwarded", "1");
    const proto = ((_staticGenerationStore_incrementalCache = staticGenerationStore.incrementalCache) == null ? void 0 : _staticGenerationStore_incrementalCache.requestProtocol) || "https";
    // For standalone or the serverful mode, use the internal origin directly
    // other than the host headers from the request.
    const origin = process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${host.value}`;
    const fetchUrl = new URL(`${origin}${basePath}${workerPathname}`);
    try {
        let readableStream;
        if (true) {
            const webRequest = req;
            if (!webRequest.body) {
                throw new Error("invariant: Missing request body.");
            }
            readableStream = webRequest.body;
        } else {}
        // Forward the request to the new worker
        const response = await fetch(fetchUrl, {
            method: "POST",
            body: readableStream,
            duplex: "half",
            headers: forwardedHeaders,
            next: {
                // @ts-ignore
                internal: 1
            }
        });
        if (response.headers.get("content-type") === app_router_headers/* RSC_CONTENT_TYPE_HEADER */.eY) {
            // copy the headers from the redirect response to the response we're sending
            for (const [key, value] of response.headers){
                if (!actionsForbiddenHeaders.includes(key)) {
                    res.setHeader(key, value);
                }
            }
            return new FlightRenderResult(response.body);
        } else {
            var // Since we aren't consuming the response body, we cancel it to avoid memory leaks
            _response_body;
            (_response_body = response.body) == null ? void 0 : _response_body.cancel();
        }
    } catch (err) {
        // we couldn't stream the forwarded response, so we'll just do a normal redirect
        console.error(`failed to forward action response`, err);
    }
}
async function createRedirectRenderResult(req, res, originalHost, redirectUrl, basePath, staticGenerationStore) {
    res.setHeader("x-action-redirect", redirectUrl);
    // If we're redirecting to another route of this Next.js application, we'll
    // try to stream the response from the other worker path. When that works,
    // we can save an extra roundtrip and avoid a full page reload.
    // When the redirect URL starts with a `/`, or to the same host as application,
    // we treat it as an app-relative redirect.
    const parsedRedirectUrl = new URL(redirectUrl, "http://n");
    const isAppRelativeRedirect = redirectUrl.startsWith("/") || originalHost && originalHost.value === parsedRedirectUrl.host;
    if (isAppRelativeRedirect) {
        var _staticGenerationStore_incrementalCache;
        if (!originalHost) {
            throw new Error("Invariant: Missing `host` header from a forwarded Server Actions request.");
        }
        const forwardedHeaders = getForwardedHeaders(req, res);
        forwardedHeaders.set(app_router_headers/* RSC_HEADER */.A, "1");
        const proto = ((_staticGenerationStore_incrementalCache = staticGenerationStore.incrementalCache) == null ? void 0 : _staticGenerationStore_incrementalCache.requestProtocol) || "https";
        // For standalone or the serverful mode, use the internal origin directly
        // other than the host headers from the request.
        const origin = process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${originalHost.value}`;
        const fetchUrl = new URL(`${origin}${basePath}${parsedRedirectUrl.pathname}${parsedRedirectUrl.search}`);
        if (staticGenerationStore.revalidatedTags) {
            var _staticGenerationStore_incrementalCache_prerenderManifest_preview, _staticGenerationStore_incrementalCache_prerenderManifest, _staticGenerationStore_incrementalCache1;
            forwardedHeaders.set(lib_constants/* NEXT_CACHE_REVALIDATED_TAGS_HEADER */.of, staticGenerationStore.revalidatedTags.join(","));
            forwardedHeaders.set(lib_constants/* NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER */.X_, ((_staticGenerationStore_incrementalCache1 = staticGenerationStore.incrementalCache) == null ? void 0 : (_staticGenerationStore_incrementalCache_prerenderManifest = _staticGenerationStore_incrementalCache1.prerenderManifest) == null ? void 0 : (_staticGenerationStore_incrementalCache_prerenderManifest_preview = _staticGenerationStore_incrementalCache_prerenderManifest.preview) == null ? void 0 : _staticGenerationStore_incrementalCache_prerenderManifest_preview.previewModeId) || "");
        }
        // Ensures that when the path was revalidated we don't return a partial response on redirects
        forwardedHeaders.delete("next-router-state-tree");
        try {
            const response = await fetch(fetchUrl, {
                method: "GET",
                headers: forwardedHeaders,
                next: {
                    // @ts-ignore
                    internal: 1
                }
            });
            if (response.headers.get("content-type") === app_router_headers/* RSC_CONTENT_TYPE_HEADER */.eY) {
                // copy the headers from the redirect response to the response we're sending
                for (const [key, value] of response.headers){
                    if (!actionsForbiddenHeaders.includes(key)) {
                        res.setHeader(key, value);
                    }
                }
                return new FlightRenderResult(response.body);
            } else {
                var // Since we aren't consuming the response body, we cancel it to avoid memory leaks
                _response_body;
                (_response_body = response.body) == null ? void 0 : _response_body.cancel();
            }
        } catch (err) {
            // we couldn't stream the redirect response, so we'll just do a normal redirect
            console.error(`failed to get redirect response`, err);
        }
    }
    return render_result/* default */.Z.fromStatic("{}");
}
var HostType;
/**
 * Ensures the value of the header can't create long logs.
 */ function limitUntrustedHeaderValueForLogs(value) {
    return value.length > 100 ? value.slice(0, 100) + "..." : value;
}
async function handleAction({ req, res, ComponentMod, serverModuleMap, generateFlight, staticGenerationStore, requestStore, serverActions, ctx }) {
    const contentType = req.headers["content-type"];
    const { serverActionsManifest, page } = ctx.renderOpts;
    const { actionId, isURLEncodedAction, isMultipartAction, isFetchAction, isServerAction } = (0,server_action_request_meta/* getServerActionRequestMetadata */.G)(req);
    // If it's not a Server Action, skip handling.
    if (!isServerAction) {
        return;
    }
    if (staticGenerationStore.isStaticGeneration) {
        throw new Error("Invariant: server actions can't be handled during static rendering");
    }
    // When running actions the default is no-store, you can still `cache: 'force-cache'`
    staticGenerationStore.fetchCache = "default-no-store";
    const originDomain = typeof req.headers["origin"] === "string" ? new URL(req.headers["origin"]).host : undefined;
    const forwardedHostHeader = req.headers["x-forwarded-host"];
    const hostHeader = req.headers["host"];
    const host = forwardedHostHeader ? {
        type: "x-forwarded-host",
        value: forwardedHostHeader
    } : hostHeader ? {
        type: "host",
        value: hostHeader
    } : undefined;
    let warning = undefined;
    function warnBadServerActionRequest() {
        if (warning) {
            (0,log/* warn */.ZK)(warning);
        }
    }
    // This is to prevent CSRF attacks. If `x-forwarded-host` is set, we need to
    // ensure that the request is coming from the same host.
    if (!originDomain) {
        // This might be an old browser that doesn't send `host` header. We ignore
        // this case.
        warning = "Missing `origin` header from a forwarded Server Actions request.";
    } else if (!host || originDomain !== host.value) {
        // If the customer sets a list of allowed origins, we'll allow the request.
        // These are considered safe but might be different from forwarded host set
        // by the infra (i.e. reverse proxies).
        if (isCsrfOriginAllowed(originDomain, serverActions == null ? void 0 : serverActions.allowedOrigins)) {
        // Ignore it
        } else {
            if (host) {
                // This seems to be an CSRF attack. We should not proceed the action.
                console.error(`\`${host.type}\` header with value \`${limitUntrustedHeaderValueForLogs(host.value)}\` does not match \`origin\` header with value \`${limitUntrustedHeaderValueForLogs(originDomain)}\` from a forwarded Server Actions request. Aborting the action.`);
            } else {
                // This is an attack. We should not proceed the action.
                console.error(`\`x-forwarded-host\` or \`host\` headers are not provided. One of these is needed to compare the \`origin\` header from a forwarded Server Actions request. Aborting the action.`);
            }
            const error = new Error("Invalid Server Actions request.");
            if (isFetchAction) {
                res.statusCode = 500;
                await Promise.all(Object.values(staticGenerationStore.pendingRevalidates || []));
                const promise = Promise.reject(error);
                try {
                    // we need to await the promise to trigger the rejection early
                    // so that it's already handled by the time we call
                    // the RSC runtime. Otherwise, it will throw an unhandled
                    // promise rejection error in the renderer.
                    await promise;
                } catch  {
                // swallow error, it's gonna be handled on the client
                }
                return {
                    type: "done",
                    result: await generateFlight(ctx, {
                        actionResult: promise,
                        // if the page was not revalidated, we can skip the rendering the flight tree
                        skipFlight: !staticGenerationStore.pathWasRevalidated
                    })
                };
            }
            throw error;
        }
    }
    // ensure we avoid caching server actions unexpectedly
    res.setHeader("Cache-Control", "no-cache, no-store, max-age=0, must-revalidate");
    let bound = [];
    const { actionAsyncStorage } = ComponentMod;
    let actionResult;
    let formState;
    let actionModId;
    const actionWasForwarded = Boolean(req.headers["x-action-forwarded"]);
    if (actionId) {
        const forwardedWorker = (0,action_utils/* selectWorkerForForwarding */.k)(actionId, page, serverActionsManifest);
        // If forwardedWorker is truthy, it means there isn't a worker for the action
        // in the current handler, so we forward the request to a worker that has the action.
        if (forwardedWorker) {
            return {
                type: "done",
                result: await createForwardedActionResponse(req, res, host, forwardedWorker, ctx.renderOpts.basePath, staticGenerationStore)
            };
        }
    }
    try {
        await actionAsyncStorage.run({
            isAction: true
        }, async ()=>{
            if (true) {
                // Use react-server-dom-webpack/server.edge
                const { decodeReply, decodeAction, decodeFormState } = ComponentMod;
                const webRequest = req;
                if (!webRequest.body) {
                    throw new Error("invariant: Missing request body.");
                }
                if (isMultipartAction) {
                    // TODO-APP: Add streaming support
                    const formData = await webRequest.request.formData();
                    if (isFetchAction) {
                        bound = await decodeReply(formData, serverModuleMap);
                    } else {
                        const action = await decodeAction(formData, serverModuleMap);
                        if (typeof action === "function") {
                            // Only warn if it's a server action, otherwise skip for other post requests
                            warnBadServerActionRequest();
                            const actionReturnedState = await action();
                            formState = decodeFormState(actionReturnedState, formData);
                        }
                        // Skip the fetch path
                        return;
                    }
                } else {
                    try {
                        actionModId = getActionModIdOrError(actionId, serverModuleMap);
                    } catch (err) {
                        if (actionId !== null) {
                            console.error(err);
                        }
                        return {
                            type: "not-found"
                        };
                    }
                    let actionData = "";
                    const reader = webRequest.body.getReader();
                    while(true){
                        const { done, value } = await reader.read();
                        if (done) {
                            break;
                        }
                        actionData += new TextDecoder().decode(value);
                    }
                    if (isURLEncodedAction) {
                        const formData = formDataFromSearchQueryString(actionData);
                        bound = await decodeReply(formData, serverModuleMap);
                    } else {
                        bound = await decodeReply(actionData, serverModuleMap);
                    }
                }
            } else {}
            // actions.js
            // app/page.js
            //   action worker1
            //     appRender1
            // app/foo/page.js
            //   action worker2
            //     appRender
            // / -> fire action -> POST / -> appRender1 -> modId for the action file
            // /foo -> fire action -> POST /foo -> appRender2 -> modId for the action file
            try {
                actionModId = actionModId ?? getActionModIdOrError(actionId, serverModuleMap);
            } catch (err) {
                if (actionId !== null) {
                    console.error(err);
                }
                return {
                    type: "not-found"
                };
            }
            const actionHandler = (await ComponentMod.__next_app__.require(actionModId))[// `actionId` must exist if we got here, as otherwise we would have thrown an error above
            actionId];
            const returnVal = await actionHandler.apply(null, bound);
            // For form actions, we need to continue rendering the page.
            if (isFetchAction) {
                await addRevalidationHeader(res, {
                    staticGenerationStore,
                    requestStore
                });
                actionResult = await generateFlight(ctx, {
                    actionResult: Promise.resolve(returnVal),
                    // if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree
                    skipFlight: !staticGenerationStore.pathWasRevalidated || actionWasForwarded
                });
            }
        });
        return {
            type: "done",
            result: actionResult,
            formState
        };
    } catch (err) {
        if ((0,redirect/* isRedirectError */.eo)(err)) {
            const redirectUrl = (0,redirect/* getURLFromRedirectError */.M6)(err);
            const statusCode = (0,redirect/* getRedirectStatusCodeFromError */.j2)(err);
            await addRevalidationHeader(res, {
                staticGenerationStore,
                requestStore
            });
            // if it's a fetch action, we'll set the status code for logging/debugging purposes
            // but we won't set a Location header, as the redirect will be handled by the client router
            res.statusCode = statusCode;
            if (isFetchAction) {
                return {
                    type: "done",
                    result: await createRedirectRenderResult(req, res, host, redirectUrl, ctx.renderOpts.basePath, staticGenerationStore)
                };
            }
            if (err.mutableCookies) {
                const headers = new Headers();
                // If there were mutable cookies set, we need to set them on the
                // response.
                if ((0,request_cookies/* appendMutableCookies */._5)(headers, err.mutableCookies)) {
                    res.setHeader("set-cookie", Array.from(headers.values()));
                }
            }
            res.setHeader("Location", redirectUrl);
            return {
                type: "done",
                result: render_result/* default */.Z.fromStatic("")
            };
        } else if ((0,not_found/* isNotFoundError */.X)(err)) {
            res.statusCode = 404;
            await addRevalidationHeader(res, {
                staticGenerationStore,
                requestStore
            });
            if (isFetchAction) {
                const promise = Promise.reject(err);
                try {
                    // we need to await the promise to trigger the rejection early
                    // so that it's already handled by the time we call
                    // the RSC runtime. Otherwise, it will throw an unhandled
                    // promise rejection error in the renderer.
                    await promise;
                } catch  {
                // swallow error, it's gonna be handled on the client
                }
                return {
                    type: "done",
                    result: await generateFlight(ctx, {
                        skipFlight: false,
                        actionResult: promise,
                        asNotFound: true
                    })
                };
            }
            return {
                type: "not-found"
            };
        }
        if (isFetchAction) {
            res.statusCode = 500;
            await Promise.all(Object.values(staticGenerationStore.pendingRevalidates || []));
            const promise = Promise.reject(err);
            try {
                // we need to await the promise to trigger the rejection early
                // so that it's already handled by the time we call
                // the RSC runtime. Otherwise, it will throw an unhandled
                // promise rejection error in the renderer.
                await promise;
            } catch  {
            // swallow error, it's gonna be handled on the client
            }
            return {
                type: "done",
                result: await generateFlight(ctx, {
                    actionResult: promise,
                    // if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree
                    skipFlight: !staticGenerationStore.pathWasRevalidated || actionWasForwarded
                })
            };
        }
        throw err;
    }
}
/**
 * Attempts to find the module ID for the action from the module map. When this fails, it could be a deployment skew where
 * the action came from a different deployment. It could also simply be an invalid POST request that is not a server action.
 * In either case, we'll throw an error to be handled by the caller.
 */ function getActionModIdOrError(actionId, serverModuleMap) {
    try {
        var _serverModuleMap_actionId;
        // if we're missing the action ID header, we can't do any further processing
        if (!actionId) {
            throw new Error("Invariant: Missing 'next-action' header.");
        }
        const actionModId = serverModuleMap == null ? void 0 : (_serverModuleMap_actionId = serverModuleMap[actionId]) == null ? void 0 : _serverModuleMap_actionId.id;
        if (!actionModId) {
            throw new Error("Invariant: Couldn't find action module ID from module map.");
        }
        return actionModId;
    } catch (err) {
        throw new Error(`Failed to find Server Action "${actionId}". This request might be from an older or newer deployment. ${err instanceof Error ? `Original error: ${err.message}` : ""}`);
    }
}

//# sourceMappingURL=action-handler.js.map
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/server-inserted-html.shared-runtime.js
var server_inserted_html_shared_runtime = __webpack_require__(3234);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/server-inserted-html.js
// Provider for the `useServerInsertedHTML` API to register callbacks to insert
// elements into the HTML stream.



function createServerInsertedHTML() {
    const serverInsertedHTMLCallbacks = [];
    const addInsertedHtml = (handler)=>{
        serverInsertedHTMLCallbacks.push(handler);
    };
    return {
        ServerInsertedHTMLProvider ({ children }) {
            return /*#__PURE__*/ (0,jsx_runtime.jsx)(server_inserted_html_shared_runtime.ServerInsertedHTMLContext.Provider, {
                value: addInsertedHtml,
                children: children
            });
        },
        renderServerInsertedHTML () {
            return serverInsertedHTMLCallbacks.map((callback, index)=>/*#__PURE__*/ (0,jsx_runtime.jsx)(react.Fragment, {
                    children: callback()
                }, "__next_server_inserted__" + index));
        }
    };
}

//# sourceMappingURL=server-inserted-html.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/shared/lib/encode-uri-path.js
function encodeURIPath(file) {
    return file.split("/").map((p)=>encodeURIComponent(p)).join("/");
} //# sourceMappingURL=encode-uri-path.js.map

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react-dom/server-rendering-stub.js
var server_rendering_stub = __webpack_require__(8754);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/required-scripts.js


function getRequiredScripts(buildManifest, assetPrefix, crossOrigin, SRIManifest, qs, nonce) {
    let preinitScripts;
    let preinitScriptCommands = [];
    const bootstrapScript = {
        src: "",
        crossOrigin
    };
    const files = buildManifest.rootMainFiles.map(encodeURIPath);
    if (files.length === 0) {
        throw new Error("Invariant: missing bootstrap script. This is a bug in Next.js");
    }
    if (SRIManifest) {
        bootstrapScript.src = `${assetPrefix}/_next/` + files[0] + qs;
        bootstrapScript.integrity = SRIManifest[files[0]];
        for(let i = 1; i < files.length; i++){
            const src = `${assetPrefix}/_next/` + files[i] + qs;
            const integrity = SRIManifest[files[i]];
            preinitScriptCommands.push(src, integrity);
        }
        preinitScripts = ()=>{
            // preinitScriptCommands is a double indexed array of src/integrity pairs
            for(let i = 0; i < preinitScriptCommands.length; i += 2){
                server_rendering_stub.preinit(preinitScriptCommands[i], {
                    as: "script",
                    integrity: preinitScriptCommands[i + 1],
                    crossOrigin,
                    nonce
                });
            }
        };
    } else {
        bootstrapScript.src = `${assetPrefix}/_next/` + files[0] + qs;
        for(let i = 1; i < files.length; i++){
            const src = `${assetPrefix}/_next/` + files[i] + qs;
            preinitScriptCommands.push(src);
        }
        preinitScripts = ()=>{
            // preinitScriptCommands is a singled indexed array of src values
            for(let i = 0; i < preinitScriptCommands.length; i++){
                server_rendering_stub.preinit(preinitScriptCommands[i], {
                    as: "script",
                    nonce,
                    crossOrigin
                });
            }
        };
    }
    return [
        preinitScripts,
        bootstrapScript
    ];
}

//# sourceMappingURL=required-scripts.js.map
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/add-path-prefix.js
var add_path_prefix = __webpack_require__(7253);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/build/webpack/alias/react-dom-server-edge.js
var react_dom_server_edge = __webpack_require__(9183);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/redirect-status-code.js
var redirect_status_code = __webpack_require__(3207);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/make-get-server-inserted-html.js








function makeGetServerInsertedHTML({ polyfills, renderServerInsertedHTML, serverCapturedErrors, basePath }) {
    let flushedErrorMetaTagsUntilIndex = 0;
    let hasUnflushedPolyfills = polyfills.length !== 0;
    return async function getServerInsertedHTML() {
        // Loop through all the errors that have been captured but not yet
        // flushed.
        const errorMetaTags = [];
        while(flushedErrorMetaTagsUntilIndex < serverCapturedErrors.length){
            const error = serverCapturedErrors[flushedErrorMetaTagsUntilIndex];
            flushedErrorMetaTagsUntilIndex++;
            if ((0,not_found/* isNotFoundError */.X)(error)) {
                errorMetaTags.push(/*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
                    name: "robots",
                    content: "noindex"
                }, error.digest),  false ? /*#__PURE__*/ 0 : null);
            } else if ((0,redirect/* isRedirectError */.eo)(error)) {
                const redirectUrl = (0,add_path_prefix/* addPathPrefix */.V)((0,redirect/* getURLFromRedirectError */.M6)(error), basePath);
                const statusCode = (0,redirect/* getRedirectStatusCodeFromError */.j2)(error);
                const isPermanent = statusCode === redirect_status_code/* RedirectStatusCode */.X.PermanentRedirect ? true : false;
                if (redirectUrl) {
                    errorMetaTags.push(/*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
                        id: "__next-page-redirect",
                        httpEquiv: "refresh",
                        content: `${isPermanent ? 0 : 1};url=${redirectUrl}`
                    }, error.digest));
                }
            }
        }
        const serverInsertedHTML = renderServerInsertedHTML();
        // Skip React rendering if we know the content is empty.
        if (!hasUnflushedPolyfills && errorMetaTags.length === 0 && Array.isArray(serverInsertedHTML) && serverInsertedHTML.length === 0) {
            return "";
        }
        const stream = await (0,react_dom_server_edge.renderToReadableStream)(/*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                /* Insert the polyfills if they haven't been flushed yet. */ hasUnflushedPolyfills && polyfills.map((polyfill)=>{
                    return /*#__PURE__*/ (0,jsx_runtime.jsx)("script", {
                        ...polyfill
                    }, polyfill.src);
                }),
                serverInsertedHTML,
                errorMetaTags
            ]
        }), {
            // Larger chunk because this isn't sent over the network.
            // Let's set it to 1MB.
            progressiveChunkSize: 1024 * 1024
        });
        hasUnflushedPolyfills = false;
        // There's no need to wait for the stream to be ready
        // e.g. calling `await stream.allReady` because `streamToString` will
        // wait and decode the stream progressively with better parallelism.
        return (0,node_web_streams_helper/* streamToString */.PN)(stream);
    };
}

//# sourceMappingURL=make-get-server-inserted-html.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/get-css-inlined-link-tags.js
/**
 * Get external stylesheet link hrefs based on server CSS manifest.
 */ function getLinkAndScriptTags(clientReferenceManifest, filePath, injectedCSS, injectedScripts, collectNewImports) {
    var _clientReferenceManifest_entryJSFiles;
    const filePathWithoutExt = filePath.replace(/\.[^.]+$/, "");
    const cssChunks = new Set();
    const jsChunks = new Set();
    const entryCSSFiles = clientReferenceManifest.entryCSSFiles[filePathWithoutExt];
    const entryJSFiles = ((_clientReferenceManifest_entryJSFiles = clientReferenceManifest.entryJSFiles) == null ? void 0 : _clientReferenceManifest_entryJSFiles[filePathWithoutExt]) ?? [];
    if (entryCSSFiles) {
        for (const file of entryCSSFiles){
            if (!injectedCSS.has(file)) {
                if (collectNewImports) {
                    injectedCSS.add(file);
                }
                cssChunks.add(file);
            }
        }
    }
    if (entryJSFiles) {
        for (const file of entryJSFiles){
            if (!injectedScripts.has(file)) {
                if (collectNewImports) {
                    injectedScripts.add(file);
                }
                jsChunks.add(file);
            }
        }
    }
    return {
        styles: [
            ...cssChunks
        ],
        scripts: [
            ...jsChunks
        ]
    };
}

//# sourceMappingURL=get-css-inlined-link-tags.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/get-preloadable-fonts.js
/**
 * Get hrefs for fonts to preload
 * Returns null if there are no fonts at all.
 * Returns string[] if there are fonts to preload (font paths)
 * Returns empty string[] if there are fonts but none to preload and no other fonts have been preloaded
 * Returns null if there are fonts but none to preload and at least some were previously preloaded
 */ function getPreloadableFonts(nextFontManifest, filePath, injectedFontPreloadTags) {
    if (!nextFontManifest || !filePath) {
        return null;
    }
    const filepathWithoutExtension = filePath.replace(/\.[^.]+$/, "");
    const fontFiles = new Set();
    let foundFontUsage = false;
    const preloadedFontFiles = nextFontManifest.app[filepathWithoutExtension];
    if (preloadedFontFiles) {
        foundFontUsage = true;
        for (const fontFile of preloadedFontFiles){
            if (!injectedFontPreloadTags.has(fontFile)) {
                fontFiles.add(fontFile);
                injectedFontPreloadTags.add(fontFile);
            }
        }
    }
    if (fontFiles.size) {
        return [
            ...fontFiles
        ].sort();
    } else if (foundFontUsage && injectedFontPreloadTags.size === 0) {
        return [];
    } else {
        return null;
    }
}

//# sourceMappingURL=get-preloadable-fonts.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/parse-loader-tree.js

function parseLoaderTree(tree) {
    const [segment, parallelRoutes, components] = tree;
    const { layout } = components;
    let { page } = components;
    // a __DEFAULT__ segment means that this route didn't match any of the
    // segments in the route, so we should use the default page
    page = segment === lib_segment/* DEFAULT_SEGMENT_KEY */.av ? components.defaultPage : page;
    const layoutOrPagePath = (layout == null ? void 0 : layout[1]) || (page == null ? void 0 : page[1]);
    return {
        page,
        segment,
        components,
        layoutOrPagePath,
        parallelRoutes
    };
}

//# sourceMappingURL=parse-loader-tree.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/get-asset-query-string.js
const isDev = "production" === "development";
const isTurbopack = !!false;
function getAssetQueryString(ctx, addTimestamp) {
    let qs = "";
    // In development we add the request timestamp to allow react to
    // reload assets when a new RSC response is received.
    // Turbopack handles HMR of assets itself and react doesn't need to reload them
    // so this approach is not needed for Turbopack.
    if (isDev && !isTurbopack && addTimestamp) {
        qs += `?v=${ctx.requestTimestamp}`;
    }
    if (ctx.renderOpts.deploymentId) {
        qs += `${isDev ? "&" : "?"}dpl=${ctx.renderOpts.deploymentId}`;
    }
    return qs;
}

//# sourceMappingURL=get-asset-query-string.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/get-layer-assets.js






function getLayerAssets({ ctx, layoutOrPagePath, injectedCSS: injectedCSSWithCurrentLayout, injectedJS: injectedJSWithCurrentLayout, injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout }) {
    const { styles: styleTags, scripts: scriptTags } = layoutOrPagePath ? getLinkAndScriptTags(ctx.clientReferenceManifest, layoutOrPagePath, injectedCSSWithCurrentLayout, injectedJSWithCurrentLayout, true) : {
        styles: [],
        scripts: []
    };
    const preloadedFontFiles = layoutOrPagePath ? getPreloadableFonts(ctx.renderOpts.nextFontManifest, layoutOrPagePath, injectedFontPreloadTagsWithCurrentLayout) : null;
    if (preloadedFontFiles) {
        if (preloadedFontFiles.length) {
            for(let i = 0; i < preloadedFontFiles.length; i++){
                const fontFilename = preloadedFontFiles[i];
                const ext = /\.(woff|woff2|eot|ttf|otf)$/.exec(fontFilename)[1];
                const type = `font/${ext}`;
                const href = `${ctx.assetPrefix}/_next/${encodeURIPath(fontFilename)}`;
                ctx.componentMod.preloadFont(href, type, ctx.renderOpts.crossOrigin);
            }
        } else {
            try {
                let url = new URL(ctx.assetPrefix);
                ctx.componentMod.preconnect(url.origin, "anonymous");
            } catch (error) {
                // assetPrefix must not be a fully qualified domain name. We assume
                // we should preconnect to same origin instead
                ctx.componentMod.preconnect("/", "anonymous");
            }
        }
    }
    const styles = styleTags ? styleTags.map((href, index)=>{
        // In dev, Safari and Firefox will cache the resource during HMR:
        // - https://github.com/vercel/next.js/issues/5860
        // - https://bugs.webkit.org/show_bug.cgi?id=187726
        // Because of this, we add a `?v=` query to bypass the cache during
        // development. We need to also make sure that the number is always
        // increasing.
        const fullHref = `${ctx.assetPrefix}/_next/${encodeURIPath(href)}${getAssetQueryString(ctx, true)}`;
        // `Precedence` is an opt-in signal for React to handle resource
        // loading and deduplication, etc. It's also used as the key to sort
        // resources so they will be injected in the correct order.
        // During HMR, it's critical to use different `precedence` values
        // for different stylesheets, so their order will be kept.
        // https://github.com/facebook/react/pull/25060
        const precedence =  false ? 0 : "next";
        ctx.componentMod.preloadStyle(fullHref, ctx.renderOpts.crossOrigin);
        return /*#__PURE__*/ (0,jsx_runtime.jsx)("link", {
            rel: "stylesheet",
            href: fullHref,
            // @ts-ignore
            precedence: precedence,
            crossOrigin: ctx.renderOpts.crossOrigin
        }, index);
    }) : [];
    const scripts = scriptTags ? scriptTags.map((href, index)=>{
        const fullSrc = `${ctx.assetPrefix}/_next/${encodeURIPath(href)}${getAssetQueryString(ctx, true)}`;
        return /*#__PURE__*/ (0,jsx_runtime.jsx)("script", {
            src: fullSrc,
            async: true
        }, `script-${index}`);
    }) : [];
    return styles.length || scripts.length ? [
        ...styles,
        ...scripts
    ] : null;
}

//# sourceMappingURL=get-layer-assets.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/has-loading-component-in-tree.js
function hasLoadingComponentInTree(tree) {
    const [, parallelRoutes, { loading }] = tree;
    if (loading) {
        return true;
    }
    return Object.values(parallelRoutes).some((parallelRoute)=>hasLoadingComponentInTree(parallelRoute));
}

//# sourceMappingURL=has-loading-component-in-tree.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/interop-default.js
/**
 * Interop between "export default" and "module.exports".
 */ function interop_default_interopDefault(mod) {
    return mod.default || mod;
}

//# sourceMappingURL=interop-default.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/create-component-styles-and-scripts.js






async function createComponentStylesAndScripts({ filePath, getComponent, injectedCSS, injectedJS, ctx }) {
    const { styles: cssHrefs, scripts: jsHrefs } = getLinkAndScriptTags(ctx.clientReferenceManifest, filePath, injectedCSS, injectedJS);
    const styles = cssHrefs ? cssHrefs.map((href, index)=>{
        const fullHref = `${ctx.assetPrefix}/_next/${encodeURIPath(href)}${getAssetQueryString(ctx, true)}`;
        // `Precedence` is an opt-in signal for React to handle resource
        // loading and deduplication, etc. It's also used as the key to sort
        // resources so they will be injected in the correct order.
        // During HMR, it's critical to use different `precedence` values
        // for different stylesheets, so their order will be kept.
        // https://github.com/facebook/react/pull/25060
        const precedence =  false ? 0 : "next";
        return /*#__PURE__*/ (0,jsx_runtime.jsx)("link", {
            rel: "stylesheet",
            href: fullHref,
            // @ts-ignore
            precedence: precedence,
            crossOrigin: ctx.renderOpts.crossOrigin
        }, index);
    }) : null;
    const scripts = jsHrefs ? jsHrefs.map((href)=>/*#__PURE__*/ (0,jsx_runtime.jsx)("script", {
            src: `${ctx.assetPrefix}/_next/${encodeURIPath(href)}${getAssetQueryString(ctx, true)}`,
            async: true
        })) : null;
    const Comp = interop_default_interopDefault(await getComponent());
    return [
        Comp,
        styles,
        scripts
    ];
}

//# sourceMappingURL=create-component-styles-and-scripts.js.map
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/static-generation-bailout.js
var static_generation_bailout = __webpack_require__(7997);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/create-component-tree.js














/**
 * Use the provided loader tree to create the React Component tree.
 */ function createComponentTree(props) {
    return (0,tracer/* getTracer */.Yz)().trace(constants/* NextNodeServerSpan */.Xy.createComponentTree, {
        spanName: "build component tree"
    }, ()=>createComponentTreeInternal(props));
}
async function createComponentTreeInternal({ createSegmentPath, loaderTree: tree, parentParams, firstItem, rootLayoutIncluded, injectedCSS, injectedJS, injectedFontPreloadTags, asNotFound, metadataOutlet, ctx, missingSlots }) {
    const { renderOpts: { nextConfigOutput, experimental }, staticGenerationStore, componentMod: { NotFoundBoundary, LayoutRouter, RenderFromTemplateContext, ClientPageRoot, createUntrackedSearchParams, createDynamicallyTrackedSearchParams, serverHooks: { DynamicServerError }, Postpone }, pagePath, getDynamicParamFromSegment, isPrefetch, query } = ctx;
    const { page, layoutOrPagePath, segment, components, parallelRoutes } = parseLoaderTree(tree);
    const { layout, template, error, loading, "not-found": notFound } = components;
    const injectedCSSWithCurrentLayout = new Set(injectedCSS);
    const injectedJSWithCurrentLayout = new Set(injectedJS);
    const injectedFontPreloadTagsWithCurrentLayout = new Set(injectedFontPreloadTags);
    const layerAssets = getLayerAssets({
        ctx,
        layoutOrPagePath,
        injectedCSS: injectedCSSWithCurrentLayout,
        injectedJS: injectedJSWithCurrentLayout,
        injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout
    });
    const [Template, templateStyles, templateScripts] = template ? await createComponentStylesAndScripts({
        ctx,
        filePath: template[1],
        getComponent: template[0],
        injectedCSS: injectedCSSWithCurrentLayout,
        injectedJS: injectedJSWithCurrentLayout
    }) : [
        react.Fragment
    ];
    const [ErrorComponent, errorStyles, errorScripts] = error ? await createComponentStylesAndScripts({
        ctx,
        filePath: error[1],
        getComponent: error[0],
        injectedCSS: injectedCSSWithCurrentLayout,
        injectedJS: injectedJSWithCurrentLayout
    }) : [];
    const [Loading, loadingStyles, loadingScripts] = loading ? await createComponentStylesAndScripts({
        ctx,
        filePath: loading[1],
        getComponent: loading[0],
        injectedCSS: injectedCSSWithCurrentLayout,
        injectedJS: injectedJSWithCurrentLayout
    }) : [];
    const isLayout = typeof layout !== "undefined";
    const isPage = typeof page !== "undefined";
    const [layoutOrPageMod] = await (0,tracer/* getTracer */.Yz)().trace(constants/* NextNodeServerSpan */.Xy.getLayoutOrPageModule, {
        hideSpan: !(isLayout || isPage),
        spanName: "resolve segment modules",
        attributes: {
            "next.segment": segment
        }
    }, ()=>getLayoutOrPageModule(tree));
    /**
   * Checks if the current segment is a root layout.
   */ const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded;
    /**
   * Checks if the current segment or any level above it has a root layout.
   */ const rootLayoutIncludedAtThisLevelOrAbove = rootLayoutIncluded || rootLayoutAtThisLevel;
    const [NotFound, notFoundStyles] = notFound ? await createComponentStylesAndScripts({
        ctx,
        filePath: notFound[1],
        getComponent: notFound[0],
        injectedCSS: injectedCSSWithCurrentLayout,
        injectedJS: injectedJSWithCurrentLayout
    }) : [];
    let dynamic = layoutOrPageMod == null ? void 0 : layoutOrPageMod.dynamic;
    if (nextConfigOutput === "export") {
        if (!dynamic || dynamic === "auto") {
            dynamic = "error";
        } else if (dynamic === "force-dynamic") {
            // force-dynamic is always incompatible with 'export'. We must interrupt the build
            throw new static_generation_bailout/* StaticGenBailoutError */.G(`Page with \`dynamic = "force-dynamic"\` couldn't be exported. \`output: "export"\` requires all pages be renderable statically because there is not runtime server to dynamic render routes in this output format. Learn more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports`);
        }
    }
    if (typeof dynamic === "string") {
        // the nested most config wins so we only force-static
        // if it's configured above any parent that configured
        // otherwise
        if (dynamic === "error") {
            staticGenerationStore.dynamicShouldError = true;
        } else if (dynamic === "force-dynamic") {
            staticGenerationStore.forceDynamic = true;
            // TODO: (PPR) remove this bailout once PPR is the default
            if (staticGenerationStore.isStaticGeneration && !staticGenerationStore.prerenderState) {
                // If the postpone API isn't available, we can't postpone the render and
                // therefore we can't use the dynamic API.
                const err = new DynamicServerError(`Page with \`dynamic = "force-dynamic"\` won't be rendered statically.`);
                staticGenerationStore.dynamicUsageDescription = err.message;
                staticGenerationStore.dynamicUsageStack = err.stack;
                throw err;
            }
        } else {
            staticGenerationStore.dynamicShouldError = false;
            staticGenerationStore.forceStatic = dynamic === "force-static";
        }
    }
    if (typeof (layoutOrPageMod == null ? void 0 : layoutOrPageMod.fetchCache) === "string") {
        staticGenerationStore.fetchCache = layoutOrPageMod == null ? void 0 : layoutOrPageMod.fetchCache;
    }
    if (typeof (layoutOrPageMod == null ? void 0 : layoutOrPageMod.revalidate) !== "undefined") {
        validateRevalidate(layoutOrPageMod == null ? void 0 : layoutOrPageMod.revalidate, staticGenerationStore.urlPathname);
    }
    if (typeof (layoutOrPageMod == null ? void 0 : layoutOrPageMod.revalidate) === "number") {
        ctx.defaultRevalidate = layoutOrPageMod.revalidate;
        if (typeof staticGenerationStore.revalidate === "undefined" || typeof staticGenerationStore.revalidate === "number" && staticGenerationStore.revalidate > ctx.defaultRevalidate) {
            staticGenerationStore.revalidate = ctx.defaultRevalidate;
        }
        if (!staticGenerationStore.forceStatic && staticGenerationStore.isStaticGeneration && ctx.defaultRevalidate === 0 && // If the postpone API isn't available, we can't postpone the render and
        // therefore we can't use the dynamic API.
        !staticGenerationStore.prerenderState) {
            const dynamicUsageDescription = `revalidate: 0 configured ${segment}`;
            staticGenerationStore.dynamicUsageDescription = dynamicUsageDescription;
            throw new DynamicServerError(dynamicUsageDescription);
        }
    }
    // If there's a dynamic usage error attached to the store, throw it.
    if (staticGenerationStore.dynamicUsageErr) {
        throw staticGenerationStore.dynamicUsageErr;
    }
    const LayoutOrPage = layoutOrPageMod ? interop_default_interopDefault(layoutOrPageMod) : undefined;
    /**
   * The React Component to render.
   */ let Component = LayoutOrPage;
    const parallelKeys = Object.keys(parallelRoutes);
    const hasSlotKey = parallelKeys.length > 1;
    // TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`.
    // This ensures that a `NotFoundBoundary` is available for when that happens,
    // but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.
    // We should instead look into handling the fallback behavior differently in development mode so that it doesn't
    // rely on the `NotFound` behavior.
    if (hasSlotKey && rootLayoutAtThisLevel && LayoutOrPage) {
        Component = (componentProps)=>{
            const NotFoundComponent = NotFound;
            const RootLayoutComponent = LayoutOrPage;
            return /*#__PURE__*/ (0,jsx_runtime.jsx)(NotFoundBoundary, {
                notFound: NotFoundComponent ? /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
                    children: [
                        layerAssets,
                        /*#__PURE__*/ (0,jsx_runtime.jsxs)(RootLayoutComponent, {
                            params: componentProps.params,
                            children: [
                                notFoundStyles,
                                /*#__PURE__*/ (0,jsx_runtime.jsx)(NotFoundComponent, {})
                            ]
                        })
                    ]
                }) : undefined,
                children: /*#__PURE__*/ (0,jsx_runtime.jsx)(RootLayoutComponent, {
                    ...componentProps
                })
            });
        };
    }
    if (false) {}
    // Handle dynamic segment params.
    const segmentParam = getDynamicParamFromSegment(segment);
    /**
   * Create object holding the parent params and current params
   */ const currentParams = // Handle null case where dynamic param is optional
    segmentParam && segmentParam.value !== null ? {
        ...parentParams,
        [segmentParam.param]: segmentParam.value
    } : parentParams;
    // Resolve the segment param
    const actualSegment = segmentParam ? segmentParam.treeSegment : segment;
    //
    // TODO: Combine this `map` traversal with the loop below that turns the array
    // into an object.
    const parallelRouteMap = await Promise.all(Object.keys(parallelRoutes).map(async (parallelRouteKey)=>{
        const isChildrenRouteKey = parallelRouteKey === "children";
        const currentSegmentPath = firstItem ? [
            parallelRouteKey
        ] : [
            actualSegment,
            parallelRouteKey
        ];
        const parallelRoute = parallelRoutes[parallelRouteKey];
        const notFoundComponent = NotFound && isChildrenRouteKey ? /*#__PURE__*/ (0,jsx_runtime.jsx)(NotFound, {}) : undefined;
        // if we're prefetching and that there's a Loading component, we bail out
        // otherwise we keep rendering for the prefetch.
        // We also want to bail out if there's no Loading component in the tree.
        let currentStyles = undefined;
        let childCacheNodeSeedData = null;
        if (// Before PPR, the way instant navigations work in Next.js is we
        // prefetch everything up to the first route segment that defines a
        // loading.tsx boundary. (We do the same if there's no loading
        // boundary in the entire tree, because we don't want to prefetch too
        // much) The rest of the tree is defered until the actual navigation.
        // It does not take into account whether the data is dynamic â€” even if
        // the tree is completely static, it will still defer everything
        // inside the loading boundary.
        //
        // This behavior predates PPR and is only relevant if the
        // PPR flag is not enabled.
        isPrefetch && (Loading || !hasLoadingComponentInTree(parallelRoute)) && // The approach with PPR is different â€” loading.tsx behaves like a
        // regular Suspense boundary and has no special behavior.
        //
        // With PPR, we prefetch as deeply as possible, and only defer when
        // dynamic data is accessed. If so, we only defer the nearest parent
        // Suspense boundary of the dynamic data access, regardless of whether
        // the boundary is defined by loading.tsx or a normal <Suspense>
        // component in userspace.
        //
        // NOTE: In practice this usually means we'll end up prefetching more
        // than we were before PPR, which may or may not be considered a
        // performance regression by some apps. The plan is to address this
        // before General Availability of PPR by introducing granular
        // per-segment fetching, so we can reuse as much of the tree as
        // possible during both prefetches and dynamic navigations. But during
        // the beta period, we should be clear about this trade off in our
        // communications.
        !experimental.ppr) {
        // Don't prefetch this child. This will trigger a lazy fetch by the
        // client router.
        } else {
            // Create the child component
            if (false) { var _parsedTree_layoutOrPagePath; }
            const { seedData, styles: childComponentStyles } = await createComponentTreeInternal({
                createSegmentPath: (child)=>{
                    return createSegmentPath([
                        ...currentSegmentPath,
                        ...child
                    ]);
                },
                loaderTree: parallelRoute,
                parentParams: currentParams,
                rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,
                injectedCSS: injectedCSSWithCurrentLayout,
                injectedJS: injectedJSWithCurrentLayout,
                injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,
                asNotFound,
                metadataOutlet,
                ctx,
                missingSlots
            });
            currentStyles = childComponentStyles;
            childCacheNodeSeedData = seedData;
        }
        // This is turned back into an object below.
        return [
            parallelRouteKey,
            /*#__PURE__*/ (0,jsx_runtime.jsx)(LayoutRouter, {
                parallelRouterKey: parallelRouteKey,
                segmentPath: createSegmentPath(currentSegmentPath),
                // TODO-APP: Add test for loading returning `undefined`. This currently can't be tested as the `webdriver()` tab will wait for the full page to load before returning.
                error: ErrorComponent,
                errorStyles: errorStyles,
                errorScripts: errorScripts,
                template: /*#__PURE__*/ (0,jsx_runtime.jsx)(Template, {
                    children: /*#__PURE__*/ (0,jsx_runtime.jsx)(RenderFromTemplateContext, {})
                }),
                templateStyles: templateStyles,
                templateScripts: templateScripts,
                notFound: notFoundComponent,
                notFoundStyles: notFoundStyles,
                styles: currentStyles
            }),
            childCacheNodeSeedData
        ];
    }));
    // Convert the parallel route map into an object after all promises have been resolved.
    let parallelRouteProps = {};
    let parallelRouteCacheNodeSeedData = {};
    for (const parallelRoute of parallelRouteMap){
        const [parallelRouteKey, parallelRouteProp, flightData] = parallelRoute;
        parallelRouteProps[parallelRouteKey] = parallelRouteProp;
        parallelRouteCacheNodeSeedData[parallelRouteKey] = flightData;
    }
    const loadingData = Loading ? [
        /*#__PURE__*/ (0,jsx_runtime.jsx)(Loading, {}),
        loadingStyles,
        loadingScripts
    ] : null;
    // When the segment does not have a layout or page we still have to add the layout router to ensure the path holds the loading component
    if (!Component) {
        return {
            seedData: [
                actualSegment,
                parallelRouteCacheNodeSeedData,
                // TODO: I don't think the extra fragment is necessary. React treats top
                // level fragments as transparent, i.e. the runtime behavior should be
                // identical even without it. But maybe there's some findDOMNode-related
                // reason that I'm not aware of, so I'm leaving it as-is out of extreme
                // caution, for now.
                /*#__PURE__*/ (0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
                    children: parallelRouteProps.children
                }),
                loadingData
            ],
            styles: layerAssets
        };
    }
    // If force-dynamic is used and the current render supports postponing, we
    // replace it with a node that will postpone the render. This ensures that the
    // postpone is invoked during the react render phase and not during the next
    // render phase.
    // @TODO this does not actually do what it seems like it would or should do. The idea is that
    // if we are rendering in a force-dynamic mode and we can postpone we should only make the segments
    // that ask for force-dynamic to be dynamic, allowing other segments to still prerender. However
    // because this comes after the children traversal and the static generation store is mutated every segment
    // along the parent path of a force-dynamic segment will hit this condition effectively making the entire
    // render force-dynamic. We should refactor this function so that we can correctly track which segments
    // need to be dynamic
    if (staticGenerationStore.forceDynamic && staticGenerationStore.prerenderState) {
        return {
            seedData: [
                actualSegment,
                parallelRouteCacheNodeSeedData,
                /*#__PURE__*/ (0,jsx_runtime.jsx)(Postpone, {
                    prerenderState: staticGenerationStore.prerenderState,
                    reason: 'dynamic = "force-dynamic" was used',
                    pathname: staticGenerationStore.urlPathname
                }),
                loadingData
            ],
            styles: layerAssets
        };
    }
    const isClientComponent = isClientReference(layoutOrPageMod);
    // We avoid cloning this object because it gets consumed here exclusively.
    const props = parallelRouteProps;
    // If it's a not found route, and we don't have any matched parallel
    // routes, we try to render the not found component if it exists.
    if (NotFound && asNotFound && // In development, it could hit the parallel-route-default not found, so we only need to check the segment.
    // Or if there's no parallel routes means it reaches the end.
    !parallelRouteMap.length) {
        props.children = /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                /*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
                    name: "robots",
                    content: "noindex"
                }),
                 false && /*#__PURE__*/ 0,
                notFoundStyles,
                /*#__PURE__*/ (0,jsx_runtime.jsx)(NotFound, {})
            ]
        });
    }
    // Assign params to props
    if (false) {}
    props.params = currentParams;
    let segmentElement;
    if (isPage) {
        // Assign searchParams to props if this is a page
        if (isClientComponent) {
            // When we are passing searchParams to a client component Page we don't want to track the dynamic access
            // here in the RSC layer because the serialization will trigger a dynamic API usage.
            // Instead we pass the searchParams untracked but we wrap the Page in a root client component
            // which can among other things adds the dynamic tracking before rendering the page.
            // @TODO make the root wrapper part of next-app-loader so we don't need the extra client component
            props.searchParams = createUntrackedSearchParams(query);
            segmentElement = /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
                children: [
                    metadataOutlet,
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(ClientPageRoot, {
                        props: props,
                        Component: Component
                    })
                ]
            });
        } else {
            // If we are passing searchParams to a server component Page we need to track their usage in case
            // the current render mode tracks dynamic API usage.
            props.searchParams = createDynamicallyTrackedSearchParams(query);
            segmentElement = /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
                children: [
                    metadataOutlet,
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(Component, {
                        ...props
                    })
                ]
            });
        }
    } else {
        // For layouts we just render the component
        segmentElement = /*#__PURE__*/ (0,jsx_runtime.jsx)(Component, {
            ...props
        });
    }
    return {
        seedData: [
            actualSegment,
            parallelRouteCacheNodeSeedData,
            /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
                children: [
                    segmentElement,
                    null
                ]
            }),
            loadingData
        ],
        styles: layerAssets
    };
}

//# sourceMappingURL=create-component-tree.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/walk-tree-with-flight-router-state.js











/**
 * Use router state to decide at what common layout to render the page.
 * This can either be the common layout between two pages or a specific place to start rendering from using the "refetch" marker in the tree.
 */ async function walkTreeWithFlightRouterState({ createSegmentPath, loaderTreeToFilter, parentParams, isFirst, flightRouterState, parentRendered, rscPayloadHead, injectedCSS, injectedJS, injectedFontPreloadTags, rootLayoutIncluded, asNotFound, metadataOutlet, ctx }) {
    const { renderOpts: { nextFontManifest, experimental }, query, isPrefetch, getDynamicParamFromSegment, componentMod: { tree: loaderTree } } = ctx;
    const [segment, parallelRoutes, components] = loaderTreeToFilter;
    const parallelRoutesKeys = Object.keys(parallelRoutes);
    const { layout } = components;
    const isLayout = typeof layout !== "undefined";
    /**
   * Checks if the current segment is a root layout.
   */ const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded;
    /**
   * Checks if the current segment or any level above it has a root layout.
   */ const rootLayoutIncludedAtThisLevelOrAbove = rootLayoutIncluded || rootLayoutAtThisLevel;
    // Because this function walks to a deeper point in the tree to start rendering we have to track the dynamic parameters up to the point where rendering starts
    const segmentParam = getDynamicParamFromSegment(segment);
    const currentParams = // Handle null case where dynamic param is optional
    segmentParam && segmentParam.value !== null ? {
        ...parentParams,
        [segmentParam.param]: segmentParam.value
    } : parentParams;
    const actualSegment = addSearchParamsIfPageSegment(segmentParam ? segmentParam.treeSegment : segment, query);
    /**
   * Decide if the current segment is where rendering has to start.
   */ const renderComponentsOnThisLevel = // No further router state available
    !flightRouterState || // Segment in router state does not match current segment
    !(0,match_segments/* matchSegment */.j)(actualSegment, flightRouterState[0]) || // Last item in the tree
    parallelRoutesKeys.length === 0 || // Explicit refresh
    flightRouterState[3] === "refetch";
    const shouldSkipComponentTree = // loading.tsx has no effect on prefetching when PPR is enabled
    !experimental.ppr && isPrefetch && !Boolean(components.loading) && (flightRouterState || // If there is no flightRouterState, we need to check the entire loader tree, as otherwise we'll be only checking the root
    !hasLoadingComponentInTree(loaderTree));
    if (!parentRendered && renderComponentsOnThisLevel) {
        const overriddenSegment = flightRouterState && (0,match_segments/* canSegmentBeOverridden */.W)(actualSegment, flightRouterState[0]) ? flightRouterState[0] : actualSegment;
        const routerState = createFlightRouterStateFromLoaderTree(// Create router state using the slice of the loaderTree
        loaderTreeToFilter, getDynamicParamFromSegment, query);
        if (shouldSkipComponentTree) {
            // Send only the router state
            return [
                [
                    overriddenSegment,
                    routerState,
                    null,
                    null
                ]
            ];
        } else {
            // Create component tree using the slice of the loaderTree
            const { seedData } = await createComponentTree(// This ensures flightRouterPath is valid and filters down the tree
            {
                ctx,
                createSegmentPath,
                loaderTree: loaderTreeToFilter,
                parentParams: currentParams,
                firstItem: isFirst,
                injectedCSS,
                injectedJS,
                injectedFontPreloadTags,
                // This is intentionally not "rootLayoutIncludedAtThisLevelOrAbove" as createComponentTree starts at the current level and does a check for "rootLayoutAtThisLevel" too.
                rootLayoutIncluded,
                asNotFound,
                metadataOutlet
            });
            // Create head
            const { layoutOrPagePath } = parseLoaderTree(loaderTreeToFilter);
            const layerAssets = getLayerAssets({
                ctx,
                layoutOrPagePath,
                injectedCSS: new Set(injectedCSS),
                injectedJS: new Set(injectedJS),
                injectedFontPreloadTags: new Set(injectedFontPreloadTags)
            });
            const head = /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
                children: [
                    layerAssets,
                    rscPayloadHead
                ]
            });
            return [
                [
                    overriddenSegment,
                    routerState,
                    seedData,
                    head
                ]
            ];
        }
    }
    // If we are not rendering on this level we need to check if the current
    // segment has a layout. If so, we need to track all the used CSS to make
    // the result consistent.
    const layoutPath = layout == null ? void 0 : layout[1];
    const injectedCSSWithCurrentLayout = new Set(injectedCSS);
    const injectedJSWithCurrentLayout = new Set(injectedJS);
    const injectedFontPreloadTagsWithCurrentLayout = new Set(injectedFontPreloadTags);
    if (layoutPath) {
        getLinkAndScriptTags(ctx.clientReferenceManifest, layoutPath, injectedCSSWithCurrentLayout, injectedJSWithCurrentLayout, true);
        getPreloadableFonts(nextFontManifest, layoutPath, injectedFontPreloadTagsWithCurrentLayout);
    }
    // Walk through all parallel routes.
    const paths = (await Promise.all(parallelRoutesKeys.map(async (parallelRouteKey)=>{
        // for (const parallelRouteKey of parallelRoutesKeys) {
        const parallelRoute = parallelRoutes[parallelRouteKey];
        const currentSegmentPath = isFirst ? [
            parallelRouteKey
        ] : [
            actualSegment,
            parallelRouteKey
        ];
        const path = await walkTreeWithFlightRouterState({
            ctx,
            createSegmentPath: (child)=>{
                return createSegmentPath([
                    ...currentSegmentPath,
                    ...child
                ]);
            },
            loaderTreeToFilter: parallelRoute,
            parentParams: currentParams,
            flightRouterState: flightRouterState && flightRouterState[1][parallelRouteKey],
            parentRendered: parentRendered || renderComponentsOnThisLevel,
            isFirst: false,
            rscPayloadHead,
            injectedCSS: injectedCSSWithCurrentLayout,
            injectedJS: injectedJSWithCurrentLayout,
            injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,
            rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,
            asNotFound,
            metadataOutlet
        });
        return path.map((item)=>{
            // we don't need to send over default routes in the flight data
            // because they are always ignored by the client, unless it's a refetch
            if (item[0] === lib_segment/* DEFAULT_SEGMENT_KEY */.av && flightRouterState && !!flightRouterState[1][parallelRouteKey][0] && flightRouterState[1][parallelRouteKey][3] !== "refetch") {
                return null;
            }
            return [
                actualSegment,
                parallelRouteKey,
                ...item
            ];
        }).filter(Boolean);
    }))).flat();
    return paths;
}

//# sourceMappingURL=walk-tree-with-flight-router-state.js.map
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/app-render/encryption-utils.js
var encryption_utils = __webpack_require__(1318);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/static/static-renderer.js
class StaticRenderer {
    constructor(options){
        this.options = options;
        this.prerender =  false ? 0 : null;
    }
    async render(children) {
        const { prelude, postponed } = await this.prerender(children, this.options);
        return {
            stream: prelude,
            postponed
        };
    }
}
class StaticResumeRenderer {
    constructor(postponed, options){
        this.postponed = postponed;
        this.options = options;
        this.resume = (__webpack_require__(9183).resume);
    }
    async render(children) {
        const stream = await this.resume(children, this.postponed, this.options);
        return {
            stream,
            resumed: true
        };
    }
}
class ServerRenderer {
    constructor(options){
        this.options = options;
        this.renderToReadableStream = (__webpack_require__(9183).renderToReadableStream);
    }
    async render(children) {
        const stream = await this.renderToReadableStream(children, this.options);
        return {
            stream
        };
    }
}
class VoidRenderer {
    async render(_children) {
        return {
            stream: new ReadableStream({
                start (controller) {
                    // Close the stream immediately
                    controller.close();
                }
            }),
            resumed: false
        };
    }
}
const DYNAMIC_DATA = 1;
const DYNAMIC_HTML = 2;
function getDynamicHTMLPostponedState(data) {
    return [
        DYNAMIC_HTML,
        data
    ];
}
function getDynamicDataPostponedState() {
    return DYNAMIC_DATA;
}
function createStaticRenderer({ ppr, isStaticGeneration, postponed, streamOptions: { signal, onError, onPostpone, onHeaders, maxHeadersLength, nonce, bootstrapScripts, formState } }) {
    if (ppr) {
        if (isStaticGeneration) {
            // This is a Prerender
            return new StaticRenderer({
                signal,
                onError,
                onPostpone,
                // We want to capture headers because we may not end up with a shell
                // and being able to send headers is the next best thing
                onHeaders,
                maxHeadersLength,
                bootstrapScripts
            });
        } else {
            // This is a Resume
            if (postponed === DYNAMIC_DATA) {
                // The HTML was complete, we don't actually need to render anything
                return new VoidRenderer();
            } else if (postponed) {
                const reactPostponedState = postponed[1];
                // The HTML had dynamic holes and we need to resume it
                return new StaticResumeRenderer(reactPostponedState, {
                    signal,
                    onError,
                    onPostpone,
                    nonce
                });
            }
        }
    }
    if (isStaticGeneration) {
        // This is a static render (without PPR)
        return new ServerRenderer({
            signal,
            onError,
            // We don't pass onHeaders. In static builds we will either have no output
            // or the entire page. In either case preload headers aren't necessary and could
            // alter the prioritiy of relative loading of resources so we opt to keep them
            // as tags exclusively.
            nonce,
            bootstrapScripts,
            formState
        });
    }
    // This is a dynamic render (without PPR)
    return new ServerRenderer({
        signal,
        onError,
        // Static renders are streamed in realtime so sending headers early is
        // generally good because it will likely go out before the shell is ready.
        onHeaders,
        maxHeadersLength,
        nonce,
        bootstrapScripts,
        formState
    });
}

//# sourceMappingURL=static-renderer.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/use-flight-response.js

const use_flight_response_isEdgeRuntime = "edge" === "edge";
const INLINE_FLIGHT_PAYLOAD_BOOTSTRAP = 0;
const INLINE_FLIGHT_PAYLOAD_DATA = 1;
const INLINE_FLIGHT_PAYLOAD_FORM_STATE = 2;
const flightResponses = new WeakMap();
const encoder = new TextEncoder();
/**
 * Render Flight stream.
 * This is only used for renderToHTML, the Flight response does not need additional wrappers.
 */ function useFlightStream(flightStream, clientReferenceManifest, nonce) {
    const response = flightResponses.get(flightStream);
    if (response) {
        return response;
    }
    // react-server-dom-webpack/client.edge must not be hoisted for require cache clearing to work correctly
    let createFromReadableStream;
    // @TODO: investigate why the aliasing for turbopack doesn't pick this up, requiring this runtime check
    if (false) {} else {
        createFromReadableStream = // eslint-disable-next-line import/no-extraneous-dependencies
        (__webpack_require__(1502).createFromReadableStream);
    }
    const newResponse = createFromReadableStream(flightStream, {
        ssrManifest: {
            moduleLoading: clientReferenceManifest.moduleLoading,
            moduleMap: use_flight_response_isEdgeRuntime ? clientReferenceManifest.edgeSSRModuleMapping : clientReferenceManifest.ssrModuleMapping
        },
        nonce
    });
    flightResponses.set(flightStream, newResponse);
    return newResponse;
}
/**
 * There are times when an SSR render may be finished but the RSC render
 * is ongoing and we need to wait for it to complete to make some determination
 * about how to handle the render. This function will drain the RSC reader and
 * resolve when completed. This will generally require teeing the RSC stream and it
 * should be noted that it will cause all the RSC chunks to queue in the underlying
 * ReadableStream however given Flight currently is a push stream that doesn't respond
 * to backpressure this shouldn't change how much memory is maximally consumed
 */ async function flightRenderComplete(flightStream) {
    const flightReader = flightStream.getReader();
    while(true){
        const { done } = await flightReader.read();
        if (done) {
            return;
        }
    }
}
/**
 * Creates a ReadableStream provides inline script tag chunks for writing hydration
 * data to the client outside the React render itself.
 *
 * @param flightStream The RSC render stream
 * @param nonce optionally a nonce used during this particular render
 * @param formState optionally the formState used with this particular render
 * @returns a ReadableStream without the complete property. This signifies a lazy ReadableStream
 */ function createInlinedDataReadableStream(flightStream, nonce, formState) {
    const startScriptTag = nonce ? `<script nonce=${JSON.stringify(nonce)}>` : "<script>";
    const decoder = new TextDecoder("utf-8", {
        fatal: true
    });
    const decoderOptions = {
        stream: true
    };
    const flightReader = flightStream.getReader();
    const readable = new ReadableStream({
        type: "bytes",
        start (controller) {
            try {
                writeInitialInstructions(controller, startScriptTag, formState);
            } catch (error) {
                // during encoding or enqueueing forward the error downstream
                controller.error(error);
            }
        },
        async pull (controller) {
            try {
                const { done, value } = await flightReader.read();
                if (done) {
                    const tail = decoder.decode(value, {
                        stream: false
                    });
                    if (tail.length) {
                        writeFlightDataInstruction(controller, startScriptTag, tail);
                    }
                    controller.close();
                } else {
                    const chunkAsString = decoder.decode(value, decoderOptions);
                    writeFlightDataInstruction(controller, startScriptTag, chunkAsString);
                }
            } catch (error) {
                // There was a problem in the upstream reader or during decoding or enqueuing
                // forward the error downstream
                controller.error(error);
            }
        }
    });
    return readable;
}
function writeInitialInstructions(controller, scriptStart, formState) {
    controller.enqueue(encoder.encode(`${scriptStart}(self.__next_f=self.__next_f||[]).push(${htmlEscapeJsonString(JSON.stringify([
        INLINE_FLIGHT_PAYLOAD_BOOTSTRAP
    ]))});self.__next_f.push(${htmlEscapeJsonString(JSON.stringify([
        INLINE_FLIGHT_PAYLOAD_FORM_STATE,
        formState
    ]))})</script>`));
}
function writeFlightDataInstruction(controller, scriptStart, chunkAsString) {
    controller.enqueue(encoder.encode(`${scriptStart}self.__next_f.push(${htmlEscapeJsonString(JSON.stringify([
        INLINE_FLIGHT_PAYLOAD_DATA,
        chunkAsString
    ]))})</script>`));
}

//# sourceMappingURL=use-flight-response.js.map
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/future/helpers/interception-routes.js
var interception_routes = __webpack_require__(117);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/client-component-renderer-logger.js
var client_component_renderer_logger = __webpack_require__(9031);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/app-render.js












































function createNotFoundLoaderTree(loaderTree) {
    // Align the segment with parallel-route-default in next-app-loader
    return [
        "",
        {},
        loaderTree[2]
    ];
}
/* This method is important for intercepted routes to function:
 * when a route is intercepted, e.g. /blog/[slug], it will be rendered
 * with the layout of the previous page, e.g. /profile/[id]. The problem is
 * that the loader tree needs to know the dynamic param in order to render (id and slug in the example).
 * Normally they are read from the path but since we are intercepting the route, the path would not contain id,
 * so we need to read it from the router state.
 */ function findDynamicParamFromRouterState(flightRouterState, segment) {
    if (!flightRouterState) {
        return null;
    }
    const treeSegment = flightRouterState[0];
    if ((0,match_segments/* canSegmentBeOverridden */.W)(segment, treeSegment)) {
        if (!Array.isArray(treeSegment) || Array.isArray(segment)) {
            return null;
        }
        return {
            param: treeSegment[0],
            value: treeSegment[1],
            treeSegment: treeSegment,
            type: treeSegment[2]
        };
    }
    for (const parallelRouterState of Object.values(flightRouterState[1])){
        const maybeDynamicParam = findDynamicParamFromRouterState(parallelRouterState, segment);
        if (maybeDynamicParam) {
            return maybeDynamicParam;
        }
    }
    return null;
}
/**
 * Returns a function that parses the dynamic segment and return the associated value.
 */ function makeGetDynamicParamFromSegment(params, flightRouterState) {
    return function getDynamicParamFromSegment(// [slug] / [[slug]] / [...slug]
    segment) {
        const segmentParam = (0,get_segment_param/* getSegmentParam */.R)(segment);
        if (!segmentParam) {
            return null;
        }
        const key = segmentParam.param;
        let value = params[key];
        // this is a special marker that will be present for interception routes
        if (value === "__NEXT_EMPTY_PARAM__") {
            value = undefined;
        }
        if (Array.isArray(value)) {
            value = value.map((i)=>encodeURIComponent(i));
        } else if (typeof value === "string") {
            value = encodeURIComponent(value);
        }
        if (!value) {
            // Handle case where optional catchall does not have a value, e.g. `/dashboard/[...slug]` when requesting `/dashboard`
            if (segmentParam.type === "optional-catchall") {
                const type = dynamicParamTypes[segmentParam.type];
                return {
                    param: key,
                    value: null,
                    type: type,
                    // This value always has to be a string.
                    treeSegment: [
                        key,
                        "",
                        type
                    ]
                };
            }
            return findDynamicParamFromRouterState(flightRouterState, segment);
        }
        const type = getShortDynamicParamType(segmentParam.type);
        return {
            param: key,
            // The value that is passed to user code.
            value: value,
            // The value that is rendered in the router tree.
            treeSegment: [
                key,
                Array.isArray(value) ? value.join("/") : value,
                type
            ],
            type: type
        };
    };
}
function NonIndex({ ctx }) {
    const is404Page = ctx.pagePath === "/404";
    const isInvalidStatusCode = typeof ctx.res.statusCode === "number" && ctx.res.statusCode > 400;
    if (is404Page || isInvalidStatusCode) {
        return /*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
            name: "robots",
            content: "noindex"
        });
    }
    return null;
}
// Handle Flight render request. This is only used when client-side navigating. E.g. when you `router.push('/dashboard')` or `router.reload()`.
async function generateFlight(ctx, options) {
    // Flight data that is going to be passed to the browser.
    // Currently a single item array but in the future multiple patches might be combined in a single request.
    let flightData = null;
    const { componentMod: { tree: loaderTree, renderToReadableStream, createDynamicallyTrackedSearchParams }, getDynamicParamFromSegment, appUsingSizeAdjustment, staticGenerationStore: { urlPathname }, query, requestId, flightRouterState } = ctx;
    if (!(options == null ? void 0 : options.skipFlight)) {
        const [MetadataTree, MetadataOutlet] = createMetadataComponents({
            tree: loaderTree,
            pathname: urlPathname,
            trailingSlash: ctx.renderOpts.trailingSlash,
            query,
            getDynamicParamFromSegment,
            appUsingSizeAdjustment,
            createDynamicallyTrackedSearchParams
        });
        flightData = (await walkTreeWithFlightRouterState({
            ctx,
            createSegmentPath: (child)=>child,
            loaderTreeToFilter: loaderTree,
            parentParams: {},
            flightRouterState,
            isFirst: true,
            // For flight, render metadata inside leaf page
            rscPayloadHead: /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
                children: [
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(NonIndex, {
                        ctx: ctx
                    }),
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(MetadataTree, {}, requestId)
                ]
            }),
            injectedCSS: new Set(),
            injectedJS: new Set(),
            injectedFontPreloadTags: new Set(),
            rootLayoutIncluded: false,
            asNotFound: ctx.isNotFoundPath || (options == null ? void 0 : options.asNotFound),
            metadataOutlet: /*#__PURE__*/ (0,jsx_runtime.jsx)(MetadataOutlet, {})
        })).map((path)=>path.slice(1)) // remove the '' (root) segment
        ;
    }
    const buildIdFlightDataPair = [
        ctx.renderOpts.buildId,
        flightData
    ];
    // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)
    // which contains the subset React.
    const flightReadableStream = renderToReadableStream(options ? [
        options.actionResult,
        buildIdFlightDataPair
    ] : buildIdFlightDataPair, ctx.clientReferenceManifest.clientModules, {
        onError: ctx.flightDataRendererErrorHandler
    });
    return new FlightRenderResult(flightReadableStream);
}
/**
 * Creates a resolver that eagerly generates a flight payload that is then
 * resolved when the resolver is called.
 */ function createFlightDataResolver(ctx) {
    // Generate the flight data and as soon as it can, convert it into a string.
    const promise = generateFlight(ctx).then(async (result)=>({
            flightData: await result.toUnchunkedString(true)
        }))// Otherwise if it errored, return the error.
    .catch((err)=>({
            err
        }));
    return async ()=>{
        // Resolve the promise to get the flight data or error.
        const result = await promise;
        // If the flight data failed to render due to an error, re-throw the error
        // here.
        if ("err" in result) {
            throw result.err;
        }
        // Otherwise, return the flight data.
        return result.flightData;
    };
}
// This is the root component that runs in the RSC context
async function ReactServerApp({ tree, ctx, asNotFound }) {
    // Create full component tree from root to leaf.
    const injectedCSS = new Set();
    const injectedJS = new Set();
    const injectedFontPreloadTags = new Set();
    const missingSlots = new Set();
    const { getDynamicParamFromSegment, query, appUsingSizeAdjustment, componentMod: { AppRouter, GlobalError, createDynamicallyTrackedSearchParams }, staticGenerationStore: { urlPathname } } = ctx;
    const initialTree = createFlightRouterStateFromLoaderTree(tree, getDynamicParamFromSegment, query);
    const [MetadataTree, MetadataOutlet] = createMetadataComponents({
        tree,
        errorType: asNotFound ? "not-found" : undefined,
        pathname: urlPathname,
        trailingSlash: ctx.renderOpts.trailingSlash,
        query,
        getDynamicParamFromSegment: getDynamicParamFromSegment,
        appUsingSizeAdjustment: appUsingSizeAdjustment,
        createDynamicallyTrackedSearchParams
    });
    const { seedData, styles } = await createComponentTree({
        ctx,
        createSegmentPath: (child)=>child,
        loaderTree: tree,
        parentParams: {},
        firstItem: true,
        injectedCSS,
        injectedJS,
        injectedFontPreloadTags,
        rootLayoutIncluded: false,
        asNotFound: asNotFound,
        metadataOutlet: /*#__PURE__*/ (0,jsx_runtime.jsx)(MetadataOutlet, {}),
        missingSlots
    });
    // When the `vary` response header is present with `Next-URL`, that means there's a chance
    // it could respond differently if there's an interception route. We provide this information
    // to `AppRouter` so that it can properly seed the prefetch cache with a prefix, if needed.
    const varyHeader = ctx.res.getHeader("vary");
    const couldBeIntercepted = typeof varyHeader === "string" && varyHeader.includes(app_router_headers/* NEXT_URL */.TP);
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
        children: [
            styles,
            /*#__PURE__*/ (0,jsx_runtime.jsx)(AppRouter, {
                buildId: ctx.renderOpts.buildId,
                assetPrefix: ctx.assetPrefix,
                initialCanonicalUrl: urlPathname,
                // This is the router state tree.
                initialTree: initialTree,
                // This is the tree of React nodes that are seeded into the cache
                initialSeedData: seedData,
                couldBeIntercepted: couldBeIntercepted,
                initialHead: /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
                    children: [
                        /*#__PURE__*/ (0,jsx_runtime.jsx)(NonIndex, {
                            ctx: ctx
                        }),
                        /*#__PURE__*/ (0,jsx_runtime.jsx)(MetadataTree, {}, ctx.requestId)
                    ]
                }),
                globalErrorComponent: GlobalError,
                // This is used to provide debug information (when in development mode)
                // about which slots were not filled by page components while creating the component tree.
                missingSlots: missingSlots
            })
        ]
    });
}
// This is the root component that runs in the RSC context
async function ReactServerError({ tree, ctx, errorType }) {
    const { getDynamicParamFromSegment, query, appUsingSizeAdjustment, componentMod: { AppRouter, GlobalError, createDynamicallyTrackedSearchParams }, staticGenerationStore: { urlPathname }, requestId } = ctx;
    const [MetadataTree] = createMetadataComponents({
        tree,
        pathname: urlPathname,
        trailingSlash: ctx.renderOpts.trailingSlash,
        errorType,
        query,
        getDynamicParamFromSegment,
        appUsingSizeAdjustment,
        createDynamicallyTrackedSearchParams
    });
    const head = /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)(NonIndex, {
                ctx: ctx
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(MetadataTree, {}, requestId),
             false && /*#__PURE__*/ 0
        ]
    });
    const initialTree = createFlightRouterStateFromLoaderTree(tree, getDynamicParamFromSegment, query);
    // For metadata notFound error there's no global not found boundary on top
    // so we create a not found page with AppRouter
    const initialSeedData = [
        initialTree[0],
        {},
        /*#__PURE__*/ (0,jsx_runtime.jsxs)("html", {
            id: "__next_error__",
            children: [
                /*#__PURE__*/ (0,jsx_runtime.jsx)("head", {}),
                /*#__PURE__*/ (0,jsx_runtime.jsx)("body", {})
            ]
        }),
        null
    ];
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(AppRouter, {
        buildId: ctx.renderOpts.buildId,
        assetPrefix: ctx.assetPrefix,
        initialCanonicalUrl: urlPathname,
        initialTree: initialTree,
        initialHead: head,
        globalErrorComponent: GlobalError,
        initialSeedData: initialSeedData,
        missingSlots: new Set()
    });
}
// This component must run in an SSR context. It will render the RSC root component
function ReactServerEntrypoint({ reactServerStream, preinitScripts, clientReferenceManifest, nonce }) {
    preinitScripts();
    const response = useFlightStream(reactServerStream, clientReferenceManifest, nonce);
    return react.use(response);
}
async function renderToHTMLOrFlightImpl(req, res, pagePath, query, renderOpts, baseCtx, requestEndedState) {
    var _getTracer_getRootSpanAttributes, _staticGenerationStore_prerenderState;
    const isNotFoundPath = pagePath === "/404";
    // A unique request timestamp used by development to ensure that it's
    // consistent and won't change during this request. This is important to
    // avoid that resources can be deduped by React Float if the same resource is
    // rendered or preloaded multiple times: `<link href="a.css?v={Date.now()}"/>`.
    const requestTimestamp = Date.now();
    const { buildManifest, subresourceIntegrityManifest, serverActionsManifest, ComponentMod, dev, nextFontManifest, supportsDynamicHTML, serverActions, appDirDevErrorLogger, assetPrefix = "", enableTainting } = renderOpts;
    // We need to expose the bundled `require` API globally for
    // react-server-dom-webpack. This is a hack until we find a better way.
    if (ComponentMod.__next_app__) {
        const instrumented = (0,client_component_renderer_logger/* wrapClientComponentLoader */.B)(ComponentMod);
        // @ts-ignore
        globalThis.__next_require__ = instrumented.require;
        // @ts-ignore
        globalThis.__next_chunk_load__ = instrumented.loadChunk;
    }
    if (typeof req.on === "function") {
        req.on("end", ()=>{
            requestEndedState.ended = true;
            if ("performance" in globalThis) {
                const metrics = (0,client_component_renderer_logger/* getClientComponentLoaderMetrics */.R)({
                    reset: true
                });
                if (metrics) {
                    (0,tracer/* getTracer */.Yz)().startSpan(constants/* NextNodeServerSpan */.Xy.clientComponentLoading, {
                        startTime: metrics.clientComponentLoadStart,
                        attributes: {
                            "next.clientComponentLoadCount": metrics.clientComponentLoadCount
                        }
                    }).end(metrics.clientComponentLoadStart + metrics.clientComponentLoadTimes);
                }
            }
        });
    }
    const metadata = {};
    const appUsingSizeAdjustment = !!(nextFontManifest == null ? void 0 : nextFontManifest.appUsingSizeAdjust);
    // TODO: fix this typescript
    const clientReferenceManifest = renderOpts.clientReferenceManifest;
    const serverModuleMap = (0,action_utils/* createServerModuleMap */.w)({
        serverActionsManifest,
        pageName: renderOpts.page
    });
    (0,encryption_utils/* setReferenceManifestsSingleton */.Mo)({
        clientReferenceManifest,
        serverActionsManifest,
        serverModuleMap
    });
    const digestErrorsMap = new Map();
    const allCapturedErrors = [];
    const isNextExport = !!renderOpts.nextExport;
    const { staticGenerationStore, requestStore } = baseCtx;
    const { isStaticGeneration } = staticGenerationStore;
    // when static generation fails during PPR, we log the errors separately. We intentionally
    // silence the error logger in this case to avoid double logging.
    const silenceStaticGenerationErrors = renderOpts.experimental.ppr && isStaticGeneration;
    const serverComponentsErrorHandler = createErrorHandler({
        source: ErrorHandlerSource.serverComponents,
        dev,
        isNextExport,
        errorLogger: appDirDevErrorLogger,
        digestErrorsMap,
        silenceLogger: silenceStaticGenerationErrors
    });
    const flightDataRendererErrorHandler = createErrorHandler({
        source: ErrorHandlerSource.flightData,
        dev,
        isNextExport,
        errorLogger: appDirDevErrorLogger,
        digestErrorsMap,
        silenceLogger: silenceStaticGenerationErrors
    });
    const htmlRendererErrorHandler = createErrorHandler({
        source: ErrorHandlerSource.html,
        dev,
        isNextExport,
        errorLogger: appDirDevErrorLogger,
        digestErrorsMap,
        allCapturedErrors,
        silenceLogger: silenceStaticGenerationErrors
    });
    ComponentMod.patchFetch();
    /**
   * Rules of Static & Dynamic HTML:
   *
   *    1.) We must generate static HTML unless the caller explicitly opts
   *        in to dynamic HTML support.
   *
   *    2.) If dynamic HTML support is requested, we must honor that request
   *        or throw an error. It is the sole responsibility of the caller to
   *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.
   *
   * These rules help ensure that other existing features like request caching,
   * coalescing, and ISR continue working as intended.
   */ const generateStaticHTML = supportsDynamicHTML !== true;
    // Pull out the hooks/references from the component.
    const { tree: loaderTree, taintObjectReference } = ComponentMod;
    if (enableTainting) {
        taintObjectReference("Do not pass process.env to client components since it will leak sensitive data", process.env);
    }
    staticGenerationStore.fetchMetrics = [];
    metadata.fetchMetrics = staticGenerationStore.fetchMetrics;
    // don't modify original query object
    query = {
        ...query
    };
    (0,internal_utils/* stripInternalQueries */.Q3)(query);
    const isRSCRequest = req.headers[app_router_headers/* RSC_HEADER */.A.toLowerCase()] !== undefined;
    const isPrefetchRSCRequest = isRSCRequest && req.headers[app_router_headers/* NEXT_ROUTER_PREFETCH_HEADER */.qw.toLowerCase()] !== undefined;
    /**
   * Router state provided from the client-side router. Used to handle rendering
   * from the common layout down. This value will be undefined if the request
   * is not a client-side navigation request or if the request is a prefetch
   * request (except when it's a prefetch request for an interception route
   * which is always dynamic).
   */ const shouldProvideFlightRouterState = isRSCRequest && (!isPrefetchRSCRequest || !renderOpts.experimental.ppr || // Interception routes currently depend on the flight router state to
    // extract dynamic params.
    (0,interception_routes/* isInterceptionRouteAppPath */.Ag)(pagePath));
    const parsedFlightRouterState = parseAndValidateFlightRouterState(req.headers[app_router_headers/* NEXT_ROUTER_STATE_TREE */.ph.toLowerCase()]);
    /**
   * The metadata items array created in next-app-loader with all relevant information
   * that we need to resolve the final metadata.
   */ let requestId;
    if (true) {
        requestId = crypto.randomUUID();
    } else {}
    /**
   * Dynamic parameters. E.g. when you visit `/dashboard/vercel` which is rendered by `/dashboard/[slug]` the value will be {"slug": "vercel"}.
   */ const params = renderOpts.params ?? {};
    const getDynamicParamFromSegment = makeGetDynamicParamFromSegment(params, // `FlightRouterState` is unconditionally provided here because this method uses it
    // to extract dynamic params as a fallback if they're not present in the path.
    parsedFlightRouterState);
    const ctx = {
        ...baseCtx,
        getDynamicParamFromSegment,
        query,
        isPrefetch: isPrefetchRSCRequest,
        requestTimestamp,
        appUsingSizeAdjustment,
        flightRouterState: shouldProvideFlightRouterState ? parsedFlightRouterState : undefined,
        requestId,
        defaultRevalidate: false,
        pagePath,
        clientReferenceManifest,
        assetPrefix,
        flightDataRendererErrorHandler,
        serverComponentsErrorHandler,
        isNotFoundPath,
        res
    };
    if (isRSCRequest && !isStaticGeneration) {
        return generateFlight(ctx);
    }
    // Create the resolver that can get the flight payload when it's ready or
    // throw the error if it occurred. If we are not generating static HTML, we
    // don't need to generate the flight payload because it's a dynamic request
    // which means we're either getting the flight payload only or just the
    // regular HTML.
    const flightDataResolver = isStaticGeneration ? createFlightDataResolver(ctx) : null;
    // Get the nonce from the incoming request if it has one.
    const csp = req.headers["content-security-policy"] || req.headers["content-security-policy-report-only"];
    let nonce;
    if (csp && typeof csp === "string") {
        nonce = getScriptNonceFromHeader(csp);
    }
    const validateRootLayout = dev;
    const { HeadManagerContext } = __webpack_require__(4190);
    // On each render, create a new `ServerInsertedHTML` context to capture
    // injected nodes from user code (`useServerInsertedHTML`).
    const { ServerInsertedHTMLProvider, renderServerInsertedHTML } = createServerInsertedHTML();
    (_getTracer_getRootSpanAttributes = (0,tracer/* getTracer */.Yz)().getRootSpanAttributes()) == null ? void 0 : _getTracer_getRootSpanAttributes.set("next.route", pagePath);
    const renderToStream = (0,tracer/* getTracer */.Yz)().wrap(constants/* AppRenderSpan */.k0.getBodyResult, {
        spanName: `render route (app) ${pagePath}`,
        attributes: {
            "next.route": pagePath
        }
    }, async ({ asNotFound, tree, formState })=>{
        const polyfills = buildManifest.polyfillFiles.filter((polyfill)=>polyfill.endsWith(".js") && !polyfill.endsWith(".module.js")).map((polyfill)=>({
                src: `${assetPrefix}/_next/${polyfill}${getAssetQueryString(ctx, false)}`,
                integrity: subresourceIntegrityManifest == null ? void 0 : subresourceIntegrityManifest[polyfill],
                crossOrigin: renderOpts.crossOrigin,
                noModule: true,
                nonce
            }));
        const [preinitScripts, bootstrapScript] = getRequiredScripts(buildManifest, assetPrefix, renderOpts.crossOrigin, subresourceIntegrityManifest, getAssetQueryString(ctx, true), nonce);
        // We kick off the Flight Request (render) here. It is ok to initiate the render in an arbitrary
        // place however it is critical that we only construct the Flight Response inside the SSR
        // render so that directives like preloads are correctly piped through
        const serverStream = ComponentMod.renderToReadableStream(/*#__PURE__*/ (0,jsx_runtime.jsx)(ReactServerApp, {
            tree: tree,
            ctx: ctx,
            asNotFound: asNotFound
        }), clientReferenceManifest.clientModules, {
            onError: serverComponentsErrorHandler
        });
        // We are going to consume this render both for SSR and for inlining the flight data
        let [renderStream, dataStream] = serverStream.tee();
        const children = /*#__PURE__*/ (0,jsx_runtime.jsx)(HeadManagerContext.Provider, {
            value: {
                appDir: true,
                nonce
            },
            children: /*#__PURE__*/ (0,jsx_runtime.jsx)(ServerInsertedHTMLProvider, {
                children: /*#__PURE__*/ (0,jsx_runtime.jsx)(ReactServerEntrypoint, {
                    reactServerStream: renderStream,
                    preinitScripts: preinitScripts,
                    clientReferenceManifest: clientReferenceManifest,
                    nonce: nonce
                })
            })
        });
        const isResume = !!renderOpts.postponed;
        const onHeaders = staticGenerationStore.prerenderState ? (headers)=>{
            headers.forEach((value, key)=>{
                metadata.headers ??= {};
                metadata.headers[key] = value;
            });
        } : isStaticGeneration || isResume ? // ask React to emit headers. For Resume this is just not supported
        // For static generation we know there will be an entire HTML document
        // output and so moving from tag to header for preloading can only
        // server to alter preloading priorities in unwanted ways
        undefined : // early headers to the response
        (headers)=>{
            headers.forEach((value, key)=>{
                res.appendHeader(key, value);
            });
        };
        const getServerInsertedHTML = makeGetServerInsertedHTML({
            polyfills,
            renderServerInsertedHTML,
            serverCapturedErrors: allCapturedErrors,
            basePath: renderOpts.basePath
        });
        const renderer = createStaticRenderer({
            ppr: renderOpts.experimental.ppr,
            isStaticGeneration,
            // If provided, the postpone state should be parsed as JSON so it can be
            // provided to React.
            postponed: typeof renderOpts.postponed === "string" ? JSON.parse(renderOpts.postponed) : null,
            streamOptions: {
                onError: htmlRendererErrorHandler,
                onHeaders,
                maxHeadersLength: 600,
                nonce,
                bootstrapScripts: [
                    bootstrapScript
                ],
                formState
            }
        });
        try {
            let { stream, postponed, resumed } = await renderer.render(children);
            const prerenderState = staticGenerationStore.prerenderState;
            if (prerenderState) {
                /**
           * When prerendering there are three outcomes to consider
           *
           *   Dynamic HTML:      The prerender has dynamic holes (caused by using Next.js Dynamic Rendering APIs)
           *                      We will need to resume this result when requests are handled and we don't include
           *                      any server inserted HTML or inlined flight data in the static HTML
           *
           *   Dynamic Data:      The prerender has no dynamic holes but dynamic APIs were used. We will not
           *                      resume this render when requests are handled but we will generate new inlined
           *                      flight data since it is dynamic and differences may end up reconciling on the client
           *
           *   Static:            The prerender has no dynamic holes and no dynamic APIs were used. We statically encode
           *                      all server inserted HTML and flight data
           */ // First we check if we have any dynamic holes in our HTML prerender
                if ((0,dynamic_rendering/* usedDynamicAPIs */.tK)(prerenderState)) {
                    if (postponed != null) {
                        // This is the Dynamic HTML case.
                        metadata.postponed = JSON.stringify(getDynamicHTMLPostponedState(postponed));
                    } else {
                        // This is the Dynamic Data case
                        metadata.postponed = JSON.stringify(getDynamicDataPostponedState());
                    }
                    // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include
                    // server inserted html in the static response because the html that is part of the prerender may depend on it
                    // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states
                    // require the same set so we unify the code path here
                    return {
                        stream: await (0,node_web_streams_helper/* continueDynamicPrerender */._W)(stream, {
                            getServerInsertedHTML
                        })
                    };
                } else {
                    // We may still be rendering the RSC stream even though the HTML is finished.
                    // We wait for the RSC stream to complete and check again if dynamic was used
                    const [original, flightSpy] = dataStream.tee();
                    dataStream = original;
                    await flightRenderComplete(flightSpy);
                    if ((0,dynamic_rendering/* usedDynamicAPIs */.tK)(prerenderState)) {
                        // This is the same logic above just repeated after ensuring the RSC stream itself has completed
                        if (postponed != null) {
                            // This is the Dynamic HTML case.
                            metadata.postponed = JSON.stringify(getDynamicHTMLPostponedState(postponed));
                        } else {
                            // This is the Dynamic Data case
                            metadata.postponed = JSON.stringify(getDynamicDataPostponedState());
                        }
                        // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include
                        // server inserted html in the static response because the html that is part of the prerender may depend on it
                        // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states
                        // require the same set so we unify the code path here
                        return {
                            stream: await (0,node_web_streams_helper/* continueDynamicPrerender */._W)(stream, {
                                getServerInsertedHTML
                            })
                        };
                    } else {
                        // This is the Static case
                        // We still have not used any dynamic APIs. At this point we can produce an entirely static prerender response
                        let renderedHTMLStream = stream;
                        if (staticGenerationStore.forceDynamic) {
                            throw new static_generation_bailout/* StaticGenBailoutError */.G('Invariant: a Page with `dynamic = "force-dynamic"` did not trigger the dynamic pathway. This is a bug in Next.js');
                        }
                        if (postponed != null) {
                            // We postponed but nothing dynamic was used. We resume the render now and immediately abort it
                            // so we can set all the postponed boundaries to client render mode before we store the HTML response
                            const resumeRenderer = createStaticRenderer({
                                ppr: true,
                                isStaticGeneration: false,
                                postponed: getDynamicHTMLPostponedState(postponed),
                                streamOptions: {
                                    signal: (0,dynamic_rendering/* createPostponedAbortSignal */.Su)("static prerender resume"),
                                    onError: htmlRendererErrorHandler,
                                    nonce
                                }
                            });
                            // We don't actually want to render anything so we just pass a stream
                            // that never resolves. The resume call is going to abort immediately anyway
                            const foreverStream = new ReadableStream();
                            const resumeChildren = /*#__PURE__*/ (0,jsx_runtime.jsx)(HeadManagerContext.Provider, {
                                value: {
                                    appDir: true,
                                    nonce
                                },
                                children: /*#__PURE__*/ (0,jsx_runtime.jsx)(ServerInsertedHTMLProvider, {
                                    children: /*#__PURE__*/ (0,jsx_runtime.jsx)(ReactServerEntrypoint, {
                                        reactServerStream: foreverStream,
                                        preinitScripts: ()=>{},
                                        clientReferenceManifest: clientReferenceManifest,
                                        nonce: nonce
                                    })
                                })
                            });
                            const { stream: resumeStream } = await resumeRenderer.render(resumeChildren);
                            // First we write everything from the prerender, then we write everything from the aborted resume render
                            renderedHTMLStream = (0,node_web_streams_helper/* chainStreams */.QW)(stream, resumeStream);
                        }
                        return {
                            stream: await (0,node_web_streams_helper/* continueStaticPrerender */.Jm)(renderedHTMLStream, {
                                inlinedDataStream: createInlinedDataReadableStream(dataStream, nonce, formState),
                                getServerInsertedHTML
                            })
                        };
                    }
                }
            } else if (renderOpts.postponed) {
                // This is a continuation of either an Incomplete or Dynamic Data Prerender.
                const inlinedDataStream = createInlinedDataReadableStream(dataStream, nonce, formState);
                if (resumed) {
                    // We have new HTML to stream and we also need to include server inserted HTML
                    return {
                        stream: await (0,node_web_streams_helper/* continueDynamicHTMLResume */.Bb)(stream, {
                            inlinedDataStream,
                            getServerInsertedHTML
                        })
                    };
                } else {
                    // We are continuing a Dynamic Data Prerender and simply need to append new inlined flight data
                    return {
                        stream: await (0,node_web_streams_helper/* continueDynamicDataResume */.J$)(stream, {
                            inlinedDataStream
                        })
                    };
                }
            } else {
                // This may be a static render or a dynamic render
                // @TODO factor this further to make the render types more clearly defined and remove
                // the deluge of optional params that passed to configure the various behaviors
                return {
                    stream: await (0,node_web_streams_helper/* continueFizzStream */.eN)(stream, {
                        inlinedDataStream: createInlinedDataReadableStream(dataStream, nonce, formState),
                        isStaticGeneration: isStaticGeneration || generateStaticHTML,
                        getServerInsertedHTML,
                        serverInsertedHTMLToHead: true,
                        validateRootLayout
                    })
                };
            }
        } catch (err) {
            if ((0,static_generation_bailout/* isStaticGenBailoutError */.q)(err) || typeof err === "object" && err !== null && "message" in err && typeof err.message === "string" && err.message.includes("https://nextjs.org/docs/advanced-features/static-html-export")) {
                // Ensure that "next dev" prints the red error overlay
                throw err;
            }
            // If this is a static generation error, we need to throw it so that it
            // can be handled by the caller if we're in static generation mode.
            if (isStaticGeneration && (0,hooks_server_context/* isDynamicServerError */.j)(err)) {
                throw err;
            }
            // If a bailout made it to this point, it means it wasn't wrapped inside
            // a suspense boundary.
            const shouldBailoutToCSR = (0,bailout_to_csr/* isBailoutToCSRError */.D)(err);
            if (shouldBailoutToCSR) {
                const stack = getStackWithoutErrorMessage(err);
                if (renderOpts.experimental.missingSuspenseWithCSRBailout) {
                    (0,log/* error */.vU)(`${err.reason} should be wrapped in a suspense boundary at page "${pagePath}". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\n${stack}`);
                    throw err;
                }
                (0,log/* warn */.ZK)(`Entire page "${pagePath}" deopted into client-side rendering due to "${err.reason}". Read more: https://nextjs.org/docs/messages/deopted-into-client-rendering\n${stack}`);
            }
            if ((0,not_found/* isNotFoundError */.X)(err)) {
                res.statusCode = 404;
            }
            let hasRedirectError = false;
            if ((0,redirect/* isRedirectError */.eo)(err)) {
                hasRedirectError = true;
                res.statusCode = (0,redirect/* getRedirectStatusCodeFromError */.j2)(err);
                if (err.mutableCookies) {
                    const headers = new Headers();
                    // If there were mutable cookies set, we need to set them on the
                    // response.
                    if ((0,request_cookies/* appendMutableCookies */._5)(headers, err.mutableCookies)) {
                        res.setHeader("set-cookie", Array.from(headers.values()));
                    }
                }
                const redirectUrl = (0,add_path_prefix/* addPathPrefix */.V)((0,redirect/* getURLFromRedirectError */.M6)(err), renderOpts.basePath);
                res.setHeader("Location", redirectUrl);
            }
            const is404 = ctx.res.statusCode === 404;
            if (!is404 && !hasRedirectError && !shouldBailoutToCSR) {
                res.statusCode = 500;
            }
            const errorType = is404 ? "not-found" : hasRedirectError ? "redirect" : undefined;
            const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(buildManifest, assetPrefix, renderOpts.crossOrigin, subresourceIntegrityManifest, getAssetQueryString(ctx, false), nonce);
            const errorServerStream = ComponentMod.renderToReadableStream(/*#__PURE__*/ (0,jsx_runtime.jsx)(ReactServerError, {
                tree: tree,
                ctx: ctx,
                errorType: errorType
            }), clientReferenceManifest.clientModules, {
                onError: serverComponentsErrorHandler
            });
            try {
                const fizzStream = await (0,node_web_streams_helper/* renderToInitialFizzStream */.MY)({
                    ReactDOMServer: __webpack_require__(9183),
                    element: /*#__PURE__*/ (0,jsx_runtime.jsx)(ReactServerEntrypoint, {
                        reactServerStream: errorServerStream,
                        preinitScripts: errorPreinitScripts,
                        clientReferenceManifest: clientReferenceManifest,
                        nonce: nonce
                    }),
                    streamOptions: {
                        nonce,
                        // Include hydration scripts in the HTML
                        bootstrapScripts: [
                            errorBootstrapScript
                        ],
                        formState
                    }
                });
                return {
                    // Returning the error that was thrown so it can be used to handle
                    // the response in the caller.
                    err,
                    stream: await (0,node_web_streams_helper/* continueFizzStream */.eN)(fizzStream, {
                        inlinedDataStream: createInlinedDataReadableStream(// This is intentionally using the readable datastream from the
                        // main render rather than the flight data from the error page
                        // render
                        dataStream, nonce, formState),
                        isStaticGeneration,
                        getServerInsertedHTML: makeGetServerInsertedHTML({
                            polyfills,
                            renderServerInsertedHTML,
                            serverCapturedErrors: [],
                            basePath: renderOpts.basePath
                        }),
                        serverInsertedHTMLToHead: true,
                        validateRootLayout
                    })
                };
            } catch (finalErr) {
                if (false) {}
                throw finalErr;
            }
        }
    });
    // For action requests, we handle them differently with a special render result.
    const actionRequestResult = await handleAction({
        req,
        res,
        ComponentMod,
        serverModuleMap,
        generateFlight,
        staticGenerationStore,
        requestStore,
        serverActions,
        ctx
    });
    let formState = null;
    if (actionRequestResult) {
        if (actionRequestResult.type === "not-found") {
            const notFoundLoaderTree = createNotFoundLoaderTree(loaderTree);
            const response = await renderToStream({
                asNotFound: true,
                tree: notFoundLoaderTree,
                formState
            });
            return new render_result/* default */.Z(response.stream, {
                metadata
            });
        } else if (actionRequestResult.type === "done") {
            if (actionRequestResult.result) {
                actionRequestResult.result.assignMetadata(metadata);
                return actionRequestResult.result;
            } else if (actionRequestResult.formState) {
                formState = actionRequestResult.formState;
            }
        }
    }
    const options = {
        metadata
    };
    let response = await renderToStream({
        asNotFound: isNotFoundPath,
        tree: loaderTree,
        formState
    });
    // If we have pending revalidates, wait until they are all resolved.
    if (staticGenerationStore.pendingRevalidates) {
        options.waitUntil = Promise.all(Object.values(staticGenerationStore.pendingRevalidates));
    }
    addImplicitTags(staticGenerationStore);
    if (staticGenerationStore.tags) {
        metadata.fetchTags = staticGenerationStore.tags.join(",");
    }
    // Create the new render result for the response.
    const result = new render_result/* default */.Z(response.stream, options);
    // If we aren't performing static generation, we can return the result now.
    if (!isStaticGeneration) {
        return result;
    }
    // If this is static generation, we should read this in now rather than
    // sending it back to be sent to the client.
    response.stream = await result.toUnchunkedString(true);
    const buildFailingError = digestErrorsMap.size > 0 ? digestErrorsMap.values().next().value : null;
    // If we're debugging partial prerendering, print all the dynamic API accesses
    // that occurred during the render.
    if (staticGenerationStore.prerenderState && (0,dynamic_rendering/* usedDynamicAPIs */.tK)(staticGenerationStore.prerenderState) && ((_staticGenerationStore_prerenderState = staticGenerationStore.prerenderState) == null ? void 0 : _staticGenerationStore_prerenderState.isDebugSkeleton)) {
        (0,log/* warn */.ZK)("The following dynamic usage was detected:");
        for (const access of (0,dynamic_rendering/* formatDynamicAPIAccesses */.gS)(staticGenerationStore.prerenderState)){
            (0,log/* warn */.ZK)(access);
        }
    }
    if (!flightDataResolver) {
        throw new Error("Invariant: Flight data resolver is missing when generating static HTML");
    }
    // If we encountered any unexpected errors during build we fail the
    // prerendering phase and the build.
    if (buildFailingError) {
        throw buildFailingError;
    }
    // Wait for and collect the flight payload data if we don't have it
    // already
    const flightData = await flightDataResolver();
    if (flightData) {
        metadata.flightData = flightData;
    }
    // If force static is specifically set to false, we should not revalidate
    // the page.
    if (staticGenerationStore.forceStatic === false) {
        staticGenerationStore.revalidate = 0;
    }
    // Copy the revalidation value onto the render result metadata.
    metadata.revalidate = staticGenerationStore.revalidate ?? ctx.defaultRevalidate;
    // provide bailout info for debugging
    if (metadata.revalidate === 0) {
        metadata.staticBailoutInfo = {
            description: staticGenerationStore.dynamicUsageDescription,
            stack: staticGenerationStore.dynamicUsageStack
        };
    }
    return new render_result/* default */.Z(response.stream, options);
}
const renderToHTMLOrFlight = (req, res, pagePath, query, renderOpts)=>{
    // TODO: this includes query string, should it?
    const pathname = validateURL(req.url);
    return request_async_storage_wrapper/* RequestAsyncStorageWrapper */.B.wrap(renderOpts.ComponentMod.requestAsyncStorage, {
        req,
        res,
        renderOpts
    }, (requestStore)=>StaticGenerationAsyncStorageWrapper.wrap(renderOpts.ComponentMod.staticGenerationAsyncStorage, {
            urlPathname: pathname,
            renderOpts,
            requestEndedState: {
                ended: false
            }
        }, (staticGenerationStore)=>renderToHTMLOrFlightImpl(req, res, pagePath, query, renderOpts, {
                requestStore,
                staticGenerationStore,
                componentMod: renderOpts.ComponentMod,
                renderOpts
            }, staticGenerationStore.requestEndedState || {})));
};

//# sourceMappingURL=app-render.js.map

/***/ })ÎôÿÿÑôÿÿØôÿÿxV¨  ;;;;;;;;;;;;;;;;;;;;;;;;AAAO;AACP;AACA;;AAEA;;ACJgD;AACtB;AACuB;AAC1C,gBAAgB,gCAAgC;AACvD;AACA,6BAA6B,mBAAI;AACjC;AACA;AACA,cAAc;AACd;AACA,aAAa;AACb;AACA;AACA,cAAc;AACd;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oCAAoC,WAAW;AAC/C,UAAU,SAAS,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qCAAqC;AAC3D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACO,qBAAqB,sCAAsC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,iBAAiB;AACjB;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;;AAEA;;ACpFO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;;ACjBgD;AACtB;AAC2B;AACL;AAChD;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB,cAAc,GAAG,MAAM;AACtE;AACA;AACA;AACA;AACA;AACO,wBAAwB,UAAU;AACzC,WAAW,UAAU;AACrB,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,uEAAuE,IAAI;AAC3E;AACA;AACA;AACA,aAAa;AACb,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT;AACA;AACO,qBAAqB,UAAU;AACtC;AACA,WAAW,UAAU;AACrB,sBAAsB,mBAAI;AAC1B;AACA,SAAS;AACT,2EAA2E,mBAAI;AAC/E;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT;AACA,2CAA2C,mBAAI;AAC/C;AACA;AACA,iBAAiB;AACjB,gBAAgB,IAAI;AACpB;AACA;AACA,iBAAiB;AACjB;AACA,0CAA0C,mBAAI;AAC9C;AACA;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,8EAA8E,mBAAI;AAClF;AACA;AACA,aAAa;AACb,wEAAwE,mBAAI;AAC5E;AACA;AACA,aAAa;AACb,iFAAiF,mBAAI;AACrF;AACA;AACA,aAAa;AACb,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA,kDAAkD,IAAI;AACtD;AACA;AACA,qBAAqB;AACrB,cAAc;AACd,uBAAuB,IAAI;AAC3B;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACO,sBAAsB,QAAQ;AACrC;AACA,YAAY,qBAAqB;AACjC,4BAA4B,MAAM;AAClC;AACA,qCAAqC,YAAY;AACjD;AACA,yBAAyB,mBAAI;AAC7B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,iBAAiB;AACvD;AACA;AACA;AACA;AACA;AACA,0BAA0B,IAAI;AAC9B;AACA;AACA,yBAAyB,mBAAI;AAC7B;AACA;AACA,KAAK;AACL;AACO,2BAA2B,aAAa;AAC/C;AACA,YAAY,+CAA+C;AAC3D,WAAW,UAAU;AACrB,kBAAkB,IAAI;AACtB;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,+DAA+D,mBAAI;AACnE;AACA;AACA;AACA,aAAa;AACb,yBAAyB,IAAI;AAC7B;AACA;AACA,SAAS;AACT;AACA;AACO,4BAA4B,cAAc;AACjD;AACA,WAAW,UAAU;AACrB,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT,uFAAuF,SAAS;AAChG;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AC3NgD;AACtB;AACU;AACpC,yBAAyB,sBAAsB;AAC/C;AACA,yBAAyB,mBAAI;AAC7B;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACO,8BAA8B,YAAY;AACjD;AACA,YAAY,qCAAqC;AACjD,WAAW,UAAU;AACrB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;ACvCqD;AAC9C,6BAA6B,WAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA,qBAAqB;AACrB,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA,qBAAqB;AACrB,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA,qBAAqB;AACrB,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA,qBAAqB;AACrB,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB,oBAAoB,SAAS;AAC7B;AACA;AACA,qBAAqB;AACrB,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,oBAAoB,IAAI;AACxB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,2DAA2D,iBAAiB;AAC5E;AACA;AACA,WAAW,UAAU;AACrB,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA,QAAQ,IAAI;AACZ,sCAAsC,KAAK;AAC3C;AACA,SAAS;AACT,QAAQ,IAAI;AACZ,oCAAoC,KAAK;AACzC;AACA,SAAS;AACT,QAAQ,IAAI;AACZ,qCAAqC,KAAK;AAC1C;AACA,SAAS;AACT;AACA;AACO,2BAA2B,SAAS;AAC3C;AACA;AACA,YAAY,OAAO;AACnB,WAAW,UAAU;AACrB,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,IAAI;AACZ;AACA;AACA,SAAS;AACT,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT;AACA,gBAAgB,IAAI;AACpB;AACA;AACA,iBAAiB;AACjB,gBAAgB,IAAI;AACpB;AACA;AACA,iBAAiB;AACjB,gBAAgB,IAAI;AACpB;AACA;AACA,iBAAiB;AACjB,gBAAgB,IAAI;AACpB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACO,wBAAwB,UAAU;AACzC;AACA,WAAW,UAAU;AACrB,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT,QAAQ,SAAS;AACjB;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AC/bgD;AACtB;AACU;AACpC,8BAA8B,MAAM;AACpC,YAAY,8BAA8B;AAC1C,yBAAyB,mBAAI;AAC7B;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA,SAAS;AACT,MAAM;AACN;AACA,6BAA6B,mBAAI;AACjC;AACA;AACA,SAAS;AACT;AACA;AACO,yBAAyB,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AClDO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACmD;;AAEnD;;;;;AChBuD;AACvD;AACA;AACA;AACA;AACA,uCAAuC,yBAAyB;AAChE;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ,KAAsC,EAAE,EAE3C,CAAC;AACN,+BAA+B,KAAqC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAU;AACjC;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,yBAAyB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,8DAA8D,YAAY;AAC1E;AACA;AACA;AACA;AAC2F;;AAE3F;;ACnGA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;AC7B8D;AACgE;AAC/E;AACH;AACS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,MAAM;AACN;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACO;AACP,2BAA2B,yBAAyB;AACpD;AACA,YAAY,8CAA8C,EAAE,kCAAkC;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8BAAe;AACxD,QAAQ,wBAAQ,kHAAkH,4BAA4B;AAC9J;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yBAAyB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA,mCAAmC,8BAA8B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yBAAyB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;ACnJO;AACP;AACA;;AAEA;;;;ACJ+D;AACxD;AACP,YAAY,4BAA4B;AACxC;AACA;AACA,kFAAkF,uCAAmB;AACrG;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,6BAA6B;AACzC;AACA;AACA;AACA;AACA;;AAEA;;AC/BO;AACP;AACA;;AAEA;;ACJ8D;AACC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8BAA8B;AACzC;AACO;AACP;AACA;AACA;AACA,kCAAkC,yBAAyB;AAC3D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,IAAI,GAAG,MAAM;AAC3E;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yBAAyB;AAChE;AACA;AACA,cAAc,gBAAgB,yBAAyB;AACvD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,yBAAyB;AAC1G;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;ACpK8D;AAChB;AACN;AACjC;AACP,QAAQ,aAAa;AACrB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,SAAS,aAAa;AAC5B;AACA;AACA;AACA,MAAM;AACN,0BAA0B,QAAQ;AAClC,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;;AAEA;;;;;;ACjCkF;AACD;AACxB;AACI;AACL;AACwC;AAC5C;AACsH;AACjH;AACC;AACa;AACX;AACd;AAC9C;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAA4C;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kFAAkF;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,YAAY;AAC/C;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA;AACA;AACA,qCAAqC,cAAc;AACnD;AACA;AACA;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA,mCAAmC,YAAY;AAC/C;AACA;AACA;AACA,qCAAqC,kBAAkB;AACvD;AACA;AACA,kCAAkC,eAAe;AACjD;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yBAAyB;AAC3D;AACA;AACA;AACA;AACA,kCAAkC,yBAAyB;AAC3D;AACA;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,KAAK,sCAAsC,yBAAyB;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iBAAiB;AACzB;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,yBAAyB,4BAAS,SAAS,qCAAmB;AAC9D,8CAA8C,MAAM;AACpD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iBAAiB;AACzB;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,yBAAyB,4BAAS,SAAS,qCAAmB;AAC9D,8CAA8C,MAAM;AACpD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,cAAc;AAC/E;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iCAAiC,uEAAuE;AAC/G;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA,MAAM;AACN,+BAA+B,qBAAqB;AACpD;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACO,sCAAsC,kIAAkI;AAC/K,sCAAsC,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oCAAgB;AAC3C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,CAAC;AACD;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA,mDAAmD;AACnD;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0BAA0B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,MAAsC,GAAG,CAA0E;AAC3J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACO;AACP,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAQ;AACpB;AACA;AACA;AACA;AACO;AACP,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACO,iCAAiC,kIAAkI;AAC1K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mBAAmB,qBAAqB;AACxC,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AC7gBuE;AAC7C;AACqG;AACrE;AAC8B;AACvC;AACI;AACR;AACqC;AACd;AACpE;AACA;AACA;AACA;AACA;AACA;AACO,oCAAoC,2IAA2I;AACtL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gCAAgC,qBAAqB;AACrD,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,eAAe;AACzF;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,8BAA8B,oCAAe;AAC7C,0FAA0F,eAAe;AACzG;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC,YAAY,YAAY;AACxB;AACA,aAAa;AACb,YAAY,SAAS;AACrB;AACA,aAAa;AACb,YAAY,kBAAkB;AAC9B;AACA,aAAa;AACb,YAAY,UAAU;AACtB;AACA,aAAa;AACb,YAAY,mBAAmB;AAC/B;AACA,aAAa;AACb,YAAY,gBAAgB;AAC5B;AACA,aAAa;AACb,YAAY,eAAe;AAC3B;AACA,aAAa;AACb,YAAY,iBAAiB;AAC7B;AACA,aAAa;AACb,YAAY,eAAe;AAC3B;AACA,aAAa;AACb,YAAY,YAAY;AACxB;AACA,aAAa;AACb,YAAY,aAAa;AACzB;AACA,aAAa;AACb;AACA,gEAAgE,mBAAI;AACpE;AACA,SAAS;AACT,6BAA6B,mBAAI,CAAC,oBAAS;AAC3C;AACA,qCAAqC,kBAAkB;AACvD;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;ACvIiF;AAC1E;AACP,qBAAqB,4CAA4C;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,kDAAoB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC1CsE;AACjB;AACiF;AACxF;AACsB;AACpE,sBAAsB,sDAAwB,WAAW;AACzD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV,yDAAyD,cAAc,QAAQ,SAAS;AACxF;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA,kDAAkD,0BAA0B;AAC5E,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA,gEAAgE,YAAY;AAC5E;AACA;AACA;AACA;AACA,wDAAwD,YAAY;AACpE,qBAAqB,cAAc;AACnC,iCAAiC,IAAI,IAAI,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA,qCAAqC,YAAY,EAAE,sCAAsC;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,wBAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gDAA0B,CAAC,EAAE,IAAI;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAA0B,CAAC,EAAE,eAAe;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8LAA8L,YAAoB;AAClN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6CAA6C,eAAe,oBAAoB,gCAAgC;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,iBAAiB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU,KAAK,mCAAmC,oBAAoB,OAAO,qBAAqB,cAAc;AAC1J;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA,wIAAwI;AACxI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,UAAU;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,UAAU;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,2CAA2C,MAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,sDAAsD,MAAM;AAC5D;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA,iEAAiE,MAAM,EAAE,wCAAwC,kCAAkC,OAAO;AAC1J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA,0EAA0E,MAAM,EAAE,wCAAwC,kCAAkC,OAAO;AACnK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AChiBqF;AACzC;AAC5C;AACA;AACA,IAAW,iCAAiC,4BAAY;AACxD;AACA;AACA,yBAAyB,kDAAuB;AAChD;AACA,SAAS;AACT;AACA;;AAEA;;;;;ACbA,MAAMA,mCAAmC;IACvC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,SAASC,WAAWC,KAAY,EAAEC,OAAe;IAC/CD,MAAMC,OAAO,GAAGA;IAChB,IAAID,MAAME,KAAK,EAAE;QACf,MAAMC,QAAQH,MAAME,KAAK,CAACE,KAAK,CAAC;QAChCD,KAAK,CAAC,EAAE,GAAGF;QACXD,MAAME,KAAK,GAAGC,MAAME,IAAI,CAAC;IAC3B;AACF;AAEA;;;;;;;;;CASC,GACM,SAASC,4BAA4BN,KAAY;IACtD,MAAME,QAAQF,MAAME,KAAK;IACzB,IAAI,CAACA,OAAO,OAAO;IACnB,OAAOA,MAAMK,OAAO,CAAC,aAAa;AACpC;AAEO,SAASC,kBAAkBR,KAAY;IAC5C,IAAI,OAAOA,CAAAA,SAAAA,OAAAA,KAAAA,IAAAA,MAAOC,OAAO,MAAK,UAAU;IAExC,IACED,MAAMC,OAAO,CAACQ,QAAQ,CACpB,+DAEF;QACA,MAAMC,eACJ;QAEF,qEAAqE;QACrE,IAAIV,MAAMC,OAAO,CAACQ,QAAQ,CAACC,eAAe;QAE1CX,WACEC,OACA,CAAC,EAAEA,MAAMC,OAAO,CAAC;;AAEvB,EAAES,aAAa,CAAC;QAEZ;IACF;IAEA,IAAIV,MAAMC,OAAO,CAACQ,QAAQ,CAAC,oCAAoC;QAC7DV,WACEC,OACA;QAEF;IACF;IAEA,KAAK,MAAMW,cAAcb,iCAAkC;QACzD,MAAMc,QAAQ,IAAIC,OAAO,CAAC,GAAG,EAAEF,WAAW,sBAAsB,CAAC;QACjE,IAAIC,MAAME,IAAI,CAACd,MAAMC,OAAO,GAAG;YAC7BF,WACEC,OACA,CAAC,EAAEW,WAAW,oLAAoL,CAAC;YAErM;QACF;IACF;AACF;;;;;;;;;ACjFoE;AACD;AACnE;AACA;AACA;AACA;AACA,IAAW,uCAAuC,oCAAe,SAAS,oCAAe;;AAEzF;;ACRoF;AACD;AACZ;AAChE,mCAAmC,oDAAoB,SAAS,6CAAmB,SAAS,uBAAuB;;AAE1H;;ACLwD;AACU;AACF;AAChB;AACkC;AAC3E;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAW,8BAA8B;AACzC;AACA,iGAAiG;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAU;AACnC;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA,YAAY,qCAAY;AACxB;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4BAAS;AAClC;AACA;AACA;AACA,0BAA0B,6BAAc;AACxC;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iDAAiD;AACjD,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AC3EO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;;AAEA;;ACd6C;AACtC;AACP;AACA,kEAAkE;AAClE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,YAAY;AACpB;AACA;AACA;AACA;;AAEA;;;;;AC7B+C;AAC/C,gCAAgC,2BAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2BAAO;AAC7B,IAAI,4BAAQ;AACZ,IAAI,2BAAO;AACX,QAAQ,4BAAQ;AAChB,QAAQ,4BAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,2BAAO;AAC9C;AACA,IAAI,4BAAQ,CAAC,4BAAQ,IAAI,0BAAM;AAC/B,IAAI,8BAAU,CAAC,8BAAU,CAAC,4BAAQ;AAClC,IAAI,8BAAU,CAAC,8BAAU,CAAC,2BAAO;AACjC,QAAQ,6BAAS;AACjB,QAAQ,6BAAS;AACjB;AACA,IAAI,8BAAU,CAAC,6BAAS;AACxB;;AAEA;;AC9BkD;AACM;AACjD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,iBAAiB,EAAE;AAC5B;AACA;AACA;AACA;AACA;AACA,QAAQ,sBAAM,QAAQ,uBAAuB;AAC7C;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AC1BA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AClB4D;AACrD;AACP,sCAAsC,oCAAgB;AACtD;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACO,2EAA2E,QAAQ;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;;AAEA;;AC3BO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;;;;;;;;;;AC/EiG;AAC7B;AACwD;AAChF;AACgB;AACwB;AAC2B;AACE;AAC9B;AAC3B;AACV;AACkC;AACR;AACb;AACA;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,MAAM;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAAc,CAAC,6BAAc;AAC5D;AACA;AACA,gCAAgC,8BAAe,CAAC,6CAA2B;AAC3E;AACA,0BAA0B,gBAAgB;AAC1C;AACA;AACA,KAAK,EAAE,uBAAuB;AAC9B;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,qCAAqC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mDAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,MAAM,KAAK,WAAW;AACjF,gCAAgC,OAAO,EAAE,SAAS,EAAE,eAAe;AACnE;AACA;AACA,YAAY,IAAmC;AAC/C;AACA;AACA;AACA;AACA;AACA,UAAU,KAAK,EAeN;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,qDAAqD,kDAAuB;AAC5E;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oCAAU;AACvC;AACA;AACA;AACA,+DAA+D,MAAM,KAAK,mBAAmB;AAC7F,oCAAoC,OAAO,EAAE,SAAS,EAAE,2BAA2B,EAAE,yBAAyB;AAC9G;AACA;AACA,iCAAiC,wDAAkC;AACnE,iCAAiC,4DAAsC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,yDAAyD,kDAAuB;AAChF;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,WAAW,4BAAY,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACO,8BAA8B,kHAAkH;AACvJ;AACA,YAAY,8BAA8B;AAC1C,YAAY,iFAAiF,EAAE,oEAA8B;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,YAAY,oBAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA,UAAU;AACV;AACA;AACA,mCAAmC,UAAU,yBAAyB,6CAA6C,mDAAmD,+CAA+C;AACrN,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gBAAgB,IAAmC;AACnD;AACA,wBAAwB,6CAA6C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,cAAc,KAAK,EAmFN;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,YAAY,oCAAe;AAC3B,gCAAgC,4CAAuB;AACvD,+BAA+B,mDAA8B;AAC7D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gDAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAAY;AACpC;AACA,UAAU,SAAS,oCAAe;AAClC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,yDAAyD,SAAS,8DAA8D,0CAA0C,YAAY,OAAO;AAC7L;AACA;;AAEA;;;;AC/kBA;AACA;AACgD;AACtB;AACuE;AAC1F;AACP;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU;AAChD,iCAAiC,mBAAI,CAAC,6DAAyB;AAC/D;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,oFAAoF,mBAAI,CAAC,cAAc;AACvG;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;;ACzBO,SAASI,cAAcC,IAAY;IACxC,OAAOA,KACJZ,KAAK,CAAC,KACNa,GAAG,CAAC,CAACC,IAAMC,mBAAmBD,IAC9Bb,IAAI,CAAC;AACV;;;;;ACLiE;AAChC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,aAAa;AAC/D;AACA;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA,uBAAuB,kBAAkB;AACzC,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA,2BAA2B,kCAAkC;AAC7D,gBAAgB,6BAAgB;AAChC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,MAAM;AACN,iCAAiC,YAAY;AAC7C,uBAAuB,kBAAkB;AACzC,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA,2BAA2B,kCAAkC;AAC7D,gBAAgB,6BAAgB;AAChC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACvDsF;AAC5D;AAC0C;AACwD;AAC7D;AACU;AACS;AACJ;AACvE,qCAAqC,qEAAqE;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oCAAe;AAC/B,iDAAiD,mBAAI;AACrD;AACA;AACA,iBAAiB,iBAAiB,MAAsC,iBAAiB,CAGzD;AAChC,cAAc,SAAS,oCAAe;AACtC,oCAAoC,wCAAa,CAAC,4CAAuB;AACzE,mCAAmC,mDAA8B;AACjE,mDAAmD,8CAAkB;AACrE;AACA,qDAAqD,mBAAI;AACzD;AACA;AACA,oCAAoC,qBAAqB,MAAM,YAAY;AAC3E,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gDAAsB,eAAe,oBAAK,CAAC,oBAAS;AACjF;AACA;AACA,yCAAyC,mBAAI;AAC7C;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,kDAAc;AAC7B;AACA;;AAEA;;ACnEA;AACA;AACA,IAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA,IAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AClC+D;AACxD;AACP;AACA,YAAY,SAAS;AACrB,UAAU,OAAO;AACjB;AACA;AACA,uBAAuB,uCAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AClBA,cAAc,YAAoB;AAClC,sBAAsB,KAAqB;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA,iBAAiB,kBAAkB,MAAM,4BAA4B;AACrE;AACA;AACA;;AAEA;;ACjBgD;AACtB;AACyC;AACL;AACC;AACE;AAC1D,0BAA0B,8KAA8K;AAC/M,YAAY,yCAAyC,qBAAqB,oBAAoB;AAC9F;AACA;AACA;AACA,kDAAkD,mBAAmB;AACrE;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA,qCAAqC,IAAI;AACzC,gCAAgC,gBAAgB,SAAS,aAAa,eAAe;AACrF;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB,SAAS,aAAa,OAAO,EAAE,mBAAmB,YAAY;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAsC,GAAG,CAAc;AAClF;AACA,6BAA6B,mBAAI;AACjC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,2BAA2B,gBAAgB,SAAS,aAAa,OAAO,EAAE,mBAAmB,YAAY;AACzG,6BAA6B,mBAAI;AACjC;AACA;AACA,SAAS,YAAY,MAAM;AAC3B,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;ACrEO;AACP,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;;AAEA;;ACRA;AACA;AACA,IAAW,SAAS,8BAAc;AAClC;AACA;;AAEA;;ACNgD;AACtB;AACyB;AACgB;AACJ;AACE;AAC1D,iDAAiD,sDAAsD;AAC9G,YAAY,qCAAqC,EAAE,oBAAoB;AACvE;AACA,4BAA4B,gBAAgB,SAAS,aAAa,OAAO,EAAE,mBAAmB,YAAY;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAsC,GAAG,CAAc;AAClF,6BAA6B,mBAAI;AACjC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,gEAAgE,mBAAI;AACpE,oBAAoB,gBAAgB,SAAS,aAAa,OAAO,EAAE,mBAAmB,YAAY;AAClG;AACA,SAAS;AACT,iBAAiB,8BAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;ACrCsF;AAC5D;AACqC;AACD;AACX;AACG;AACkC;AACpC;AACwB;AACpB;AACqC;AAC7C;AACY;AAC8B;AAC1F;AACA;AACA,IAAW;AACX,WAAW,4BAAS,SAAS,oCAAkB;AAC/C;AACA,KAAK;AACL;AACA,6CAA6C,mLAAmL;AAChO,YAAY,cAAc,gCAAgC,yCAAyC,6JAA6J,oBAAoB,YAAY,4DAA4D;AAC5V,YAAY,8DAA8D,EAAE,eAAe;AAC3F,YAAY,0DAA0D;AACtE;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yEAAyE,+BAA+B;AACxG;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,QAAQ,cAAc;AACtB;AACA,sEAAsE,+BAA+B;AACrG;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qEAAqE,+BAA+B;AACpG;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,oCAAoC,4BAAS,SAAS,oCAAkB;AACxE;AACA;AACA;AACA;AACA;AACA,KAAK,MAAM,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,+BAA+B;AACvF;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,sBAAsB,sDAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kBAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,QAAQ;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8BAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAI;AACrC,4DAA4D,oBAAK,CAAC,oBAAS;AAC3E;AACA;AACA,sCAAsC,oBAAK;AAC3C;AACA;AACA;AACA,8CAA8C,mBAAI,sBAAsB;AACxE;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB,wCAAwC,mBAAI;AAC5C;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,QAAQ,KAAsC,EAAE,EAc3C;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,mBAAI,aAAa;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,gBAAgB,KAAsD,EAAE,qCAQ3D;AACb,oBAAoB,yCAAyC;AAC7D;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mBAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mBAAI;AAC5C,4CAA4C,mBAAI,8BAA8B;AAC9E,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAI,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mBAAI,CAAC,oBAAS;AAC5C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mBAAI;AAClC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oBAAK,CAAC,oBAAS;AACtD;AACA,8BAA8B,mBAAI;AAClC;AACA;AACA,iBAAiB;AACjB,gBAAgB,MAAsC,kBAAkB,CAGtD;AAClB;AACA,8BAA8B,mBAAI,aAAa;AAC/C;AACA,SAAS;AACT;AACA;AACA,QAAQ,KAAwE,EAAE,EAG7E;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,oBAAK,CAAC,oBAAS;AAC1D;AACA;AACA,kCAAkC,mBAAI;AACtC;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA,2CAA2C,oBAAK,CAAC,oBAAS;AAC1D;AACA;AACA,kCAAkC,mBAAI;AACtC;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,MAAM;AACN;AACA,uCAAuC,mBAAI;AAC3C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAK,CAAC,oBAAS;AACzC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;;ACtbyE;AAC/C;AACoE;AAC3B;AACL;AACsE;AAC9E;AACF;AACwB;AACd;AACC;AAC/D;AACA;AACA;AACA,IAAW,+CAA+C,wNAAwN;AAClR,YAAY,cAAc,gCAAgC,iEAAiE,qBAAqB;AAChJ;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA;AACA,KAAK,sCAAY;AACjB;AACA;AACA;AACA;AACA,KAAK,yBAAyB;AAC9B;AACA,uDAAuD,gDAAsB;AAC7E,4BAA4B,qCAAqC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,oBAAoB,WAAW,QAAQ,mBAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,oBAAoB,mBAAmB,EAAE,eAAe;AACxD,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,uCAAuC,oBAAK,CAAC,oBAAS;AACtD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oBAAoB;AAC5B,QAAQ,mBAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4BAA4B,uCAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;AAEA;;;;AC9JA;AACA;AACA;AACA,yBAAyB,MAAqC,GAAG,CAA0C;AAC3G;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kCAAuC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,sCAAsC,kDAAuD;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACO;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO,gCAAgC,qDAAqD,gGAAgG;AAC5L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AC1HqD;AACrD,MAAM,iCAAa,GAAG,MAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,KAAqB,EAAE,EAG1B,CAAC;AACN;AACA,QAAQ,oDAAwE;AAChF;AACA;AACA;AACA;AACA,uBAAuB,iCAAa;AACpC,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAW;AACX;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAW;AACX,oDAAoD,sBAAsB;AAC1E;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,yCAAyC,YAAY,yCAAyC,oBAAoB;AAClH;AACA,QAAQ,EAAE,qBAAqB,oBAAoB;AACnD;AACA;AACA,QAAQ;AACR;AACA;AACA,yCAAyC,YAAY,qBAAqB,oBAAoB;AAC9F;AACA;AACA,QAAQ;AACR;;AAEA;;;;;;ACtHsF;AAC5D;AACkB;AACmL;AAC/I;AACvB;AAC8E;AAChE;AACqB;AACmB;AAC3C;AACwD;AACvE;AACsB;AAC3B;AACY;AACoB;AACa;AACvC;AACoB;AACmB;AAChD;AACyD;AACtD;AACmC;AAC9B;AACiC;AACpB;AACV;AACsB;AACF;AACS;AACvB;AACC;AACK;AACwD;AACxC;AAC2B;AACI;AAChC;AACP;AACgC;AACK;AAC1D;AACvD;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAsB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4CAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,KAAK;AACzB;AACA;AACA;AACA,6BAA6B,mBAAI;AACjC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB,gFAAgF,+EAA+E,aAAa,wCAAwC;AAChP;AACA,+CAA+C,wBAAwB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,0CAA0C,oBAAK,CAAC,oBAAS;AACzD;AACA,kCAAkC,mBAAI;AACtC;AACA,qBAAqB;AACrB,kCAAkC,mBAAI,iBAAiB;AACvD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,0CAA0C,mBAAI,mBAAmB;AACjE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA,YAAY,2EAA2E,8DAA8D,2BAA2B,gBAAgB;AAChM,wBAAwB,qCAAqC;AAC7D,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,mBAAmB,QAAQ,mBAAmB;AAC1D;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mBAAI,mBAAmB;AAC7D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,qFAAqF,mCAAQ;AAC7F,yBAAyB,oBAAK,CAAC,oBAAS;AACxC;AACA;AACA,0BAA0B,mBAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,oBAAK,CAAC,oBAAS;AAC1D;AACA,sCAAsC,mBAAI;AAC1C;AACA,yBAAyB;AACzB,sCAAsC,mBAAI,iBAAiB;AAC3D;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA,kCAAkC,sBAAsB;AACxD,YAAY,2EAA2E,8DAA8D,2BAA2B,aAAa,cAAc;AAC3M,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,+BAA+B,oBAAK,CAAC,oBAAS;AAC9C;AACA,0BAA0B,mBAAI;AAC9B;AACA,aAAa;AACb,0BAA0B,mBAAI,iBAAiB;AAC/C,YAAY,MAAsC,kBAAkB,CAGtD;AACd;AACA,KAAK;AACL,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA,UAAU;AACV,sBAAsB,oBAAK;AAC3B;AACA;AACA,8BAA8B,mBAAI,WAAW;AAC7C,8BAA8B,mBAAI,WAAW;AAC7C;AACA,SAAS;AACT;AACA;AACA,yBAAyB,mBAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iCAAiC,mEAAmE;AACpG;AACA,qBAAqB,eAAe;AACpC,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,WAAW;AAC9E;AACA,YAAY,sMAAsM;AAClN;AACA;AACA;AACA,6BAA6B,qEAAyB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2EAA+B;AAC/D;AACA,iBAAiB;AACjB;AACA,oBAAoB,4BAAS,aAAa,oCAAkB;AAC5D;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA4B,6CAAqB;AACjD;AACA;AACA,KAAK;AACL,IAAI,2DAA8B;AAClC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,sCAAsC;AAClD,YAAY,qBAAqB;AACjC;AACA;AACA;AACA,yCAAyC,kBAAkB;AAC3D,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,2CAA2C,kBAAkB;AAC7D,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qCAAqC,kBAAkB;AACvD,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAyC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,+CAAoB;AACxB,qCAAqC,oCAAU;AAC/C,6DAA6D,sDAA2B;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0DAA0B;AAC9B,oCAAoC,iCAAiC,aAAa,iDAAsB;AACxG;AACA;AACA;AACA;AACA,QAAQ,IAAmC;AAC3C;AACA,MAAM,KAAK,EAEN;AACL;AACA,6HAA6H,iBAAiB;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA,YAAY,qBAAqB,EAAE,mBAAO,CAAC,IAAsD;AACjG;AACA;AACA,YAAY,uDAAuD,EAAE,wBAAwB;AAC7F,wCAAwC,4BAAS;AACjD,2BAA2B,4BAAS,QAAQ,+BAAa;AACzD,wCAAwC,SAAS;AACjD;AACA;AACA;AACA,KAAK,WAAW,6BAA6B;AAC7C;AACA,wBAAwB,YAAY,SAAS,SAAS,EAAE,mBAAmB,aAAa;AACxF;AACA;AACA;AACA;AACA,aAAa;AACb,kDAAkD,kBAAkB,mFAAmF,mBAAmB;AAC1K;AACA;AACA;AACA,+EAA+E,mBAAI;AACnF;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,uCAAuC,mBAAI;AAC3C;AACA;AACA;AACA,aAAa;AACb,oCAAoC,mBAAI;AACxC,wCAAwC,mBAAI;AAC5C;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,sCAAsC,yBAAyB;AAC/D;AACA;AACA;AACA;AACA,SAAS;AACT,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6CAAe;AACnC;AACA;AACA,4DAA4D,4BAA4B;AACxF,sBAAsB;AACtB;AACA,4DAA4D,4BAA4B;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4DAAwB;AAC9D;AACA,yBAAyB;AACzB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C,wBAAwB,6CAAe;AACvC;AACA;AACA;AACA,gEAAgE,4BAA4B;AAC5F,0BAA0B;AAC1B;AACA,gEAAgE,4BAA4B;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,4DAAwB;AAClE;AACA,6BAA6B;AAC7B;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sCAAsC,sDAAqB;AAC3D;AACA;AACA;AACA;AACA,mDAAmD,oBAAoB;AACvE;AACA;AACA,2CAA2C,4BAA4B;AACvE;AACA,4CAA4C,wDAA0B;AACtE;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,iEAAiE,mBAAI;AACrE;AACA;AACA;AACA,iCAAiC;AACjC,wDAAwD,mBAAI;AAC5D,4DAA4D,mBAAI;AAChE;AACA,8DAA8D;AAC9D;AACA;AACA,qCAAqC;AACrC,iCAAiC;AACjC,6BAA6B;AAC7B,oCAAoC,uBAAuB;AAC3D;AACA,iDAAiD,gDAAY;AAC7D;AACA;AACA,0CAA0C,2DAAuB;AACjE,mDAAmD,+BAA+B;AAClF;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,cAAc;AACd;AACA,0CAA0C,+BAA+B;AACzE;AACA;AACA;AACA,sCAAsC,6DAAyB;AAC/D;AACA;AACA,yBAAyB;AACzB;AACA,kBAAkB;AAClB;AACA;AACA,sCAAsC,6DAAyB;AAC/D;AACA,yBAAyB;AACzB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kCAAkC,sDAAkB;AACpD,2CAA2C,+BAA+B;AAC1E;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,UAAU;AACV,gBAAgB,4DAAuB;AACvC;AACA;AACA;AACA;AACA;AACA,sCAAsC,oDAAoB;AAC1D;AACA;AACA;AACA;AACA,uCAAuC,6CAAmB;AAC1D;AACA,8BAA8B,2BAA2B;AACzD;AACA,oBAAoB,qBAAK,IAAI,YAAY,oDAAoD,SAAS,oFAAoF,MAAM;AAChM;AACA;AACA,gBAAgB,oBAAI,iBAAiB,SAAS,+CAA+C,WAAW,gFAAgF,MAAM;AAC9L;AACA,gBAAgB,oCAAe;AAC/B;AACA;AACA;AACA,gBAAgB,oCAAe;AAC/B;AACA,iCAAiC,mDAA8B;AAC/D;AACA;AACA;AACA;AACA,wBAAwB,gDAAoB;AAC5C;AACA;AACA;AACA,oCAAoC,wCAAa,CAAC,4CAAuB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,kBAAkB,mFAAmF,mBAAmB;AACxL,wFAAwF,mBAAI;AAC5F;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,yCAAyC,6DAAyB;AAClE,oCAAoC,mBAAO,CAAC,IAAuB;AACnE,2CAA2C,mBAAI;AAC/C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,kCAAkC,sDAAkB;AACpD,2CAA2C,+BAA+B;AAC1E;AACA;AACA;AACA;AACA,+CAA+C,yBAAyB;AACxE;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA,cAAc;AACd,oBAAoB,KAAmE,EAAE,EAGxE;AACjB;AACA;AACA;AACA,KAAK;AACL;AACA,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,uBAAuB,4BAAY;AACnC;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI,eAAe;AACnB;AACA;AACA;AACA;AACA,uBAAuB,4BAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,6CAAe;AAC/D,QAAQ,oBAAI;AACZ,6BAA6B,sDAAwB;AACrD,YAAY,oBAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4BAAY;AAC3B;AACO;AACP;AACA,qBAAqB,WAAW;AAChC,WAAW,+DAA0B;AACrC;AACA;AACA;AACA,KAAK,kBAAkB,mCAAmC;AAC1D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa,+CAA+C;AAC5D;;AAEA,sC`5	  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/non-nullable.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/generate/meta.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/constants.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/generate/basic.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/generate/alternate.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/generate/opengraph.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/generate/icons.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/default-metadata.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/generate/utils.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-url.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-title.js|ssr!  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-opengraph.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/client-reference.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/lib/app-dir-module.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/interop-default.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-basics.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-icons.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/resolve-metadata.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/metadata.js|ssr5  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/async-storage/static-generation-async-storage-wrapper.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/lib/patch-fetch.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/flight-render-result.js|ssr®webpack://../../src/lib/format-server-error.ts"  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/export/helpers/is-navigation-signal-error.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/export/helpers/is-dynamic-usage-error.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/create-error-handler.js|ssr'  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-short-dynamic-param-type.js|ssr
  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/htmlescape.js|ssr'  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-script-nonce-from-header.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/types.js|ssr1  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/parse-and-validate-flight-router-state.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/validate-url.js|ssr6  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/create-flight-router-state-from-loader-tree.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/lib/server-ipc/utils.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/csrf-protection.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/action-handler.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/server-inserted-html.js|ssr´webpack://../../../src/shared/lib/encode-uri-path.ts  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/required-scripts.js|ssr(  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/make-get-server-inserted-html.js|ssr$  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-css-inlined-link-tags.js|ssr   webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-preloadable-fonts.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/parse-loader-tree.js|ssr!  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-asset-query-string.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-layer-assets.js|ssr(  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/has-loading-component-in-tree.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/interop-default.js|ssr.  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/create-component-styles-and-scripts.js|ssr   webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/create-component-tree.js|ssr-  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/walk-tree-with-flight-router-state.js|ssr!  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/static/static-renderer.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/use-flight-response.js|ssr  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/app-render.js|ssr`5‚   export function nonNullable(value) {
    return value !== null && value !== undefined;
}

//# sourceMappingURL=non-nullable.js.map¤
  import { jsx as _jsx } from "react/jsx-runtime";
import React from "react";
import { nonNullable } from "../../non-nullable";
export function Meta({ name, property, content, media }) {
    if (typeof content !== "undefined" && content !== null && content !== "") {
        return /*#__PURE__*/ _jsx("meta", {
            ...name ? {
                name
            } : {
                property
            },
            ...media ? {
                media
            } : undefined,
            content: typeof content === "string" ? content : content.toString()
        });
    }
    return null;
}
export function MetaFilter(items) {
    const acc = [];
    for (const item of items){
        if (Array.isArray(item)) {
            acc.push(...item.filter(nonNullable));
        } else if (nonNullable(item)) {
            acc.push(item);
        }
    }
    return acc;
}
function camelToSnake(camelCaseStr) {
    return camelCaseStr.replace(/([A-Z])/g, function(match) {
        return "_" + match.toLowerCase();
    });
}
function getMetaKey(prefix, key) {
    // Use `twitter:image` and `og:image` instead of `twitter:image:url` and `og:image:url`
    // to be more compatible as it's a more common format
    if ((prefix === "og:image" || prefix === "twitter:image") && key === "url") {
        return prefix;
    }
    if (prefix.startsWith("og:") || prefix.startsWith("twitter:")) {
        key = camelToSnake(key);
    }
    return prefix + ":" + key;
}
function ExtendMeta({ content, namePrefix, propertyPrefix }) {
    if (!content) return null;
    return MetaFilter(Object.entries(content).map(([k, v])=>{
        return typeof v === "undefined" ? null : Meta({
            ...propertyPrefix && {
                property: getMetaKey(propertyPrefix, k)
            },
            ...namePrefix && {
                name: getMetaKey(namePrefix, k)
            },
            content: typeof v === "string" ? v : v == null ? void 0 : v.toString()
        });
    }));
}
export function MultiMeta({ propertyPrefix, namePrefix, contents }) {
    if (typeof contents === "undefined" || contents === null) {
        return null;
    }
    return MetaFilter(contents.map((content)=>{
        if (typeof content === "string" || typeof content === "number" || content instanceof URL) {
            return Meta({
                ...propertyPrefix ? {
                    property: propertyPrefix
                } : {
                    name: namePrefix
                },
                content
            });
        } else {
            return ExtendMeta({
                namePrefix,
                propertyPrefix,
                content
            });
        }
    }));
}

//# sourceMappingURL=meta.js.map   export const ViewportMetaKeys = {
    width: "width",
    height: "height",
    initialScale: "initial-scale",
    minimumScale: "minimum-scale",
    maximumScale: "maximum-scale",
    viewportFit: "viewport-fit",
    userScalable: "user-scalable",
    interactiveWidget: "interactive-widget"
};
export const IconKeys = [
    "icon",
    "shortcut",
    "apple",
    "other"
];

//# sourceMappingURL=constants.js.mapŽ  import { jsx as _jsx } from "react/jsx-runtime";
import React from "react";
import { Meta, MetaFilter, MultiMeta } from "./meta";
import { ViewportMetaKeys } from "../constants";
// convert viewport object to string for viewport meta tag
function resolveViewportLayout(viewport) {
    let resolved = null;
    if (viewport && typeof viewport === "object") {
        resolved = "";
        for(const viewportKey_ in ViewportMetaKeys){
            const viewportKey = viewportKey_;
            if (viewportKey in viewport) {
                let value = viewport[viewportKey];
                if (typeof value === "boolean") value = value ? "yes" : "no";
                if (resolved) resolved += ", ";
                resolved += `${ViewportMetaKeys[viewportKey]}=${value}`;
            }
        }
    }
    return resolved;
}
export function ViewportMeta({ viewport }) {
    return MetaFilter([
        Meta({
            name: "viewport",
            content: resolveViewportLayout(viewport)
        }),
        ...viewport.themeColor ? viewport.themeColor.map((themeColor)=>Meta({
                name: "theme-color",
                content: themeColor.color,
                media: themeColor.media
            })) : [],
        Meta({
            name: "color-scheme",
            content: viewport.colorScheme
        })
    ]);
}
export function BasicMeta({ metadata }) {
    var _metadata_keywords, _metadata_robots, _metadata_robots1;
    return MetaFilter([
        /*#__PURE__*/ _jsx("meta", {
            charSet: "utf-8"
        }),
        metadata.title !== null && metadata.title.absolute ? /*#__PURE__*/ _jsx("title", {
            children: metadata.title.absolute
        }) : null,
        Meta({
            name: "description",
            content: metadata.description
        }),
        Meta({
            name: "application-name",
            content: metadata.applicationName
        }),
        ...metadata.authors ? metadata.authors.map((author)=>[
                author.url ? /*#__PURE__*/ _jsx("link", {
                    rel: "author",
                    href: author.url.toString()
                }) : null,
                Meta({
                    name: "author",
                    content: author.name
                })
            ]) : [],
        metadata.manifest ? /*#__PURE__*/ _jsx("link", {
            rel: "manifest",
            href: metadata.manifest.toString(),
            crossOrigin: "use-credentials"
        }) : null,
        Meta({
            name: "generator",
            content: metadata.generator
        }),
        Meta({
            name: "keywords",
            content: (_metadata_keywords = metadata.keywords) == null ? void 0 : _metadata_keywords.join(",")
        }),
        Meta({
            name: "referrer",
            content: metadata.referrer
        }),
        Meta({
            name: "creator",
            content: metadata.creator
        }),
        Meta({
            name: "publisher",
            content: metadata.publisher
        }),
        Meta({
            name: "robots",
            content: (_metadata_robots = metadata.robots) == null ? void 0 : _metadata_robots.basic
        }),
        Meta({
            name: "googlebot",
            content: (_metadata_robots1 = metadata.robots) == null ? void 0 : _metadata_robots1.googleBot
        }),
        Meta({
            name: "abstract",
            content: metadata.abstract
        }),
        ...metadata.archives ? metadata.archives.map((archive)=>/*#__PURE__*/ _jsx("link", {
                rel: "archives",
                href: archive
            })) : [],
        ...metadata.assets ? metadata.assets.map((asset)=>/*#__PURE__*/ _jsx("link", {
                rel: "assets",
                href: asset
            })) : [],
        ...metadata.bookmarks ? metadata.bookmarks.map((bookmark)=>/*#__PURE__*/ _jsx("link", {
                rel: "bookmarks",
                href: bookmark
            })) : [],
        Meta({
            name: "category",
            content: metadata.category
        }),
        Meta({
            name: "classification",
            content: metadata.classification
        }),
        ...metadata.other ? Object.entries(metadata.other).map(([name, content])=>{
            if (Array.isArray(content)) {
                return content.map((contentItem)=>Meta({
                        name,
                        content: contentItem
                    }));
            } else {
                return Meta({
                    name,
                    content
                });
            }
        }) : []
    ]);
}
export function ItunesMeta({ itunes }) {
    if (!itunes) return null;
    const { appId, appArgument } = itunes;
    let content = `app-id=${appId}`;
    if (appArgument) {
        content += `, app-argument=${appArgument}`;
    }
    return /*#__PURE__*/ _jsx("meta", {
        name: "apple-itunes-app",
        content: content
    });
}
const formatDetectionKeys = [
    "telephone",
    "date",
    "address",
    "email",
    "url"
];
export function FormatDetectionMeta({ formatDetection }) {
    if (!formatDetection) return null;
    let content = "";
    for (const key of formatDetectionKeys){
        if (key in formatDetection) {
            if (content) content += ", ";
            content += `${key}=no`;
        }
    }
    return /*#__PURE__*/ _jsx("meta", {
        name: "format-detection",
        content: content
    });
}
export function AppleWebAppMeta({ appleWebApp }) {
    if (!appleWebApp) return null;
    const { capable, title, startupImage, statusBarStyle } = appleWebApp;
    return MetaFilter([
        capable ? Meta({
            name: "apple-mobile-web-app-capable",
            content: "yes"
        }) : null,
        Meta({
            name: "apple-mobile-web-app-title",
            content: title
        }),
        startupImage ? startupImage.map((image)=>/*#__PURE__*/ _jsx("link", {
                href: image.url,
                media: image.media,
                rel: "apple-touch-startup-image"
            })) : null,
        statusBarStyle ? Meta({
            name: "apple-mobile-web-app-status-bar-style",
            content: statusBarStyle
        }) : null
    ]);
}
export function VerificationMeta({ verification }) {
    if (!verification) return null;
    return MetaFilter([
        MultiMeta({
            namePrefix: "google-site-verification",
            contents: verification.google
        }),
        MultiMeta({
            namePrefix: "y_key",
            contents: verification.yahoo
        }),
        MultiMeta({
            namePrefix: "yandex-verification",
            contents: verification.yandex
        }),
        MultiMeta({
            namePrefix: "me",
            contents: verification.me
        }),
        ...verification.other ? Object.entries(verification.other).map(([key, value])=>MultiMeta({
                namePrefix: key,
                contents: value
            })) : []
    ]);
}

//# sourceMappingURL=basic.js.map+  import { jsx as _jsx } from "react/jsx-runtime";
import React from "react";
import { MetaFilter } from "./meta";
function AlternateLink({ descriptor, ...props }) {
    if (!descriptor.url) return null;
    return /*#__PURE__*/ _jsx("link", {
        ...props,
        ...descriptor.title && {
            title: descriptor.title
        },
        href: descriptor.url.toString()
    });
}
export function AlternatesMetadata({ alternates }) {
    if (!alternates) return null;
    const { canonical, languages, media, types } = alternates;
    return MetaFilter([
        canonical ? AlternateLink({
            rel: "canonical",
            descriptor: canonical
        }) : null,
        languages ? Object.entries(languages).flatMap(([locale, descriptors])=>descriptors == null ? void 0 : descriptors.map((descriptor)=>AlternateLink({
                    rel: "alternate",
                    hrefLang: locale,
                    descriptor
                }))) : null,
        media ? Object.entries(media).flatMap(([mediaName, descriptors])=>descriptors == null ? void 0 : descriptors.map((descriptor)=>AlternateLink({
                    rel: "alternate",
                    media: mediaName,
                    descriptor
                }))) : null,
        types ? Object.entries(types).flatMap(([type, descriptors])=>descriptors == null ? void 0 : descriptors.map((descriptor)=>AlternateLink({
                    rel: "alternate",
                    type,
                    descriptor
                }))) : null
    ]);
}

//# sourceMappingURL=alternate.js.mapâ;  import { Meta, MetaFilter, MultiMeta } from "./meta";
export function OpenGraphMetadata({ openGraph }) {
    var _openGraph_title, _openGraph_url, _openGraph_ttl;
    if (!openGraph) {
        return null;
    }
    let typedOpenGraph;
    if ("type" in openGraph) {
        const openGraphType = openGraph.type;
        switch(openGraphType){
            case "website":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "website"
                    })
                ];
                break;
            case "article":
                var _openGraph_publishedTime, _openGraph_modifiedTime, _openGraph_expirationTime;
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "article"
                    }),
                    Meta({
                        property: "article:published_time",
                        content: (_openGraph_publishedTime = openGraph.publishedTime) == null ? void 0 : _openGraph_publishedTime.toString()
                    }),
                    Meta({
                        property: "article:modified_time",
                        content: (_openGraph_modifiedTime = openGraph.modifiedTime) == null ? void 0 : _openGraph_modifiedTime.toString()
                    }),
                    Meta({
                        property: "article:expiration_time",
                        content: (_openGraph_expirationTime = openGraph.expirationTime) == null ? void 0 : _openGraph_expirationTime.toString()
                    }),
                    MultiMeta({
                        propertyPrefix: "article:author",
                        contents: openGraph.authors
                    }),
                    Meta({
                        property: "article:section",
                        content: openGraph.section
                    }),
                    MultiMeta({
                        propertyPrefix: "article:tag",
                        contents: openGraph.tags
                    })
                ];
                break;
            case "book":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "book"
                    }),
                    Meta({
                        property: "book:isbn",
                        content: openGraph.isbn
                    }),
                    Meta({
                        property: "book:release_date",
                        content: openGraph.releaseDate
                    }),
                    MultiMeta({
                        propertyPrefix: "book:author",
                        contents: openGraph.authors
                    }),
                    MultiMeta({
                        propertyPrefix: "book:tag",
                        contents: openGraph.tags
                    })
                ];
                break;
            case "profile":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "profile"
                    }),
                    Meta({
                        property: "profile:first_name",
                        content: openGraph.firstName
                    }),
                    Meta({
                        property: "profile:last_name",
                        content: openGraph.lastName
                    }),
                    Meta({
                        property: "profile:username",
                        content: openGraph.username
                    }),
                    Meta({
                        property: "profile:gender",
                        content: openGraph.gender
                    })
                ];
                break;
            case "music.song":
                var _openGraph_duration;
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "music.song"
                    }),
                    Meta({
                        property: "music:duration",
                        content: (_openGraph_duration = openGraph.duration) == null ? void 0 : _openGraph_duration.toString()
                    }),
                    MultiMeta({
                        propertyPrefix: "music:album",
                        contents: openGraph.albums
                    }),
                    MultiMeta({
                        propertyPrefix: "music:musician",
                        contents: openGraph.musicians
                    })
                ];
                break;
            case "music.album":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "music.album"
                    }),
                    MultiMeta({
                        propertyPrefix: "music:song",
                        contents: openGraph.songs
                    }),
                    MultiMeta({
                        propertyPrefix: "music:musician",
                        contents: openGraph.musicians
                    }),
                    Meta({
                        property: "music:release_date",
                        content: openGraph.releaseDate
                    })
                ];
                break;
            case "music.playlist":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "music.playlist"
                    }),
                    MultiMeta({
                        propertyPrefix: "music:song",
                        contents: openGraph.songs
                    }),
                    MultiMeta({
                        propertyPrefix: "music:creator",
                        contents: openGraph.creators
                    })
                ];
                break;
            case "music.radio_station":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "music.radio_station"
                    }),
                    MultiMeta({
                        propertyPrefix: "music:creator",
                        contents: openGraph.creators
                    })
                ];
                break;
            case "video.movie":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "video.movie"
                    }),
                    MultiMeta({
                        propertyPrefix: "video:actor",
                        contents: openGraph.actors
                    }),
                    MultiMeta({
                        propertyPrefix: "video:director",
                        contents: openGraph.directors
                    }),
                    MultiMeta({
                        propertyPrefix: "video:writer",
                        contents: openGraph.writers
                    }),
                    Meta({
                        property: "video:duration",
                        content: openGraph.duration
                    }),
                    Meta({
                        property: "video:release_date",
                        content: openGraph.releaseDate
                    }),
                    MultiMeta({
                        propertyPrefix: "video:tag",
                        contents: openGraph.tags
                    })
                ];
                break;
            case "video.episode":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "video.episode"
                    }),
                    MultiMeta({
                        propertyPrefix: "video:actor",
                        contents: openGraph.actors
                    }),
                    MultiMeta({
                        propertyPrefix: "video:director",
                        contents: openGraph.directors
                    }),
                    MultiMeta({
                        propertyPrefix: "video:writer",
                        contents: openGraph.writers
                    }),
                    Meta({
                        property: "video:duration",
                        content: openGraph.duration
                    }),
                    Meta({
                        property: "video:release_date",
                        content: openGraph.releaseDate
                    }),
                    MultiMeta({
                        propertyPrefix: "video:tag",
                        contents: openGraph.tags
                    }),
                    Meta({
                        property: "video:series",
                        content: openGraph.series
                    })
                ];
                break;
            case "video.tv_show":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "video.tv_show"
                    })
                ];
                break;
            case "video.other":
                typedOpenGraph = [
                    Meta({
                        property: "og:type",
                        content: "video.other"
                    })
                ];
                break;
            default:
                const _exhaustiveCheck = openGraphType;
                throw new Error(`Invalid OpenGraph type: ${_exhaustiveCheck}`);
        }
    }
    return MetaFilter([
        Meta({
            property: "og:determiner",
            content: openGraph.determiner
        }),
        Meta({
            property: "og:title",
            content: (_openGraph_title = openGraph.title) == null ? void 0 : _openGraph_title.absolute
        }),
        Meta({
            property: "og:description",
            content: openGraph.description
        }),
        Meta({
            property: "og:url",
            content: (_openGraph_url = openGraph.url) == null ? void 0 : _openGraph_url.toString()
        }),
        Meta({
            property: "og:site_name",
            content: openGraph.siteName
        }),
        Meta({
            property: "og:locale",
            content: openGraph.locale
        }),
        Meta({
            property: "og:country_name",
            content: openGraph.countryName
        }),
        Meta({
            property: "og:ttl",
            content: (_openGraph_ttl = openGraph.ttl) == null ? void 0 : _openGraph_ttl.toString()
        }),
        MultiMeta({
            propertyPrefix: "og:image",
            contents: openGraph.images
        }),
        MultiMeta({
            propertyPrefix: "og:video",
            contents: openGraph.videos
        }),
        MultiMeta({
            propertyPrefix: "og:audio",
            contents: openGraph.audio
        }),
        MultiMeta({
            propertyPrefix: "og:email",
            contents: openGraph.emails
        }),
        MultiMeta({
            propertyPrefix: "og:phone_number",
            contents: openGraph.phoneNumbers
        }),
        MultiMeta({
            propertyPrefix: "og:fax_number",
            contents: openGraph.faxNumbers
        }),
        MultiMeta({
            propertyPrefix: "og:locale:alternate",
            contents: openGraph.alternateLocale
        }),
        ...typedOpenGraph ? typedOpenGraph : []
    ]);
}
function TwitterAppItem({ app, type }) {
    var _app_url_type, _app_url;
    return [
        Meta({
            name: `twitter:app:name:${type}`,
            content: app.name
        }),
        Meta({
            name: `twitter:app:id:${type}`,
            content: app.id[type]
        }),
        Meta({
            name: `twitter:app:url:${type}`,
            content: (_app_url = app.url) == null ? void 0 : (_app_url_type = _app_url[type]) == null ? void 0 : _app_url_type.toString()
        })
    ];
}
export function TwitterMetadata({ twitter }) {
    var _twitter_title;
    if (!twitter) return null;
    const { card } = twitter;
    return MetaFilter([
        Meta({
            name: "twitter:card",
            content: card
        }),
        Meta({
            name: "twitter:site",
            content: twitter.site
        }),
        Meta({
            name: "twitter:site:id",
            content: twitter.siteId
        }),
        Meta({
            name: "twitter:creator",
            content: twitter.creator
        }),
        Meta({
            name: "twitter:creator:id",
            content: twitter.creatorId
        }),
        Meta({
            name: "twitter:title",
            content: (_twitter_title = twitter.title) == null ? void 0 : _twitter_title.absolute
        }),
        Meta({
            name: "twitter:description",
            content: twitter.description
        }),
        MultiMeta({
            namePrefix: "twitter:image",
            contents: twitter.images
        }),
        ...card === "player" ? twitter.players.flatMap((player)=>[
                Meta({
                    name: "twitter:player",
                    content: player.playerUrl.toString()
                }),
                Meta({
                    name: "twitter:player:stream",
                    content: player.streamUrl.toString()
                }),
                Meta({
                    name: "twitter:player:width",
                    content: player.width
                }),
                Meta({
                    name: "twitter:player:height",
                    content: player.height
                })
            ]) : [],
        ...card === "app" ? [
            TwitterAppItem({
                app: twitter.app,
                type: "iphone"
            }),
            TwitterAppItem({
                app: twitter.app,
                type: "ipad"
            }),
            TwitterAppItem({
                app: twitter.app,
                type: "googleplay"
            })
        ] : []
    ]);
}
export function AppLinksMeta({ appLinks }) {
    if (!appLinks) return null;
    return MetaFilter([
        MultiMeta({
            propertyPrefix: "al:ios",
            contents: appLinks.ios
        }),
        MultiMeta({
            propertyPrefix: "al:iphone",
            contents: appLinks.iphone
        }),
        MultiMeta({
            propertyPrefix: "al:ipad",
            contents: appLinks.ipad
        }),
        MultiMeta({
            propertyPrefix: "al:android",
            contents: appLinks.android
        }),
        MultiMeta({
            propertyPrefix: "al:windows_phone",
            contents: appLinks.windows_phone
        }),
        MultiMeta({
            propertyPrefix: "al:windows",
            contents: appLinks.windows
        }),
        MultiMeta({
            propertyPrefix: "al:windows_universal",
            contents: appLinks.windows_universal
        }),
        MultiMeta({
            propertyPrefix: "al:web",
            contents: appLinks.web
        })
    ]);
}

//# sourceMappingURL=opengraph.js.mapË  import { jsx as _jsx } from "react/jsx-runtime";
import React from "react";
import { MetaFilter } from "./meta";
function IconDescriptorLink({ icon }) {
    const { url, rel = "icon", ...props } = icon;
    return /*#__PURE__*/ _jsx("link", {
        rel: rel,
        href: url.toString(),
        ...props
    });
}
function IconLink({ rel, icon }) {
    if (typeof icon === "object" && !(icon instanceof URL)) {
        if (!icon.rel && rel) icon.rel = rel;
        return IconDescriptorLink({
            icon
        });
    } else {
        const href = icon.toString();
        return /*#__PURE__*/ _jsx("link", {
            rel: rel,
            href: href
        });
    }
}
export function IconsMetadata({ icons }) {
    if (!icons) return null;
    const shortcutList = icons.shortcut;
    const iconList = icons.icon;
    const appleList = icons.apple;
    const otherList = icons.other;
    return MetaFilter([
        shortcutList ? shortcutList.map((icon)=>IconLink({
                rel: "shortcut icon",
                icon
            })) : null,
        iconList ? iconList.map((icon)=>IconLink({
                rel: "icon",
                icon
            })) : null,
        appleList ? appleList.map((icon)=>IconLink({
                rel: "apple-touch-icon",
                icon
            })) : null,
        otherList ? otherList.map((icon)=>IconDescriptorLink({
                icon
            })) : null
    ]);
}

//# sourceMappingURL=icons.js.mapý  export function createDefaultViewport() {
    return {
        // name=viewport
        width: "device-width",
        initialScale: 1,
        // visual metadata
        themeColor: null,
        colorScheme: null
    };
}
export function createDefaultMetadata() {
    return {
        // Deprecated ones
        viewport: null,
        themeColor: null,
        colorScheme: null,
        metadataBase: null,
        // Other values are all null
        title: null,
        description: null,
        applicationName: null,
        authors: null,
        generator: null,
        keywords: null,
        referrer: null,
        creator: null,
        publisher: null,
        robots: null,
        manifest: null,
        alternates: {
            canonical: null,
            languages: null,
            media: null,
            types: null
        },
        icons: null,
        openGraph: null,
        twitter: null,
        verification: {},
        appleWebApp: null,
        formatDetection: null,
        itunes: null,
        abstract: null,
        appLinks: null,
        archives: null,
        assets: null,
        bookmarks: null,
        category: null,
        classification: null,
        other: {}
    };
}

//# sourceMappingURL=default-metadata.js.map}  function resolveArray(value) {
    if (Array.isArray(value)) {
        return value;
    }
    return [
        value
    ];
}
function resolveAsArrayOrUndefined(value) {
    if (typeof value === "undefined" || value === null) {
        return undefined;
    }
    return resolveArray(value);
}
export { resolveAsArrayOrUndefined, resolveArray };

//# sourceMappingURL=utils.js.mapë  import path from "../../../shared/lib/isomorphic/path";
function isStringOrURL(icon) {
    return typeof icon === "string" || icon instanceof URL;
}
function createLocalMetadataBase() {
    return new URL(`http://localhost:${process.env.PORT || 3000}`);
}
function getPreviewDeploymentUrl() {
    const origin = process.env.VERCEL_BRANCH_URL || process.env.VERCEL_URL;
    return origin ? new URL(`https://${origin}`) : undefined;
}
function getProductionDeploymentUrl() {
    const origin = process.env.VERCEL_PROJECT_PRODUCTION_URL;
    return origin ? new URL(`https://${origin}`) : undefined;
}
// For deployment url for metadata routes, prefer to use the deployment url if possible
// as these routes are unique to the deployments url.
export function getSocialImageFallbackMetadataBase(metadataBase) {
    const isMetadataBaseMissing = !metadataBase;
    const defaultMetadataBase = createLocalMetadataBase();
    const previewDeploymentUrl = getPreviewDeploymentUrl();
    const productionDeploymentUrl = getProductionDeploymentUrl();
    let fallbackMetadataBase;
    if (process.env.NODE_ENV === "development") {
        fallbackMetadataBase = defaultMetadataBase;
    } else {
        fallbackMetadataBase = process.env.NODE_ENV === "production" && previewDeploymentUrl && process.env.VERCEL_ENV === "preview" ? previewDeploymentUrl : metadataBase || productionDeploymentUrl || defaultMetadataBase;
    }
    return {
        fallbackMetadataBase,
        isMetadataBaseMissing
    };
}
function resolveUrl(url, metadataBase) {
    if (url instanceof URL) return url;
    if (!url) return null;
    try {
        // If we can construct a URL instance from url, ignore metadataBase
        const parsedUrl = new URL(url);
        return parsedUrl;
    } catch  {}
    if (!metadataBase) {
        metadataBase = createLocalMetadataBase();
    }
    // Handle relative or absolute paths
    const basePath = metadataBase.pathname || "";
    const joinedPath = path.posix.join(basePath, url);
    return new URL(joinedPath, metadataBase);
}
// Resolve with `pathname` if `url` is a relative path.
function resolveRelativeUrl(url, pathname) {
    if (typeof url === "string" && url.startsWith("./")) {
        return path.posix.resolve(pathname, url);
    }
    return url;
}
// The regex is matching logic from packages/next/src/lib/load-custom-routes.ts
const FILE_REGEX = /^(?:\/((?!\.well-known(?:\/.*)?)(?:[^/]+\/)*[^/]+\.\w+))(\/?|$)/i;
function isFilePattern(pathname) {
    return FILE_REGEX.test(pathname);
}
// Resolve `pathname` if `url` is a relative path the compose with `metadataBase`.
function resolveAbsoluteUrlWithPathname(url, metadataBase, { trailingSlash, pathname }) {
    // Resolve url with pathname that always starts with `/`
    url = resolveRelativeUrl(url, pathname);
    // Convert string url or URL instance to absolute url string,
    // if there's case needs to be resolved with metadataBase
    let resolvedUrl = "";
    const result = metadataBase ? resolveUrl(url, metadataBase) : url;
    if (typeof result === "string") {
        resolvedUrl = result;
    } else {
        resolvedUrl = result.pathname === "/" ? result.origin : result.href;
    }
    // Add trailing slash if it's enabled for urls matches the condition
    // - Not external, same origin with metadataBase
    // - Doesn't have query
    if (trailingSlash && !resolvedUrl.endsWith("/")) {
        let isRelative = resolvedUrl.startsWith("/");
        let hasQuery = resolvedUrl.includes("?");
        let isExternal = false;
        let isFileUrl = false;
        if (!isRelative) {
            try {
                const parsedUrl = new URL(resolvedUrl);
                isExternal = metadataBase != null && parsedUrl.origin !== metadataBase.origin;
                isFileUrl = isFilePattern(parsedUrl.pathname);
            } catch  {
                // If it's not a valid URL, treat it as external
                isExternal = true;
            }
            if (// Do not apply trailing slash for file like urls, aligning with the behavior with `trailingSlash`
            !isFileUrl && !isExternal && !hasQuery) return `${resolvedUrl}/`;
        }
    }
    return resolvedUrl;
}
export { isStringOrURL, resolveUrl, resolveRelativeUrl, resolveAbsoluteUrlWithPathname,  };

//# sourceMappingURL=resolve-url.js.map©  function resolveTitleTemplate(template, title) {
    return template ? template.replace(/%s/g, title) : title;
}
export function resolveTitle(title, stashedTemplate) {
    let resolved;
    const template = typeof title !== "string" && title && "template" in title ? title.template : null;
    if (typeof title === "string") {
        resolved = resolveTitleTemplate(stashedTemplate, title);
    } else if (title) {
        if ("default" in title) {
            resolved = resolveTitleTemplate(stashedTemplate, title.default);
        }
        if ("absolute" in title && title.absolute) {
            resolved = title.absolute;
        }
    }
    if (title && typeof title !== "string") {
        return {
            template,
            absolute: resolved || ""
        };
    } else {
        return {
            absolute: resolved || title || "",
            template
        };
    }
}

//# sourceMappingURL=resolve-title.js.map=  import { resolveAsArrayOrUndefined } from "../generate/utils";
import { getSocialImageFallbackMetadataBase, isStringOrURL, resolveUrl, resolveAbsoluteUrlWithPathname } from "./resolve-url";
import { resolveTitle } from "./resolve-title";
import { isFullStringUrl } from "../../url";
import { warnOnce } from "../../../build/output/log";
const OgTypeFields = {
    article: [
        "authors",
        "tags"
    ],
    song: [
        "albums",
        "musicians"
    ],
    playlist: [
        "albums",
        "musicians"
    ],
    radio: [
        "creators"
    ],
    video: [
        "actors",
        "directors",
        "writers",
        "tags"
    ],
    basic: [
        "emails",
        "phoneNumbers",
        "faxNumbers",
        "alternateLocale",
        "audio",
        "videos"
    ]
};
function resolveAndValidateImage(item, metadataBase, isMetadataBaseMissing) {
    if (!item) return undefined;
    const isItemUrl = isStringOrURL(item);
    const inputUrl = isItemUrl ? item : item.url;
    if (!inputUrl) return undefined;
    validateResolvedImageUrl(inputUrl, metadataBase, isMetadataBaseMissing);
    return isItemUrl ? {
        url: resolveUrl(inputUrl, metadataBase)
    } : {
        ...item,
        // Update image descriptor url
        url: resolveUrl(inputUrl, metadataBase)
    };
}
export function resolveImages(images, metadataBase) {
    const resolvedImages = resolveAsArrayOrUndefined(images);
    if (!resolvedImages) return resolvedImages;
    const { isMetadataBaseMissing, fallbackMetadataBase } = getSocialImageFallbackMetadataBase(metadataBase);
    const nonNullableImages = [];
    for (const item of resolvedImages){
        const resolvedItem = resolveAndValidateImage(item, fallbackMetadataBase, isMetadataBaseMissing);
        if (!resolvedItem) continue;
        nonNullableImages.push(resolvedItem);
    }
    return nonNullableImages;
}
const ogTypeToFields = {
    article: OgTypeFields.article,
    book: OgTypeFields.article,
    "music.song": OgTypeFields.song,
    "music.album": OgTypeFields.song,
    "music.playlist": OgTypeFields.playlist,
    "music.radio_station": OgTypeFields.radio,
    "video.movie": OgTypeFields.video,
    "video.episode": OgTypeFields.video
};
function getFieldsByOgType(ogType) {
    if (!ogType || !(ogType in ogTypeToFields)) return OgTypeFields.basic;
    return ogTypeToFields[ogType].concat(OgTypeFields.basic);
}
function validateResolvedImageUrl(inputUrl, fallbackMetadataBase, isMetadataBaseMissing) {
    // Only warn on the image url that needs to be resolved with metadataBase
    if (typeof inputUrl === "string" && !isFullStringUrl(inputUrl) && isMetadataBaseMissing) {
        warnOnce(`metadataBase property in metadata export is not set for resolving social open graph or twitter images, using "${fallbackMetadataBase.origin}". See https://nextjs.org/docs/app/api-reference/functions/generate-metadata#metadatabase`);
    }
}
export const resolveOpenGraph = (openGraph, metadataBase, metadataContext, titleTemplate)=>{
    if (!openGraph) return null;
    function resolveProps(target, og) {
        const ogType = og && "type" in og ? og.type : undefined;
        const keys = getFieldsByOgType(ogType);
        for (const k of keys){
            const key = k;
            if (key in og && key !== "url") {
                const value = og[key];
                if (value) {
                    const arrayValue = resolveAsArrayOrUndefined(value);
                    target[key] = arrayValue;
                }
            }
        }
        target.images = resolveImages(og.images, metadataBase);
    }
    const resolved = {
        ...openGraph,
        title: resolveTitle(openGraph.title, titleTemplate)
    };
    resolveProps(resolved, openGraph);
    resolved.url = openGraph.url ? resolveAbsoluteUrlWithPathname(openGraph.url, metadataBase, metadataContext) : null;
    return resolved;
};
const TwitterBasicInfoKeys = [
    "site",
    "siteId",
    "creator",
    "creatorId",
    "description"
];
export const resolveTwitter = (twitter, metadataBase, titleTemplate)=>{
    var _resolved_images;
    if (!twitter) return null;
    let card = "card" in twitter ? twitter.card : undefined;
    const resolved = {
        ...twitter,
        title: resolveTitle(twitter.title, titleTemplate)
    };
    for (const infoKey of TwitterBasicInfoKeys){
        resolved[infoKey] = twitter[infoKey] || null;
    }
    resolved.images = resolveImages(twitter.images, metadataBase);
    card = card || (((_resolved_images = resolved.images) == null ? void 0 : _resolved_images.length) ? "summary_large_image" : "summary");
    resolved.card = card;
    if ("card" in resolved) {
        switch(resolved.card){
            case "player":
                {
                    resolved.players = resolveAsArrayOrUndefined(resolved.players) || [];
                    break;
                }
            case "app":
                {
                    resolved.app = resolved.app || {};
                    break;
                }
            default:
                break;
        }
    }
    return resolved;
};

//# sourceMappingURL=resolve-opengraph.js.mapÅ   export function isClientReference(reference) {
    return (reference == null ? void 0 : reference.$$typeof) === Symbol.for("react.client.reference");
}

//# sourceMappingURL=client-reference.js.map  import { DEFAULT_SEGMENT_KEY } from "../../shared/lib/segment";
export async function getLayoutOrPageModule(loaderTree) {
    const { layout, page, defaultPage } = loaderTree[2];
    const isLayout = typeof layout !== "undefined";
    const isPage = typeof page !== "undefined";
    const isDefaultPage = typeof defaultPage !== "undefined" && loaderTree[0] === DEFAULT_SEGMENT_KEY;
    let value = undefined;
    let modType = undefined;
    if (isLayout) {
        value = await layout[0]();
        modType = "layout";
    } else if (isPage) {
        value = await page[0]();
        modType = "page";
    } else if (isDefaultPage) {
        value = await defaultPage[0]();
        modType = "page";
    }
    return [
        value,
        modType
    ];
}
export async function getComponentTypeModule(loaderTree, componentType) {
    const { [componentType]: component } = loaderTree[2];
    if (typeof component !== "undefined") {
        return await component[0]();
    }
    return undefined;
}

//# sourceMappingURL=app-dir-module.js.maps   export function interopDefault(mod) {
    return mod.default || mod;
}

//# sourceMappingURL=interop-default.js.mapN  import { resolveAsArrayOrUndefined } from "../generate/utils";
import { resolveAbsoluteUrlWithPathname } from "./resolve-url";
function resolveAlternateUrl(url, metadataBase, metadataContext) {
    // If alter native url is an URL instance,
    // we treat it as a URL base and resolve with current pathname
    if (url instanceof URL) {
        url = new URL(metadataContext.pathname, url);
    }
    return resolveAbsoluteUrlWithPathname(url, metadataBase, metadataContext);
}
export const resolveThemeColor = (themeColor)=>{
    var _resolveAsArrayOrUndefined;
    if (!themeColor) return null;
    const themeColorDescriptors = [];
    (_resolveAsArrayOrUndefined = resolveAsArrayOrUndefined(themeColor)) == null ? void 0 : _resolveAsArrayOrUndefined.forEach((descriptor)=>{
        if (typeof descriptor === "string") themeColorDescriptors.push({
            color: descriptor
        });
        else if (typeof descriptor === "object") themeColorDescriptors.push({
            color: descriptor.color,
            media: descriptor.media
        });
    });
    return themeColorDescriptors;
};
function resolveUrlValuesOfObject(obj, metadataBase, metadataContext) {
    if (!obj) return null;
    const result = {};
    for (const [key, value] of Object.entries(obj)){
        if (typeof value === "string" || value instanceof URL) {
            result[key] = [
                {
                    url: resolveAlternateUrl(value, metadataBase, metadataContext)
                }
            ];
        } else {
            result[key] = [];
            value == null ? void 0 : value.forEach((item, index)=>{
                const url = resolveAlternateUrl(item.url, metadataBase, metadataContext);
                result[key][index] = {
                    url,
                    title: item.title
                };
            });
        }
    }
    return result;
}
function resolveCanonicalUrl(urlOrDescriptor, metadataBase, metadataContext) {
    if (!urlOrDescriptor) return null;
    const url = typeof urlOrDescriptor === "string" || urlOrDescriptor instanceof URL ? urlOrDescriptor : urlOrDescriptor.url;
    // Return string url because structureClone can't handle URL instance
    return {
        url: resolveAlternateUrl(url, metadataBase, metadataContext)
    };
}
export const resolveAlternates = (alternates, metadataBase, context)=>{
    if (!alternates) return null;
    const canonical = resolveCanonicalUrl(alternates.canonical, metadataBase, context);
    const languages = resolveUrlValuesOfObject(alternates.languages, metadataBase, context);
    const media = resolveUrlValuesOfObject(alternates.media, metadataBase, context);
    const types = resolveUrlValuesOfObject(alternates.types, metadataBase, context);
    const result = {
        canonical,
        languages,
        media,
        types
    };
    return result;
};
const robotsKeys = [
    "noarchive",
    "nosnippet",
    "noimageindex",
    "nocache",
    "notranslate",
    "indexifembedded",
    "nositelinkssearchbox",
    "unavailable_after",
    "max-video-preview",
    "max-image-preview",
    "max-snippet"
];
const resolveRobotsValue = (robots)=>{
    if (!robots) return null;
    if (typeof robots === "string") return robots;
    const values = [];
    if (robots.index) values.push("index");
    else if (typeof robots.index === "boolean") values.push("noindex");
    if (robots.follow) values.push("follow");
    else if (typeof robots.follow === "boolean") values.push("nofollow");
    for (const key of robotsKeys){
        const value = robots[key];
        if (typeof value !== "undefined" && value !== false) {
            values.push(typeof value === "boolean" ? key : `${key}:${value}`);
        }
    }
    return values.join(", ");
};
export const resolveRobots = (robots)=>{
    if (!robots) return null;
    return {
        basic: resolveRobotsValue(robots),
        googleBot: typeof robots !== "string" ? resolveRobotsValue(robots.googleBot) : null
    };
};
const VerificationKeys = [
    "google",
    "yahoo",
    "yandex",
    "me",
    "other"
];
export const resolveVerification = (verification)=>{
    if (!verification) return null;
    const res = {};
    for (const key of VerificationKeys){
        const value = verification[key];
        if (value) {
            if (key === "other") {
                res.other = {};
                for(const otherKey in verification.other){
                    const otherValue = resolveAsArrayOrUndefined(verification.other[otherKey]);
                    if (otherValue) res.other[otherKey] = otherValue;
                }
            } else res[key] = resolveAsArrayOrUndefined(value);
        }
    }
    return res;
};
export const resolveAppleWebApp = (appWebApp)=>{
    var _resolveAsArrayOrUndefined;
    if (!appWebApp) return null;
    if (appWebApp === true) {
        return {
            capable: true
        };
    }
    const startupImages = appWebApp.startupImage ? (_resolveAsArrayOrUndefined = resolveAsArrayOrUndefined(appWebApp.startupImage)) == null ? void 0 : _resolveAsArrayOrUndefined.map((item)=>typeof item === "string" ? {
            url: item
        } : item) : null;
    return {
        capable: "capable" in appWebApp ? !!appWebApp.capable : true,
        title: appWebApp.title || null,
        startupImage: startupImages,
        statusBarStyle: appWebApp.statusBarStyle || "default"
    };
};
export const resolveAppLinks = (appLinks)=>{
    if (!appLinks) return null;
    for(const key in appLinks){
        // @ts-ignore // TODO: type infer
        appLinks[key] = resolveAsArrayOrUndefined(appLinks[key]);
    }
    return appLinks;
};
export const resolveItunes = (itunes, metadataBase, context)=>{
    if (!itunes) return null;
    return {
        appId: itunes.appId,
        appArgument: itunes.appArgument ? resolveAlternateUrl(itunes.appArgument, metadataBase, context) : undefined
    };
};

//# sourceMappingURL=resolve-basics.js.map¤  import { resolveAsArrayOrUndefined } from "../generate/utils";
import { isStringOrURL } from "./resolve-url";
import { IconKeys } from "../constants";
export function resolveIcon(icon) {
    if (isStringOrURL(icon)) return {
        url: icon
    };
    else if (Array.isArray(icon)) return icon;
    return icon;
}
export const resolveIcons = (icons)=>{
    if (!icons) {
        return null;
    }
    const resolved = {
        icon: [],
        apple: []
    };
    if (Array.isArray(icons)) {
        resolved.icon = icons.map(resolveIcon).filter(Boolean);
    } else if (isStringOrURL(icons)) {
        resolved.icon = [
            resolveIcon(icons)
        ];
    } else {
        for (const key of IconKeys){
            const values = resolveAsArrayOrUndefined(icons[key]);
            if (values) resolved[key] = values.map(resolveIcon);
        }
    }
    return resolved;
};

//# sourceMappingURL=resolve-icons.js.map;Y  import { createDefaultMetadata, createDefaultViewport } from "./default-metadata";
import { resolveOpenGraph, resolveTwitter } from "./resolvers/resolve-opengraph";
import { resolveTitle } from "./resolvers/resolve-title";
import { resolveAsArrayOrUndefined } from "./generate/utils";
import { isClientReference } from "../client-reference";
import { getComponentTypeModule, getLayoutOrPageModule } from "../../server/lib/app-dir-module";
import { interopDefault } from "../interop-default";
import { resolveAlternates, resolveAppleWebApp, resolveAppLinks, resolveRobots, resolveThemeColor, resolveVerification, resolveItunes } from "./resolvers/resolve-basics";
import { resolveIcons } from "./resolvers/resolve-icons";
import { getTracer } from "../../server/lib/trace/tracer";
import { ResolveMetadataSpan } from "../../server/lib/trace/constants";
import { PAGE_SEGMENT_KEY } from "../../shared/lib/segment";
import * as Log from "../../build/output/log";
function hasIconsProperty(icons, prop) {
    if (!icons) return false;
    if (prop === "icon") {
        // Detect if icons.icon will be presented, icons array and icons string will all be merged into icons.icon
        return !!(typeof icons === "string" || icons instanceof URL || Array.isArray(icons) || prop in icons && icons[prop]);
    } else {
        // Detect if icons.apple will be presented, only icons.apple will be merged into icons.apple
        return !!(typeof icons === "object" && prop in icons && icons[prop]);
    }
}
function mergeStaticMetadata(source, target, staticFilesMetadata, metadataContext, titleTemplates) {
    var _source_twitter, _source_openGraph;
    if (!staticFilesMetadata) return;
    const { icon, apple, openGraph, twitter, manifest } = staticFilesMetadata;
    // file based metadata is specified and current level metadata icons is not specified
    if (icon && !hasIconsProperty(source == null ? void 0 : source.icons, "icon") || apple && !hasIconsProperty(source == null ? void 0 : source.icons, "apple")) {
        target.icons = {
            icon: icon || [],
            apple: apple || []
        };
    }
    // file based metadata is specified and current level metadata twitter.images is not specified
    if (twitter && !(source == null ? void 0 : (_source_twitter = source.twitter) == null ? void 0 : _source_twitter.hasOwnProperty("images"))) {
        const resolvedTwitter = resolveTwitter({
            ...target.twitter,
            images: twitter
        }, target.metadataBase, titleTemplates.twitter);
        target.twitter = resolvedTwitter;
    }
    // file based metadata is specified and current level metadata openGraph.images is not specified
    if (openGraph && !(source == null ? void 0 : (_source_openGraph = source.openGraph) == null ? void 0 : _source_openGraph.hasOwnProperty("images"))) {
        const resolvedOpenGraph = resolveOpenGraph({
            ...target.openGraph,
            images: openGraph
        }, target.metadataBase, metadataContext, titleTemplates.openGraph);
        target.openGraph = resolvedOpenGraph;
    }
    if (manifest) {
        target.manifest = manifest;
    }
    return target;
}
// Merge the source metadata into the resolved target metadata.
function mergeMetadata({ source, target, staticFilesMetadata, titleTemplates, metadataContext, buildState }) {
    // If there's override metadata, prefer it otherwise fallback to the default metadata.
    const metadataBase = typeof (source == null ? void 0 : source.metadataBase) !== "undefined" ? source.metadataBase : target.metadataBase;
    for(const key_ in source){
        const key = key_;
        switch(key){
            case "title":
                {
                    target.title = resolveTitle(source.title, titleTemplates.title);
                    break;
                }
            case "alternates":
                {
                    target.alternates = resolveAlternates(source.alternates, metadataBase, metadataContext);
                    break;
                }
            case "openGraph":
                {
                    target.openGraph = resolveOpenGraph(source.openGraph, metadataBase, metadataContext, titleTemplates.openGraph);
                    break;
                }
            case "twitter":
                {
                    target.twitter = resolveTwitter(source.twitter, metadataBase, titleTemplates.twitter);
                    break;
                }
            case "verification":
                target.verification = resolveVerification(source.verification);
                break;
            case "icons":
                {
                    target.icons = resolveIcons(source.icons);
                    break;
                }
            case "appleWebApp":
                target.appleWebApp = resolveAppleWebApp(source.appleWebApp);
                break;
            case "appLinks":
                target.appLinks = resolveAppLinks(source.appLinks);
                break;
            case "robots":
                {
                    target.robots = resolveRobots(source.robots);
                    break;
                }
            case "archives":
            case "assets":
            case "bookmarks":
            case "keywords":
                {
                    target[key] = resolveAsArrayOrUndefined(source[key]);
                    break;
                }
            case "authors":
                {
                    target[key] = resolveAsArrayOrUndefined(source.authors);
                    break;
                }
            case "itunes":
                {
                    target[key] = resolveItunes(source.itunes, metadataBase, metadataContext);
                    break;
                }
            // directly assign fields that fallback to null
            case "applicationName":
            case "description":
            case "generator":
            case "creator":
            case "publisher":
            case "category":
            case "classification":
            case "referrer":
            case "formatDetection":
            case "manifest":
                // @ts-ignore TODO: support inferring
                target[key] = source[key] || null;
                break;
            case "other":
                target.other = Object.assign({}, target.other, source.other);
                break;
            case "metadataBase":
                target.metadataBase = metadataBase;
                break;
            default:
                {
                    if ((key === "viewport" || key === "themeColor" || key === "colorScheme") && source[key] != null) {
                        buildState.warnings.add(`Unsupported metadata ${key} is configured in metadata export in ${metadataContext.pathname}. Please move it to viewport export instead.\nRead more: https://nextjs.org/docs/app/api-reference/functions/generate-viewport`);
                    }
                    break;
                }
        }
    }
    mergeStaticMetadata(source, target, staticFilesMetadata, metadataContext, titleTemplates);
}
function mergeViewport({ target, source }) {
    if (!source) return;
    for(const key_ in source){
        const key = key_;
        switch(key){
            case "themeColor":
                {
                    target.themeColor = resolveThemeColor(source.themeColor);
                    break;
                }
            case "colorScheme":
                target.colorScheme = source.colorScheme || null;
                break;
            default:
                if (typeof source[key] !== "undefined") {
                    // @ts-ignore viewport properties
                    target[key] = source[key];
                }
                break;
        }
    }
}
async function getDefinedViewport(mod, props, tracingProps) {
    if (isClientReference(mod)) {
        return null;
    }
    if (typeof mod.generateViewport === "function") {
        const { route } = tracingProps;
        return (parent)=>getTracer().trace(ResolveMetadataSpan.generateViewport, {
                spanName: `generateViewport ${route}`,
                attributes: {
                    "next.page": route
                }
            }, ()=>mod.generateViewport(props, parent));
    }
    return mod.viewport || null;
}
async function getDefinedMetadata(mod, props, tracingProps) {
    // Layer is a client component, we just skip it. It can't have metadata exported.
    // Return early to avoid accessing properties error for client references.
    if (isClientReference(mod)) {
        return null;
    }
    if (typeof mod.generateMetadata === "function") {
        const { route } = tracingProps;
        return (parent)=>getTracer().trace(ResolveMetadataSpan.generateMetadata, {
                spanName: `generateMetadata ${route}`,
                attributes: {
                    "next.page": route
                }
            }, ()=>mod.generateMetadata(props, parent));
    }
    return mod.metadata || null;
}
async function collectStaticImagesFiles(metadata, props, type) {
    var _this;
    if (!(metadata == null ? void 0 : metadata[type])) return undefined;
    const iconPromises = metadata[type].map(async (imageModule)=>interopDefault(await imageModule(props)));
    return (iconPromises == null ? void 0 : iconPromises.length) > 0 ? (_this = await Promise.all(iconPromises)) == null ? void 0 : _this.flat() : undefined;
}
async function resolveStaticMetadata(components, props) {
    const { metadata } = components;
    if (!metadata) return null;
    const [icon, apple, openGraph, twitter] = await Promise.all([
        collectStaticImagesFiles(metadata, props, "icon"),
        collectStaticImagesFiles(metadata, props, "apple"),
        collectStaticImagesFiles(metadata, props, "openGraph"),
        collectStaticImagesFiles(metadata, props, "twitter")
    ]);
    const staticMetadata = {
        icon,
        apple,
        openGraph,
        twitter,
        manifest: metadata.manifest
    };
    return staticMetadata;
}
// [layout.metadata, static files metadata] -> ... -> [page.metadata, static files metadata]
export async function collectMetadata({ tree, metadataItems, errorMetadataItem, props, route, errorConvention }) {
    let mod;
    let modType;
    const hasErrorConventionComponent = Boolean(errorConvention && tree[2][errorConvention]);
    if (errorConvention) {
        mod = await getComponentTypeModule(tree, "layout");
        modType = errorConvention;
    } else {
        [mod, modType] = await getLayoutOrPageModule(tree);
    }
    if (modType) {
        route += `/${modType}`;
    }
    const staticFilesMetadata = await resolveStaticMetadata(tree[2], props);
    const metadataExport = mod ? await getDefinedMetadata(mod, props, {
        route
    }) : null;
    const viewportExport = mod ? await getDefinedViewport(mod, props, {
        route
    }) : null;
    metadataItems.push([
        metadataExport,
        staticFilesMetadata,
        viewportExport
    ]);
    if (hasErrorConventionComponent && errorConvention) {
        const errorMod = await getComponentTypeModule(tree, errorConvention);
        const errorViewportExport = errorMod ? await getDefinedViewport(errorMod, props, {
            route
        }) : null;
        const errorMetadataExport = errorMod ? await getDefinedMetadata(errorMod, props, {
            route
        }) : null;
        errorMetadataItem[0] = errorMetadataExport;
        errorMetadataItem[1] = staticFilesMetadata;
        errorMetadataItem[2] = errorViewportExport;
    }
}
export async function resolveMetadataItems({ tree, parentParams, metadataItems, errorMetadataItem, treePrefix = [], getDynamicParamFromSegment, searchParams, errorConvention }) {
    const [segment, parallelRoutes, { page }] = tree;
    const currentTreePrefix = [
        ...treePrefix,
        segment
    ];
    const isPage = typeof page !== "undefined";
    // Handle dynamic segment params.
    const segmentParam = getDynamicParamFromSegment(segment);
    /**
   * Create object holding the parent params and current params
   */ const currentParams = // Handle null case where dynamic param is optional
    segmentParam && segmentParam.value !== null ? {
        ...parentParams,
        [segmentParam.param]: segmentParam.value
    } : parentParams;
    let layerProps;
    if (isPage) {
        layerProps = {
            params: currentParams,
            searchParams
        };
    } else {
        layerProps = {
            params: currentParams
        };
    }
    await collectMetadata({
        tree,
        metadataItems,
        errorMetadataItem,
        errorConvention,
        props: layerProps,
        route: currentTreePrefix// __PAGE__ shouldn't be shown in a route
        .filter((s)=>s !== PAGE_SEGMENT_KEY).join("/")
    });
    for(const key in parallelRoutes){
        const childTree = parallelRoutes[key];
        await resolveMetadataItems({
            tree: childTree,
            metadataItems,
            errorMetadataItem,
            parentParams: currentParams,
            treePrefix: currentTreePrefix,
            searchParams,
            getDynamicParamFromSegment,
            errorConvention
        });
    }
    if (Object.keys(parallelRoutes).length === 0 && errorConvention) {
        // If there are no parallel routes, place error metadata as the last item.
        // e.g. layout -> layout -> not-found
        metadataItems.push(errorMetadataItem);
    }
    return metadataItems;
}
const isTitleTruthy = (title)=>!!(title == null ? void 0 : title.absolute);
const hasTitle = (metadata)=>isTitleTruthy(metadata == null ? void 0 : metadata.title);
function inheritFromMetadata(target, metadata) {
    if (target) {
        if (!hasTitle(target) && hasTitle(metadata)) {
            target.title = metadata.title;
        }
        if (!target.description && metadata.description) {
            target.description = metadata.description;
        }
    }
}
const commonOgKeys = [
    "title",
    "description",
    "images"
];
function postProcessMetadata(metadata, titleTemplates) {
    const { openGraph, twitter } = metadata;
    if (openGraph) {
        // If there's openGraph information but not configured in twitter,
        // inherit them from openGraph metadata.
        let autoFillProps = {};
        const hasTwTitle = hasTitle(twitter);
        const hasTwDescription = twitter == null ? void 0 : twitter.description;
        const hasTwImages = Boolean((twitter == null ? void 0 : twitter.hasOwnProperty("images")) && twitter.images);
        if (!hasTwTitle) {
            if (isTitleTruthy(openGraph.title)) {
                autoFillProps.title = openGraph.title;
            } else if (metadata.title && isTitleTruthy(metadata.title)) {
                autoFillProps.title = metadata.title;
            }
        }
        if (!hasTwDescription) autoFillProps.description = openGraph.description || metadata.description || undefined;
        if (!hasTwImages) autoFillProps.images = openGraph.images;
        if (Object.keys(autoFillProps).length > 0) {
            const partialTwitter = resolveTwitter(autoFillProps, metadata.metadataBase, titleTemplates.twitter);
            if (metadata.twitter) {
                metadata.twitter = Object.assign({}, metadata.twitter, {
                    ...!hasTwTitle && {
                        title: partialTwitter == null ? void 0 : partialTwitter.title
                    },
                    ...!hasTwDescription && {
                        description: partialTwitter == null ? void 0 : partialTwitter.description
                    },
                    ...!hasTwImages && {
                        images: partialTwitter == null ? void 0 : partialTwitter.images
                    }
                });
            } else {
                metadata.twitter = partialTwitter;
            }
        }
    }
    // If there's no title and description configured in openGraph or twitter,
    // use the title and description from metadata.
    inheritFromMetadata(openGraph, metadata);
    inheritFromMetadata(twitter, metadata);
    return metadata;
}
function collectMetadataExportPreloading(results, dynamicMetadataExportFn, resolvers) {
    const result = dynamicMetadataExportFn(new Promise((resolve)=>{
        resolvers.push(resolve);
    }));
    if (result instanceof Promise) {
        // since we eager execute generateMetadata and
        // they can reject at anytime we need to ensure
        // we attach the catch handler right away to
        // prevent unhandled rejections crashing the process
        result.catch((err)=>{
            return {
                __nextError: err
            };
        });
    }
    results.push(result);
}
async function getMetadataFromExport(getPreloadMetadataExport, dynamicMetadataResolveState, metadataItems, currentIndex, resolvedMetadata, metadataResults) {
    const metadataExport = getPreloadMetadataExport(metadataItems[currentIndex]);
    const dynamicMetadataResolvers = dynamicMetadataResolveState.resolvers;
    let metadata = null;
    if (typeof metadataExport === "function") {
        // Only preload at the beginning when resolves are empty
        if (!dynamicMetadataResolvers.length) {
            for(let j = currentIndex; j < metadataItems.length; j++){
                const preloadMetadataExport = getPreloadMetadataExport(metadataItems[j]) // metadataItems[j][0]
                ;
                // call each `generateMetadata function concurrently and stash their resolver
                if (typeof preloadMetadataExport === "function") {
                    collectMetadataExportPreloading(metadataResults, preloadMetadataExport, dynamicMetadataResolvers);
                }
            }
        }
        const resolveParent = dynamicMetadataResolvers[dynamicMetadataResolveState.resolvingIndex];
        const metadataResult = metadataResults[dynamicMetadataResolveState.resolvingIndex++];
        // In dev we clone and freeze to prevent relying on mutating resolvedMetadata directly.
        // In prod we just pass resolvedMetadata through without any copying.
        const currentResolvedMetadata = process.env.NODE_ENV === "development" ? Object.freeze(require("./clone-metadata").cloneMetadata(resolvedMetadata)) : resolvedMetadata;
        // This resolve should unblock the generateMetadata function if it awaited the parent
        // argument. If it didn't await the parent argument it might already have a value since it was
        // called concurrently. Regardless we await the return value before continuing on to the next layer
        resolveParent(currentResolvedMetadata);
        metadata = metadataResult instanceof Promise ? await metadataResult : metadataResult;
        if (metadata && typeof metadata === "object" && "__nextError" in metadata) {
            // re-throw caught metadata error from preloading
            throw metadata["__nextError"];
        }
    } else if (metadataExport !== null && typeof metadataExport === "object") {
        // This metadataExport is the object form
        metadata = metadataExport;
    }
    return metadata;
}
export async function accumulateMetadata(metadataItems, metadataContext) {
    const resolvedMetadata = createDefaultMetadata();
    const metadataResults = [];
    let titleTemplates = {
        title: null,
        twitter: null,
        openGraph: null
    };
    // Loop over all metadata items again, merging synchronously any static object exports,
    // awaiting any static promise exports, and resolving parent metadata and awaiting any generated metadata
    const dynamicMetadataResolvers = {
        resolvers: [],
        resolvingIndex: 0
    };
    const buildState = {
        warnings: new Set()
    };
    for(let i = 0; i < metadataItems.length; i++){
        const staticFilesMetadata = metadataItems[i][1];
        const metadata = await getMetadataFromExport((metadataItem)=>metadataItem[0], dynamicMetadataResolvers, metadataItems, i, resolvedMetadata, metadataResults);
        mergeMetadata({
            target: resolvedMetadata,
            source: metadata,
            metadataContext,
            staticFilesMetadata,
            titleTemplates,
            buildState
        });
        // If the layout is the same layer with page, skip the leaf layout and leaf page
        // The leaf layout and page are the last two items
        if (i < metadataItems.length - 2) {
            var _resolvedMetadata_title, _resolvedMetadata_openGraph, _resolvedMetadata_twitter;
            titleTemplates = {
                title: ((_resolvedMetadata_title = resolvedMetadata.title) == null ? void 0 : _resolvedMetadata_title.template) || null,
                openGraph: ((_resolvedMetadata_openGraph = resolvedMetadata.openGraph) == null ? void 0 : _resolvedMetadata_openGraph.title.template) || null,
                twitter: ((_resolvedMetadata_twitter = resolvedMetadata.twitter) == null ? void 0 : _resolvedMetadata_twitter.title.template) || null
            };
        }
    }
    // Only log warnings if there are any, and only once after the metadata resolving process is finished
    if (buildState.warnings.size > 0) {
        for (const warning of buildState.warnings){
            Log.warn(warning);
        }
    }
    return postProcessMetadata(resolvedMetadata, titleTemplates);
}
export async function accumulateViewport(metadataItems) {
    const resolvedViewport = createDefaultViewport();
    const viewportResults = [];
    const dynamicMetadataResolvers = {
        resolvers: [],
        resolvingIndex: 0
    };
    for(let i = 0; i < metadataItems.length; i++){
        const viewport = await getMetadataFromExport((metadataItem)=>metadataItem[2], dynamicMetadataResolvers, metadataItems, i, resolvedViewport, viewportResults);
        mergeViewport({
            target: resolvedViewport,
            source: viewport
        });
    }
    return resolvedViewport;
}
export async function resolveMetadata({ tree, parentParams, metadataItems, errorMetadataItem, getDynamicParamFromSegment, searchParams, errorConvention, metadataContext }) {
    const resolvedMetadataItems = await resolveMetadataItems({
        tree,
        parentParams,
        metadataItems,
        errorMetadataItem,
        getDynamicParamFromSegment,
        searchParams,
        errorConvention
    });
    let error;
    let metadata = createDefaultMetadata();
    let viewport = createDefaultViewport();
    try {
        viewport = await accumulateViewport(resolvedMetadataItems);
        metadata = await accumulateMetadata(resolvedMetadataItems, metadataContext);
    } catch (err) {
        error = err;
    }
    return [
        error,
        metadata,
        viewport
    ];
}

//# sourceMappingURL=resolve-metadata.js.mapõ  import { jsx as _jsx, Fragment as _Fragment } from "react/jsx-runtime";
import React from "react";
import { AppleWebAppMeta, FormatDetectionMeta, ItunesMeta, BasicMeta, ViewportMeta, VerificationMeta } from "./generate/basic";
import { AlternatesMetadata } from "./generate/alternate";
import { OpenGraphMetadata, TwitterMetadata, AppLinksMeta } from "./generate/opengraph";
import { IconsMetadata } from "./generate/icons";
import { resolveMetadata } from "./resolve-metadata";
import { MetaFilter } from "./generate/meta";
import { createDefaultMetadata, createDefaultViewport } from "./default-metadata";
import { isNotFoundError } from "../../client/components/not-found";
// Use a promise to share the status of the metadata resolving,
// returning two components `MetadataTree` and `MetadataOutlet`
// `MetadataTree` is the one that will be rendered at first in the content sequence for metadata tags.
// `MetadataOutlet` is the one that will be rendered under error boundaries for metadata resolving errors.
// In this way we can let the metadata tags always render successfully,
// and the error will be caught by the error boundary and trigger fallbacks.
export function createMetadataComponents({ tree, pathname, trailingSlash, query, getDynamicParamFromSegment, appUsingSizeAdjustment, errorType, createDynamicallyTrackedSearchParams }) {
    const metadataContext = {
        // Make sure the pathname without query string
        pathname: pathname.split("?")[0],
        trailingSlash
    };
    let resolve;
    // Only use promise.resolve here to avoid unhandled rejections
    const metadataErrorResolving = new Promise((res)=>{
        resolve = res;
    });
    async function MetadataTree() {
        const defaultMetadata = createDefaultMetadata();
        const defaultViewport = createDefaultViewport();
        let metadata = defaultMetadata;
        let viewport = defaultViewport;
        let error;
        const errorMetadataItem = [
            null,
            null,
            null
        ];
        const errorConvention = errorType === "redirect" ? undefined : errorType;
        const searchParams = createDynamicallyTrackedSearchParams(query);
        const [resolvedError, resolvedMetadata, resolvedViewport] = await resolveMetadata({
            tree,
            parentParams: {},
            metadataItems: [],
            errorMetadataItem,
            searchParams,
            getDynamicParamFromSegment,
            errorConvention,
            metadataContext
        });
        if (!resolvedError) {
            viewport = resolvedViewport;
            metadata = resolvedMetadata;
            resolve(undefined);
        } else {
            error = resolvedError;
            // If the error triggers in initial metadata resolving, re-resolve with proper error type.
            // They'll be saved for flight data, when hydrates, it will replaces the SSR'd metadata with this.
            // for not-found error: resolve not-found metadata
            if (!errorType && isNotFoundError(resolvedError)) {
                const [notFoundMetadataError, notFoundMetadata, notFoundViewport] = await resolveMetadata({
                    tree,
                    parentParams: {},
                    metadataItems: [],
                    errorMetadataItem,
                    searchParams,
                    getDynamicParamFromSegment,
                    errorConvention: "not-found",
                    metadataContext
                });
                viewport = notFoundViewport;
                metadata = notFoundMetadata;
                error = notFoundMetadataError || error;
            }
            resolve(error);
        }
        const elements = MetaFilter([
            ViewportMeta({
                viewport: viewport
            }),
            BasicMeta({
                metadata
            }),
            AlternatesMetadata({
                alternates: metadata.alternates
            }),
            ItunesMeta({
                itunes: metadata.itunes
            }),
            FormatDetectionMeta({
                formatDetection: metadata.formatDetection
            }),
            VerificationMeta({
                verification: metadata.verification
            }),
            AppleWebAppMeta({
                appleWebApp: metadata.appleWebApp
            }),
            OpenGraphMetadata({
                openGraph: metadata.openGraph
            }),
            TwitterMetadata({
                twitter: metadata.twitter
            }),
            AppLinksMeta({
                appLinks: metadata.appLinks
            }),
            IconsMetadata({
                icons: metadata.icons
            })
        ]);
        if (appUsingSizeAdjustment) elements.push(/*#__PURE__*/ _jsx("meta", {
            name: "next-size-adjust"
        }));
        return /*#__PURE__*/ _jsx(_Fragment, {
            children: elements.map((el, index)=>{
                return /*#__PURE__*/ React.cloneElement(el, {
                    key: index
                });
            })
        });
    }
    async function MetadataOutlet() {
        const error = await metadataErrorResolving;
        if (error) {
            throw error;
        }
        return null;
    }
    return [
        MetadataTree,
        MetadataOutlet
    ];
}

//# sourceMappingURL=metadata.js.mapˆ  import { createPrerenderState } from "../../server/app-render/dynamic-rendering";
export const StaticGenerationAsyncStorageWrapper = {
    wrap (storage, { urlPathname, renderOpts, requestEndedState }, callback) {
        /**
     * Rules of Static & Dynamic HTML:
     *
     *    1.) We must generate static HTML unless the caller explicitly opts
     *        in to dynamic HTML support.
     *
     *    2.) If dynamic HTML support is requested, we must honor that request
     *        or throw an error. It is the sole responsibility of the caller to
     *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.
     *
     *    3.) If the request is in draft mode, we must generate dynamic HTML.
     *
     *    4.) If the request is a server action, we must generate dynamic HTML.
     *
     * These rules help ensure that other existing features like request caching,
     * coalescing, and ISR continue working as intended.
     */ const isStaticGeneration = !renderOpts.supportsDynamicHTML && !renderOpts.isDraftMode && !renderOpts.isServerAction;
        const prerenderState = isStaticGeneration && renderOpts.experimental.ppr ? createPrerenderState(renderOpts.isDebugPPRSkeleton) : null;
        const store = {
            isStaticGeneration,
            urlPathname,
            pagePath: renderOpts.originalPathname,
            incrementalCache: // we fallback to a global incremental cache for edge-runtime locally
            // so that it can access the fs cache without mocks
            renderOpts.incrementalCache || globalThis.__incrementalCache,
            isRevalidate: renderOpts.isRevalidate,
            isPrerendering: renderOpts.nextExport,
            fetchCache: renderOpts.fetchCache,
            isOnDemandRevalidate: renderOpts.isOnDemandRevalidate,
            isDraftMode: renderOpts.isDraftMode,
            prerenderState,
            requestEndedState
        };
        // TODO: remove this when we resolve accessing the store outside the execution context
        renderOpts.store = store;
        return storage.run(store, callback, store);
    }
};

//# sourceMappingURL=static-generation-async-storage-wrapper.js.map›õÿÿò  import { RSC_CONTENT_TYPE_HEADER } from "../../client/components/app-router-headers";
import RenderResult from "../render-result";
/**
 * Flight Response is always set to RSC_CONTENT_TYPE_HEADER to ensure it does not get interpreted as HTML.
 */ export class FlightRenderResult extends RenderResult {
    constructor(response){
        super(response, {
            contentType: RSC_CONTENT_TYPE_HEADER,
            metadata: {}
        });
    }
}

//# sourceMappingURL=flight-render-result.js.mapË  import { isNotFoundError } from "../../client/components/not-found";
import { isRedirectError } from "../../client/components/redirect";
/**
 * Returns true if the error is a navigation signal error. These errors are
 * thrown by user code to perform navigation operations and interrupt the React
 * render.
 */ export const isNavigationSignalError = (err)=>isNotFoundError(err) || isRedirectError(err);

//# sourceMappingURL=is-navigation-signal-error.js.map¥  import { isDynamicServerError } from "../../client/components/hooks-server-context";
import { isBailoutToCSRError } from "../../shared/lib/lazy-dynamic/bailout-to-csr";
import { isNavigationSignalError } from "./is-navigation-signal-error";
export const isDynamicUsageError = (err)=>isDynamicServerError(err) || isBailoutToCSRError(err) || isNavigationSignalError(err);

//# sourceMappingURL=is-dynamic-usage-error.js.mapÐ  import stringHash from "next/dist/compiled/string-hash";
import { formatServerError } from "../../lib/format-server-error";
import { SpanStatusCode, getTracer } from "../lib/trace/tracer";
import { isAbortError } from "../pipe-readable";
import { isDynamicUsageError } from "../../export/helpers/is-dynamic-usage-error";
export const ErrorHandlerSource = {
    serverComponents: "serverComponents",
    flightData: "flightData",
    html: "html"
};
/**
 * Create error handler for renderers.
 * Tolerate dynamic server errors during prerendering so console
 * isn't spammed with unactionable errors
 */ export function createErrorHandler({ /**
   * Used for debugging
   */ source, dev, isNextExport, errorLogger, digestErrorsMap, allCapturedErrors, silenceLogger }) {
    return (err, errorInfo)=>{
        var _err_message;
        // If the error already has a digest, respect the original digest,
        // so it won't get re-generated into another new error.
        if (!err.digest) {
            // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.
            err.digest = stringHash(err.message + ((errorInfo == null ? void 0 : errorInfo.stack) || err.stack || "")).toString();
        }
        const digest = err.digest;
        if (allCapturedErrors) allCapturedErrors.push(err);
        // These errors are expected. We return the digest
        // so that they can be properly handled.
        if (isDynamicUsageError(err)) return err.digest;
        // If the response was closed, we don't need to log the error.
        if (isAbortError(err)) return;
        if (!digestErrorsMap.has(digest)) {
            digestErrorsMap.set(digest, err);
        } else if (source === ErrorHandlerSource.html) {
            // For SSR errors, if we have the existing digest in errors map,
            // we should use the existing error object to avoid duplicate error logs.
            err = digestErrorsMap.get(digest);
        }
        // Format server errors in development to add more helpful error messages
        if (dev) {
            formatServerError(err);
        }
        // Used for debugging error source
        // console.error(source, err)
        // Don't log the suppressed error during export
        if (!(isNextExport && (err == null ? void 0 : (_err_message = err.message) == null ? void 0 : _err_message.includes("The specific message is omitted in production builds to avoid leaking sensitive details.")))) {
            // Record exception in an active span, if available.
            const span = getTracer().getActiveScopeSpan();
            if (span) {
                span.recordException(err);
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: err.message
                });
            }
            if (!silenceLogger) {
                if (errorLogger) {
                    errorLogger(err).catch(()=>{});
                } else {
                    // The error logger is currently not provided in the edge runtime.
                    // Use the exposed `__next_log_error__` instead.
                    // This will trace error traces to the original source code.
                    if (typeof __next_log_error__ === "function") {
                        __next_log_error__(err);
                    } else {
                        console.error(err);
                    }
                }
            }
        }
        return err.digest;
    };
}

//# sourceMappingURL=create-error-handler.js.map  export const dynamicParamTypes = {
    catchall: "c",
    "catchall-intercepted": "ci",
    "optional-catchall": "oc",
    dynamic: "d",
    "dynamic-intercepted": "di"
};
/**
 * Shorten the dynamic param in order to make it smaller when transmitted to the browser.
 */ export function getShortDynamicParamType(type) {
    const short = dynamicParamTypes[type];
    if (!short) {
        throw new Error("Unknown dynamic param type");
    }
    return short;
}

//# sourceMappingURL=get-short-dynamic-param-type.js.mapþ  // This utility is based on https://github.com/zertosh/htmlescape
// License: https://github.com/zertosh/htmlescape/blob/0527ca7156a524d256101bb310a9f970f63078ad/LICENSE
const ESCAPE_LOOKUP = {
    "&": "\\u0026",
    ">": "\\u003e",
    "<": "\\u003c",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
};
export const ESCAPE_REGEX = /[&><\u2028\u2029]/g;
export function htmlEscapeJsonString(str) {
    return str.replace(ESCAPE_REGEX, (match)=>ESCAPE_LOOKUP[match]);
}

//# sourceMappingURL=htmlescape.js.map]  import { ESCAPE_REGEX } from "../htmlescape";
export function getScriptNonceFromHeader(cspHeaderValue) {
    var _directive_split_slice_map_find;
    const directives = cspHeaderValue// Directives are split by ';'.
    .split(";").map((directive)=>directive.trim());
    // First try to find the directive for the 'script-src', otherwise try to
    // fallback to the 'default-src'.
    const directive = directives.find((dir)=>dir.startsWith("script-src")) || directives.find((dir)=>dir.startsWith("default-src"));
    // If no directive could be found, then we're done.
    if (!directive) {
        return;
    }
    // Extract the nonce from the directive
    const nonce = (_directive_split_slice_map_find = directive.split(" ")// Remove the 'strict-src'/'default-src' string, this can't be the nonce.
    .slice(1).map((source)=>source.trim())// Find the first source with the 'nonce-' prefix.
    .find((source)=>source.startsWith("'nonce-") && source.length > 8 && source.endsWith("'"))) == null ? void 0 : _directive_split_slice_map_find.slice(7, -1);
    // If we could't find the nonce, then we're done.
    if (!nonce) {
        return;
    }
    // Don't accept the nonce value if it contains HTML escape characters.
    // Technically, the spec requires a base64'd value, but this is just an
    // extra layer.
    if (ESCAPE_REGEX.test(nonce)) {
        throw new Error("Nonce value from Content-Security-Policy contained HTML escape characters.\nLearn more: https://nextjs.org/docs/messages/nonce-contained-invalid-characters");
    }
    return nonce;
}

//# sourceMappingURL=get-script-nonce-from-header.js.map0  import s from "next/dist/compiled/superstruct";
const dynamicParamTypesSchema = s.enums([
    "c",
    "ci",
    "oc",
    "d",
    "di"
]);
const segmentSchema = s.union([
    s.string(),
    s.tuple([
        s.string(),
        s.string(),
        dynamicParamTypesSchema
    ])
]);
// unfortunately the tuple is not understood well by Describe so we have to
// use any here. This does not have any impact on the runtime type since the validation
// does work correctly.
export const flightRouterStateSchema = s.tuple([
    segmentSchema,
    s.record(s.string(), s.lazy(()=>flightRouterStateSchema)),
    s.optional(s.nullable(s.string())),
    s.optional(s.nullable(s.union([
        s.literal("refetch"),
        s.literal("refresh")
    ]))),
    s.optional(s.boolean())
]);

//# sourceMappingURL=types.js.mapn  import { flightRouterStateSchema } from "./types";
import { assert } from "next/dist/compiled/superstruct";
export function parseAndValidateFlightRouterState(stateHeader) {
    if (typeof stateHeader === "undefined") {
        return undefined;
    }
    if (Array.isArray(stateHeader)) {
        throw new Error("Multiple router state headers were sent. This is not allowed.");
    }
    // We limit the size of the router state header to ~40kb. This is to prevent
    // a malicious user from sending a very large header and slowing down the
    // resolving of the router state.
    // This is around 2,000 nested or parallel route segment states:
    // '{"children":["",{}]}'.length === 20.
    if (stateHeader.length > 20 * 2000) {
        throw new Error("The router state header was too large.");
    }
    try {
        const state = JSON.parse(decodeURIComponent(stateHeader));
        assert(state, flightRouterStateSchema);
        return state;
    } catch  {
        throw new Error("The router state header was sent but could not be parsed.");
    }
}

//# sourceMappingURL=parse-and-validate-flight-router-state.js.map   const DUMMY_ORIGIN = "http://n";
const INVALID_URL_MESSAGE = "Invalid request URL";
export function validateURL(url) {
    if (!url) {
        throw new Error(INVALID_URL_MESSAGE);
    }
    try {
        const parsed = new URL(url, DUMMY_ORIGIN);
        // Avoid origin change by extra slashes in pathname
        if (parsed.origin !== DUMMY_ORIGIN) {
            throw new Error(INVALID_URL_MESSAGE);
        }
        return url;
    } catch  {
        throw new Error(INVALID_URL_MESSAGE);
    }
}

//# sourceMappingURL=validate-url.js.map7  import { PAGE_SEGMENT_KEY } from "../../shared/lib/segment";
export function addSearchParamsIfPageSegment(segment, searchParams) {
    const isPageSegment = segment === PAGE_SEGMENT_KEY;
    if (isPageSegment) {
        const stringifiedQuery = JSON.stringify(searchParams);
        return stringifiedQuery !== "{}" ? segment + "?" + stringifiedQuery : segment;
    }
    return segment;
}
export function createFlightRouterStateFromLoaderTree([segment, parallelRoutes, { layout }], getDynamicParamFromSegment, searchParams, rootLayoutIncluded = false) {
    const dynamicParam = getDynamicParamFromSegment(segment);
    const treeSegment = dynamicParam ? dynamicParam.treeSegment : segment;
    const segmentTree = [
        addSearchParamsIfPageSegment(treeSegment, searchParams),
        {}
    ];
    if (!rootLayoutIncluded && typeof layout !== "undefined") {
        rootLayoutIncluded = true;
        segmentTree[4] = true;
    }
    segmentTree[1] = Object.keys(parallelRoutes).reduce((existingValue, currentValue)=>{
        existingValue[currentValue] = createFlightRouterStateFromLoaderTree(parallelRoutes[currentValue], getDynamicParamFromSegment, searchParams, rootLayoutIncluded);
        return existingValue;
    }, {});
    return segmentTree;
}

//# sourceMappingURL=create-flight-router-state-from-loader-tree.js.mapB  export const ipcForbiddenHeaders = [
    "accept-encoding",
    "keepalive",
    "keep-alive",
    "content-encoding",
    "transfer-encoding",
    // https://github.com/nodejs/undici/issues/1470
    "connection",
    // marked as unsupported by undici: https://github.com/nodejs/undici/blob/c83b084879fa0bb8e0469d31ec61428ac68160d5/lib/core/request.js#L354
    "expect"
];
export const actionsForbiddenHeaders = [
    ...ipcForbiddenHeaders,
    "content-length",
    "set-cookie"
];
export const filterReqHeaders = (headers, forbiddenHeaders)=>{
    // Some browsers are not matching spec and sending Content-Length: 0. This causes issues in undici
    // https://github.com/nodejs/undici/issues/2046
    if (headers["content-length"] && headers["content-length"] === "0") {
        delete headers["content-length"];
    }
    for (const [key, value] of Object.entries(headers)){
        if (forbiddenHeaders.includes(key) || !(Array.isArray(value) || typeof value === "string")) {
            delete headers[key];
        }
    }
    return headers;
};

//# sourceMappingURL=utils.js.mapd  // micromatch is only available at node runtime, so it cannot be used here since the code path that calls this function
// can be run from edge. This is a simple implementation that safely achieves the required functionality.
// the goal is to match the functionality for remotePatterns as defined here -
// https://nextjs.org/docs/app/api-reference/components/image#remotepatterns
// TODO - retrofit micromatch to work in edge and use that instead
function matchWildcardDomain(domain, pattern) {
    const domainParts = domain.split(".");
    const patternParts = pattern.split(".");
    if (patternParts.length < 1) {
        // pattern is empty and therefore invalid to match against
        return false;
    }
    if (domainParts.length < patternParts.length) {
        // domain has too few segments and thus cannot match
        return false;
    }
    let depth = 0;
    while(patternParts.length && depth++ < 2){
        const patternPart = patternParts.pop();
        const domainPart = domainParts.pop();
        switch(patternPart){
            case "":
            case "*":
            case "**":
                {
                    // invalid pattern. pattern segments must be non empty
                    // Additionally wildcards are only supported below the domain level
                    return false;
                }
            default:
                {
                    if (domainPart !== patternPart) {
                        return false;
                    }
                }
        }
    }
    while(patternParts.length){
        const patternPart = patternParts.pop();
        const domainPart = domainParts.pop();
        switch(patternPart){
            case "":
                {
                    // invalid pattern. pattern segments must be non empty
                    return false;
                }
            case "*":
                {
                    // wildcard matches anything so we continue if the domain part is non-empty
                    if (domainPart) {
                        continue;
                    } else {
                        return false;
                    }
                }
            case "**":
                {
                    // if this is not the last item in the pattern the pattern is invalid
                    if (patternParts.length > 0) {
                        return false;
                    }
                    // recursive wildcard matches anything so we terminate here if the domain part is non empty
                    return domainPart !== undefined;
                }
            default:
                {
                    if (domainPart !== patternPart) {
                        return false;
                    }
                }
        }
    }
    // We exhausted the pattern. If we also exhausted the domain we have a match
    return domainParts.length === 0;
}
export const isCsrfOriginAllowed = (originDomain, allowedOrigins = [])=>{
    return allowedOrigins.some((allowedOrigin)=>allowedOrigin && (allowedOrigin === originDomain || matchWildcardDomain(originDomain, allowedOrigin)));
};

//# sourceMappingURL=csrf-protection.js.mapqv  import { RSC_HEADER, RSC_CONTENT_TYPE_HEADER } from "../../client/components/app-router-headers";
import { isNotFoundError } from "../../client/components/not-found";
import { getRedirectStatusCodeFromError, getURLFromRedirectError, isRedirectError } from "../../client/components/redirect";
import RenderResult from "../render-result";
import { FlightRenderResult } from "./flight-render-result";
import { filterReqHeaders, actionsForbiddenHeaders } from "../lib/server-ipc/utils";
import { appendMutableCookies, getModifiedCookieValues } from "../web/spec-extension/adapters/request-cookies";
import { NEXT_CACHE_REVALIDATED_TAGS_HEADER, NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER } from "../../lib/constants";
import { getServerActionRequestMetadata } from "../lib/server-action-request-meta";
import { isCsrfOriginAllowed } from "./csrf-protection";
import { warn } from "../../build/output/log";
import { RequestCookies, ResponseCookies } from "../web/spec-extension/cookies";
import { HeadersAdapter } from "../web/spec-extension/adapters/headers";
import { fromNodeOutgoingHttpHeaders } from "../web/utils";
import { selectWorkerForForwarding } from "./action-utils";
function formDataFromSearchQueryString(query) {
    const searchParams = new URLSearchParams(query);
    const formData = new FormData();
    for (const [key, value] of searchParams){
        formData.append(key, value);
    }
    return formData;
}
function nodeHeadersToRecord(headers) {
    const record = {};
    for (const [key, value] of Object.entries(headers)){
        if (value !== undefined) {
            record[key] = Array.isArray(value) ? value.join(", ") : `${value}`;
        }
    }
    return record;
}
function getForwardedHeaders(req, res) {
    // Get request headers and cookies
    const requestHeaders = req.headers;
    const requestCookies = new RequestCookies(HeadersAdapter.from(requestHeaders));
    // Get response headers and cookies
    const responseHeaders = res.getHeaders();
    const responseCookies = new ResponseCookies(fromNodeOutgoingHttpHeaders(responseHeaders));
    // Merge request and response headers
    const mergedHeaders = filterReqHeaders({
        ...nodeHeadersToRecord(requestHeaders),
        ...nodeHeadersToRecord(responseHeaders)
    }, actionsForbiddenHeaders);
    // Merge cookies into requestCookies, so responseCookies always take precedence
    // and overwrite/delete those from requestCookies.
    responseCookies.getAll().forEach((cookie)=>{
        if (typeof cookie.value === "undefined") {
            requestCookies.delete(cookie.name);
        } else {
            requestCookies.set(cookie);
        }
    });
    // Update the 'cookie' header with the merged cookies
    mergedHeaders["cookie"] = requestCookies.toString();
    // Remove headers that should not be forwarded
    delete mergedHeaders["transfer-encoding"];
    return new Headers(mergedHeaders);
}
async function addRevalidationHeader(res, { staticGenerationStore, requestStore }) {
    var _staticGenerationStore_revalidatedTags;
    await Promise.all(Object.values(staticGenerationStore.pendingRevalidates || []));
    // If a tag was revalidated, the client router needs to invalidate all the
    // client router cache as they may be stale. And if a path was revalidated, the
    // client needs to invalidate all subtrees below that path.
    // To keep the header size small, we use a tuple of
    // [[revalidatedPaths], isTagRevalidated ? 1 : 0, isCookieRevalidated ? 1 : 0]
    // instead of a JSON object.
    // TODO-APP: Currently the prefetch cache doesn't have subtree information,
    // so we need to invalidate the entire cache if a path was revalidated.
    // TODO-APP: Currently paths are treated as tags, so the second element of the tuple
    // is always empty.
    const isTagRevalidated = ((_staticGenerationStore_revalidatedTags = staticGenerationStore.revalidatedTags) == null ? void 0 : _staticGenerationStore_revalidatedTags.length) ? 1 : 0;
    const isCookieRevalidated = getModifiedCookieValues(requestStore.mutableCookies).length ? 1 : 0;
    res.setHeader("x-action-revalidated", JSON.stringify([
        [],
        isTagRevalidated,
        isCookieRevalidated
    ]));
}
/**
 * Forwards a server action request to a separate worker. Used when the requested action is not available in the current worker.
 */ async function createForwardedActionResponse(req, res, host, workerPathname, basePath, staticGenerationStore) {
    var _staticGenerationStore_incrementalCache;
    if (!host) {
        throw new Error("Invariant: Missing `host` header from a forwarded Server Actions request.");
    }
    const forwardedHeaders = getForwardedHeaders(req, res);
    // indicate that this action request was forwarded from another worker
    // we use this to skip rendering the flight tree so that we don't update the UI
    // with the response from the forwarded worker
    forwardedHeaders.set("x-action-forwarded", "1");
    const proto = ((_staticGenerationStore_incrementalCache = staticGenerationStore.incrementalCache) == null ? void 0 : _staticGenerationStore_incrementalCache.requestProtocol) || "https";
    // For standalone or the serverful mode, use the internal origin directly
    // other than the host headers from the request.
    const origin = process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${host.value}`;
    const fetchUrl = new URL(`${origin}${basePath}${workerPathname}`);
    try {
        let readableStream;
        if (process.env.NEXT_RUNTIME === "edge") {
            const webRequest = req;
            if (!webRequest.body) {
                throw new Error("invariant: Missing request body.");
            }
            readableStream = webRequest.body;
        } else {
            // Convert the Node.js readable stream to a Web Stream.
            readableStream = new ReadableStream({
                start (controller) {
                    req.on("data", (chunk)=>{
                        controller.enqueue(new Uint8Array(chunk));
                    });
                    req.on("end", ()=>{
                        controller.close();
                    });
                    req.on("error", (err)=>{
                        controller.error(err);
                    });
                }
            });
        }
        // Forward the request to the new worker
        const response = await fetch(fetchUrl, {
            method: "POST",
            body: readableStream,
            duplex: "half",
            headers: forwardedHeaders,
            next: {
                // @ts-ignore
                internal: 1
            }
        });
        if (response.headers.get("content-type") === RSC_CONTENT_TYPE_HEADER) {
            // copy the headers from the redirect response to the response we're sending
            for (const [key, value] of response.headers){
                if (!actionsForbiddenHeaders.includes(key)) {
                    res.setHeader(key, value);
                }
            }
            return new FlightRenderResult(response.body);
        } else {
            var // Since we aren't consuming the response body, we cancel it to avoid memory leaks
            _response_body;
            (_response_body = response.body) == null ? void 0 : _response_body.cancel();
        }
    } catch (err) {
        // we couldn't stream the forwarded response, so we'll just do a normal redirect
        console.error(`failed to forward action response`, err);
    }
}
async function createRedirectRenderResult(req, res, originalHost, redirectUrl, basePath, staticGenerationStore) {
    res.setHeader("x-action-redirect", redirectUrl);
    // If we're redirecting to another route of this Next.js application, we'll
    // try to stream the response from the other worker path. When that works,
    // we can save an extra roundtrip and avoid a full page reload.
    // When the redirect URL starts with a `/`, or to the same host as application,
    // we treat it as an app-relative redirect.
    const parsedRedirectUrl = new URL(redirectUrl, "http://n");
    const isAppRelativeRedirect = redirectUrl.startsWith("/") || originalHost && originalHost.value === parsedRedirectUrl.host;
    if (isAppRelativeRedirect) {
        var _staticGenerationStore_incrementalCache;
        if (!originalHost) {
            throw new Error("Invariant: Missing `host` header from a forwarded Server Actions request.");
        }
        const forwardedHeaders = getForwardedHeaders(req, res);
        forwardedHeaders.set(RSC_HEADER, "1");
        const proto = ((_staticGenerationStore_incrementalCache = staticGenerationStore.incrementalCache) == null ? void 0 : _staticGenerationStore_incrementalCache.requestProtocol) || "https";
        // For standalone or the serverful mode, use the internal origin directly
        // other than the host headers from the request.
        const origin = process.env.__NEXT_PRIVATE_ORIGIN || `${proto}://${originalHost.value}`;
        const fetchUrl = new URL(`${origin}${basePath}${parsedRedirectUrl.pathname}${parsedRedirectUrl.search}`);
        if (staticGenerationStore.revalidatedTags) {
            var _staticGenerationStore_incrementalCache_prerenderManifest_preview, _staticGenerationStore_incrementalCache_prerenderManifest, _staticGenerationStore_incrementalCache1;
            forwardedHeaders.set(NEXT_CACHE_REVALIDATED_TAGS_HEADER, staticGenerationStore.revalidatedTags.join(","));
            forwardedHeaders.set(NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER, ((_staticGenerationStore_incrementalCache1 = staticGenerationStore.incrementalCache) == null ? void 0 : (_staticGenerationStore_incrementalCache_prerenderManifest = _staticGenerationStore_incrementalCache1.prerenderManifest) == null ? void 0 : (_staticGenerationStore_incrementalCache_prerenderManifest_preview = _staticGenerationStore_incrementalCache_prerenderManifest.preview) == null ? void 0 : _staticGenerationStore_incrementalCache_prerenderManifest_preview.previewModeId) || "");
        }
        // Ensures that when the path was revalidated we don't return a partial response on redirects
        forwardedHeaders.delete("next-router-state-tree");
        try {
            const response = await fetch(fetchUrl, {
                method: "GET",
                headers: forwardedHeaders,
                next: {
                    // @ts-ignore
                    internal: 1
                }
            });
            if (response.headers.get("content-type") === RSC_CONTENT_TYPE_HEADER) {
                // copy the headers from the redirect response to the response we're sending
                for (const [key, value] of response.headers){
                    if (!actionsForbiddenHeaders.includes(key)) {
                        res.setHeader(key, value);
                    }
                }
                return new FlightRenderResult(response.body);
            } else {
                var // Since we aren't consuming the response body, we cancel it to avoid memory leaks
                _response_body;
                (_response_body = response.body) == null ? void 0 : _response_body.cancel();
            }
        } catch (err) {
            // we couldn't stream the redirect response, so we'll just do a normal redirect
            console.error(`failed to get redirect response`, err);
        }
    }
    return RenderResult.fromStatic("{}");
}
var HostType;
/**
 * Ensures the value of the header can't create long logs.
 */ function limitUntrustedHeaderValueForLogs(value) {
    return value.length > 100 ? value.slice(0, 100) + "..." : value;
}
export async function handleAction({ req, res, ComponentMod, serverModuleMap, generateFlight, staticGenerationStore, requestStore, serverActions, ctx }) {
    const contentType = req.headers["content-type"];
    const { serverActionsManifest, page } = ctx.renderOpts;
    const { actionId, isURLEncodedAction, isMultipartAction, isFetchAction, isServerAction } = getServerActionRequestMetadata(req);
    // If it's not a Server Action, skip handling.
    if (!isServerAction) {
        return;
    }
    if (staticGenerationStore.isStaticGeneration) {
        throw new Error("Invariant: server actions can't be handled during static rendering");
    }
    // When running actions the default is no-store, you can still `cache: 'force-cache'`
    staticGenerationStore.fetchCache = "default-no-store";
    const originDomain = typeof req.headers["origin"] === "string" ? new URL(req.headers["origin"]).host : undefined;
    const forwardedHostHeader = req.headers["x-forwarded-host"];
    const hostHeader = req.headers["host"];
    const host = forwardedHostHeader ? {
        type: "x-forwarded-host",
        value: forwardedHostHeader
    } : hostHeader ? {
        type: "host",
        value: hostHeader
    } : undefined;
    let warning = undefined;
    function warnBadServerActionRequest() {
        if (warning) {
            warn(warning);
        }
    }
    // This is to prevent CSRF attacks. If `x-forwarded-host` is set, we need to
    // ensure that the request is coming from the same host.
    if (!originDomain) {
        // This might be an old browser that doesn't send `host` header. We ignore
        // this case.
        warning = "Missing `origin` header from a forwarded Server Actions request.";
    } else if (!host || originDomain !== host.value) {
        // If the customer sets a list of allowed origins, we'll allow the request.
        // These are considered safe but might be different from forwarded host set
        // by the infra (i.e. reverse proxies).
        if (isCsrfOriginAllowed(originDomain, serverActions == null ? void 0 : serverActions.allowedOrigins)) {
        // Ignore it
        } else {
            if (host) {
                // This seems to be an CSRF attack. We should not proceed the action.
                console.error(`\`${host.type}\` header with value \`${limitUntrustedHeaderValueForLogs(host.value)}\` does not match \`origin\` header with value \`${limitUntrustedHeaderValueForLogs(originDomain)}\` from a forwarded Server Actions request. Aborting the action.`);
            } else {
                // This is an attack. We should not proceed the action.
                console.error(`\`x-forwarded-host\` or \`host\` headers are not provided. One of these is needed to compare the \`origin\` header from a forwarded Server Actions request. Aborting the action.`);
            }
            const error = new Error("Invalid Server Actions request.");
            if (isFetchAction) {
                res.statusCode = 500;
                await Promise.all(Object.values(staticGenerationStore.pendingRevalidates || []));
                const promise = Promise.reject(error);
                try {
                    // we need to await the promise to trigger the rejection early
                    // so that it's already handled by the time we call
                    // the RSC runtime. Otherwise, it will throw an unhandled
                    // promise rejection error in the renderer.
                    await promise;
                } catch  {
                // swallow error, it's gonna be handled on the client
                }
                return {
                    type: "done",
                    result: await generateFlight(ctx, {
                        actionResult: promise,
                        // if the page was not revalidated, we can skip the rendering the flight tree
                        skipFlight: !staticGenerationStore.pathWasRevalidated
                    })
                };
            }
            throw error;
        }
    }
    // ensure we avoid caching server actions unexpectedly
    res.setHeader("Cache-Control", "no-cache, no-store, max-age=0, must-revalidate");
    let bound = [];
    const { actionAsyncStorage } = ComponentMod;
    let actionResult;
    let formState;
    let actionModId;
    const actionWasForwarded = Boolean(req.headers["x-action-forwarded"]);
    if (actionId) {
        const forwardedWorker = selectWorkerForForwarding(actionId, page, serverActionsManifest);
        // If forwardedWorker is truthy, it means there isn't a worker for the action
        // in the current handler, so we forward the request to a worker that has the action.
        if (forwardedWorker) {
            return {
                type: "done",
                result: await createForwardedActionResponse(req, res, host, forwardedWorker, ctx.renderOpts.basePath, staticGenerationStore)
            };
        }
    }
    try {
        await actionAsyncStorage.run({
            isAction: true
        }, async ()=>{
            if (process.env.NEXT_RUNTIME === "edge") {
                // Use react-server-dom-webpack/server.edge
                const { decodeReply, decodeAction, decodeFormState } = ComponentMod;
                const webRequest = req;
                if (!webRequest.body) {
                    throw new Error("invariant: Missing request body.");
                }
                if (isMultipartAction) {
                    // TODO-APP: Add streaming support
                    const formData = await webRequest.request.formData();
                    if (isFetchAction) {
                        bound = await decodeReply(formData, serverModuleMap);
                    } else {
                        const action = await decodeAction(formData, serverModuleMap);
                        if (typeof action === "function") {
                            // Only warn if it's a server action, otherwise skip for other post requests
                            warnBadServerActionRequest();
                            const actionReturnedState = await action();
                            formState = decodeFormState(actionReturnedState, formData);
                        }
                        // Skip the fetch path
                        return;
                    }
                } else {
                    try {
                        actionModId = getActionModIdOrError(actionId, serverModuleMap);
                    } catch (err) {
                        if (actionId !== null) {
                            console.error(err);
                        }
                        return {
                            type: "not-found"
                        };
                    }
                    let actionData = "";
                    const reader = webRequest.body.getReader();
                    while(true){
                        const { done, value } = await reader.read();
                        if (done) {
                            break;
                        }
                        actionData += new TextDecoder().decode(value);
                    }
                    if (isURLEncodedAction) {
                        const formData = formDataFromSearchQueryString(actionData);
                        bound = await decodeReply(formData, serverModuleMap);
                    } else {
                        bound = await decodeReply(actionData, serverModuleMap);
                    }
                }
            } else {
                // Use react-server-dom-webpack/server.node which supports streaming
                const { decodeReply, decodeReplyFromBusboy, decodeAction, decodeFormState } = require(`./react-server.node`);
                if (isMultipartAction) {
                    if (isFetchAction) {
                        const readableLimit = (serverActions == null ? void 0 : serverActions.bodySizeLimit) ?? "1 MB";
                        const limit = require("next/dist/compiled/bytes").parse(readableLimit);
                        const busboy = require("busboy");
                        const bb = busboy({
                            headers: req.headers,
                            limits: {
                                fieldSize: limit
                            }
                        });
                        req.pipe(bb);
                        bound = await decodeReplyFromBusboy(bb, serverModuleMap);
                    } else {
                        // Convert the Node.js readable stream to a Web Stream.
                        const readableStream = new ReadableStream({
                            start (controller) {
                                req.on("data", (chunk)=>{
                                    controller.enqueue(new Uint8Array(chunk));
                                });
                                req.on("end", ()=>{
                                    controller.close();
                                });
                                req.on("error", (err)=>{
                                    controller.error(err);
                                });
                            }
                        });
                        // React doesn't yet publish a busboy version of decodeAction
                        // so we polyfill the parsing of FormData.
                        const fakeRequest = new Request("http://localhost", {
                            method: "POST",
                            // @ts-expect-error
                            headers: {
                                "Content-Type": contentType
                            },
                            body: readableStream,
                            duplex: "half"
                        });
                        const formData = await fakeRequest.formData();
                        const action = await decodeAction(formData, serverModuleMap);
                        if (typeof action === "function") {
                            // Only warn if it's a server action, otherwise skip for other post requests
                            warnBadServerActionRequest();
                            const actionReturnedState = await action();
                            formState = await decodeFormState(actionReturnedState, formData);
                        }
                        // Skip the fetch path
                        return;
                    }
                } else {
                    try {
                        actionModId = getActionModIdOrError(actionId, serverModuleMap);
                    } catch (err) {
                        if (actionId !== null) {
                            console.error(err);
                        }
                        return {
                            type: "not-found"
                        };
                    }
                    const chunks = [];
                    for await (const chunk of req){
                        chunks.push(Buffer.from(chunk));
                    }
                    const actionData = Buffer.concat(chunks).toString("utf-8");
                    const readableLimit = (serverActions == null ? void 0 : serverActions.bodySizeLimit) ?? "1 MB";
                    const limit = require("next/dist/compiled/bytes").parse(readableLimit);
                    if (actionData.length > limit) {
                        const { ApiError } = require("../api-utils");
                        throw new ApiError(413, `Body exceeded ${readableLimit} limit.
To configure the body size limit for Server Actions, see: https://nextjs.org/docs/app/api-reference/next-config-js/serverActions#bodysizelimit`);
                    }
                    if (isURLEncodedAction) {
                        const formData = formDataFromSearchQueryString(actionData);
                        bound = await decodeReply(formData, serverModuleMap);
                    } else {
                        bound = await decodeReply(actionData, serverModuleMap);
                    }
                }
            }
            // actions.js
            // app/page.js
            //   action worker1
            //     appRender1
            // app/foo/page.js
            //   action worker2
            //     appRender
            // / -> fire action -> POST / -> appRender1 -> modId for the action file
            // /foo -> fire action -> POST /foo -> appRender2 -> modId for the action file
            try {
                actionModId = actionModId ?? getActionModIdOrError(actionId, serverModuleMap);
            } catch (err) {
                if (actionId !== null) {
                    console.error(err);
                }
                return {
                    type: "not-found"
                };
            }
            const actionHandler = (await ComponentMod.__next_app__.require(actionModId))[// `actionId` must exist if we got here, as otherwise we would have thrown an error above
            actionId];
            const returnVal = await actionHandler.apply(null, bound);
            // For form actions, we need to continue rendering the page.
            if (isFetchAction) {
                await addRevalidationHeader(res, {
                    staticGenerationStore,
                    requestStore
                });
                actionResult = await generateFlight(ctx, {
                    actionResult: Promise.resolve(returnVal),
                    // if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree
                    skipFlight: !staticGenerationStore.pathWasRevalidated || actionWasForwarded
                });
            }
        });
        return {
            type: "done",
            result: actionResult,
            formState
        };
    } catch (err) {
        if (isRedirectError(err)) {
            const redirectUrl = getURLFromRedirectError(err);
            const statusCode = getRedirectStatusCodeFromError(err);
            await addRevalidationHeader(res, {
                staticGenerationStore,
                requestStore
            });
            // if it's a fetch action, we'll set the status code for logging/debugging purposes
            // but we won't set a Location header, as the redirect will be handled by the client router
            res.statusCode = statusCode;
            if (isFetchAction) {
                return {
                    type: "done",
                    result: await createRedirectRenderResult(req, res, host, redirectUrl, ctx.renderOpts.basePath, staticGenerationStore)
                };
            }
            if (err.mutableCookies) {
                const headers = new Headers();
                // If there were mutable cookies set, we need to set them on the
                // response.
                if (appendMutableCookies(headers, err.mutableCookies)) {
                    res.setHeader("set-cookie", Array.from(headers.values()));
                }
            }
            res.setHeader("Location", redirectUrl);
            return {
                type: "done",
                result: RenderResult.fromStatic("")
            };
        } else if (isNotFoundError(err)) {
            res.statusCode = 404;
            await addRevalidationHeader(res, {
                staticGenerationStore,
                requestStore
            });
            if (isFetchAction) {
                const promise = Promise.reject(err);
                try {
                    // we need to await the promise to trigger the rejection early
                    // so that it's already handled by the time we call
                    // the RSC runtime. Otherwise, it will throw an unhandled
                    // promise rejection error in the renderer.
                    await promise;
                } catch  {
                // swallow error, it's gonna be handled on the client
                }
                return {
                    type: "done",
                    result: await generateFlight(ctx, {
                        skipFlight: false,
                        actionResult: promise,
                        asNotFound: true
                    })
                };
            }
            return {
                type: "not-found"
            };
        }
        if (isFetchAction) {
            res.statusCode = 500;
            await Promise.all(Object.values(staticGenerationStore.pendingRevalidates || []));
            const promise = Promise.reject(err);
            try {
                // we need to await the promise to trigger the rejection early
                // so that it's already handled by the time we call
                // the RSC runtime. Otherwise, it will throw an unhandled
                // promise rejection error in the renderer.
                await promise;
            } catch  {
            // swallow error, it's gonna be handled on the client
            }
            return {
                type: "done",
                result: await generateFlight(ctx, {
                    actionResult: promise,
                    // if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree
                    skipFlight: !staticGenerationStore.pathWasRevalidated || actionWasForwarded
                })
            };
        }
        throw err;
    }
}
/**
 * Attempts to find the module ID for the action from the module map. When this fails, it could be a deployment skew where
 * the action came from a different deployment. It could also simply be an invalid POST request that is not a server action.
 * In either case, we'll throw an error to be handled by the caller.
 */ function getActionModIdOrError(actionId, serverModuleMap) {
    try {
        var _serverModuleMap_actionId;
        // if we're missing the action ID header, we can't do any further processing
        if (!actionId) {
            throw new Error("Invariant: Missing 'next-action' header.");
        }
        const actionModId = serverModuleMap == null ? void 0 : (_serverModuleMap_actionId = serverModuleMap[actionId]) == null ? void 0 : _serverModuleMap_actionId.id;
        if (!actionModId) {
            throw new Error("Invariant: Couldn't find action module ID from module map.");
        }
        return actionModId;
    } catch (err) {
        throw new Error(`Failed to find Server Action "${actionId}". This request might be from an older or newer deployment. ${err instanceof Error ? `Original error: ${err.message}` : ""}`);
    }
}

//# sourceMappingURL=action-handler.js.map  // Provider for the `useServerInsertedHTML` API to register callbacks to insert
// elements into the HTML stream.
import { jsx as _jsx } from "react/jsx-runtime";
import React from "react";
import { ServerInsertedHTMLContext } from "../../shared/lib/server-inserted-html.shared-runtime";
export function createServerInsertedHTML() {
    const serverInsertedHTMLCallbacks = [];
    const addInsertedHtml = (handler)=>{
        serverInsertedHTMLCallbacks.push(handler);
    };
    return {
        ServerInsertedHTMLProvider ({ children }) {
            return /*#__PURE__*/ _jsx(ServerInsertedHTMLContext.Provider, {
                value: addInsertedHtml,
                children: children
            });
        },
        renderServerInsertedHTML () {
            return serverInsertedHTMLCallbacks.map((callback, index)=>/*#__PURE__*/ _jsx(React.Fragment, {
                    children: callback()
                }, "__next_server_inserted__" + index));
        }
    };
}

//# sourceMappingURL=server-inserted-html.js.map:  import { encodeURIPath } from "../../shared/lib/encode-uri-path";
import ReactDOM from "react-dom";
export function getRequiredScripts(buildManifest, assetPrefix, crossOrigin, SRIManifest, qs, nonce) {
    let preinitScripts;
    let preinitScriptCommands = [];
    const bootstrapScript = {
        src: "",
        crossOrigin
    };
    const files = buildManifest.rootMainFiles.map(encodeURIPath);
    if (files.length === 0) {
        throw new Error("Invariant: missing bootstrap script. This is a bug in Next.js");
    }
    if (SRIManifest) {
        bootstrapScript.src = `${assetPrefix}/_next/` + files[0] + qs;
        bootstrapScript.integrity = SRIManifest[files[0]];
        for(let i = 1; i < files.length; i++){
            const src = `${assetPrefix}/_next/` + files[i] + qs;
            const integrity = SRIManifest[files[i]];
            preinitScriptCommands.push(src, integrity);
        }
        preinitScripts = ()=>{
            // preinitScriptCommands is a double indexed array of src/integrity pairs
            for(let i = 0; i < preinitScriptCommands.length; i += 2){
                ReactDOM.preinit(preinitScriptCommands[i], {
                    as: "script",
                    integrity: preinitScriptCommands[i + 1],
                    crossOrigin,
                    nonce
                });
            }
        };
    } else {
        bootstrapScript.src = `${assetPrefix}/_next/` + files[0] + qs;
        for(let i = 1; i < files.length; i++){
            const src = `${assetPrefix}/_next/` + files[i] + qs;
            preinitScriptCommands.push(src);
        }
        preinitScripts = ()=>{
            // preinitScriptCommands is a singled indexed array of src values
            for(let i = 0; i < preinitScriptCommands.length; i++){
                ReactDOM.preinit(preinitScriptCommands[i], {
                    as: "script",
                    nonce,
                    crossOrigin
                });
            }
        };
    }
    return [
        preinitScripts,
        bootstrapScript
    ];
}

//# sourceMappingURL=required-scripts.js.map  import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React from "react";
import { isNotFoundError } from "../../client/components/not-found";
import { getURLFromRedirectError, isRedirectError, getRedirectStatusCodeFromError } from "../../client/components/redirect";
import { renderToReadableStream } from "react-dom/server.edge";
import { streamToString } from "../stream-utils/node-web-streams-helper";
import { RedirectStatusCode } from "../../client/components/redirect-status-code";
import { addPathPrefix } from "../../shared/lib/router/utils/add-path-prefix";
export function makeGetServerInsertedHTML({ polyfills, renderServerInsertedHTML, serverCapturedErrors, basePath }) {
    let flushedErrorMetaTagsUntilIndex = 0;
    let hasUnflushedPolyfills = polyfills.length !== 0;
    return async function getServerInsertedHTML() {
        // Loop through all the errors that have been captured but not yet
        // flushed.
        const errorMetaTags = [];
        while(flushedErrorMetaTagsUntilIndex < serverCapturedErrors.length){
            const error = serverCapturedErrors[flushedErrorMetaTagsUntilIndex];
            flushedErrorMetaTagsUntilIndex++;
            if (isNotFoundError(error)) {
                errorMetaTags.push(/*#__PURE__*/ _jsx("meta", {
                    name: "robots",
                    content: "noindex"
                }, error.digest), process.env.NODE_ENV === "development" ? /*#__PURE__*/ _jsx("meta", {
                    name: "next-error",
                    content: "not-found"
                }, "next-error") : null);
            } else if (isRedirectError(error)) {
                const redirectUrl = addPathPrefix(getURLFromRedirectError(error), basePath);
                const statusCode = getRedirectStatusCodeFromError(error);
                const isPermanent = statusCode === RedirectStatusCode.PermanentRedirect ? true : false;
                if (redirectUrl) {
                    errorMetaTags.push(/*#__PURE__*/ _jsx("meta", {
                        id: "__next-page-redirect",
                        httpEquiv: "refresh",
                        content: `${isPermanent ? 0 : 1};url=${redirectUrl}`
                    }, error.digest));
                }
            }
        }
        const serverInsertedHTML = renderServerInsertedHTML();
        // Skip React rendering if we know the content is empty.
        if (!hasUnflushedPolyfills && errorMetaTags.length === 0 && Array.isArray(serverInsertedHTML) && serverInsertedHTML.length === 0) {
            return "";
        }
        const stream = await renderToReadableStream(/*#__PURE__*/ _jsxs(_Fragment, {
            children: [
                /* Insert the polyfills if they haven't been flushed yet. */ hasUnflushedPolyfills && polyfills.map((polyfill)=>{
                    return /*#__PURE__*/ _jsx("script", {
                        ...polyfill
                    }, polyfill.src);
                }),
                serverInsertedHTML,
                errorMetaTags
            ]
        }), {
            // Larger chunk because this isn't sent over the network.
            // Let's set it to 1MB.
            progressiveChunkSize: 1024 * 1024
        });
        hasUnflushedPolyfills = false;
        // There's no need to wait for the stream to be ready
        // e.g. calling `await stream.allReady` because `streamToString` will
        // wait and decode the stream progressively with better parallelism.
        return streamToString(stream);
    };
}

//# sourceMappingURL=make-get-server-inserted-html.js.mapu  /**
 * Get external stylesheet link hrefs based on server CSS manifest.
 */ export function getLinkAndScriptTags(clientReferenceManifest, filePath, injectedCSS, injectedScripts, collectNewImports) {
    var _clientReferenceManifest_entryJSFiles;
    const filePathWithoutExt = filePath.replace(/\.[^.]+$/, "");
    const cssChunks = new Set();
    const jsChunks = new Set();
    const entryCSSFiles = clientReferenceManifest.entryCSSFiles[filePathWithoutExt];
    const entryJSFiles = ((_clientReferenceManifest_entryJSFiles = clientReferenceManifest.entryJSFiles) == null ? void 0 : _clientReferenceManifest_entryJSFiles[filePathWithoutExt]) ?? [];
    if (entryCSSFiles) {
        for (const file of entryCSSFiles){
            if (!injectedCSS.has(file)) {
                if (collectNewImports) {
                    injectedCSS.add(file);
                }
                cssChunks.add(file);
            }
        }
    }
    if (entryJSFiles) {
        for (const file of entryJSFiles){
            if (!injectedScripts.has(file)) {
                if (collectNewImports) {
                    injectedScripts.add(file);
                }
                jsChunks.add(file);
            }
        }
    }
    return {
        styles: [
            ...cssChunks
        ],
        scripts: [
            ...jsChunks
        ]
    };
}

//# sourceMappingURL=get-css-inlined-link-tags.js.map  /**
 * Get hrefs for fonts to preload
 * Returns null if there are no fonts at all.
 * Returns string[] if there are fonts to preload (font paths)
 * Returns empty string[] if there are fonts but none to preload and no other fonts have been preloaded
 * Returns null if there are fonts but none to preload and at least some were previously preloaded
 */ export function getPreloadableFonts(nextFontManifest, filePath, injectedFontPreloadTags) {
    if (!nextFontManifest || !filePath) {
        return null;
    }
    const filepathWithoutExtension = filePath.replace(/\.[^.]+$/, "");
    const fontFiles = new Set();
    let foundFontUsage = false;
    const preloadedFontFiles = nextFontManifest.app[filepathWithoutExtension];
    if (preloadedFontFiles) {
        foundFontUsage = true;
        for (const fontFile of preloadedFontFiles){
            if (!injectedFontPreloadTags.has(fontFile)) {
                fontFiles.add(fontFile);
                injectedFontPreloadTags.add(fontFile);
            }
        }
    }
    if (fontFiles.size) {
        return [
            ...fontFiles
        ].sort();
    } else if (foundFontUsage && injectedFontPreloadTags.size === 0) {
        return [];
    } else {
        return null;
    }
}

//# sourceMappingURL=get-preloadable-fonts.js.mapÊ  import { DEFAULT_SEGMENT_KEY } from "../../shared/lib/segment";
export function parseLoaderTree(tree) {
    const [segment, parallelRoutes, components] = tree;
    const { layout } = components;
    let { page } = components;
    // a __DEFAULT__ segment means that this route didn't match any of the
    // segments in the route, so we should use the default page
    page = segment === DEFAULT_SEGMENT_KEY ? components.defaultPage : page;
    const layoutOrPagePath = (layout == null ? void 0 : layout[1]) || (page == null ? void 0 : page[1]);
    return {
        page,
        segment,
        components,
        layoutOrPagePath,
        parallelRoutes
    };
}

//# sourceMappingURL=parse-loader-tree.js.mapÑ  const isDev = process.env.NODE_ENV === "development";
const isTurbopack = !!process.env.TURBOPACK;
export function getAssetQueryString(ctx, addTimestamp) {
    let qs = "";
    // In development we add the request timestamp to allow react to
    // reload assets when a new RSC response is received.
    // Turbopack handles HMR of assets itself and react doesn't need to reload them
    // so this approach is not needed for Turbopack.
    if (isDev && !isTurbopack && addTimestamp) {
        qs += `?v=${ctx.requestTimestamp}`;
    }
    if (ctx.renderOpts.deploymentId) {
        qs += `${isDev ? "&" : "?"}dpl=${ctx.renderOpts.deploymentId}`;
    }
    return qs;
}

//# sourceMappingURL=get-asset-query-string.js.map   import { jsx as _jsx } from "react/jsx-runtime";
import React from "react";
import { getLinkAndScriptTags } from "./get-css-inlined-link-tags";
import { getPreloadableFonts } from "./get-preloadable-fonts";
import { getAssetQueryString } from "./get-asset-query-string";
import { encodeURIPath } from "../../shared/lib/encode-uri-path";
export function getLayerAssets({ ctx, layoutOrPagePath, injectedCSS: injectedCSSWithCurrentLayout, injectedJS: injectedJSWithCurrentLayout, injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout }) {
    const { styles: styleTags, scripts: scriptTags } = layoutOrPagePath ? getLinkAndScriptTags(ctx.clientReferenceManifest, layoutOrPagePath, injectedCSSWithCurrentLayout, injectedJSWithCurrentLayout, true) : {
        styles: [],
        scripts: []
    };
    const preloadedFontFiles = layoutOrPagePath ? getPreloadableFonts(ctx.renderOpts.nextFontManifest, layoutOrPagePath, injectedFontPreloadTagsWithCurrentLayout) : null;
    if (preloadedFontFiles) {
        if (preloadedFontFiles.length) {
            for(let i = 0; i < preloadedFontFiles.length; i++){
                const fontFilename = preloadedFontFiles[i];
                const ext = /\.(woff|woff2|eot|ttf|otf)$/.exec(fontFilename)[1];
                const type = `font/${ext}`;
                const href = `${ctx.assetPrefix}/_next/${encodeURIPath(fontFilename)}`;
                ctx.componentMod.preloadFont(href, type, ctx.renderOpts.crossOrigin);
            }
        } else {
            try {
                let url = new URL(ctx.assetPrefix);
                ctx.componentMod.preconnect(url.origin, "anonymous");
            } catch (error) {
                // assetPrefix must not be a fully qualified domain name. We assume
                // we should preconnect to same origin instead
                ctx.componentMod.preconnect("/", "anonymous");
            }
        }
    }
    const styles = styleTags ? styleTags.map((href, index)=>{
        // In dev, Safari and Firefox will cache the resource during HMR:
        // - https://github.com/vercel/next.js/issues/5860
        // - https://bugs.webkit.org/show_bug.cgi?id=187726
        // Because of this, we add a `?v=` query to bypass the cache during
        // development. We need to also make sure that the number is always
        // increasing.
        const fullHref = `${ctx.assetPrefix}/_next/${encodeURIPath(href)}${getAssetQueryString(ctx, true)}`;
        // `Precedence` is an opt-in signal for React to handle resource
        // loading and deduplication, etc. It's also used as the key to sort
        // resources so they will be injected in the correct order.
        // During HMR, it's critical to use different `precedence` values
        // for different stylesheets, so their order will be kept.
        // https://github.com/facebook/react/pull/25060
        const precedence = process.env.NODE_ENV === "development" ? "next_" + href : "next";
        ctx.componentMod.preloadStyle(fullHref, ctx.renderOpts.crossOrigin);
        return /*#__PURE__*/ _jsx("link", {
            rel: "stylesheet",
            href: fullHref,
            // @ts-ignore
            precedence: precedence,
            crossOrigin: ctx.renderOpts.crossOrigin
        }, index);
    }) : [];
    const scripts = scriptTags ? scriptTags.map((href, index)=>{
        const fullSrc = `${ctx.assetPrefix}/_next/${encodeURIPath(href)}${getAssetQueryString(ctx, true)}`;
        return /*#__PURE__*/ _jsx("script", {
            src: fullSrc,
            async: true
        }, `script-${index}`);
    }) : [];
    return styles.length || scripts.length ? [
        ...styles,
        ...scripts
    ] : null;
}

//# sourceMappingURL=get-layer-assets.js.map8  export function hasLoadingComponentInTree(tree) {
    const [, parallelRoutes, { loading }] = tree;
    if (loading) {
        return true;
    }
    return Object.values(parallelRoutes).some((parallelRoute)=>hasLoadingComponentInTree(parallelRoute));
}

//# sourceMappingURL=has-loading-component-in-tree.js.mapµ   /**
 * Interop between "export default" and "module.exports".
 */ export function interopDefault(mod) {
    return mod.default || mod;
}

//# sourceMappingURL=interop-default.js.map~  import { jsx as _jsx } from "react/jsx-runtime";
import React from "react";
import { interopDefault } from "./interop-default";
import { getLinkAndScriptTags } from "./get-css-inlined-link-tags";
import { getAssetQueryString } from "./get-asset-query-string";
import { encodeURIPath } from "../../shared/lib/encode-uri-path";
export async function createComponentStylesAndScripts({ filePath, getComponent, injectedCSS, injectedJS, ctx }) {
    const { styles: cssHrefs, scripts: jsHrefs } = getLinkAndScriptTags(ctx.clientReferenceManifest, filePath, injectedCSS, injectedJS);
    const styles = cssHrefs ? cssHrefs.map((href, index)=>{
        const fullHref = `${ctx.assetPrefix}/_next/${encodeURIPath(href)}${getAssetQueryString(ctx, true)}`;
        // `Precedence` is an opt-in signal for React to handle resource
        // loading and deduplication, etc. It's also used as the key to sort
        // resources so they will be injected in the correct order.
        // During HMR, it's critical to use different `precedence` values
        // for different stylesheets, so their order will be kept.
        // https://github.com/facebook/react/pull/25060
        const precedence = process.env.NODE_ENV === "development" ? "next_" + href : "next";
        return /*#__PURE__*/ _jsx("link", {
            rel: "stylesheet",
            href: fullHref,
            // @ts-ignore
            precedence: precedence,
            crossOrigin: ctx.renderOpts.crossOrigin
        }, index);
    }) : null;
    const scripts = jsHrefs ? jsHrefs.map((href)=>/*#__PURE__*/ _jsx("script", {
            src: `${ctx.assetPrefix}/_next/${encodeURIPath(href)}${getAssetQueryString(ctx, true)}`,
            async: true
        })) : null;
    const Comp = interopDefault(await getComponent());
    return [
        Comp,
        styles,
        scripts
    ];
}

//# sourceMappingURL=create-component-styles-and-scripts.js.map
Z  import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React from "react";
import { isClientReference } from "../../lib/client-reference";
import { getLayoutOrPageModule } from "../lib/app-dir-module";
import { interopDefault } from "./interop-default";
import { parseLoaderTree } from "./parse-loader-tree";
import { createComponentStylesAndScripts } from "./create-component-styles-and-scripts";
import { getLayerAssets } from "./get-layer-assets";
import { hasLoadingComponentInTree } from "./has-loading-component-in-tree";
import { validateRevalidate } from "../lib/patch-fetch";
import { PARALLEL_ROUTE_DEFAULT_PATH } from "../../client/components/parallel-route-default";
import { getTracer } from "../lib/trace/tracer";
import { NextNodeServerSpan } from "../lib/trace/constants";
import { StaticGenBailoutError } from "../../client/components/static-generation-bailout";
/**
 * Use the provided loader tree to create the React Component tree.
 */ export function createComponentTree(props) {
    return getTracer().trace(NextNodeServerSpan.createComponentTree, {
        spanName: "build component tree"
    }, ()=>createComponentTreeInternal(props));
}
async function createComponentTreeInternal({ createSegmentPath, loaderTree: tree, parentParams, firstItem, rootLayoutIncluded, injectedCSS, injectedJS, injectedFontPreloadTags, asNotFound, metadataOutlet, ctx, missingSlots }) {
    const { renderOpts: { nextConfigOutput, experimental }, staticGenerationStore, componentMod: { NotFoundBoundary, LayoutRouter, RenderFromTemplateContext, ClientPageRoot, createUntrackedSearchParams, createDynamicallyTrackedSearchParams, serverHooks: { DynamicServerError }, Postpone }, pagePath, getDynamicParamFromSegment, isPrefetch, query } = ctx;
    const { page, layoutOrPagePath, segment, components, parallelRoutes } = parseLoaderTree(tree);
    const { layout, template, error, loading, "not-found": notFound } = components;
    const injectedCSSWithCurrentLayout = new Set(injectedCSS);
    const injectedJSWithCurrentLayout = new Set(injectedJS);
    const injectedFontPreloadTagsWithCurrentLayout = new Set(injectedFontPreloadTags);
    const layerAssets = getLayerAssets({
        ctx,
        layoutOrPagePath,
        injectedCSS: injectedCSSWithCurrentLayout,
        injectedJS: injectedJSWithCurrentLayout,
        injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout
    });
    const [Template, templateStyles, templateScripts] = template ? await createComponentStylesAndScripts({
        ctx,
        filePath: template[1],
        getComponent: template[0],
        injectedCSS: injectedCSSWithCurrentLayout,
        injectedJS: injectedJSWithCurrentLayout
    }) : [
        React.Fragment
    ];
    const [ErrorComponent, errorStyles, errorScripts] = error ? await createComponentStylesAndScripts({
        ctx,
        filePath: error[1],
        getComponent: error[0],
        injectedCSS: injectedCSSWithCurrentLayout,
        injectedJS: injectedJSWithCurrentLayout
    }) : [];
    const [Loading, loadingStyles, loadingScripts] = loading ? await createComponentStylesAndScripts({
        ctx,
        filePath: loading[1],
        getComponent: loading[0],
        injectedCSS: injectedCSSWithCurrentLayout,
        injectedJS: injectedJSWithCurrentLayout
    }) : [];
    const isLayout = typeof layout !== "undefined";
    const isPage = typeof page !== "undefined";
    const [layoutOrPageMod] = await getTracer().trace(NextNodeServerSpan.getLayoutOrPageModule, {
        hideSpan: !(isLayout || isPage),
        spanName: "resolve segment modules",
        attributes: {
            "next.segment": segment
        }
    }, ()=>getLayoutOrPageModule(tree));
    /**
   * Checks if the current segment is a root layout.
   */ const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded;
    /**
   * Checks if the current segment or any level above it has a root layout.
   */ const rootLayoutIncludedAtThisLevelOrAbove = rootLayoutIncluded || rootLayoutAtThisLevel;
    const [NotFound, notFoundStyles] = notFound ? await createComponentStylesAndScripts({
        ctx,
        filePath: notFound[1],
        getComponent: notFound[0],
        injectedCSS: injectedCSSWithCurrentLayout,
        injectedJS: injectedJSWithCurrentLayout
    }) : [];
    let dynamic = layoutOrPageMod == null ? void 0 : layoutOrPageMod.dynamic;
    if (nextConfigOutput === "export") {
        if (!dynamic || dynamic === "auto") {
            dynamic = "error";
        } else if (dynamic === "force-dynamic") {
            // force-dynamic is always incompatible with 'export'. We must interrupt the build
            throw new StaticGenBailoutError(`Page with \`dynamic = "force-dynamic"\` couldn't be exported. \`output: "export"\` requires all pages be renderable statically because there is not runtime server to dynamic render routes in this output format. Learn more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports`);
        }
    }
    if (typeof dynamic === "string") {
        // the nested most config wins so we only force-static
        // if it's configured above any parent that configured
        // otherwise
        if (dynamic === "error") {
            staticGenerationStore.dynamicShouldError = true;
        } else if (dynamic === "force-dynamic") {
            staticGenerationStore.forceDynamic = true;
            // TODO: (PPR) remove this bailout once PPR is the default
            if (staticGenerationStore.isStaticGeneration && !staticGenerationStore.prerenderState) {
                // If the postpone API isn't available, we can't postpone the render and
                // therefore we can't use the dynamic API.
                const err = new DynamicServerError(`Page with \`dynamic = "force-dynamic"\` won't be rendered statically.`);
                staticGenerationStore.dynamicUsageDescription = err.message;
                staticGenerationStore.dynamicUsageStack = err.stack;
                throw err;
            }
        } else {
            staticGenerationStore.dynamicShouldError = false;
            staticGenerationStore.forceStatic = dynamic === "force-static";
        }
    }
    if (typeof (layoutOrPageMod == null ? void 0 : layoutOrPageMod.fetchCache) === "string") {
        staticGenerationStore.fetchCache = layoutOrPageMod == null ? void 0 : layoutOrPageMod.fetchCache;
    }
    if (typeof (layoutOrPageMod == null ? void 0 : layoutOrPageMod.revalidate) !== "undefined") {
        validateRevalidate(layoutOrPageMod == null ? void 0 : layoutOrPageMod.revalidate, staticGenerationStore.urlPathname);
    }
    if (typeof (layoutOrPageMod == null ? void 0 : layoutOrPageMod.revalidate) === "number") {
        ctx.defaultRevalidate = layoutOrPageMod.revalidate;
        if (typeof staticGenerationStore.revalidate === "undefined" || typeof staticGenerationStore.revalidate === "number" && staticGenerationStore.revalidate > ctx.defaultRevalidate) {
            staticGenerationStore.revalidate = ctx.defaultRevalidate;
        }
        if (!staticGenerationStore.forceStatic && staticGenerationStore.isStaticGeneration && ctx.defaultRevalidate === 0 && // If the postpone API isn't available, we can't postpone the render and
        // therefore we can't use the dynamic API.
        !staticGenerationStore.prerenderState) {
            const dynamicUsageDescription = `revalidate: 0 configured ${segment}`;
            staticGenerationStore.dynamicUsageDescription = dynamicUsageDescription;
            throw new DynamicServerError(dynamicUsageDescription);
        }
    }
    // If there's a dynamic usage error attached to the store, throw it.
    if (staticGenerationStore.dynamicUsageErr) {
        throw staticGenerationStore.dynamicUsageErr;
    }
    const LayoutOrPage = layoutOrPageMod ? interopDefault(layoutOrPageMod) : undefined;
    /**
   * The React Component to render.
   */ let Component = LayoutOrPage;
    const parallelKeys = Object.keys(parallelRoutes);
    const hasSlotKey = parallelKeys.length > 1;
    // TODO-APP: This is a hack to support unmatched parallel routes, which will throw `notFound()`.
    // This ensures that a `NotFoundBoundary` is available for when that happens,
    // but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.
    // We should instead look into handling the fallback behavior differently in development mode so that it doesn't
    // rely on the `NotFound` behavior.
    if (hasSlotKey && rootLayoutAtThisLevel && LayoutOrPage) {
        Component = (componentProps)=>{
            const NotFoundComponent = NotFound;
            const RootLayoutComponent = LayoutOrPage;
            return /*#__PURE__*/ _jsx(NotFoundBoundary, {
                notFound: NotFoundComponent ? /*#__PURE__*/ _jsxs(_Fragment, {
                    children: [
                        layerAssets,
                        /*#__PURE__*/ _jsxs(RootLayoutComponent, {
                            params: componentProps.params,
                            children: [
                                notFoundStyles,
                                /*#__PURE__*/ _jsx(NotFoundComponent, {})
                            ]
                        })
                    ]
                }) : undefined,
                children: /*#__PURE__*/ _jsx(RootLayoutComponent, {
                    ...componentProps
                })
            });
        };
    }
    if (process.env.NODE_ENV === "development") {
        const { isValidElementType } = require("next/dist/compiled/react-is");
        if ((isPage || typeof Component !== "undefined") && !isValidElementType(Component)) {
            throw new Error(`The default export is not a React Component in page: "${pagePath}"`);
        }
        if (typeof ErrorComponent !== "undefined" && !isValidElementType(ErrorComponent)) {
            throw new Error(`The default export of error is not a React Component in page: ${segment}`);
        }
        if (typeof Loading !== "undefined" && !isValidElementType(Loading)) {
            throw new Error(`The default export of loading is not a React Component in ${segment}`);
        }
        if (typeof NotFound !== "undefined" && !isValidElementType(NotFound)) {
            throw new Error(`The default export of notFound is not a React Component in ${segment}`);
        }
    }
    // Handle dynamic segment params.
    const segmentParam = getDynamicParamFromSegment(segment);
    /**
   * Create object holding the parent params and current params
   */ const currentParams = // Handle null case where dynamic param is optional
    segmentParam && segmentParam.value !== null ? {
        ...parentParams,
        [segmentParam.param]: segmentParam.value
    } : parentParams;
    // Resolve the segment param
    const actualSegment = segmentParam ? segmentParam.treeSegment : segment;
    //
    // TODO: Combine this `map` traversal with the loop below that turns the array
    // into an object.
    const parallelRouteMap = await Promise.all(Object.keys(parallelRoutes).map(async (parallelRouteKey)=>{
        const isChildrenRouteKey = parallelRouteKey === "children";
        const currentSegmentPath = firstItem ? [
            parallelRouteKey
        ] : [
            actualSegment,
            parallelRouteKey
        ];
        const parallelRoute = parallelRoutes[parallelRouteKey];
        const notFoundComponent = NotFound && isChildrenRouteKey ? /*#__PURE__*/ _jsx(NotFound, {}) : undefined;
        // if we're prefetching and that there's a Loading component, we bail out
        // otherwise we keep rendering for the prefetch.
        // We also want to bail out if there's no Loading component in the tree.
        let currentStyles = undefined;
        let childCacheNodeSeedData = null;
        if (// Before PPR, the way instant navigations work in Next.js is we
        // prefetch everything up to the first route segment that defines a
        // loading.tsx boundary. (We do the same if there's no loading
        // boundary in the entire tree, because we don't want to prefetch too
        // much) The rest of the tree is defered until the actual navigation.
        // It does not take into account whether the data is dynamic â€” even if
        // the tree is completely static, it will still defer everything
        // inside the loading boundary.
        //
        // This behavior predates PPR and is only relevant if the
        // PPR flag is not enabled.
        isPrefetch && (Loading || !hasLoadingComponentInTree(parallelRoute)) && // The approach with PPR is different â€” loading.tsx behaves like a
        // regular Suspense boundary and has no special behavior.
        //
        // With PPR, we prefetch as deeply as possible, and only defer when
        // dynamic data is accessed. If so, we only defer the nearest parent
        // Suspense boundary of the dynamic data access, regardless of whether
        // the boundary is defined by loading.tsx or a normal <Suspense>
        // component in userspace.
        //
        // NOTE: In practice this usually means we'll end up prefetching more
        // than we were before PPR, which may or may not be considered a
        // performance regression by some apps. The plan is to address this
        // before General Availability of PPR by introducing granular
        // per-segment fetching, so we can reuse as much of the tree as
        // possible during both prefetches and dynamic navigations. But during
        // the beta period, we should be clear about this trade off in our
        // communications.
        !experimental.ppr) {
        // Don't prefetch this child. This will trigger a lazy fetch by the
        // client router.
        } else {
            // Create the child component
            if (process.env.NODE_ENV === "development" && missingSlots) {
                var _parsedTree_layoutOrPagePath;
                // When we detect the default fallback (which triggers a 404), we collect the missing slots
                // to provide more helpful debug information during development mode.
                const parsedTree = parseLoaderTree(parallelRoute);
                if ((_parsedTree_layoutOrPagePath = parsedTree.layoutOrPagePath) == null ? void 0 : _parsedTree_layoutOrPagePath.endsWith(PARALLEL_ROUTE_DEFAULT_PATH)) {
                    missingSlots.add(parallelRouteKey);
                }
            }
            const { seedData, styles: childComponentStyles } = await createComponentTreeInternal({
                createSegmentPath: (child)=>{
                    return createSegmentPath([
                        ...currentSegmentPath,
                        ...child
                    ]);
                },
                loaderTree: parallelRoute,
                parentParams: currentParams,
                rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,
                injectedCSS: injectedCSSWithCurrentLayout,
                injectedJS: injectedJSWithCurrentLayout,
                injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,
                asNotFound,
                metadataOutlet,
                ctx,
                missingSlots
            });
            currentStyles = childComponentStyles;
            childCacheNodeSeedData = seedData;
        }
        // This is turned back into an object below.
        return [
            parallelRouteKey,
            /*#__PURE__*/ _jsx(LayoutRouter, {
                parallelRouterKey: parallelRouteKey,
                segmentPath: createSegmentPath(currentSegmentPath),
                // TODO-APP: Add test for loading returning `undefined`. This currently can't be tested as the `webdriver()` tab will wait for the full page to load before returning.
                error: ErrorComponent,
                errorStyles: errorStyles,
                errorScripts: errorScripts,
                template: /*#__PURE__*/ _jsx(Template, {
                    children: /*#__PURE__*/ _jsx(RenderFromTemplateContext, {})
                }),
                templateStyles: templateStyles,
                templateScripts: templateScripts,
                notFound: notFoundComponent,
                notFoundStyles: notFoundStyles,
                styles: currentStyles
            }),
            childCacheNodeSeedData
        ];
    }));
    // Convert the parallel route map into an object after all promises have been resolved.
    let parallelRouteProps = {};
    let parallelRouteCacheNodeSeedData = {};
    for (const parallelRoute of parallelRouteMap){
        const [parallelRouteKey, parallelRouteProp, flightData] = parallelRoute;
        parallelRouteProps[parallelRouteKey] = parallelRouteProp;
        parallelRouteCacheNodeSeedData[parallelRouteKey] = flightData;
    }
    const loadingData = Loading ? [
        /*#__PURE__*/ _jsx(Loading, {}),
        loadingStyles,
        loadingScripts
    ] : null;
    // When the segment does not have a layout or page we still have to add the layout router to ensure the path holds the loading component
    if (!Component) {
        return {
            seedData: [
                actualSegment,
                parallelRouteCacheNodeSeedData,
                // TODO: I don't think the extra fragment is necessary. React treats top
                // level fragments as transparent, i.e. the runtime behavior should be
                // identical even without it. But maybe there's some findDOMNode-related
                // reason that I'm not aware of, so I'm leaving it as-is out of extreme
                // caution, for now.
                /*#__PURE__*/ _jsx(_Fragment, {
                    children: parallelRouteProps.children
                }),
                loadingData
            ],
            styles: layerAssets
        };
    }
    // If force-dynamic is used and the current render supports postponing, we
    // replace it with a node that will postpone the render. This ensures that the
    // postpone is invoked during the react render phase and not during the next
    // render phase.
    // @TODO this does not actually do what it seems like it would or should do. The idea is that
    // if we are rendering in a force-dynamic mode and we can postpone we should only make the segments
    // that ask for force-dynamic to be dynamic, allowing other segments to still prerender. However
    // because this comes after the children traversal and the static generation store is mutated every segment
    // along the parent path of a force-dynamic segment will hit this condition effectively making the entire
    // render force-dynamic. We should refactor this function so that we can correctly track which segments
    // need to be dynamic
    if (staticGenerationStore.forceDynamic && staticGenerationStore.prerenderState) {
        return {
            seedData: [
                actualSegment,
                parallelRouteCacheNodeSeedData,
                /*#__PURE__*/ _jsx(Postpone, {
                    prerenderState: staticGenerationStore.prerenderState,
                    reason: 'dynamic = "force-dynamic" was used',
                    pathname: staticGenerationStore.urlPathname
                }),
                loadingData
            ],
            styles: layerAssets
        };
    }
    const isClientComponent = isClientReference(layoutOrPageMod);
    // We avoid cloning this object because it gets consumed here exclusively.
    const props = parallelRouteProps;
    // If it's a not found route, and we don't have any matched parallel
    // routes, we try to render the not found component if it exists.
    if (NotFound && asNotFound && // In development, it could hit the parallel-route-default not found, so we only need to check the segment.
    // Or if there's no parallel routes means it reaches the end.
    !parallelRouteMap.length) {
        props.children = /*#__PURE__*/ _jsxs(_Fragment, {
            children: [
                /*#__PURE__*/ _jsx("meta", {
                    name: "robots",
                    content: "noindex"
                }),
                process.env.NODE_ENV === "development" && /*#__PURE__*/ _jsx("meta", {
                    name: "next-error",
                    content: "not-found"
                }),
                notFoundStyles,
                /*#__PURE__*/ _jsx(NotFound, {})
            ]
        });
    }
    // Assign params to props
    if (process.env.NODE_ENV === "development" && "params" in parallelRouteProps) {
        // @TODO consider making this an error and running the check in build as well
        console.error(`"params" is a reserved prop in Layouts and Pages and cannot be used as the name of a parallel route in ${segment}`);
    }
    props.params = currentParams;
    let segmentElement;
    if (isPage) {
        // Assign searchParams to props if this is a page
        if (isClientComponent) {
            // When we are passing searchParams to a client component Page we don't want to track the dynamic access
            // here in the RSC layer because the serialization will trigger a dynamic API usage.
            // Instead we pass the searchParams untracked but we wrap the Page in a root client component
            // which can among other things adds the dynamic tracking before rendering the page.
            // @TODO make the root wrapper part of next-app-loader so we don't need the extra client component
            props.searchParams = createUntrackedSearchParams(query);
            segmentElement = /*#__PURE__*/ _jsxs(_Fragment, {
                children: [
                    metadataOutlet,
                    /*#__PURE__*/ _jsx(ClientPageRoot, {
                        props: props,
                        Component: Component
                    })
                ]
            });
        } else {
            // If we are passing searchParams to a server component Page we need to track their usage in case
            // the current render mode tracks dynamic API usage.
            props.searchParams = createDynamicallyTrackedSearchParams(query);
            segmentElement = /*#__PURE__*/ _jsxs(_Fragment, {
                children: [
                    metadataOutlet,
                    /*#__PURE__*/ _jsx(Component, {
                        ...props
                    })
                ]
            });
        }
    } else {
        // For layouts we just render the component
        segmentElement = /*#__PURE__*/ _jsx(Component, {
            ...props
        });
    }
    return {
        seedData: [
            actualSegment,
            parallelRouteCacheNodeSeedData,
            /*#__PURE__*/ _jsxs(_Fragment, {
                children: [
                    segmentElement,
                    null
                ]
            }),
            loadingData
        ],
        styles: layerAssets
    };
}

//# sourceMappingURL=create-component-tree.js.mapY   import { jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React from "react";
import { canSegmentBeOverridden, matchSegment } from "../../client/components/match-segments";
import { getLinkAndScriptTags } from "./get-css-inlined-link-tags";
import { getPreloadableFonts } from "./get-preloadable-fonts";
import { addSearchParamsIfPageSegment, createFlightRouterStateFromLoaderTree } from "./create-flight-router-state-from-loader-tree";
import { parseLoaderTree } from "./parse-loader-tree";
import { getLayerAssets } from "./get-layer-assets";
import { hasLoadingComponentInTree } from "./has-loading-component-in-tree";
import { createComponentTree } from "./create-component-tree";
import { DEFAULT_SEGMENT_KEY } from "../../shared/lib/segment";
/**
 * Use router state to decide at what common layout to render the page.
 * This can either be the common layout between two pages or a specific place to start rendering from using the "refetch" marker in the tree.
 */ export async function walkTreeWithFlightRouterState({ createSegmentPath, loaderTreeToFilter, parentParams, isFirst, flightRouterState, parentRendered, rscPayloadHead, injectedCSS, injectedJS, injectedFontPreloadTags, rootLayoutIncluded, asNotFound, metadataOutlet, ctx }) {
    const { renderOpts: { nextFontManifest, experimental }, query, isPrefetch, getDynamicParamFromSegment, componentMod: { tree: loaderTree } } = ctx;
    const [segment, parallelRoutes, components] = loaderTreeToFilter;
    const parallelRoutesKeys = Object.keys(parallelRoutes);
    const { layout } = components;
    const isLayout = typeof layout !== "undefined";
    /**
   * Checks if the current segment is a root layout.
   */ const rootLayoutAtThisLevel = isLayout && !rootLayoutIncluded;
    /**
   * Checks if the current segment or any level above it has a root layout.
   */ const rootLayoutIncludedAtThisLevelOrAbove = rootLayoutIncluded || rootLayoutAtThisLevel;
    // Because this function walks to a deeper point in the tree to start rendering we have to track the dynamic parameters up to the point where rendering starts
    const segmentParam = getDynamicParamFromSegment(segment);
    const currentParams = // Handle null case where dynamic param is optional
    segmentParam && segmentParam.value !== null ? {
        ...parentParams,
        [segmentParam.param]: segmentParam.value
    } : parentParams;
    const actualSegment = addSearchParamsIfPageSegment(segmentParam ? segmentParam.treeSegment : segment, query);
    /**
   * Decide if the current segment is where rendering has to start.
   */ const renderComponentsOnThisLevel = // No further router state available
    !flightRouterState || // Segment in router state does not match current segment
    !matchSegment(actualSegment, flightRouterState[0]) || // Last item in the tree
    parallelRoutesKeys.length === 0 || // Explicit refresh
    flightRouterState[3] === "refetch";
    const shouldSkipComponentTree = // loading.tsx has no effect on prefetching when PPR is enabled
    !experimental.ppr && isPrefetch && !Boolean(components.loading) && (flightRouterState || // If there is no flightRouterState, we need to check the entire loader tree, as otherwise we'll be only checking the root
    !hasLoadingComponentInTree(loaderTree));
    if (!parentRendered && renderComponentsOnThisLevel) {
        const overriddenSegment = flightRouterState && canSegmentBeOverridden(actualSegment, flightRouterState[0]) ? flightRouterState[0] : actualSegment;
        const routerState = createFlightRouterStateFromLoaderTree(// Create router state using the slice of the loaderTree
        loaderTreeToFilter, getDynamicParamFromSegment, query);
        if (shouldSkipComponentTree) {
            // Send only the router state
            return [
                [
                    overriddenSegment,
                    routerState,
                    null,
                    null
                ]
            ];
        } else {
            // Create component tree using the slice of the loaderTree
            const { seedData } = await createComponentTree(// This ensures flightRouterPath is valid and filters down the tree
            {
                ctx,
                createSegmentPath,
                loaderTree: loaderTreeToFilter,
                parentParams: currentParams,
                firstItem: isFirst,
                injectedCSS,
                injectedJS,
                injectedFontPreloadTags,
                // This is intentionally not "rootLayoutIncludedAtThisLevelOrAbove" as createComponentTree starts at the current level and does a check for "rootLayoutAtThisLevel" too.
                rootLayoutIncluded,
                asNotFound,
                metadataOutlet
            });
            // Create head
            const { layoutOrPagePath } = parseLoaderTree(loaderTreeToFilter);
            const layerAssets = getLayerAssets({
                ctx,
                layoutOrPagePath,
                injectedCSS: new Set(injectedCSS),
                injectedJS: new Set(injectedJS),
                injectedFontPreloadTags: new Set(injectedFontPreloadTags)
            });
            const head = /*#__PURE__*/ _jsxs(_Fragment, {
                children: [
                    layerAssets,
                    rscPayloadHead
                ]
            });
            return [
                [
                    overriddenSegment,
                    routerState,
                    seedData,
                    head
                ]
            ];
        }
    }
    // If we are not rendering on this level we need to check if the current
    // segment has a layout. If so, we need to track all the used CSS to make
    // the result consistent.
    const layoutPath = layout == null ? void 0 : layout[1];
    const injectedCSSWithCurrentLayout = new Set(injectedCSS);
    const injectedJSWithCurrentLayout = new Set(injectedJS);
    const injectedFontPreloadTagsWithCurrentLayout = new Set(injectedFontPreloadTags);
    if (layoutPath) {
        getLinkAndScriptTags(ctx.clientReferenceManifest, layoutPath, injectedCSSWithCurrentLayout, injectedJSWithCurrentLayout, true);
        getPreloadableFonts(nextFontManifest, layoutPath, injectedFontPreloadTagsWithCurrentLayout);
    }
    // Walk through all parallel routes.
    const paths = (await Promise.all(parallelRoutesKeys.map(async (parallelRouteKey)=>{
        // for (const parallelRouteKey of parallelRoutesKeys) {
        const parallelRoute = parallelRoutes[parallelRouteKey];
        const currentSegmentPath = isFirst ? [
            parallelRouteKey
        ] : [
            actualSegment,
            parallelRouteKey
        ];
        const path = await walkTreeWithFlightRouterState({
            ctx,
            createSegmentPath: (child)=>{
                return createSegmentPath([
                    ...currentSegmentPath,
                    ...child
                ]);
            },
            loaderTreeToFilter: parallelRoute,
            parentParams: currentParams,
            flightRouterState: flightRouterState && flightRouterState[1][parallelRouteKey],
            parentRendered: parentRendered || renderComponentsOnThisLevel,
            isFirst: false,
            rscPayloadHead,
            injectedCSS: injectedCSSWithCurrentLayout,
            injectedJS: injectedJSWithCurrentLayout,
            injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,
            rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,
            asNotFound,
            metadataOutlet
        });
        return path.map((item)=>{
            // we don't need to send over default routes in the flight data
            // because they are always ignored by the client, unless it's a refetch
            if (item[0] === DEFAULT_SEGMENT_KEY && flightRouterState && !!flightRouterState[1][parallelRouteKey][0] && flightRouterState[1][parallelRouteKey][3] !== "refetch") {
                return null;
            }
            return [
                actualSegment,
                parallelRouteKey,
                ...item
            ];
        }).filter(Boolean);
    }))).flat();
    return paths;
}

//# sourceMappingURL=walk-tree-with-flight-router-state.js.map›  class StaticRenderer {
    constructor(options){
        this.options = options;
        this.prerender = process.env.__NEXT_EXPERIMENTAL_REACT ? require("react-dom/static.edge").prerender : null;
    }
    async render(children) {
        const { prelude, postponed } = await this.prerender(children, this.options);
        return {
            stream: prelude,
            postponed
        };
    }
}
class StaticResumeRenderer {
    constructor(postponed, options){
        this.postponed = postponed;
        this.options = options;
        this.resume = require("react-dom/server.edge").resume;
    }
    async render(children) {
        const stream = await this.resume(children, this.postponed, this.options);
        return {
            stream,
            resumed: true
        };
    }
}
export class ServerRenderer {
    constructor(options){
        this.options = options;
        this.renderToReadableStream = require("react-dom/server.edge").renderToReadableStream;
    }
    async render(children) {
        const stream = await this.renderToReadableStream(children, this.options);
        return {
            stream
        };
    }
}
export class VoidRenderer {
    async render(_children) {
        return {
            stream: new ReadableStream({
                start (controller) {
                    // Close the stream immediately
                    controller.close();
                }
            }),
            resumed: false
        };
    }
}
export const DYNAMIC_DATA = 1;
export const DYNAMIC_HTML = 2;
export function getDynamicHTMLPostponedState(data) {
    return [
        DYNAMIC_HTML,
        data
    ];
}
export function getDynamicDataPostponedState() {
    return DYNAMIC_DATA;
}
export function createStaticRenderer({ ppr, isStaticGeneration, postponed, streamOptions: { signal, onError, onPostpone, onHeaders, maxHeadersLength, nonce, bootstrapScripts, formState } }) {
    if (ppr) {
        if (isStaticGeneration) {
            // This is a Prerender
            return new StaticRenderer({
                signal,
                onError,
                onPostpone,
                // We want to capture headers because we may not end up with a shell
                // and being able to send headers is the next best thing
                onHeaders,
                maxHeadersLength,
                bootstrapScripts
            });
        } else {
            // This is a Resume
            if (postponed === DYNAMIC_DATA) {
                // The HTML was complete, we don't actually need to render anything
                return new VoidRenderer();
            } else if (postponed) {
                const reactPostponedState = postponed[1];
                // The HTML had dynamic holes and we need to resume it
                return new StaticResumeRenderer(reactPostponedState, {
                    signal,
                    onError,
                    onPostpone,
                    nonce
                });
            }
        }
    }
    if (isStaticGeneration) {
        // This is a static render (without PPR)
        return new ServerRenderer({
            signal,
            onError,
            // We don't pass onHeaders. In static builds we will either have no output
            // or the entire page. In either case preload headers aren't necessary and could
            // alter the prioritiy of relative loading of resources so we opt to keep them
            // as tags exclusively.
            nonce,
            bootstrapScripts,
            formState
        });
    }
    // This is a dynamic render (without PPR)
    return new ServerRenderer({
        signal,
        onError,
        // Static renders are streamed in realtime so sending headers early is
        // generally good because it will likely go out before the shell is ready.
        onHeaders,
        maxHeadersLength,
        nonce,
        bootstrapScripts,
        formState
    });
}

//# sourceMappingURL=static-renderer.js.map¾  import { htmlEscapeJsonString } from "../htmlescape";
const isEdgeRuntime = process.env.NEXT_RUNTIME === "edge";
const INLINE_FLIGHT_PAYLOAD_BOOTSTRAP = 0;
const INLINE_FLIGHT_PAYLOAD_DATA = 1;
const INLINE_FLIGHT_PAYLOAD_FORM_STATE = 2;
const flightResponses = new WeakMap();
const encoder = new TextEncoder();
/**
 * Render Flight stream.
 * This is only used for renderToHTML, the Flight response does not need additional wrappers.
 */ export function useFlightStream(flightStream, clientReferenceManifest, nonce) {
    const response = flightResponses.get(flightStream);
    if (response) {
        return response;
    }
    // react-server-dom-webpack/client.edge must not be hoisted for require cache clearing to work correctly
    let createFromReadableStream;
    // @TODO: investigate why the aliasing for turbopack doesn't pick this up, requiring this runtime check
    if (process.env.TURBOPACK) {
        createFromReadableStream = // eslint-disable-next-line import/no-extraneous-dependencies
        require("react-server-dom-turbopack/client.edge").createFromReadableStream;
    } else {
        createFromReadableStream = // eslint-disable-next-line import/no-extraneous-dependencies
        require("react-server-dom-webpack/client.edge").createFromReadableStream;
    }
    const newResponse = createFromReadableStream(flightStream, {
        ssrManifest: {
            moduleLoading: clientReferenceManifest.moduleLoading,
            moduleMap: isEdgeRuntime ? clientReferenceManifest.edgeSSRModuleMapping : clientReferenceManifest.ssrModuleMapping
        },
        nonce
    });
    flightResponses.set(flightStream, newResponse);
    return newResponse;
}
/**
 * There are times when an SSR render may be finished but the RSC render
 * is ongoing and we need to wait for it to complete to make some determination
 * about how to handle the render. This function will drain the RSC reader and
 * resolve when completed. This will generally require teeing the RSC stream and it
 * should be noted that it will cause all the RSC chunks to queue in the underlying
 * ReadableStream however given Flight currently is a push stream that doesn't respond
 * to backpressure this shouldn't change how much memory is maximally consumed
 */ export async function flightRenderComplete(flightStream) {
    const flightReader = flightStream.getReader();
    while(true){
        const { done } = await flightReader.read();
        if (done) {
            return;
        }
    }
}
/**
 * Creates a ReadableStream provides inline script tag chunks for writing hydration
 * data to the client outside the React render itself.
 *
 * @param flightStream The RSC render stream
 * @param nonce optionally a nonce used during this particular render
 * @param formState optionally the formState used with this particular render
 * @returns a ReadableStream without the complete property. This signifies a lazy ReadableStream
 */ export function createInlinedDataReadableStream(flightStream, nonce, formState) {
    const startScriptTag = nonce ? `<script nonce=${JSON.stringify(nonce)}>` : "<script>";
    const decoder = new TextDecoder("utf-8", {
        fatal: true
    });
    const decoderOptions = {
        stream: true
    };
    const flightReader = flightStream.getReader();
    const readable = new ReadableStream({
        type: "bytes",
        start (controller) {
            try {
                writeInitialInstructions(controller, startScriptTag, formState);
            } catch (error) {
                // during encoding or enqueueing forward the error downstream
                controller.error(error);
            }
        },
        async pull (controller) {
            try {
                const { done, value } = await flightReader.read();
                if (done) {
                    const tail = decoder.decode(value, {
                        stream: false
                    });
                    if (tail.length) {
                        writeFlightDataInstruction(controller, startScriptTag, tail);
                    }
                    controller.close();
                } else {
                    const chunkAsString = decoder.decode(value, decoderOptions);
                    writeFlightDataInstruction(controller, startScriptTag, chunkAsString);
                }
            } catch (error) {
                // There was a problem in the upstream reader or during decoding or enqueuing
                // forward the error downstream
                controller.error(error);
            }
        }
    });
    return readable;
}
function writeInitialInstructions(controller, scriptStart, formState) {
    controller.enqueue(encoder.encode(`${scriptStart}(self.__next_f=self.__next_f||[]).push(${htmlEscapeJsonString(JSON.stringify([
        INLINE_FLIGHT_PAYLOAD_BOOTSTRAP
    ]))});self.__next_f.push(${htmlEscapeJsonString(JSON.stringify([
        INLINE_FLIGHT_PAYLOAD_FORM_STATE,
        formState
    ]))})</script>`));
}
function writeFlightDataInstruction(controller, scriptStart, chunkAsString) {
    controller.enqueue(encoder.encode(`${scriptStart}self.__next_f.push(${htmlEscapeJsonString(JSON.stringify([
        INLINE_FLIGHT_PAYLOAD_DATA,
        chunkAsString
    ]))})</script>`));
}

//# sourceMappingURL=use-flight-response.js.map«¼  import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React from "react";
import RenderResult from "../render-result";
import { chainStreams, renderToInitialFizzStream, continueFizzStream, continueDynamicPrerender, continueStaticPrerender, continueDynamicHTMLResume, continueDynamicDataResume } from "../stream-utils/node-web-streams-helper";
import { canSegmentBeOverridden } from "../../client/components/match-segments";
import { stripInternalQueries } from "../internal-utils";
import { NEXT_ROUTER_PREFETCH_HEADER, NEXT_ROUTER_STATE_TREE, NEXT_URL, RSC_HEADER } from "../../client/components/app-router-headers";
import { createMetadataComponents } from "../../lib/metadata/metadata";
import { RequestAsyncStorageWrapper } from "../async-storage/request-async-storage-wrapper";
import { StaticGenerationAsyncStorageWrapper } from "../async-storage/static-generation-async-storage-wrapper";
import { isNotFoundError } from "../../client/components/not-found";
import { getURLFromRedirectError, isRedirectError, getRedirectStatusCodeFromError } from "../../client/components/redirect";
import { addImplicitTags } from "../lib/patch-fetch";
import { AppRenderSpan, NextNodeServerSpan } from "../lib/trace/constants";
import { getTracer } from "../lib/trace/tracer";
import { FlightRenderResult } from "./flight-render-result";
import { createErrorHandler, ErrorHandlerSource } from "./create-error-handler";
import { getShortDynamicParamType, dynamicParamTypes } from "./get-short-dynamic-param-type";
import { getSegmentParam } from "./get-segment-param";
import { getScriptNonceFromHeader } from "./get-script-nonce-from-header";
import { parseAndValidateFlightRouterState } from "./parse-and-validate-flight-router-state";
import { validateURL } from "./validate-url";
import { createFlightRouterStateFromLoaderTree } from "./create-flight-router-state-from-loader-tree";
import { handleAction } from "./action-handler";
import { isBailoutToCSRError } from "../../shared/lib/lazy-dynamic/bailout-to-csr";
import { warn, error } from "../../build/output/log";
import { appendMutableCookies } from "../web/spec-extension/adapters/request-cookies";
import { createServerInsertedHTML } from "./server-inserted-html";
import { getRequiredScripts } from "./required-scripts";
import { addPathPrefix } from "../../shared/lib/router/utils/add-path-prefix";
import { makeGetServerInsertedHTML } from "./make-get-server-inserted-html";
import { walkTreeWithFlightRouterState } from "./walk-tree-with-flight-router-state";
import { createComponentTree } from "./create-component-tree";
import { getAssetQueryString } from "./get-asset-query-string";
import { setReferenceManifestsSingleton } from "./encryption-utils";
import { createStaticRenderer, getDynamicDataPostponedState, getDynamicHTMLPostponedState } from "./static/static-renderer";
import { isDynamicServerError } from "../../client/components/hooks-server-context";
import { useFlightStream, createInlinedDataReadableStream, flightRenderComplete } from "./use-flight-response";
import { StaticGenBailoutError, isStaticGenBailoutError } from "../../client/components/static-generation-bailout";
import { isInterceptionRouteAppPath } from "../future/helpers/interception-routes";
import { getStackWithoutErrorMessage } from "../../lib/format-server-error";
import { usedDynamicAPIs, createPostponedAbortSignal, formatDynamicAPIAccesses } from "./dynamic-rendering";
import { getClientComponentLoaderMetrics, wrapClientComponentLoader } from "../client-component-renderer-logger";
import { createServerModuleMap } from "./action-utils";
function createNotFoundLoaderTree(loaderTree) {
    // Align the segment with parallel-route-default in next-app-loader
    return [
        "",
        {},
        loaderTree[2]
    ];
}
/* This method is important for intercepted routes to function:
 * when a route is intercepted, e.g. /blog/[slug], it will be rendered
 * with the layout of the previous page, e.g. /profile/[id]. The problem is
 * that the loader tree needs to know the dynamic param in order to render (id and slug in the example).
 * Normally they are read from the path but since we are intercepting the route, the path would not contain id,
 * so we need to read it from the router state.
 */ function findDynamicParamFromRouterState(flightRouterState, segment) {
    if (!flightRouterState) {
        return null;
    }
    const treeSegment = flightRouterState[0];
    if (canSegmentBeOverridden(segment, treeSegment)) {
        if (!Array.isArray(treeSegment) || Array.isArray(segment)) {
            return null;
        }
        return {
            param: treeSegment[0],
            value: treeSegment[1],
            treeSegment: treeSegment,
            type: treeSegment[2]
        };
    }
    for (const parallelRouterState of Object.values(flightRouterState[1])){
        const maybeDynamicParam = findDynamicParamFromRouterState(parallelRouterState, segment);
        if (maybeDynamicParam) {
            return maybeDynamicParam;
        }
    }
    return null;
}
/**
 * Returns a function that parses the dynamic segment and return the associated value.
 */ function makeGetDynamicParamFromSegment(params, flightRouterState) {
    return function getDynamicParamFromSegment(// [slug] / [[slug]] / [...slug]
    segment) {
        const segmentParam = getSegmentParam(segment);
        if (!segmentParam) {
            return null;
        }
        const key = segmentParam.param;
        let value = params[key];
        // this is a special marker that will be present for interception routes
        if (value === "__NEXT_EMPTY_PARAM__") {
            value = undefined;
        }
        if (Array.isArray(value)) {
            value = value.map((i)=>encodeURIComponent(i));
        } else if (typeof value === "string") {
            value = encodeURIComponent(value);
        }
        if (!value) {
            // Handle case where optional catchall does not have a value, e.g. `/dashboard/[...slug]` when requesting `/dashboard`
            if (segmentParam.type === "optional-catchall") {
                const type = dynamicParamTypes[segmentParam.type];
                return {
                    param: key,
                    value: null,
                    type: type,
                    // This value always has to be a string.
                    treeSegment: [
                        key,
                        "",
                        type
                    ]
                };
            }
            return findDynamicParamFromRouterState(flightRouterState, segment);
        }
        const type = getShortDynamicParamType(segmentParam.type);
        return {
            param: key,
            // The value that is passed to user code.
            value: value,
            // The value that is rendered in the router tree.
            treeSegment: [
                key,
                Array.isArray(value) ? value.join("/") : value,
                type
            ],
            type: type
        };
    };
}
function NonIndex({ ctx }) {
    const is404Page = ctx.pagePath === "/404";
    const isInvalidStatusCode = typeof ctx.res.statusCode === "number" && ctx.res.statusCode > 400;
    if (is404Page || isInvalidStatusCode) {
        return /*#__PURE__*/ _jsx("meta", {
            name: "robots",
            content: "noindex"
        });
    }
    return null;
}
// Handle Flight render request. This is only used when client-side navigating. E.g. when you `router.push('/dashboard')` or `router.reload()`.
async function generateFlight(ctx, options) {
    // Flight data that is going to be passed to the browser.
    // Currently a single item array but in the future multiple patches might be combined in a single request.
    let flightData = null;
    const { componentMod: { tree: loaderTree, renderToReadableStream, createDynamicallyTrackedSearchParams }, getDynamicParamFromSegment, appUsingSizeAdjustment, staticGenerationStore: { urlPathname }, query, requestId, flightRouterState } = ctx;
    if (!(options == null ? void 0 : options.skipFlight)) {
        const [MetadataTree, MetadataOutlet] = createMetadataComponents({
            tree: loaderTree,
            pathname: urlPathname,
            trailingSlash: ctx.renderOpts.trailingSlash,
            query,
            getDynamicParamFromSegment,
            appUsingSizeAdjustment,
            createDynamicallyTrackedSearchParams
        });
        flightData = (await walkTreeWithFlightRouterState({
            ctx,
            createSegmentPath: (child)=>child,
            loaderTreeToFilter: loaderTree,
            parentParams: {},
            flightRouterState,
            isFirst: true,
            // For flight, render metadata inside leaf page
            rscPayloadHead: /*#__PURE__*/ _jsxs(_Fragment, {
                children: [
                    /*#__PURE__*/ _jsx(NonIndex, {
                        ctx: ctx
                    }),
                    /*#__PURE__*/ _jsx(MetadataTree, {}, requestId)
                ]
            }),
            injectedCSS: new Set(),
            injectedJS: new Set(),
            injectedFontPreloadTags: new Set(),
            rootLayoutIncluded: false,
            asNotFound: ctx.isNotFoundPath || (options == null ? void 0 : options.asNotFound),
            metadataOutlet: /*#__PURE__*/ _jsx(MetadataOutlet, {})
        })).map((path)=>path.slice(1)) // remove the '' (root) segment
        ;
    }
    const buildIdFlightDataPair = [
        ctx.renderOpts.buildId,
        flightData
    ];
    // For app dir, use the bundled version of Flight server renderer (renderToReadableStream)
    // which contains the subset React.
    const flightReadableStream = renderToReadableStream(options ? [
        options.actionResult,
        buildIdFlightDataPair
    ] : buildIdFlightDataPair, ctx.clientReferenceManifest.clientModules, {
        onError: ctx.flightDataRendererErrorHandler
    });
    return new FlightRenderResult(flightReadableStream);
}
/**
 * Creates a resolver that eagerly generates a flight payload that is then
 * resolved when the resolver is called.
 */ function createFlightDataResolver(ctx) {
    // Generate the flight data and as soon as it can, convert it into a string.
    const promise = generateFlight(ctx).then(async (result)=>({
            flightData: await result.toUnchunkedString(true)
        }))// Otherwise if it errored, return the error.
    .catch((err)=>({
            err
        }));
    return async ()=>{
        // Resolve the promise to get the flight data or error.
        const result = await promise;
        // If the flight data failed to render due to an error, re-throw the error
        // here.
        if ("err" in result) {
            throw result.err;
        }
        // Otherwise, return the flight data.
        return result.flightData;
    };
}
// This is the root component that runs in the RSC context
async function ReactServerApp({ tree, ctx, asNotFound }) {
    // Create full component tree from root to leaf.
    const injectedCSS = new Set();
    const injectedJS = new Set();
    const injectedFontPreloadTags = new Set();
    const missingSlots = new Set();
    const { getDynamicParamFromSegment, query, appUsingSizeAdjustment, componentMod: { AppRouter, GlobalError, createDynamicallyTrackedSearchParams }, staticGenerationStore: { urlPathname } } = ctx;
    const initialTree = createFlightRouterStateFromLoaderTree(tree, getDynamicParamFromSegment, query);
    const [MetadataTree, MetadataOutlet] = createMetadataComponents({
        tree,
        errorType: asNotFound ? "not-found" : undefined,
        pathname: urlPathname,
        trailingSlash: ctx.renderOpts.trailingSlash,
        query,
        getDynamicParamFromSegment: getDynamicParamFromSegment,
        appUsingSizeAdjustment: appUsingSizeAdjustment,
        createDynamicallyTrackedSearchParams
    });
    const { seedData, styles } = await createComponentTree({
        ctx,
        createSegmentPath: (child)=>child,
        loaderTree: tree,
        parentParams: {},
        firstItem: true,
        injectedCSS,
        injectedJS,
        injectedFontPreloadTags,
        rootLayoutIncluded: false,
        asNotFound: asNotFound,
        metadataOutlet: /*#__PURE__*/ _jsx(MetadataOutlet, {}),
        missingSlots
    });
    // When the `vary` response header is present with `Next-URL`, that means there's a chance
    // it could respond differently if there's an interception route. We provide this information
    // to `AppRouter` so that it can properly seed the prefetch cache with a prefix, if needed.
    const varyHeader = ctx.res.getHeader("vary");
    const couldBeIntercepted = typeof varyHeader === "string" && varyHeader.includes(NEXT_URL);
    return /*#__PURE__*/ _jsxs(_Fragment, {
        children: [
            styles,
            /*#__PURE__*/ _jsx(AppRouter, {
                buildId: ctx.renderOpts.buildId,
                assetPrefix: ctx.assetPrefix,
                initialCanonicalUrl: urlPathname,
                // This is the router state tree.
                initialTree: initialTree,
                // This is the tree of React nodes that are seeded into the cache
                initialSeedData: seedData,
                couldBeIntercepted: couldBeIntercepted,
                initialHead: /*#__PURE__*/ _jsxs(_Fragment, {
                    children: [
                        /*#__PURE__*/ _jsx(NonIndex, {
                            ctx: ctx
                        }),
                        /*#__PURE__*/ _jsx(MetadataTree, {}, ctx.requestId)
                    ]
                }),
                globalErrorComponent: GlobalError,
                // This is used to provide debug information (when in development mode)
                // about which slots were not filled by page components while creating the component tree.
                missingSlots: missingSlots
            })
        ]
    });
}
// This is the root component that runs in the RSC context
async function ReactServerError({ tree, ctx, errorType }) {
    const { getDynamicParamFromSegment, query, appUsingSizeAdjustment, componentMod: { AppRouter, GlobalError, createDynamicallyTrackedSearchParams }, staticGenerationStore: { urlPathname }, requestId } = ctx;
    const [MetadataTree] = createMetadataComponents({
        tree,
        pathname: urlPathname,
        trailingSlash: ctx.renderOpts.trailingSlash,
        errorType,
        query,
        getDynamicParamFromSegment,
        appUsingSizeAdjustment,
        createDynamicallyTrackedSearchParams
    });
    const head = /*#__PURE__*/ _jsxs(_Fragment, {
        children: [
            /*#__PURE__*/ _jsx(NonIndex, {
                ctx: ctx
            }),
            /*#__PURE__*/ _jsx(MetadataTree, {}, requestId),
            process.env.NODE_ENV === "development" && /*#__PURE__*/ _jsx("meta", {
                name: "next-error",
                content: "not-found"
            })
        ]
    });
    const initialTree = createFlightRouterStateFromLoaderTree(tree, getDynamicParamFromSegment, query);
    // For metadata notFound error there's no global not found boundary on top
    // so we create a not found page with AppRouter
    const initialSeedData = [
        initialTree[0],
        {},
        /*#__PURE__*/ _jsxs("html", {
            id: "__next_error__",
            children: [
                /*#__PURE__*/ _jsx("head", {}),
                /*#__PURE__*/ _jsx("body", {})
            ]
        }),
        null
    ];
    return /*#__PURE__*/ _jsx(AppRouter, {
        buildId: ctx.renderOpts.buildId,
        assetPrefix: ctx.assetPrefix,
        initialCanonicalUrl: urlPathname,
        initialTree: initialTree,
        initialHead: head,
        globalErrorComponent: GlobalError,
        initialSeedData: initialSeedData,
        missingSlots: new Set()
    });
}
// This component must run in an SSR context. It will render the RSC root component
function ReactServerEntrypoint({ reactServerStream, preinitScripts, clientReferenceManifest, nonce }) {
    preinitScripts();
    const response = useFlightStream(reactServerStream, clientReferenceManifest, nonce);
    return React.use(response);
}
async function renderToHTMLOrFlightImpl(req, res, pagePath, query, renderOpts, baseCtx, requestEndedState) {
    var _getTracer_getRootSpanAttributes, _staticGenerationStore_prerenderState;
    const isNotFoundPath = pagePath === "/404";
    // A unique request timestamp used by development to ensure that it's
    // consistent and won't change during this request. This is important to
    // avoid that resources can be deduped by React Float if the same resource is
    // rendered or preloaded multiple times: `<link href="a.css?v={Date.now()}"/>`.
    const requestTimestamp = Date.now();
    const { buildManifest, subresourceIntegrityManifest, serverActionsManifest, ComponentMod, dev, nextFontManifest, supportsDynamicHTML, serverActions, appDirDevErrorLogger, assetPrefix = "", enableTainting } = renderOpts;
    // We need to expose the bundled `require` API globally for
    // react-server-dom-webpack. This is a hack until we find a better way.
    if (ComponentMod.__next_app__) {
        const instrumented = wrapClientComponentLoader(ComponentMod);
        // @ts-ignore
        globalThis.__next_require__ = instrumented.require;
        // @ts-ignore
        globalThis.__next_chunk_load__ = instrumented.loadChunk;
    }
    if (typeof req.on === "function") {
        req.on("end", ()=>{
            requestEndedState.ended = true;
            if ("performance" in globalThis) {
                const metrics = getClientComponentLoaderMetrics({
                    reset: true
                });
                if (metrics) {
                    getTracer().startSpan(NextNodeServerSpan.clientComponentLoading, {
                        startTime: metrics.clientComponentLoadStart,
                        attributes: {
                            "next.clientComponentLoadCount": metrics.clientComponentLoadCount
                        }
                    }).end(metrics.clientComponentLoadStart + metrics.clientComponentLoadTimes);
                }
            }
        });
    }
    const metadata = {};
    const appUsingSizeAdjustment = !!(nextFontManifest == null ? void 0 : nextFontManifest.appUsingSizeAdjust);
    // TODO: fix this typescript
    const clientReferenceManifest = renderOpts.clientReferenceManifest;
    const serverModuleMap = createServerModuleMap({
        serverActionsManifest,
        pageName: renderOpts.page
    });
    setReferenceManifestsSingleton({
        clientReferenceManifest,
        serverActionsManifest,
        serverModuleMap
    });
    const digestErrorsMap = new Map();
    const allCapturedErrors = [];
    const isNextExport = !!renderOpts.nextExport;
    const { staticGenerationStore, requestStore } = baseCtx;
    const { isStaticGeneration } = staticGenerationStore;
    // when static generation fails during PPR, we log the errors separately. We intentionally
    // silence the error logger in this case to avoid double logging.
    const silenceStaticGenerationErrors = renderOpts.experimental.ppr && isStaticGeneration;
    const serverComponentsErrorHandler = createErrorHandler({
        source: ErrorHandlerSource.serverComponents,
        dev,
        isNextExport,
        errorLogger: appDirDevErrorLogger,
        digestErrorsMap,
        silenceLogger: silenceStaticGenerationErrors
    });
    const flightDataRendererErrorHandler = createErrorHandler({
        source: ErrorHandlerSource.flightData,
        dev,
        isNextExport,
        errorLogger: appDirDevErrorLogger,
        digestErrorsMap,
        silenceLogger: silenceStaticGenerationErrors
    });
    const htmlRendererErrorHandler = createErrorHandler({
        source: ErrorHandlerSource.html,
        dev,
        isNextExport,
        errorLogger: appDirDevErrorLogger,
        digestErrorsMap,
        allCapturedErrors,
        silenceLogger: silenceStaticGenerationErrors
    });
    ComponentMod.patchFetch();
    /**
   * Rules of Static & Dynamic HTML:
   *
   *    1.) We must generate static HTML unless the caller explicitly opts
   *        in to dynamic HTML support.
   *
   *    2.) If dynamic HTML support is requested, we must honor that request
   *        or throw an error. It is the sole responsibility of the caller to
   *        ensure they aren't e.g. requesting dynamic HTML for an AMP page.
   *
   * These rules help ensure that other existing features like request caching,
   * coalescing, and ISR continue working as intended.
   */ const generateStaticHTML = supportsDynamicHTML !== true;
    // Pull out the hooks/references from the component.
    const { tree: loaderTree, taintObjectReference } = ComponentMod;
    if (enableTainting) {
        taintObjectReference("Do not pass process.env to client components since it will leak sensitive data", process.env);
    }
    staticGenerationStore.fetchMetrics = [];
    metadata.fetchMetrics = staticGenerationStore.fetchMetrics;
    // don't modify original query object
    query = {
        ...query
    };
    stripInternalQueries(query);
    const isRSCRequest = req.headers[RSC_HEADER.toLowerCase()] !== undefined;
    const isPrefetchRSCRequest = isRSCRequest && req.headers[NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] !== undefined;
    /**
   * Router state provided from the client-side router. Used to handle rendering
   * from the common layout down. This value will be undefined if the request
   * is not a client-side navigation request or if the request is a prefetch
   * request (except when it's a prefetch request for an interception route
   * which is always dynamic).
   */ const shouldProvideFlightRouterState = isRSCRequest && (!isPrefetchRSCRequest || !renderOpts.experimental.ppr || // Interception routes currently depend on the flight router state to
    // extract dynamic params.
    isInterceptionRouteAppPath(pagePath));
    const parsedFlightRouterState = parseAndValidateFlightRouterState(req.headers[NEXT_ROUTER_STATE_TREE.toLowerCase()]);
    /**
   * The metadata items array created in next-app-loader with all relevant information
   * that we need to resolve the final metadata.
   */ let requestId;
    if (process.env.NEXT_RUNTIME === "edge") {
        requestId = crypto.randomUUID();
    } else {
        requestId = require("next/dist/compiled/nanoid").nanoid();
    }
    /**
   * Dynamic parameters. E.g. when you visit `/dashboard/vercel` which is rendered by `/dashboard/[slug]` the value will be {"slug": "vercel"}.
   */ const params = renderOpts.params ?? {};
    const getDynamicParamFromSegment = makeGetDynamicParamFromSegment(params, // `FlightRouterState` is unconditionally provided here because this method uses it
    // to extract dynamic params as a fallback if they're not present in the path.
    parsedFlightRouterState);
    const ctx = {
        ...baseCtx,
        getDynamicParamFromSegment,
        query,
        isPrefetch: isPrefetchRSCRequest,
        requestTimestamp,
        appUsingSizeAdjustment,
        flightRouterState: shouldProvideFlightRouterState ? parsedFlightRouterState : undefined,
        requestId,
        defaultRevalidate: false,
        pagePath,
        clientReferenceManifest,
        assetPrefix,
        flightDataRendererErrorHandler,
        serverComponentsErrorHandler,
        isNotFoundPath,
        res
    };
    if (isRSCRequest && !isStaticGeneration) {
        return generateFlight(ctx);
    }
    // Create the resolver that can get the flight payload when it's ready or
    // throw the error if it occurred. If we are not generating static HTML, we
    // don't need to generate the flight payload because it's a dynamic request
    // which means we're either getting the flight payload only or just the
    // regular HTML.
    const flightDataResolver = isStaticGeneration ? createFlightDataResolver(ctx) : null;
    // Get the nonce from the incoming request if it has one.
    const csp = req.headers["content-security-policy"] || req.headers["content-security-policy-report-only"];
    let nonce;
    if (csp && typeof csp === "string") {
        nonce = getScriptNonceFromHeader(csp);
    }
    const validateRootLayout = dev;
    const { HeadManagerContext } = require("../../shared/lib/head-manager-context.shared-runtime");
    // On each render, create a new `ServerInsertedHTML` context to capture
    // injected nodes from user code (`useServerInsertedHTML`).
    const { ServerInsertedHTMLProvider, renderServerInsertedHTML } = createServerInsertedHTML();
    (_getTracer_getRootSpanAttributes = getTracer().getRootSpanAttributes()) == null ? void 0 : _getTracer_getRootSpanAttributes.set("next.route", pagePath);
    const renderToStream = getTracer().wrap(AppRenderSpan.getBodyResult, {
        spanName: `render route (app) ${pagePath}`,
        attributes: {
            "next.route": pagePath
        }
    }, async ({ asNotFound, tree, formState })=>{
        const polyfills = buildManifest.polyfillFiles.filter((polyfill)=>polyfill.endsWith(".js") && !polyfill.endsWith(".module.js")).map((polyfill)=>({
                src: `${assetPrefix}/_next/${polyfill}${getAssetQueryString(ctx, false)}`,
                integrity: subresourceIntegrityManifest == null ? void 0 : subresourceIntegrityManifest[polyfill],
                crossOrigin: renderOpts.crossOrigin,
                noModule: true,
                nonce
            }));
        const [preinitScripts, bootstrapScript] = getRequiredScripts(buildManifest, assetPrefix, renderOpts.crossOrigin, subresourceIntegrityManifest, getAssetQueryString(ctx, true), nonce);
        // We kick off the Flight Request (render) here. It is ok to initiate the render in an arbitrary
        // place however it is critical that we only construct the Flight Response inside the SSR
        // render so that directives like preloads are correctly piped through
        const serverStream = ComponentMod.renderToReadableStream(/*#__PURE__*/ _jsx(ReactServerApp, {
            tree: tree,
            ctx: ctx,
            asNotFound: asNotFound
        }), clientReferenceManifest.clientModules, {
            onError: serverComponentsErrorHandler
        });
        // We are going to consume this render both for SSR and for inlining the flight data
        let [renderStream, dataStream] = serverStream.tee();
        const children = /*#__PURE__*/ _jsx(HeadManagerContext.Provider, {
            value: {
                appDir: true,
                nonce
            },
            children: /*#__PURE__*/ _jsx(ServerInsertedHTMLProvider, {
                children: /*#__PURE__*/ _jsx(ReactServerEntrypoint, {
                    reactServerStream: renderStream,
                    preinitScripts: preinitScripts,
                    clientReferenceManifest: clientReferenceManifest,
                    nonce: nonce
                })
            })
        });
        const isResume = !!renderOpts.postponed;
        const onHeaders = staticGenerationStore.prerenderState ? (headers)=>{
            headers.forEach((value, key)=>{
                metadata.headers ??= {};
                metadata.headers[key] = value;
            });
        } : isStaticGeneration || isResume ? // ask React to emit headers. For Resume this is just not supported
        // For static generation we know there will be an entire HTML document
        // output and so moving from tag to header for preloading can only
        // server to alter preloading priorities in unwanted ways
        undefined : // early headers to the response
        (headers)=>{
            headers.forEach((value, key)=>{
                res.appendHeader(key, value);
            });
        };
        const getServerInsertedHTML = makeGetServerInsertedHTML({
            polyfills,
            renderServerInsertedHTML,
            serverCapturedErrors: allCapturedErrors,
            basePath: renderOpts.basePath
        });
        const renderer = createStaticRenderer({
            ppr: renderOpts.experimental.ppr,
            isStaticGeneration,
            // If provided, the postpone state should be parsed as JSON so it can be
            // provided to React.
            postponed: typeof renderOpts.postponed === "string" ? JSON.parse(renderOpts.postponed) : null,
            streamOptions: {
                onError: htmlRendererErrorHandler,
                onHeaders,
                maxHeadersLength: 600,
                nonce,
                bootstrapScripts: [
                    bootstrapScript
                ],
                formState
            }
        });
        try {
            let { stream, postponed, resumed } = await renderer.render(children);
            const prerenderState = staticGenerationStore.prerenderState;
            if (prerenderState) {
                /**
           * When prerendering there are three outcomes to consider
           *
           *   Dynamic HTML:      The prerender has dynamic holes (caused by using Next.js Dynamic Rendering APIs)
           *                      We will need to resume this result when requests are handled and we don't include
           *                      any server inserted HTML or inlined flight data in the static HTML
           *
           *   Dynamic Data:      The prerender has no dynamic holes but dynamic APIs were used. We will not
           *                      resume this render when requests are handled but we will generate new inlined
           *                      flight data since it is dynamic and differences may end up reconciling on the client
           *
           *   Static:            The prerender has no dynamic holes and no dynamic APIs were used. We statically encode
           *                      all server inserted HTML and flight data
           */ // First we check if we have any dynamic holes in our HTML prerender
                if (usedDynamicAPIs(prerenderState)) {
                    if (postponed != null) {
                        // This is the Dynamic HTML case.
                        metadata.postponed = JSON.stringify(getDynamicHTMLPostponedState(postponed));
                    } else {
                        // This is the Dynamic Data case
                        metadata.postponed = JSON.stringify(getDynamicDataPostponedState());
                    }
                    // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include
                    // server inserted html in the static response because the html that is part of the prerender may depend on it
                    // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states
                    // require the same set so we unify the code path here
                    return {
                        stream: await continueDynamicPrerender(stream, {
                            getServerInsertedHTML
                        })
                    };
                } else {
                    // We may still be rendering the RSC stream even though the HTML is finished.
                    // We wait for the RSC stream to complete and check again if dynamic was used
                    const [original, flightSpy] = dataStream.tee();
                    dataStream = original;
                    await flightRenderComplete(flightSpy);
                    if (usedDynamicAPIs(prerenderState)) {
                        // This is the same logic above just repeated after ensuring the RSC stream itself has completed
                        if (postponed != null) {
                            // This is the Dynamic HTML case.
                            metadata.postponed = JSON.stringify(getDynamicHTMLPostponedState(postponed));
                        } else {
                            // This is the Dynamic Data case
                            metadata.postponed = JSON.stringify(getDynamicDataPostponedState());
                        }
                        // Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include
                        // server inserted html in the static response because the html that is part of the prerender may depend on it
                        // It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states
                        // require the same set so we unify the code path here
                        return {
                            stream: await continueDynamicPrerender(stream, {
                                getServerInsertedHTML
                            })
                        };
                    } else {
                        // This is the Static case
                        // We still have not used any dynamic APIs. At this point we can produce an entirely static prerender response
                        let renderedHTMLStream = stream;
                        if (staticGenerationStore.forceDynamic) {
                            throw new StaticGenBailoutError('Invariant: a Page with `dynamic = "force-dynamic"` did not trigger the dynamic pathway. This is a bug in Next.js');
                        }
                        if (postponed != null) {
                            // We postponed but nothing dynamic was used. We resume the render now and immediately abort it
                            // so we can set all the postponed boundaries to client render mode before we store the HTML response
                            const resumeRenderer = createStaticRenderer({
                                ppr: true,
                                isStaticGeneration: false,
                                postponed: getDynamicHTMLPostponedState(postponed),
                                streamOptions: {
                                    signal: createPostponedAbortSignal("static prerender resume"),
                                    onError: htmlRendererErrorHandler,
                                    nonce
                                }
                            });
                            // We don't actually want to render anything so we just pass a stream
                            // that never resolves. The resume call is going to abort immediately anyway
                            const foreverStream = new ReadableStream();
                            const resumeChildren = /*#__PURE__*/ _jsx(HeadManagerContext.Provider, {
                                value: {
                                    appDir: true,
                                    nonce
                                },
                                children: /*#__PURE__*/ _jsx(ServerInsertedHTMLProvider, {
                                    children: /*#__PURE__*/ _jsx(ReactServerEntrypoint, {
                                        reactServerStream: foreverStream,
                                        preinitScripts: ()=>{},
                                        clientReferenceManifest: clientReferenceManifest,
                                        nonce: nonce
                                    })
                                })
                            });
                            const { stream: resumeStream } = await resumeRenderer.render(resumeChildren);
                            // First we write everything from the prerender, then we write everything from the aborted resume render
                            renderedHTMLStream = chainStreams(stream, resumeStream);
                        }
                        return {
                            stream: await continueStaticPrerender(renderedHTMLStream, {
                                inlinedDataStream: createInlinedDataReadableStream(dataStream, nonce, formState),
                                getServerInsertedHTML
                            })
                        };
                    }
                }
            } else if (renderOpts.postponed) {
                // This is a continuation of either an Incomplete or Dynamic Data Prerender.
                const inlinedDataStream = createInlinedDataReadableStream(dataStream, nonce, formState);
                if (resumed) {
                    // We have new HTML to stream and we also need to include server inserted HTML
                    return {
                        stream: await continueDynamicHTMLResume(stream, {
                            inlinedDataStream,
                            getServerInsertedHTML
                        })
                    };
                } else {
                    // We are continuing a Dynamic Data Prerender and simply need to append new inlined flight data
                    return {
                        stream: await continueDynamicDataResume(stream, {
                            inlinedDataStream
                        })
                    };
                }
            } else {
                // This may be a static render or a dynamic render
                // @TODO factor this further to make the render types more clearly defined and remove
                // the deluge of optional params that passed to configure the various behaviors
                return {
                    stream: await continueFizzStream(stream, {
                        inlinedDataStream: createInlinedDataReadableStream(dataStream, nonce, formState),
                        isStaticGeneration: isStaticGeneration || generateStaticHTML,
                        getServerInsertedHTML,
                        serverInsertedHTMLToHead: true,
                        validateRootLayout
                    })
                };
            }
        } catch (err) {
            if (isStaticGenBailoutError(err) || typeof err === "object" && err !== null && "message" in err && typeof err.message === "string" && err.message.includes("https://nextjs.org/docs/advanced-features/static-html-export")) {
                // Ensure that "next dev" prints the red error overlay
                throw err;
            }
            // If this is a static generation error, we need to throw it so that it
            // can be handled by the caller if we're in static generation mode.
            if (isStaticGeneration && isDynamicServerError(err)) {
                throw err;
            }
            // If a bailout made it to this point, it means it wasn't wrapped inside
            // a suspense boundary.
            const shouldBailoutToCSR = isBailoutToCSRError(err);
            if (shouldBailoutToCSR) {
                const stack = getStackWithoutErrorMessage(err);
                if (renderOpts.experimental.missingSuspenseWithCSRBailout) {
                    error(`${err.reason} should be wrapped in a suspense boundary at page "${pagePath}". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\n${stack}`);
                    throw err;
                }
                warn(`Entire page "${pagePath}" deopted into client-side rendering due to "${err.reason}". Read more: https://nextjs.org/docs/messages/deopted-into-client-rendering\n${stack}`);
            }
            if (isNotFoundError(err)) {
                res.statusCode = 404;
            }
            let hasRedirectError = false;
            if (isRedirectError(err)) {
                hasRedirectError = true;
                res.statusCode = getRedirectStatusCodeFromError(err);
                if (err.mutableCookies) {
                    const headers = new Headers();
                    // If there were mutable cookies set, we need to set them on the
                    // response.
                    if (appendMutableCookies(headers, err.mutableCookies)) {
                        res.setHeader("set-cookie", Array.from(headers.values()));
                    }
                }
                const redirectUrl = addPathPrefix(getURLFromRedirectError(err), renderOpts.basePath);
                res.setHeader("Location", redirectUrl);
            }
            const is404 = ctx.res.statusCode === 404;
            if (!is404 && !hasRedirectError && !shouldBailoutToCSR) {
                res.statusCode = 500;
            }
            const errorType = is404 ? "not-found" : hasRedirectError ? "redirect" : undefined;
            const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(buildManifest, assetPrefix, renderOpts.crossOrigin, subresourceIntegrityManifest, getAssetQueryString(ctx, false), nonce);
            const errorServerStream = ComponentMod.renderToReadableStream(/*#__PURE__*/ _jsx(ReactServerError, {
                tree: tree,
                ctx: ctx,
                errorType: errorType
            }), clientReferenceManifest.clientModules, {
                onError: serverComponentsErrorHandler
            });
            try {
                const fizzStream = await renderToInitialFizzStream({
                    ReactDOMServer: require("react-dom/server.edge"),
                    element: /*#__PURE__*/ _jsx(ReactServerEntrypoint, {
                        reactServerStream: errorServerStream,
                        preinitScripts: errorPreinitScripts,
                        clientReferenceManifest: clientReferenceManifest,
                        nonce: nonce
                    }),
                    streamOptions: {
                        nonce,
                        // Include hydration scripts in the HTML
                        bootstrapScripts: [
                            errorBootstrapScript
                        ],
                        formState
                    }
                });
                return {
                    // Returning the error that was thrown so it can be used to handle
                    // the response in the caller.
                    err,
                    stream: await continueFizzStream(fizzStream, {
                        inlinedDataStream: createInlinedDataReadableStream(// This is intentionally using the readable datastream from the
                        // main render rather than the flight data from the error page
                        // render
                        dataStream, nonce, formState),
                        isStaticGeneration,
                        getServerInsertedHTML: makeGetServerInsertedHTML({
                            polyfills,
                            renderServerInsertedHTML,
                            serverCapturedErrors: [],
                            basePath: renderOpts.basePath
                        }),
                        serverInsertedHTMLToHead: true,
                        validateRootLayout
                    })
                };
            } catch (finalErr) {
                if (process.env.NODE_ENV === "development" && isNotFoundError(finalErr)) {
                    const bailOnNotFound = require("../../client/components/dev-root-not-found-boundary").bailOnNotFound;
                    bailOnNotFound();
                }
                throw finalErr;
            }
        }
    });
    // For action requests, we handle them differently with a special render result.
    const actionRequestResult = await handleAction({
        req,
        res,
        ComponentMod,
        serverModuleMap,
        generateFlight,
        staticGenerationStore,
        requestStore,
        serverActions,
        ctx
    });
    let formState = null;
    if (actionRequestResult) {
        if (actionRequestResult.type === "not-found") {
            const notFoundLoaderTree = createNotFoundLoaderTree(loaderTree);
            const response = await renderToStream({
                asNotFound: true,
                tree: notFoundLoaderTree,
                formState
            });
            return new RenderResult(response.stream, {
                metadata
            });
        } else if (actionRequestResult.type === "done") {
            if (actionRequestResult.result) {
                actionRequestResult.result.assignMetadata(metadata);
                return actionRequestResult.result;
            } else if (actionRequestResult.formState) {
                formState = actionRequestResult.formState;
            }
        }
    }
    const options = {
        metadata
    };
    let response = await renderToStream({
        asNotFound: isNotFoundPath,
        tree: loaderTree,
        formState
    });
    // If we have pending revalidates, wait until they are all resolved.
    if (staticGenerationStore.pendingRevalidates) {
        options.waitUntil = Promise.all(Object.values(staticGenerationStore.pendingRevalidates));
    }
    addImplicitTags(staticGenerationStore);
    if (staticGenerationStore.tags) {
        metadata.fetchTags = staticGenerationStore.tags.join(",");
    }
    // Create the new render result for the response.
    const result = new RenderResult(response.stream, options);
    // If we aren't performing static generation, we can return the result now.
    if (!isStaticGeneration) {
        return result;
    }
    // If this is static generation, we should read this in now rather than
    // sending it back to be sent to the client.
    response.stream = await result.toUnchunkedString(true);
    const buildFailingError = digestErrorsMap.size > 0 ? digestErrorsMap.values().next().value : null;
    // If we're debugging partial prerendering, print all the dynamic API accesses
    // that occurred during the render.
    if (staticGenerationStore.prerenderState && usedDynamicAPIs(staticGenerationStore.prerenderState) && ((_staticGenerationStore_prerenderState = staticGenerationStore.prerenderState) == null ? void 0 : _staticGenerationStore_prerenderState.isDebugSkeleton)) {
        warn("The following dynamic usage was detected:");
        for (const access of formatDynamicAPIAccesses(staticGenerationStore.prerenderState)){
            warn(access);
        }
    }
    if (!flightDataResolver) {
        throw new Error("Invariant: Flight data resolver is missing when generating static HTML");
    }
    // If we encountered any unexpected errors during build we fail the
    // prerendering phase and the build.
    if (buildFailingError) {
        throw buildFailingError;
    }
    // Wait for and collect the flight payload data if we don't have it
    // already
    const flightData = await flightDataResolver();
    if (flightData) {
        metadata.flightData = flightData;
    }
    // If force static is specifically set to false, we should not revalidate
    // the page.
    if (staticGenerationStore.forceStatic === false) {
        staticGenerationStore.revalidate = 0;
    }
    // Copy the revalidation value onto the render result metadata.
    metadata.revalidate = staticGenerationStore.revalidate ?? ctx.defaultRevalidate;
    // provide bailout info for debugging
    if (metadata.revalidate === 0) {
        metadata.staticBailoutInfo = {
            description: staticGenerationStore.dynamicUsageDescription,
            stack: staticGenerationStore.dynamicUsageStack
        };
    }
    return new RenderResult(response.stream, options);
}
export const renderToHTMLOrFlight = (req, res, pagePath, query, renderOpts)=>{
    // TODO: this includes query string, should it?
    const pathname = validateURL(req.url);
    return RequestAsyncStorageWrapper.wrap(renderOpts.ComponentMod.requestAsyncStorage, {
        req,
        res,
        renderOpts
    }, (requestStore)=>StaticGenerationAsyncStorageWrapper.wrap(renderOpts.ComponentMod.staticGenerationAsyncStorage, {
            urlPathname: pathname,
            renderOpts,
            requestEndedState: {
                ended: false
            }
        }, (staticGenerationStore)=>renderToHTMLOrFlightImpl(req, res, pagePath, query, renderOpts, {
                requestStore,
                staticGenerationStore,
                componentMod: renderOpts.ComponentMod,
                renderOpts
            }, staticGenerationStore.requestEndedState || {})));
};

//# sourceMappingURL=app-render.js.map` invalidServerComponentReactHooksŠsetMessageÉõÿÿ³õÿÿÌõÿÿ…lines¨õÿÿ«õÿÿ›getStackWithoutErrorMessageŠõÿÿ‘formatServerErrordöÿÿŒaddedMessageŠclientHook…regexØõÿÿõÿÿencodeURIPath`ôÿÿ\ôÿÿpÙõÿÿ@G  kôÿÿÌöÿÿkôÿÿD  
// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  f: () => (/* binding */ renderToHTMLOrFlight)
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5486);
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__(2428);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/render-result.js
var render_result = __webpack_require__(8317);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/stream-utils/node-web-streams-helper.js + 3 modules
var node_web_streams_helper = __webpack_require__(4894);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/match-segments.js
var match_segments = __webpack_require__(393);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/internal-utils.js
var internal_utils = __webpack_require__(9879);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/app-router-headers.js
var app_router_headers = __webpack_require__(3185);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/non-nullable.js
Íöÿÿôÿÿ¿  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/non-nullable.js|ssr06undefinedôÿÿU   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/generate/meta.js
Ëöÿÿôÿÿ¾’  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/generate/meta.js|ssr047undefined4974undefined76124undefined126132undefined294297__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined603609undefined761771__WEBPACK_MODULE_REFERENCE__7_5b226e6f6e4e756c6c61626c65225d_directImport_asiSafe1__._undefined795805__WEBPACK_MODULE_REFERENCE__7_5b226e6f6e4e756c6c61626c65225d_call_directImport_asiSafe1__._undefined19851991undefined_   164238(0,jsx_runtime.jsx)undefined695780nonNullableundefined804894nonNullableundefinedRawSourceQ   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/constants.js
ÈöÿÿŠôÿÿ¼)  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/constants.js|ssr06undefined296302undefined‹ôÿÿV   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/generate/basic.js
Æöÿÿˆôÿÿ»†  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/generate/basic.js|ssr047undefined4974undefined76128undefined130177undefined415430__WEBPACK_MODULE_REFERENCE__9_5b2256696577706f72744d6574614b657973225d_directImport_asiSafe1__._undefined731746__WEBPACK_MODULE_REFERENCE__9_5b2256696577706f72744d6574614b657973225d_directImport_asiSafe1__._undefined826832undefined882891__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefined903906__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined10761079__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined12331236__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined13371343undefined14551464__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefined14901493__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined16211624__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined17101713__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined18121815__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined20212024__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined21622165__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined23282331__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined24902493__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined25882591__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined27552758__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined28512854__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined29452948__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined30433046__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined31983201__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined33623365__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined35283531__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined37003703__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined38773880__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined39873990__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined40834086__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined43594362__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined45104513__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined46314637undefined48884891__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined50725078undefined53935396__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined54775483undefined56485657__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefined56795682__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined57905793__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined59475950__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined61296132__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined62596265undefined63596368__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefined63806388__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined65066514__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined66126620__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined67336741__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined69126920__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefinedS  240335ViewportMetaKeysundefined636731ViewportMetaKeysundefined860948MetaFilterundefined9601036Metaundefined12061282Metaundefined14361512Metaundefined17241812MetaFilterundefined18381912(0,jsx_runtime.jsx)undefined20402114(0,jsx_runtime.jsx)undefined22002276Metaundefined23752451Metaundefined26572731(0,jsx_runtime.jsx)undefined28692945Metaundefined31083182(0,jsx_runtime.jsx)undefined33413417Metaundefined35123588Metaundefined37523828Metaundefined39213997Metaundefined40884164Metaundefined42594335Metaundefined44874563Metaundefined47244800Metaundefined49635037(0,jsx_runtime.jsx)undefined52065280(0,jsx_runtime.jsx)undefined54545528(0,jsx_runtime.jsx)undefined56355711Metaundefined58045880Metaundefined61536229Metaundefined63776453Metaundefined68216895(0,jsx_runtime.jsx)undefined73907464(0,jsx_runtime.jsx)undefined77097797MetaFilterundefined78197895Metaundefined80038079Metaundefined82338307(0,jsx_runtime.jsx)undefined84868562Metaundefined87828870MetaFilterundefined88828968MultiMetaundefined90869172MultiMetaundefined92709356MultiMetaundefined94699555MultiMetaundefined97269812MultiMetaundefinedRawSourceZ   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/generate/alternate.js
Ãöÿÿ…ôÿÿ¹  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/generate/alternate.js|ssr047undefined4974undefined76111undefined227230__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined390396undefined551560__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefinedD   117191(0,jsx_runtime.jsx)undefined505593MetaFilterundefinedRawSourceZ   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/generate/opengraph.js
Àöÿÿ‚ôÿÿ·Í#  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/generate/opengraph.js|ssr052undefined5460undefined427430__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined768771__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined907910__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined11591162__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined14071410__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined16631671__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined18291832__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined19841992__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined22452248__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined23812384__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined25272530__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined26882696__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined28512859__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined31123115__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined32513254__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined34113414__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined35693572__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined37263729__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined40274030__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined41694172__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined43984406__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined45604568__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined48364839__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined49794987__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined51395147__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined53075310__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined55805583__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined57265734__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined58865894__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined61686171__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined63196327__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined65936596__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined67366744__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined68986906__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined70667074__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined72307233__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined73857388__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined75477555__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined78157818__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined79607968__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined81228130__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined82908298__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined84548457__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined86098612__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined87718779__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined89298932__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined91909193__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined94439446__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined97919800__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefined98129815__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined99209923__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1008410087__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1019410197__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1035210355__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1045710460__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1055710560__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1066810671__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1082610834__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1093710945__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1104811056__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1115811166__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1126911277__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1139311401__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1151311521__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1178911792__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1189211895__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1199712000__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1220712213undefined1235012359__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefined1237112374__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1245812461__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1255312556__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1265312656__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1275412757__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1286012863__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1301913022__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1312813136__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1331313316__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1345713460__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1360813611__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1374313746__WEBPACK_MODULE_REFERENCE__8_5b224d657461225d_call_directImport_asiSafe1__._undefined1427014276undefined1435814367__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefined1437914387__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1448414492__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1459514603__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1470214710__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1481514823__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1494014948__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1505315061__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined1518615194__WEBPACK_MODULE_REFERENCE__8_5b224d756c74694d657461225d_call_directImport_asiSafe1__._undefined|  367443Metaundefined781857Metaundefined9931069Metaundefined13181394Metaundefined16391715Metaundefined19682054MultiMetaundefined22122288Metaundefined24402526MultiMetaundefined27792855Metaundefined29883064Metaundefined32073283Metaundefined34413527MultiMetaundefined36823768MultiMetaundefined40214097Metaundefined42334309Metaundefined44664542Metaundefined46974773Metaundefined49275003Metaundefined53015377Metaundefined55165592Metaundefined58185904MultiMetaundefined60586144MultiMetaundefined64126488Metaundefined66286714MultiMetaundefined68666952MultiMetaundefined71127188Metaundefined74587534Metaundefined76777763MultiMetaundefined79158001MultiMetaundefined82758351Metaundefined84998585MultiMetaundefined88518927Metaundefined90679153MultiMetaundefined93079393MultiMetaundefined95539639MultiMetaundefined97959871Metaundefined1002310099Metaundefined1025810344MultiMetaundefined1060410680Metaundefined1082210908MultiMetaundefined1106211148MultiMetaundefined1130811394MultiMetaundefined1155011626Metaundefined1177811854Metaundefined1201312099MultiMetaundefined1224912325Metaundefined1258312659Metaundefined1290912985Metaundefined1333013418MetaFilterundefined1343013506Metaundefined1361113687Metaundefined1384813924Metaundefined1403114107Metaundefined1426214338Metaundefined1444014516Metaundefined1461314689Metaundefined1479714873Metaundefined1502815114MultiMetaundefined1521715303MultiMetaundefined1540615492MultiMetaundefined1559415680MultiMetaundefined1578315869MultiMetaundefined1598516071MultiMetaundefined1618316269MultiMetaundefined1653716613Metaundefined1671316789Metaundefined1689116967Metaundefined1731017398MetaFilterundefined1741017486Metaundefined1757017646Metaundefined1773817814Metaundefined1791117987Metaundefined1808518161Metaundefined1826418340Metaundefined1849618572Metaundefined1867818764MultiMetaundefined1894119017Metaundefined1915819234Metaundefined1938219458Metaundefined1959019666Metaundefined2027120359MetaFilterundefined2037120457MultiMetaundefined2055420640MultiMetaundefined2074320829MultiMetaundefined2092821014MultiMetaundefined2111921205MultiMetaundefined2132221408MultiMetaundefined2151321599MultiMetaundefined2172421810MultiMetaundefinedRawSourceV   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/generate/icons.js
½öÿÿôÿÿµf  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/generate/icons.js|ssr047undefined4974undefined76111undefined228231__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined606609__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined686692undefined913922__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefinedg   118192(0,jsx_runtime.jsx)undefined567641(0,jsx_runtime.jsx)undefined9381026MetaFilterundefinedRawSourceX   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/default-metadata.js
ºöÿÿ|ôÿÿý  export function createDefaultViewport() {
    return {
        // name=viewport
        width: "device-width",
        initialScale: 1,
        // visual metadata
        themeColor: null,
        colorScheme: null
    };
}
export function createDefaultMetadata() {
    return {
        // Deprecated ones
        viewport: null,
        themeColor: null,
        colorScheme: null,
        metadataBase: null,
        // Other values are all null
        title: null,
        description: null,
        applicationName: null,
        authors: null,
        generator: null,
        keywords: null,
        referrer: null,
        creator: null,
        publisher: null,
        robots: null,
        manifest: null,
        alternates: {
            canonical: null,
            languages: null,
            media: null,
            types: null
        },
        icons: null,
        openGraph: null,
        twitter: null,
        verification: {},
        appleWebApp: null,
        formatDetection: null,
        itunes: null,
        abstract: null,
        appLinks: null,
        archives: null,
        assets: null,
        bookmarks: null,
        category: null,
        classification: null,
        other: {}
    };
}

//# sourceMappingURL=default-metadata.js.map0  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/default-metadata.js|ssr06undefined224230undefined|ôÿÿV   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/generate/utils.js
·öÿÿyôÿÿ±#  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/generate/utils.js|ssr295345undefinedzôÿÿ  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/isomorphic/path.js
var path = __webpack_require__(7652);
var path_default = /*#__PURE__*/__webpack_require__.n(path);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-url.js
µöÿÿwôÿÿ°V  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-url.js|ssr054undefined741747undefined10801117falseundefined11201178{}undefined12181254 trueundefined19681977__WEBPACK_MODULE_REFERENCE__16_5b2264656661756c74222c22706f736978225d_call_asiSafe1__._undefined22232232__WEBPACK_MODULE_REFERENCE__16_5b2264656661756c74222c22706f736978225d_call_asiSafe1__._undefined41994289undefinedS   17841870path_default().posixundefined21162202path_default().posixundefinedRawSource_   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-title.js
²öÿÿtôÿÿ®,  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-title.js|ssr113119undefineduôÿÿ-  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/lib/url.js
var url = __webpack_require__(8890);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/build/output/log.js
var log = __webpack_require__(292);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-opengraph.js
°öÿÿrôÿÿ­c  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-opengraph.js|ssr061undefined63188undefined190236undefined238281undefined283335undefined946958__WEBPACK_MODULE_REFERENCE__17_5b226973537472696e674f7255524c225d_call_directImport_asiSafe1__._undefined11691178__WEBPACK_MODULE_REFERENCE__17_5b227265736f6c766555726c225d_call_directImport_asiSafe1__._undefined12831292__WEBPACK_MODULE_REFERENCE__17_5b227265736f6c766555726c225d_call_directImport_asiSafe1__._undefined13271333undefined14081432__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined15511584__WEBPACK_MODULE_REFERENCE__17_5b22676574536f6369616c496d61676546616c6c6261636b4d6574616461746142617365225d_call_directImport_asiSafe1__._undefined26282642__WEBPACK_MODULE_REFERENCE__19_5b22697346756c6c537472696e6755726c225d_call_directImport_asiSafe1__._undefined26902697__WEBPACK_MODULE_REFERENCE__20_5b227761726e4f6e6365225d_call_directImport_asiSafe1__._undefined29412947undefined34313455__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined36833694__WEBPACK_MODULE_REFERENCE__18_5b227265736f6c76655469746c65225d_call_directImport_asiSafe1__._undefined38093838__WEBPACK_MODULE_REFERENCE__17_5b227265736f6c76654162736f6c75746555726c57697468506174686e616d65225d_call_directImport_asiSafe1__._undefined40284034undefined42764287__WEBPACK_MODULE_REFERENCE__18_5b227265736f6c76655469746c65225d_call_directImport_asiSafe1__._undefined48134837__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefinedÌ  614709isStringOrURLundefined9201009resolveUrlundefined11141203resolveUrlundefined13121431resolveAsArrayOrUndefinedundefined15501687getSocialImageFallbackMetadataBaseundefined27312830(0,url/* isFullStringUrl */.N)undefined28782963(0,log/* warnOnce */.O4)undefined36903809resolveAsArrayOrUndefinedundefined40374130resolveTitleundefined42454374resolveAbsoluteUrlWithPathnameundefined48054898resolveTitleundefined54245543resolveAsArrayOrUndefinedundefinedRawSourceO   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/client-reference.js
­öÿÿoôÿÿ«  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/client-reference.js|ssr06undefinedpôÿÿÈ   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/segment.js
var lib_segment = __webpack_require__(8478);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/lib/app-dir-module.js
«öÿÿmôÿÿª°  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/lib/app-dir-module.js|ssr062undefined6470undefined361379__WEBPACK_MODULE_REFERENCE__23_5b2244454641554c545f5345474d454e545f4b4559225d_directImport_asiSafe1__._undefined762768undefined?   291393lib_segment/* DEFAULT_SEGMENT_KEY */.avundefinedRawSourceN   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/interop-default.js
¨öÿÿjôÿÿs   export function interopDefault(mod) {
    return mod.default || mod;
}

//# sourceMappingURL=interop-default.js.map  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/interop-default.js|ssr06undefinedjôÿÿ`   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-basics.js
¥öÿÿgôÿÿ¦é  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-basics.js|ssr061undefined63125undefined409438__WEBPACK_MODULE_REFERENCE__17_5b227265736f6c76654162736f6c75746555726c57697468506174686e616d65225d_call_directImport_asiSafe1__._undefined479485undefined670694__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined22932299undefined37633769undefined40854091undefined44624486__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined46374661__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined47064712undefined49955019__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined54135419undefined55885612__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined56605666undefined  284413resolveAbsoluteUrlWithPathnameundefined638757resolveAsArrayOrUndefinedundefined45044623resolveAsArrayOrUndefinedundefined47744893resolveAsArrayOrUndefinedundefined52205339resolveAsArrayOrUndefinedundefined59016020resolveAsArrayOrUndefinedundefinedRawSource_   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-icons.js
¢öÿÿdôÿÿ¤  import { resolveAsArrayOrUndefined } from "../generate/utils";
import { isStringOrURL } from "./resolve-url";
import { IconKeys } from "../constants";
export function resolveIcon(icon) {
    if (isStringOrURL(icon)) return {
        url: icon
    };
    else if (Array.isArray(icon)) return icon;
    return icon;
}
export const resolveIcons = (icons)=>{
    if (!icons) {
        return null;
    }
    const resolved = {
        icon: [],
        apple: []
    };
    if (Array.isArray(icons)) {
        resolved.icon = icons.map(resolveIcon).filter(Boolean);
    } else if (isStringOrURL(icons)) {
        resolved.icon = [
            resolveIcon(icons)
        ];
    } else {
        for (const key of IconKeys){
            const values = resolveAsArrayOrUndefined(icons[key]);
            if (values) resolved[key] = values.map(resolveIcon);
        }
    }
    return resolved;
};

//# sourceMappingURL=resolve-icons.js.map(  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/resolvers/resolve-icons.js|ssr061undefined63108undefined110149undefined151157undefined195207__WEBPACK_MODULE_REFERENCE__17_5b226973537472696e674f7255524c225d_call_directImport_asiSafe1__._undefined316322undefined577589__WEBPACK_MODULE_REFERENCE__17_5b226973537472696e674f7255524c225d_call_directImport_asiSafe1__._undefined708715__WEBPACK_MODULE_REFERENCE__9_5b2249636f6e4b657973225d_directImport_asiSafe1__._undefined746770__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined   40135isStringOrURLundefined498593isStringOrURLundefined712791IconKeysundefined822941resolveAsArrayOrUndefinedundefinedRawSourceF  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/lib/trace/tracer.js
var tracer = __webpack_require__(8844);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/lib/trace/constants.js
var constants = __webpack_require__(6236);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/resolve-metadata.js
žöÿÿ`ôÿÿ¡¡  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/resolve-metadata.js|ssr081undefined83163undefined165221undefined223283undefined285340undefined342437undefined439490undefined492661undefined663719undefined721778undefined780850undefined852911undefined913958undefined23952408__WEBPACK_MODULE_REFERENCE__21_5b227265736f6c766554776974746572225d_call_directImport_asiSafe1__._undefined28652880__WEBPACK_MODULE_REFERENCE__21_5b227265736f6c76654f70656e4772617068225d_call_directImport_asiSafe1__._undefined37223733__WEBPACK_MODULE_REFERENCE__18_5b227265736f6c76655469746c65225d_call_directImport_asiSafe1__._undefined39063922__WEBPACK_MODULE_REFERENCE__26_5b227265736f6c7665416c7465726e61746573225d_call_directImport_asiSafe1__._undefined41074122__WEBPACK_MODULE_REFERENCE__21_5b227265736f6c76654f70656e4772617068225d_call_directImport_asiSafe1__._undefined43284341__WEBPACK_MODULE_REFERENCE__21_5b227265736f6c766554776974746572225d_call_directImport_asiSafe1__._undefined45144532__WEBPACK_MODULE_REFERENCE__26_5b227265736f6c7665566572696669636174696f6e225d_call_directImport_asiSafe1__._undefined46584669__WEBPACK_MODULE_REFERENCE__27_5b227265736f6c766549636f6e73225d_call_directImport_asiSafe1__._undefined48004817__WEBPACK_MODULE_REFERENCE__26_5b227265736f6c76654170706c65576562417070225d_call_directImport_asiSafe1__._undefined49264940__WEBPACK_MODULE_REFERENCE__26_5b227265736f6c76654170704c696e6b73225d_call_directImport_asiSafe1__._undefined50645076__WEBPACK_MODULE_REFERENCE__26_5b227265736f6c7665526f626f7473225d_call_directImport_asiSafe1__._undefined53065330__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined54715495__WEBPACK_MODULE_REFERENCE__15_5b227265736f6c7665417341727261794f72556e646566696e6564225d_call_directImport_asiSafe1__._undefined56385650__WEBPACK_MODULE_REFERENCE__26_5b227265736f6c76654974756e6573225d_call_directImport_asiSafe1__._undefined73277343__WEBPACK_MODULE_REFERENCE__26_5b227265736f6c76655468656d65436f6c6f72225d_call_directImport_asiSafe1__._undefined78397855__WEBPACK_MODULE_REFERENCE__22_5b226973436c69656e745265666572656e6365225d_call_directImport_asiSafe1__._undefined80118019__WEBPACK_MODULE_REFERENCE__28_5b22676574547261636572225d_call_directImport_asiSafe1__._undefined80298047__WEBPACK_MODULE_REFERENCE__29_5b225265736f6c76654d657461646174615370616e225d_asiSafe1__._undefined85448560__WEBPACK_MODULE_REFERENCE__22_5b226973436c69656e745265666572656e6365225d_call_directImport_asiSafe1__._undefined87168724__WEBPACK_MODULE_REFERENCE__28_5b22676574547261636572225d_call_directImport_asiSafe1__._undefined87348752__WEBPACK_MODULE_REFERENCE__29_5b225265736f6c76654d657461646174615370616e225d_asiSafe1__._undefined92329245__WEBPACK_MODULE_REFERENCE__25_5b22696e7465726f7044656661756c74225d_call_directImport_asiSafe1__._undefined1013910145undefined1042510446__WEBPACK_MODULE_REFERENCE__24_5b22676574436f6d706f6e656e74547970654d6f64756c65225d_call_directImport_asiSafe1__._undefined1054410564__WEBPACK_MODULE_REFERENCE__24_5b226765744c61796f75744f72506167654d6f64756c65225d_call_directImport_asiSafe1__._undefined1111311134__WEBPACK_MODULE_REFERENCE__24_5b22676574436f6d706f6e656e74547970654d6f64756c65225d_call_directImport_asiSafe1__._undefined1158011586undefined1280312818__WEBPACK_MODULE_REFERENCE__23_5b22504147455f5345474d454e545f4b4559225d_directImport_asiSafe1__._undefined1401714016(/* unused pure expression or super */ null && (undefined1406514064))undefined1514915162__WEBPACK_MODULE_REFERENCE__21_5b227265736f6c766554776974746572225d_call_directImport_asiSafe1__._undefined1820618243 falseundefined18247183200undefined1918319189undefined1928719307__WEBPACK_MODULE_REFERENCE__14_5b2263726561746544656661756c744d65746164617461225d_call_directImport_asiSafe1__._undefined2130121308__WEBPACK_MODULE_REFERENCE__20_5b227761726e225d_call_asiSafe1__._undefined2140421410undefined2149121511__WEBPACK_MODULE_REFERENCE__14_5b2263726561746544656661756c7456696577706f7274225d_call_directImport_asiSafe1__._undefined2200022006undefined2244722467__WEBPACK_MODULE_REFERENCE__14_5b2263726561746544656661756c744d65746164617461225d_call_directImport_asiSafe1__._undefined2249122511__WEBPACK_MODULE_REFERENCE__14_5b2263726561746544656661756c7456696577706f7274225d_call_directImport_asiSafe1__._undefined¾  14481545resolveTwitterundefined20022103resolveOpenGraphundefined29453038resolveTitleundefined32113314resolveAlternatesundefined34993600resolveOpenGraphundefined38063903resolveTwitterundefined40764183resolveVerificationundefined43094402resolveIconsundefined45334638resolveAppleWebAppundefined47474846resolveAppLinksundefined49705065resolveRobotsundefined52955414resolveAsArrayOrUndefinedundefined55555674resolveAsArrayOrUndefinedundefined58175912resolveItunesundefined75897692resolveThemeColorundefined81888291isClientReferenceundefined84478534(0,tracer/* getTracer */.Yz)undefined85448633constants/* ResolveMetadataSpan */._sundefined91309233isClientReferenceundefined93899476(0,tracer/* getTracer */.Yz)undefined94869575constants/* ResolveMetadataSpan */._sundefined1005510152interopDefaultundefined1132511438getComponentTypeModuleundefined1153611647getLayoutOrPageModuleundefined1219612309getComponentTypeModuleundefined1397114067lib_segment/* PAGE_SEGMENT_KEY */.GCundefined1644816545resolveTwitterundefined2055820669createDefaultMetadataundefined2266322727log/* warn */.ZKundefined2290323014createDefaultViewportundefined2394324054createDefaultMetadataundefined2407824189createDefaultViewportundefinedRawSourceË   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/not-found.js
var not_found = __webpack_require__(5254);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/metadata/metadata.js
›öÿÿ]ôÿÿŸý
  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/lib/metadata/metadata.js|ssr070undefined7297undefined99225undefined227284undefined286373undefined375423undefined425477undefined479523undefined525606undefined608675undefined11641170undefined17451765__WEBPACK_MODULE_REFERENCE__14_5b2263726561746544656661756c744d65746164617461225d_call_directImport_asiSafe1__._undefined18021822__WEBPACK_MODULE_REFERENCE__14_5b2263726561746544656661756c7456696577706f7274225d_call_directImport_asiSafe1__._undefined22562270__WEBPACK_MODULE_REFERENCE__30_5b227265736f6c76654d65746164617461225d_call_directImport_asiSafe1__._undefined30223036__WEBPACK_MODULE_REFERENCE__31_5b2269734e6f74466f756e644572726f72225d_call_directImport_asiSafe1__._undefined31463160__WEBPACK_MODULE_REFERENCE__30_5b227265736f6c76654d65746164617461225d_call_directImport_asiSafe1__._undefined37173726__WEBPACK_MODULE_REFERENCE__8_5b224d65746146696c746572225d_call_directImport_asiSafe1__._undefined37423753__WEBPACK_MODULE_REFERENCE__10_5b2256696577706f72744d657461225d_call_directImport_asiSafe1__._undefined38203828__WEBPACK_MODULE_REFERENCE__10_5b2242617369634d657461225d_call_directImport_asiSafe1__._undefined38853902__WEBPACK_MODULE_REFERENCE__11_5b22416c7465726e617465734d65746164617461225d_call_directImport_asiSafe1__._undefined39823991__WEBPACK_MODULE_REFERENCE__10_5b224974756e65734d657461225d_call_directImport_asiSafe1__._undefined40634081__WEBPACK_MODULE_REFERENCE__10_5b22466f726d6174446574656374696f6e4d657461225d_call_directImport_asiSafe1__._undefined41714186__WEBPACK_MODULE_REFERENCE__10_5b22566572696669636174696f6e4d657461225d_call_directImport_asiSafe1__._undefined42704284__WEBPACK_MODULE_REFERENCE__10_5b224170706c655765624170704d657461225d_call_directImport_asiSafe1__._undefined43664382__WEBPACK_MODULE_REFERENCE__12_5b224f70656e47726170684d65746164617461225d_call_directImport_asiSafe1__._undefined44604474__WEBPACK_MODULE_REFERENCE__12_5b22547769747465724d65746164617461225d_call_directImport_asiSafe1__._undefined45484559__WEBPACK_MODULE_REFERENCE__12_5b224170704c696e6b734d657461225d_call_directImport_asiSafe1__._undefined46354647__WEBPACK_MODULE_REFERENCE__13_5b2249636f6e734d65746164617461225d_call_directImport_asiSafe1__._undefined47804783__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined48744877__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined48794887__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined49794996__WEBPACK_MODULE_REFERENCE__1_5b2264656661756c74222c22636c6f6e65456c656d656e74225d_call_asiSafe1__._undefinedÌ  10711182createDefaultMetadataundefined12191330createDefaultViewportundefined17641863resolveMetadataundefined26152714(0,not_found/* isNotFoundError */.X)undefined28242923resolveMetadataundefined34803568MetaFilterundefined35843677ViewportMetaundefined37443831BasicMetaundefined38883993AlternatesMetadataundefined40734162ItunesMetaundefined42344341FormatDetectionMetaundefined44314532VerificationMetaundefined46164715AppleWebAppMetaundefined47974900OpenGraphMetadataundefined49785077TwitterMetadataundefined51515244AppLinksMetaundefined53205415IconsMetadataundefined55485622(0,jsx_runtime.jsx)undefined57135787(0,jsx_runtime.jsx)undefined57895868jsx_runtime.Fragmentundefined59606059react.cloneElementundefinedRawSource´  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/async-storage/request-async-storage-wrapper.js + 1 modules
var request_async_storage_wrapper = __webpack_require__(4569);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/app-render/dynamic-rendering.js
var dynamic_rendering = __webpack_require__(8255);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/async-storage/static-generation-async-storage-wrapper.js
˜öÿÿZôÿÿÍ  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/async-storage/static-generation-async-storage-wrapper.js|ssr080undefined8288undefined11621181__WEBPACK_MODULE_REFERENCE__34_5b2263726561746550726572656e6465725374617465225d_call_directImport_asiSafe1__._undefinedL   10741183(0,dynamic_rendering/* createPrerenderState */.FI)undefinedRawSource;  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/redirect.js
var redirect = __webpack_require__(3925);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/lib/constants.js
var lib_constants = __webpack_require__(4410);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/lib/patch-fetch.js
•öÿÿ2ôÿÿøÿÿWôÿÿ6õÿÿZ  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/lib/patch-fetch.js|ssr069undefined71123undefined125258undefined260305undefined307374undefined398397(/* unused pure expression or super */ null && (undefined398421"edge"undefined433432))undefined539545undefined13921398undefined32753281undefined36963721__WEBPACK_MODULE_REFERENCE__37_5b224e4558545f43414348455f494d504c494349545f5441475f4944225d_directImport_asiSafe1__._undefined41514176__WEBPACK_MODULE_REFERENCE__37_5b224e4558545f43414348455f494d504c494349545f5441475f4944225d_directImport_asiSafe1__._undefined47494768"production"undefined1900519010Bufferundefined2308223087Bufferundefined2741027416undefined‹   34123528lib_constants/* NEXT_CACHE_IMPLICIT_TAG_ID */.ztundefined39584074lib_constants/* NEXT_CACHE_IMPLICIT_TAG_ID */.ztundefinedRawSourcea   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/flight-render-result.js
’öÿÿTôÿÿò  import { RSC_CONTENT_TYPE_HEADER } from "../../client/components/app-router-headers";
import RenderResult from "../render-result";
/**
 * Flight Response is always set to RSC_CONTENT_TYPE_HEADER to ensure it does not get interpreted as HTML.
 */ export class FlightRenderResult extends RenderResult {
    constructor(response){
        super(response, {
            contentType: RSC_CONTENT_TYPE_HEADER,
            metadata: {}
        });
    }
}

//# sourceMappingURL=flight-render-result.js.map"  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/flight-render-result.js|ssr084undefined86129undefined246252undefined286297__WEBPACK_MODULE_REFERENCE__2_5b2264656661756c74225d_directImport_asiSafe1__._undefined379401__WEBPACK_MODULE_REFERENCE__6_5b225253435f434f4e54454e545f545950455f484541444552225d_directImport_asiSafe1__._undefinedu   150227render_result/* default */.Zundefined309418app_router_headers/* RSC_CONTENT_TYPE_HEADER */.eYundefinedRawSource  
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/string-hash/index.js
var string_hash = __webpack_require__(1252);
var string_hash_default = /*#__PURE__*/__webpack_require__.n(string_hash);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/lib/format-server-error.js
Žöÿÿ—öÿÿg	  const invalidServerComponentReactHooks = [
    "useDeferredValue",
    "useEffect",
    "useImperativeHandle",
    "useInsertionEffect",
    "useLayoutEffect",
    "useReducer",
    "useRef",
    "useState",
    "useSyncExternalStore",
    "useTransition",
    "experimental_useOptimistic",
    "useOptimistic"
];
function setMessage(error, message) {
    error.message = message;
    if (error.stack) {
        const lines = error.stack.split("\n");
        lines[0] = message;
        error.stack = lines.join("\n");
    }
}
/**
 * Input:
 * Error: Something went wrong
    at funcName (/path/to/file.js:10:5)
    at anotherFunc (/path/to/file.js:15:10)
 
 * Output:
    at funcName (/path/to/file.js:10:5)
    at anotherFunc (/path/to/file.js:15:10) 
 */ export function getStackWithoutErrorMessage(error) {
    const stack = error.stack;
    if (!stack) return "";
    return stack.replace(/^[^\n]*\n/, "");
}
export function formatServerError(error) {
    if (typeof (error == null ? void 0 : error.message) !== "string") return;
    if (error.message.includes("Class extends value undefined is not a constructor or null")) {
        const addedMessage = "This might be caused by a React Class Component being rendered in a Server Component, React Class Components only works in Client Components. Read more: https://nextjs.org/docs/messages/class-component-in-server-component";
        // If this error instance already has the message, don't add it again
        if (error.message.includes(addedMessage)) return;
        setMessage(error, `${error.message}

${addedMessage}`);
        return;
    }
    if (error.message.includes("createContext is not a function")) {
        setMessage(error, 'createContext only works in Client Components. Add the "use client" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/context-in-server-component');
        return;
    }
    for (const clientHook of invalidServerComponentReactHooks){
        const regex = new RegExp(`\\b${clientHook}\\b.*is not a function`);
        if (regex.test(error.message)) {
            setMessage(error, `${clientHook} only works in Client Components. Add the "use client" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/react-client-hook-in-server-component`);
            return;
        }
    }
} //# sourceMappingURL=format-server-error.js.map
8  {"version":3,"sources":["webpack://../../src/lib/format-server-error.ts"],"names":["invalidServerComponentReactHooks","setMessage","error","message","stack","lines","split","join","getStackWithoutErrorMessage","replace","formatServerError","includes","addedMessage","clientHook","regex","RegExp","test"],"mappings":"AAAA,MAAMA,mCAAmC;IACvC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,SAASC,WAAWC,KAAY,EAAEC,OAAe;IAC/CD,MAAMC,OAAO,GAAGA;IAChB,IAAID,MAAME,KAAK,EAAE;QACf,MAAMC,QAAQH,MAAME,KAAK,CAACE,KAAK,CAAC;QAChCD,KAAK,CAAC,EAAE,GAAGF;QACXD,MAAME,KAAK,GAAGC,MAAME,IAAI,CAAC;IAC3B;AACF;AAEA;;;;;;;;;CASC,GACD,OAAO,SAASC,4BAA4BN,KAAY;IACtD,MAAME,QAAQF,MAAME,KAAK;IACzB,IAAI,CAACA,OAAO,OAAO;IACnB,OAAOA,MAAMK,OAAO,CAAC,aAAa;AACpC;AAEA,OAAO,SAASC,kBAAkBR,KAAY;IAC5C,IAAI,OAAOA,CAAAA,SAAAA,OAAAA,KAAAA,IAAAA,MAAOC,OAAO,AAAPA,MAAY,UAAU;IAExC,IACED,MAAMC,OAAO,CAACQ,QAAQ,CACpB,+DAEF;QACA,MAAMC,eACJ;QAEF,qEAAqE;QACrE,IAAIV,MAAMC,OAAO,CAACQ,QAAQ,CAACC,eAAe;QAE1CX,WACEC,OACA,CAAC,EAAEA,MAAMC,OAAO,CAAC;;AAEvB,EAAES,aAAa,CAAC;QAEZ;IACF;IAEA,IAAIV,MAAMC,OAAO,CAACQ,QAAQ,CAAC,oCAAoC;QAC7DV,WACEC,OACA;QAEF;IACF;IAEA,KAAK,MAAMW,cAAcb,iCAAkC;QACzD,MAAMc,QAAQ,IAAIC,OAAO,CAAC,GAAG,EAAEF,WAAW,sBAAsB,CAAC;QACjE,IAAIC,MAAME,IAAI,CAACd,MAAMC,OAAO,GAAG;YAC7BF,WACEC,OACA,CAAC,EAAEW,WAAW,oLAAoL,CAAC;YAErM;QACF;IACF;AACF","file":"x"}#   false758764undefined914920undefinedOôÿÿø  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/pipe-readable.js
var pipe_readable = __webpack_require__(7515);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/hooks-server-context.js
var hooks_server_context = __webpack_require__(2726);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/lazy-dynamic/bailout-to-csr.js
var bailout_to_csr = __webpack_require__(1192);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/export/helpers/is-navigation-signal-error.js
ŠöÿÿLôÿÿ‘1  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/export/helpers/is-navigation-signal-error.js|ssr067undefined69135undefined312318undefined358372__WEBPACK_MODULE_REFERENCE__31_5b2269734e6f74466f756e644572726f72225d_call_directImport_asiSafe1__._undefined382396__WEBPACK_MODULE_REFERENCE__36_5b22697352656469726563744572726f72225d_call_directImport_asiSafe1__._undefinedo   216315(0,not_found/* isNotFoundError */.X)undefined325424(0,redirect/* isRedirectError */.eo)undefinedRawSource`   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/export/helpers/is-dynamic-usage-error.js
‡öÿÿIôÿÿÑ  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/export/helpers/is-dynamic-usage-error.js|ssr083undefined85167undefined169239undefined241247undefined283302__WEBPACK_MODULE_REFERENCE__43_5b22697344796e616d69635365727665724572726f72225d_call_directImport_asiSafe1__._undefined312330__WEBPACK_MODULE_REFERENCE__44_5b2269734261696c6f7574546f4353524572726f72225d_call_directImport_asiSafe1__._undefined340362__WEBPACK_MODULE_REFERENCE__45_5b2269734e617669676174696f6e5369676e616c4572726f72225d_call_directImport_asiSafe1__._undefined­   38147(0,hooks_server_context/* isDynamicServerError */.j)undefined157264(0,bailout_to_csr/* isBailoutToCSRError */.D)undefined274389isNavigationSignalErrorundefinedRawSourcea   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/create-error-handler.js
„öÿÿFôÿÿ  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/create-error-handler.js|ssr055undefined57122undefined124187undefined189236undefined238319undefined321327undefined603609undefined11091118__WEBPACK_MODULE_REFERENCE__40_5b2264656661756c74225d_call_directImport_asiSafe1__._undefined14401458__WEBPACK_MODULE_REFERENCE__46_5b22697344796e616d696355736167654572726f72225d_call_directImport_asiSafe1__._undefined15681579__WEBPACK_MODULE_REFERENCE__42_5b22697341626f72744572726f72225d_call_directImport_asiSafe1__._undefined20752091__WEBPACK_MODULE_REFERENCE__41_5b22666f726d61745365727665724572726f72225d_call_directImport_asiSafe1__._undefined25572565__WEBPACK_MODULE_REFERENCE__28_5b22676574547261636572225d_call_directImport_asiSafe1__._undefined27172730__WEBPACK_MODULE_REFERENCE__28_5b225370616e537461747573436f6465225d_asiSafe1__._undefined  779862string_hash_default()undefined11841291isDynamicUsageErrorundefined14011494(0,pipe_readable/* isAbortError */.D)undefined19902093formatServerErrorundefined25592646(0,tracer/* getTracer */.Yz)undefined27982877tracer/* SpanStatusCode */.QnundefinedRawSourcei   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/get-short-dynamic-param-type.js
öÿÿCôÿÿ  export const dynamicParamTypes = {
    catchall: "c",
    "catchall-intercepted": "ci",
    "optional-catchall": "oc",
    dynamic: "d",
    "dynamic-intercepted": "di"
};
/**
 * Shorten the dynamic param in order to make it smaller when transmitted to the browser.
 */ export function getShortDynamicParamType(type) {
    const short = dynamicParamTypes[type];
    if (!short) {
        throw new Error("Unknown dynamic param type");
    }
    return short;
}

//# sourceMappingURL=get-short-dynamic-param-type.js.mapA  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-short-dynamic-param-type.js|ssr06undefined270276undefinedCôÿÿ×   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/app-render/get-segment-param.js
var get_segment_param = __webpack_require__(7126);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/htmlescape.js
~öÿÿ@ôÿÿ‰(  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/htmlescape.js|ssr306312undefined356362undefinedAôÿÿi   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/get-script-nonce-from-header.js
|öÿÿ>ôÿÿˆ¢  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-script-nonce-from-header.js|ssr044undefined4652undefined13341345__WEBPACK_MODULE_REFERENCE__50_5b224553434150455f5245474558225d_call_asiSafe1__._undefined&   12821362ESCAPE_REGEXundefinedRawSource  
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/superstruct/index.cjs
var superstruct = __webpack_require__(6466);
var superstruct_default = /*#__PURE__*/__webpack_require__.n(superstruct);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/types.js
yöÿÿ;ôÿÿ†U	  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/types.js|ssr046undefined8086__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c22656e756d73225d_call_asiSafe1__._undefined163169__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c22756e696f6e225d_call_asiSafe1__._undefined177184__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c22737472696e67225d_call_asiSafe1__._undefined193199__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c227475706c65225d_call_asiSafe1__._undefined211218__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c22737472696e67225d_call_asiSafe1__._undefined231238__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c22737472696e67225d_call_asiSafe1__._undefined474480undefined513519__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c227475706c65225d_call_asiSafe1__._undefined546553__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c227265636f7264225d_call_asiSafe1__._undefined555562__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c22737472696e67225d_call_asiSafe1__._undefined567572__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c226c617a79225d_call_asiSafe1__._undefined609618__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c226f7074696f6e616c225d_call_asiSafe1__._undefined620629__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c226e756c6c61626c65225d_call_asiSafe1__._undefined631638__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c22737472696e67225d_call_asiSafe1__._undefined649658__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c226f7074696f6e616c225d_call_asiSafe1__._undefined660669__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c226e756c6c61626c65225d_call_asiSafe1__._undefined671677__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c22756e696f6e225d_call_asiSafe1__._undefined689697__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c226c69746572616c225d_call_asiSafe1__._undefined719727__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c226c69746572616c225d_call_asiSafe1__._undefined754763__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c226f7074696f6e616c225d_call_asiSafe1__._undefined765773__WEBPACK_MODULE_REFERENCE__52_5b2264656661756c74222c22626f6f6c65616e225d_call_asiSafe1__._undefined…  33119superstruct_default().enumsundefined196282superstruct_default().unionundefined290378superstruct_default().stringundefined387473superstruct_default().tupleundefined485573superstruct_default().stringundefined586674superstruct_default().stringundefined9421028superstruct_default().tupleundefined10551143superstruct_default().recordundefined11451233superstruct_default().stringundefined12381322superstruct_default().lazyundefined13591451superstruct_default().optionalundefined14531545superstruct_default().nullableundefined15471635superstruct_default().stringundefined16461738superstruct_default().optionalundefined17401832superstruct_default().nullableundefined18341920superstruct_default().unionundefined19322022superstruct_default().literalundefined20442134superstruct_default().literalundefined21612253superstruct_default().optionalundefined22552345superstruct_default().booleanundefinedRawSources   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/parse-and-validate-flight-router-state.js
vöÿÿ8ôÿÿ„9  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/parse-and-validate-flight-router-state.js|ssr049undefined51106undefined108114undefined896901__WEBPACK_MODULE_REFERENCE__52_5b22617373657274225d_call_directImport_asiSafe1__._undefined910932__WEBPACK_MODULE_REFERENCE__53_5b22666c69676874526f757465725374617465536368656d61225d_directImport_asiSafe1__._undefinedT   783864(0,superstruct.assert)undefined873983flightRouterStateSchemaundefinedRawSourceY   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/validate-url.js
söÿÿ5ôÿÿ‚$  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/validate-url.js|ssr8490undefined6ôÿÿx   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/create-flight-router-state-from-loader-tree.js
qöÿÿ3ôÿÿÎ  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/create-flight-router-state-from-loader-tree.js|ssr059undefined6167undefined169184__WEBPACK_MODULE_REFERENCE__23_5b22504147455f5345474d454e545f4b4559225d_directImport_asiSafe1__._undefined390396undefined<   102198lib_segment/* PAGE_SEGMENT_KEY */.GCundefinedRawSourceV   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/lib/server-ipc/utils.js
nöÿÿ0ôÿÿÿÿÿ=  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/lib/server-ipc/utils.js|ssr06undefined374380undefined485491undefined1ôÿÿŠ  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/adapters/request-cookies.js
var request_cookies = __webpack_require__(4488);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/lib/server-action-request-meta.js
var server_action_request_meta = __webpack_require__(5627);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/csrf-protection.js
löÿÿ.ôÿÿ~ÿÿÿ+  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/csrf-protection.js|ssr28992905undefined/ôÿÿM  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/cookies.js
var cookies = __webpack_require__(9474);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/adapters/headers.js
var headers = __webpack_require__(3581);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/utils.js
var utils = __webpack_require__(3541);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/app-render/action-utils.js
var action_utils = __webpack_require__(12);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/action-handler.js
jöÿÿ,ôÿÿ}ÿÿÿe  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/action-handler.js|ssr096undefined98165undefined167290undefined292335undefined337396undefined398481undefined483593undefined595707undefined709791undefined793848undefined850895undefined897976undefined9781049undefined10511109undefined11111169undefined18441857__WEBPACK_MODULE_REFERENCE__61_5b2252657175657374436f6f6b696573225d_directImport_asiSafe1__._undefined18591872__WEBPACK_MODULE_REFERENCE__62_5b224865616465727341646170746572225d_call_asiSafe1__._undefined20152029__WEBPACK_MODULE_REFERENCE__61_5b22526573706f6e7365436f6f6b696573225d_directImport_asiSafe1__._undefined20312057__WEBPACK_MODULE_REFERENCE__63_5b2266726f6d4e6f64654f7574676f696e674874747048656164657273225d_call_directImport_asiSafe1__._undefined21462161__WEBPACK_MODULE_REFERENCE__57_5b2266696c74657252657148656164657273225d_call_directImport_asiSafe1__._undefined22682290__WEBPACK_MODULE_REFERENCE__57_5b22616374696f6e73466f7262696464656e48656164657273225d_directImport_asiSafe1__._undefined40154037__WEBPACK_MODULE_REFERENCE__58_5b226765744d6f646966696564436f6f6b696556616c756573225d_call_directImport_asiSafe1__._undefined54925526trueundefined57476307{}undefined66936715__WEBPACK_MODULE_REFERENCE__6_5b225253435f434f4e54454e545f545950455f484541444552225d_directImport_asiSafe1__._undefined68886910__WEBPACK_MODULE_REFERENCE__57_5b22616374696f6e73466f7262696464656e48656164657273225d_call_asiSafe1__._undefined70317048__WEBPACK_MODULE_REFERENCE__39_5b22466c6967687452656e646572526573756c74225d_directImport_asiSafe1__._undefined85338542__WEBPACK_MODULE_REFERENCE__6_5b225253435f484541444552225d_directImport_asiSafe1__._undefined93649397__WEBPACK_MODULE_REFERENCE__37_5b224e4558545f43414348455f524556414c4944415445445f544147535f484541444552225d_directImport_asiSafe1__._undefined94839520__WEBPACK_MODULE_REFERENCE__37_5b224e4558545f43414348455f524556414c49444154455f5441475f544f4b454e5f484541444552225d_directImport_asiSafe1__._undefined1050410526__WEBPACK_MODULE_REFERENCE__6_5b225253435f434f4e54454e545f545950455f484541444552225d_directImport_asiSafe1__._undefined1071110733__WEBPACK_MODULE_REFERENCE__57_5b22616374696f6e73466f7262696464656e48656164657273225d_call_asiSafe1__._undefined1087010887__WEBPACK_MODULE_REFERENCE__39_5b22466c6967687452656e646572526573756c74225d_directImport_asiSafe1__._undefined1137811389__WEBPACK_MODULE_REFERENCE__2_5b2264656661756c74225d_call_asiSafe1__._undefined1161411620undefined1197712006__WEBPACK_MODULE_REFERENCE__59_5b22676574536572766572416374696f6e526571756573744d65746164617461225d_call_directImport_asiSafe1__._undefined1295112954__WEBPACK_MODULE_REFERENCE__20_5b227761726e225d_call_directImport_asiSafe1__._undefined1362313641__WEBPACK_MODULE_REFERENCE__60_5b226973437372664f726967696e416c6c6f776564225d_call_directImport_asiSafe1__._undefined1607716101__WEBPACK_MODULE_REFERENCE__64_5b2273656c656374576f726b6572466f72466f7277617264696e67225d_call_directImport_asiSafe1__._undefined1669216726trueundefined1916023719{}undefined2552025534__WEBPACK_MODULE_REFERENCE__36_5b22697352656469726563744572726f72225d_call_directImport_asiSafe1__._undefined2557625598__WEBPACK_MODULE_REFERENCE__36_5b2267657455524c46726f6d52656469726563744572726f72225d_call_directImport_asiSafe1__._undefined2563725666__WEBPACK_MODULE_REFERENCE__36_5b226765745265646972656374537461747573436f646546726f6d4572726f72225d_call_directImport_asiSafe1__._undefined2652426543__WEBPACK_MODULE_REFERENCE__58_5b22617070656e644d757461626c65436f6f6b696573225d_call_directImport_asiSafe1__._undefined2681526826__WEBPACK_MODULE_REFERENCE__2_5b2264656661756c74225d_call_asiSafe1__._undefined2687726891__WEBPACK_MODULE_REFERENCE__31_5b2269734e6f74466f756e644572726f72225d_call_directImport_asiSafe1__._undefinedÂ  688780cookies/* RequestCookies */.qundefined782866headers/* HeadersAdapter */.hundefined10091103cookies/* ResponseCookies */.nundefined11051228(0,utils/* fromNodeOutgoingHttpHeaders */.EK)undefined13171418filterReqHeadersundefined15251635actionsForbiddenHeadersundefined33603475(0,request_cookies/* getModifiedCookieValues */.fB)undefined55415650app_router_headers/* RSC_CONTENT_TYPE_HEADER */.eYundefined58235925actionsForbiddenHeadersundefined60466146FlightRenderResultundefined76317714app_router_headers/* RSC_HEADER */.Aundefined85368668lib_constants/* NEXT_CACHE_REVALIDATED_TAGS_HEADER */.ofundefined87548894lib_constants/* NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER */.X_undefined98789987app_router_headers/* RSC_CONTENT_TYPE_HEADER */.eYundefined1017210274actionsForbiddenHeadersundefined1041110511FlightRenderResultundefined1100211071render_result/* default */.Zundefined1165211781(0,server_action_request_meta/* getServerActionRequestMetadata */.G)undefined1272612803(0,log/* warn */.ZK)undefined1347213579isCsrfOriginAllowedundefined1601516134(0,action_utils/* selectWorkerForForwarding */.k)undefined2096421063(0,redirect/* isRedirectError */.eo)undefined2110521220(0,redirect/* getURLFromRedirectError */.M6)undefined2125921388(0,redirect/* getRedirectStatusCodeFromError */.j2)undefined2224622355(0,request_cookies/* appendMutableCookies */._5)undefined2262722696render_result/* default */.Zundefined2274722846(0,not_found/* isNotFoundError */.X)undefinedRawSource	  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/server-inserted-html.shared-runtime.js
var server_inserted_html_shared_runtime = __webpack_require__(3234);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/server-inserted-html.js
göÿÿ)ôÿÿ{ÿÿÿê  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/server-inserted-html.js|ssr114161undefined163188undefined190286undefined288294undefined574577__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined579603__WEBPACK_MODULE_REFERENCE__66_5b22536572766572496e73657274656448544d4c436f6e74657874225d_asiSafe1__._undefined841844__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined846859__WEBPACK_MODULE_REFERENCE__1_5b2264656661756c74222c22467261676d656e74225d_asiSafe1__._undefined¶   396470(0,jsx_runtime.jsx)undefined472573server_inserted_html_shared_runtime.ServerInsertedHTMLContextundefined811885(0,jsx_runtime.jsx)undefined887973react.FragmentundefinedRawSourceU   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/shared/lib/encode-uri-path.js
döÿÿmöÿÿš   export function encodeURIPath(file) {
    return file.split("/").map((p)=>encodeURIComponent(p)).join("/");
} //# sourceMappingURL=encode-uri-path.js.map
(  {"version":3,"sources":["webpack://../../../src/shared/lib/encode-uri-path.ts"],"names":["encodeURIPath","file","split","map","p","encodeURIComponent","join"],"mappings":"AAAA,OAAO,SAASA,cAAcC,IAAY;IACxC,OAAOA,KACJC,KAAK,CAAC,KACNC,GAAG,CAAC,CAACC,IAAMC,mBAAmBD,IAC9BE,IAAI,CAAC;AACV","file":"x"}1üÿÿ&ôÿÿí   
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react-dom/server-rendering-stub.js
var server_rendering_stub = __webpack_require__(8754);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/required-scripts.js
aöÿÿ#ôÿÿvÿÿÿ…  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/required-scripts.js|ssr064undefined6698undefined100106undefined386398__WEBPACK_MODULE_REFERENCE__68_5b22656e636f646555524950617468225d_directImport_asiSafe1__._undefined11151130__WEBPACK_MODULE_REFERENCE__69_5b2264656661756c74222c22707265696e6974225d_call_asiSafe1__._undefined18021817__WEBPACK_MODULE_REFERENCE__69_5b2264656661756c74222c22707265696e6974225d_call_asiSafe1__._undefined   281371encodeURIPathundefined10881178server_rendering_stub.preinitundefined18501940server_rendering_stub.preinitundefinedRawSource  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/add-path-prefix.js
var add_path_prefix = __webpack_require__(7253);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/build/webpack/alias/react-dom-server-edge.js
var react_dom_server_edge = __webpack_require__(9183);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/redirect-status-code.js
var redirect_status_code = __webpack_require__(3207);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/make-get-server-inserted-html.js
^öÿÿ ôÿÿtÿÿÿx  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/make-get-server-inserted-html.js|ssr085undefined87112undefined114181undefined183306undefined308370undefined372444undefined446527undefined529606undefined608614undefined12251239__WEBPACK_MODULE_REFERENCE__31_5b2269734e6f74466f756e644572726f72225d_call_directImport_asiSafe1__._undefined13001303__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined14241461 falseundefined147916060undefined16401654__WEBPACK_MODULE_REFERENCE__36_5b22697352656469726563744572726f72225d_call_directImport_asiSafe1__._undefined17021714__WEBPACK_MODULE_REFERENCE__71_5b2261646450617468507265666978225d_call_directImport_asiSafe1__._undefined17161738__WEBPACK_MODULE_REFERENCE__36_5b2267657455524c46726f6d52656469726563744572726f72225d_call_directImport_asiSafe1__._undefined17941823__WEBPACK_MODULE_REFERENCE__36_5b226765745265646972656374537461747573436f646546726f6d4572726f72225d_call_directImport_asiSafe1__._undefined18841901__WEBPACK_MODULE_REFERENCE__73_5b225265646972656374537461747573436f6465225d_asiSafe1__._undefined20252028__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined26262647__WEBPACK_MODULE_REFERENCE__72_5b2272656e646572546f5265616461626c6553747265616d225d_call_directImport_asiSafe1__._undefined26632667__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined26692677__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined28772880__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined35173530__WEBPACK_MODULE_REFERENCE__3_5b2273747265616d546f537472696e67225d_call_directImport_asiSafe1__._undefined¢  618717(0,not_found/* isNotFoundError */.X)undefined778852(0,jsx_runtime.jsx)undefined10301129(0,redirect/* isRedirectError */.eo)undefined11771272(0,add_path_prefix/* addPathPrefix */.V)undefined12741389(0,redirect/* getURLFromRedirectError */.M6)undefined14451574(0,redirect/* getRedirectStatusCodeFromError */.j2)undefined16351722redirect_status_code/* RedirectStatusCode */.Xundefined18461920(0,jsx_runtime.jsx)undefined25182631(0,react_dom_server_edge.renderToReadableStream)undefined26472723(0,jsx_runtime.jsxs)undefined27252804jsx_runtime.Fragmentundefined30043078(0,jsx_runtime.jsx)undefined37153811(0,node_web_streams_helper/* streamToString */.PN)undefinedRawSourcef   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/get-css-inlined-link-tags.js
[öÿÿôÿÿrÿÿÿ1  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-css-inlined-link-tags.js|ssr7682undefinedôÿÿb   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/get-preloadable-fonts.js
Yöÿÿôÿÿqÿÿÿ/  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-preloadable-fonts.js|ssr354360undefinedôÿÿ^   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/parse-loader-tree.js
WöÿÿôÿÿÊ  import { DEFAULT_SEGMENT_KEY } from "../../shared/lib/segment";
export function parseLoaderTree(tree) {
    const [segment, parallelRoutes, components] = tree;
    const { layout } = components;
    let { page } = components;
    // a __DEFAULT__ segment means that this route didn't match any of the
    // segments in the route, so we should use the default page
    page = segment === DEFAULT_SEGMENT_KEY ? components.defaultPage : page;
    const layoutOrPagePath = (layout == null ? void 0 : layout[1]) || (page == null ? void 0 : page[1]);
    return {
        page,
        segment,
        components,
        layoutOrPagePath,
        parallelRoutes
    };
}

//# sourceMappingURL=parse-loader-tree.js.map«  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/parse-loader-tree.js|ssr062undefined6470undefined388406__WEBPACK_MODULE_REFERENCE__23_5b2244454641554c545f5345474d454e545f4b4559225d_directImport_asiSafe1__._undefined?   318420lib_segment/* DEFAULT_SEGMENT_KEY */.avundefinedRawSourcec   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/get-asset-query-string.js
SöÿÿôÿÿÑ  const isDev = process.env.NODE_ENV === "development";
const isTurbopack = !!process.env.TURBOPACK;
export function getAssetQueryString(ctx, addTimestamp) {
    let qs = "";
    // In development we add the request timestamp to allow react to
    // reload assets when a new RSC response is received.
    // Turbopack handles HMR of assets itself and react doesn't need to reload them
    // so this approach is not needed for Turbopack.
    if (isDev && !isTurbopack && addTimestamp) {
        qs += `?v=${ctx.requestTimestamp}`;
    }
    if (ctx.renderOpts.deploymentId) {
        qs += `${isDev ? "&" : "?"}dpl=${ctx.renderOpts.deploymentId}`;
    }
    return qs;
}

//# sourceMappingURL=get-asset-query-string.js.mapZ  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-asset-query-string.js|ssr1433"production"undefined7696falseundefined99105undefinedôÿÿ]   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/get-layer-assets.js
Pöÿÿôÿÿkÿÿÿ¤  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-layer-assets.js|ssr047undefined4974undefined76142undefined144205undefined207269undefined271335undefined337343undefined622641__WEBPACK_MODULE_REFERENCE__75_5b226765744c696e6b416e6453637269707454616773225d_call_directImport_asiSafe1__._undefined856874__WEBPACK_MODULE_REFERENCE__76_5b226765745072656c6f616461626c65466f6e7473225d_call_directImport_asiSafe1__._undefined13541366__WEBPACK_MODULE_REFERENCE__68_5b22656e636f646555524950617468225d_call_directImport_asiSafe1__._undefined23952407__WEBPACK_MODULE_REFERENCE__68_5b22656e636f646555524950617468225d_call_directImport_asiSafe1__._undefined24172435__WEBPACK_MODULE_REFERENCE__78_5b2267657441737365745175657279537472696e67225d_call_directImport_asiSafe1__._undefined28932930 falseundefined293429470undefined30653068__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined34023414__WEBPACK_MODULE_REFERENCE__68_5b22656e636f646555524950617468225d_call_directImport_asiSafe1__._undefined34243442__WEBPACK_MODULE_REFERENCE__78_5b2267657441737365745175657279537472696e67225d_call_directImport_asiSafe1__._undefined34873490__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined8  284393getLinkAndScriptTagsundefined608715getPreloadableFontsundefined11951290encodeURIPathundefined23192414encodeURIPathundefined24242531getAssetQueryStringundefined31163190(0,jsx_runtime.jsx)undefined35243619encodeURIPathundefined36293736getAssetQueryStringundefined37813855(0,jsx_runtime.jsx)undefinedRawSourcej   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/has-loading-component-in-tree.js
Möÿÿôÿÿiÿÿÿ3  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/has-loading-component-in-tree.js|ssr06undefinedôÿÿ\   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/interop-default.js
Köÿÿôÿÿµ   /**
 * Interop between "export default" and "module.exports".
 */ export function interopDefault(mod) {
    return mod.default || mod;
}

//# sourceMappingURL=interop-default.js.map'  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/interop-default.js|ssr6672undefined4   7588interop_default_interopDefaultundefinedRawSourcep   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/create-component-styles-and-scripts.js
Göÿÿ	ôÿÿeÿÿÿ:  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/create-component-styles-and-scripts.js|ssr047undefined4974undefined76126undefined128194undefined196258undefined260324undefined326332undefined491510__WEBPACK_MODULE_REFERENCE__75_5b226765744c696e6b416e6453637269707454616773225d_call_directImport_asiSafe1__._undefined690702__WEBPACK_MODULE_REFERENCE__68_5b22656e636f646555524950617468225d_call_directImport_asiSafe1__._undefined712730__WEBPACK_MODULE_REFERENCE__78_5b2267657441737365745175657279537472696e67225d_call_directImport_asiSafe1__._undefined11881225 falseundefined122912420undefined12831286__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined15691572__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined16311643__WEBPACK_MODULE_REFERENCE__68_5b22656e636f646555524950617468225d_call_directImport_asiSafe1__._undefined16531671__WEBPACK_MODULE_REFERENCE__78_5b2267657441737365745175657279537472696e67225d_call_directImport_asiSafe1__._undefined17481761__WEBPACK_MODULE_REFERENCE__81_5b22696e7465726f7044656661756c74225d_call_directImport_asiSafe1__._undefined#  164273getLinkAndScriptTagsundefined453548encodeURIPathundefined558665getAssetQueryStringundefined11731247(0,jsx_runtime.jsx)undefined15301604(0,jsx_runtime.jsx)undefined16631758encodeURIPathundefined17681875getAssetQueryStringundefined19522049interop_default_interopDefaultundefinedRawSourceý   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/static-generation-bailout.js
var static_generation_bailout = __webpack_require__(7997);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/create-component-tree.js
Döÿÿôÿÿcÿÿÿ  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/create-component-tree.js|ssr085undefined87112undefined114176undefined178239undefined241291undefined293346undefined348435undefined437488undefined490565undefined567622undefined624716undefined718765undefined767826undefined828917undefined9951001undefined10511059__WEBPACK_MODULE_REFERENCE__28_5b22676574547261636572225d_call_directImport_asiSafe1__._undefined10691086__WEBPACK_MODULE_REFERENCE__29_5b224e6578744e6f64655365727665725370616e225d_asiSafe1__._undefined18611875__WEBPACK_MODULE_REFERENCE__77_5b2270617273654c6f6164657254726565225d_call_directImport_asiSafe1__._undefined22032216__WEBPACK_MODULE_REFERENCE__79_5b226765744c61796572417373657473225d_call_directImport_asiSafe1__._undefined25142544__WEBPACK_MODULE_REFERENCE__82_5b22637265617465436f6d706f6e656e745374796c6573416e6453637269707473225d_call_directImport_asiSafe1__._undefined27452758__WEBPACK_MODULE_REFERENCE__1_5b2264656661756c74222c22467261676d656e74225d_asiSafe1__._undefined28372867__WEBPACK_MODULE_REFERENCE__82_5b22637265617465436f6d706f6e656e745374796c6573416e6453637269707473225d_call_directImport_asiSafe1__._undefined31253155__WEBPACK_MODULE_REFERENCE__82_5b22637265617465436f6d706f6e656e745374796c6573416e6453637269707473225d_call_directImport_asiSafe1__._undefined34843492__WEBPACK_MODULE_REFERENCE__28_5b22676574547261636572225d_call_directImport_asiSafe1__._undefined35023519__WEBPACK_MODULE_REFERENCE__29_5b224e6578744e6f64655365727665725370616e225d_asiSafe1__._undefined37113731__WEBPACK_MODULE_REFERENCE__24_5b226765744c61796f75744f72506167654d6f64756c65225d_call_directImport_asiSafe1__._undefined41074137__WEBPACK_MODULE_REFERENCE__82_5b22637265617465436f6d706f6e656e745374796c6573416e6453637269707473225d_call_directImport_asiSafe1__._undefined46954715__WEBPACK_MODULE_REFERENCE__83_5b2253746174696347656e4261696c6f75744572726f72225d_directImport_asiSafe1__._undefined65426559__WEBPACK_MODULE_REFERENCE__38_5b2276616c6964617465526576616c6964617465225d_call_directImport_asiSafe1__._undefined78617874__WEBPACK_MODULE_REFERENCE__81_5b22696e7465726f7044656661756c74225d_call_directImport_asiSafe1__._undefined87798782__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined88648868__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined88708878__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined89908994__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined92129215__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined93919394__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined95179554falseundefined955710433{}undefined1153711540__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1259112615__WEBPACK_MODULE_REFERENCE__80_5b226861734c6f6164696e67436f6d706f6e656e74496e54726565225d_call_directImport_asiSafe1__._undefined1388713940falseundefined1394314512{ var _parsedTree_layoutOrPagePath; }undefined1554915552__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1603916042__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1610016103__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1695916962__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1774117744__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1774617754__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined1908819091__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1945119467__WEBPACK_MODULE_REFERENCE__22_5b226973436c69656e745265666572656e6365225d_call_directImport_asiSafe1__._undefined2002620030__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined2003220040__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined2009920102__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2022520262 falseundefined20281203940undefined2045920462__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2054820619falseundefined2062220854{}undefined2166321667__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined2166921677__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined2178021783__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2225622260__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined2226222270__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined2237322376__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2259522598__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2278222786__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined2278822796__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefinedú  139226(0,tracer/* getTracer */.Yz)undefined236323constants/* NextNodeServerSpan */.Xyundefined10981197parseLoaderTreeundefined15251622getLayerAssetsundefined19202051createComponentStylesAndScriptsundefined22522338react.Fragmentundefined24172548createComponentStylesAndScriptsundefined28062937createComponentStylesAndScriptsundefined32663353(0,tracer/* getTracer */.Yz)undefined33633450constants/* NextNodeServerSpan */.Xyundefined36423753getLayoutOrPageModuleundefined41294260createComponentStylesAndScriptsundefined48184924static_generation_bailout/* StaticGenBailoutError */.Gundefined67516856validateRevalidateundefined81588255interop_default_interopDefaultundefined91609234(0,jsx_runtime.jsx)undefined93169392(0,jsx_runtime.jsxs)undefined93949473jsx_runtime.Fragmentundefined95859661(0,jsx_runtime.jsxs)undefined98799953(0,jsx_runtime.jsx)undefined1012910203(0,jsx_runtime.jsx)undefined1143811512(0,jsx_runtime.jsx)undefined1256312682hasLoadingComponentInTreeundefined1503415108(0,jsx_runtime.jsx)undefined1559515669(0,jsx_runtime.jsx)undefined1572715801(0,jsx_runtime.jsx)undefined1665716731(0,jsx_runtime.jsx)undefined1751017584(0,jsx_runtime.jsx)undefined1758617665jsx_runtime.Fragmentundefined1899919073(0,jsx_runtime.jsx)undefined1943319536isClientReferenceundefined2009520171(0,jsx_runtime.jsxs)undefined2017320252jsx_runtime.Fragmentundefined2031120385(0,jsx_runtime.jsx)undefined2059720671(0,jsx_runtime.jsx)undefined2157421650(0,jsx_runtime.jsxs)undefined2165221731jsx_runtime.Fragmentundefined2183421908(0,jsx_runtime.jsx)undefined2238122457(0,jsx_runtime.jsxs)undefined2245922538jsx_runtime.Fragmentundefined2264122715(0,jsx_runtime.jsx)undefined2293423008(0,jsx_runtime.jsx)undefined2319223268(0,jsx_runtime.jsxs)undefined2327023349jsx_runtime.FragmentundefinedRawSourceo   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/walk-tree-with-flight-router-state.js
Aöÿÿôÿÿaÿÿÿ  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/walk-tree-with-flight-router-state.js|ssr072undefined7499undefined101194undefined196262undefined264325undefined327458undefined460513undefined515566undefined568643undefined645706undefined708770undefined9941000undefined24232450__WEBPACK_MODULE_REFERENCE__56_5b22616464536561726368506172616d734966506167655365676d656e74225d_call_directImport_asiSafe1__._undefined27552766__WEBPACK_MODULE_REFERENCE__4_5b226d617463685365676d656e74225d_call_directImport_asiSafe1__._undefined32533277__WEBPACK_MODULE_REFERENCE__80_5b226861734c6f6164696e67436f6d706f6e656e74496e54726565225d_call_directImport_asiSafe1__._undefined34063427__WEBPACK_MODULE_REFERENCE__4_5b2263616e5365676d656e7442654f76657272696464656e225d_call_directImport_asiSafe1__._undefined35343570__WEBPACK_MODULE_REFERENCE__56_5b22637265617465466c69676874526f75746572537461746546726f6d4c6f6164657254726565225d_call_directImport_asiSafe1__._undefined40964114__WEBPACK_MODULE_REFERENCE__84_5b22637265617465436f6d706f6e656e7454726565225d_call_directImport_asiSafe1__._undefined48454859__WEBPACK_MODULE_REFERENCE__77_5b2270617273654c6f6164657254726565225d_call_directImport_asiSafe1__._undefined49144927__WEBPACK_MODULE_REFERENCE__79_5b226765744c61796572417373657473225d_call_directImport_asiSafe1__._undefined52155219__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined52215229__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined60656084__WEBPACK_MODULE_REFERENCE__75_5b226765744c696e6b416e6453637269707454616773225d_call_directImport_asiSafe1__._undefined62016219__WEBPACK_MODULE_REFERENCE__76_5b226765745072656c6f616461626c65466f6e7473225d_call_directImport_asiSafe1__._undefined78357853__WEBPACK_MODULE_REFERENCE__23_5b2244454641554c545f5345474d454e545f4b4559225d_directImport_asiSafe1__._undefined<  16551780addSearchParamsIfPageSegmentundefined20852177(0,match_segments/* matchSegment */.j)undefined26642783hasLoadingComponentInTreeundefined29123024(0,match_segments/* canSegmentBeOverridden */.W)undefined31313274createFlightRouterStateFromLoaderTreeundefined38003907createComponentTreeundefined46384737parseLoaderTreeundefined47924889getLayerAssetsundefined51775253(0,jsx_runtime.jsxs)undefined52555334jsx_runtime.Fragmentundefined61706279getLinkAndScriptTagsundefined63966503getPreloadableFontsundefined81198221lib_segment/* DEFAULT_SEGMENT_KEY */.avundefinedRawSourceì   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/app-render/encryption-utils.js
var encryption_utils = __webpack_require__(1318);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/static/static-renderer.js
>öÿÿ ôÿÿ_ÿÿÿ-  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/static/static-renderer.js|ssr106142 falseundefined1461870undefined560598(__webpack_require__(9183).resume)undefined800806undefined926980(__webpack_require__(9183).renderToReadableStream)undefined11551161undefined14801486undefined15111517undefined15421548undefined16521658undefined17281734undefinedôÿÿ`   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/use-flight-response.js
<öÿÿþóÿÿ^ÿÿÿV  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/use-flight-response.js|ssr052undefined7699"edge"undefined439445undefined885905falseundefined9081095{}undefined12091280(__webpack_require__(1502).createFromReadableStream)undefined22552261undefined29322938undefined47574776__WEBPACK_MODULE_REFERENCE__50_5b2268746d6c4573636170654a736f6e537472696e67225d_call_directImport_asiSafe1__._undefined48664885__WEBPACK_MODULE_REFERENCE__50_5b2268746d6c4573636170654a736f6e537472696e67225d_call_directImport_asiSafe1__._undefined51415160__WEBPACK_MODULE_REFERENCE__50_5b2268746d6c4573636170654a736f6e537472696e67225d_call_directImport_asiSafe1__._undefined×   719use_flight_response_isEdgeRuntimeundefined11661178use_flight_response_isEdgeRuntimeundefined44434552htmlEscapeJsonStringundefined46424751htmlEscapeJsonStringundefined50075116htmlEscapeJsonStringundefinedRawSource‡  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/future/helpers/interception-routes.js
var interception_routes = __webpack_require__(117);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/client-component-renderer-logger.js
var client_component_renderer_logger = __webpack_require__(9031);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/app-render/app-render.js
9öÿÿûóÿÿ\ÿÿÿ?  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/app-render.js|ssr085undefined87112undefined114157undefined159381undefined383462undefined464520undefined522656undefined658728undefined730821undefined823933undefined9351002undefined10041127undefined11291181undefined11831257undefined12591306undefined13081367undefined13691448undefined14501542undefined15441597undefined15991672undefined16741766undefined17681812undefined18141915undefined19171964undefined19662048undefined20502102undefined21042189undefined21912256undefined22582313undefined23152392undefined23942469undefined24712555undefined25572618undefined26202682undefined26842751undefined27532876undefined28782961undefined29633073undefined30753189undefined31913273undefined32753350undefined33523459undefined34613573undefined35753629undefined44814502__WEBPACK_MODULE_REFERENCE__4_5b2263616e5365676d656e7442654f76657272696464656e225d_call_directImport_asiSafe1__._undefined53755389__WEBPACK_MODULE_REFERENCE__49_5b226765745365676d656e74506172616d225d_call_directImport_asiSafe1__._undefined61516167__WEBPACK_MODULE_REFERENCE__48_5b2264796e616d6963506172616d5479706573225d_directImport_asiSafe1__._undefined66596682__WEBPACK_MODULE_REFERENCE__48_5b2267657453686f727444796e616d6963506172616d54797065225d_call_directImport_asiSafe1__._undefined73277330__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined81828205__WEBPACK_MODULE_REFERENCE__32_5b226372656174654d65746164617461436f6d706f6e656e7473225d_call_directImport_asiSafe1__._undefined85158543__WEBPACK_MODULE_REFERENCE__85_5b2277616c6b5472656557697468466c69676874526f757465725374617465225d_call_directImport_asiSafe1__._undefined88458849__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined88518859__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined89268929__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined90349037__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined93979400__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1001710034__WEBPACK_MODULE_REFERENCE__39_5b22466c6967687452656e646572526573756c74225d_directImport_asiSafe1__._undefined1147011506__WEBPACK_MODULE_REFERENCE__56_5b22637265617465466c69676874526f75746572537461746546726f6d4c6f6164657254726565225d_call_directImport_asiSafe1__._undefined1159311616__WEBPACK_MODULE_REFERENCE__32_5b226372656174654d65746164617461436f6d706f6e656e7473225d_call_directImport_asiSafe1__._undefined1200212020__WEBPACK_MODULE_REFERENCE__84_5b22637265617465436f6d706f6e656e7454726565225d_call_directImport_asiSafe1__._undefined1233612339__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1281512822__WEBPACK_MODULE_REFERENCE__6_5b224e4558545f55524c225d_directImport_asiSafe1__._undefined1285112855__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined1285712865__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined1293612939__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1341513419__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined1342113429__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined1350413507__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1362413627__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1438414407__WEBPACK_MODULE_REFERENCE__32_5b226372656174654d65746164617461436f6d706f6e656e7473225d_call_directImport_asiSafe1__._undefined1469514699__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined1470114709__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined1476014763__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1484414847__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1489114928 falseundefined14947150480undefined1509215128__WEBPACK_MODULE_REFERENCE__56_5b22637265617465466c69676874526f75746572537461746546726f6d4c6f6164657254726565225d_call_directImport_asiSafe1__._undefined1539115395__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined1549515498__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1554315546__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1563115634__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1618916203__WEBPACK_MODULE_REFERENCE__88_5b22757365466c6967687453747265616d225d_call_directImport_asiSafe1__._undefined1626816276__WEBPACK_MODULE_REFERENCE__1_5b2264656661756c74222c22757365225d_call_asiSafe1__._undefined1731717341__WEBPACK_MODULE_REFERENCE__90_5b2277726170436c69656e74436f6d706f6e656e744c6f61646572225d_call_directImport_asiSafe1__._undefined1772417754__WEBPACK_MODULE_REFERENCE__90_5b22676574436c69656e74436f6d706f6e656e744c6f616465724d657472696373225d_call_directImport_asiSafe1__._undefined1786117869__WEBPACK_MODULE_REFERENCE__28_5b22676574547261636572225d_call_directImport_asiSafe1__._undefined1788317900__WEBPACK_MODULE_REFERENCE__29_5b224e6578744e6f64655365727665725370616e225d_asiSafe1__._undefined1857218592__WEBPACK_MODULE_REFERENCE__64_5b226372656174655365727665724d6f64756c654d6170225d_call_directImport_asiSafe1__._undefined1867318702__WEBPACK_MODULE_REFERENCE__86_5b227365745265666572656e63654d616e69666573747353696e676c65746f6e225d_call_directImport_asiSafe1__._undefined1934319360__WEBPACK_MODULE_REFERENCE__47_5b226372656174654572726f7248616e646c6572225d_call_directImport_asiSafe1__._undefined1938019397__WEBPACK_MODULE_REFERENCE__47_5b224572726f7248616e646c6572536f75726365225d_asiSafe1__._undefined1962419641__WEBPACK_MODULE_REFERENCE__47_5b226372656174654572726f7248616e646c6572225d_call_directImport_asiSafe1__._undefined1966119678__WEBPACK_MODULE_REFERENCE__47_5b224572726f7248616e646c6572536f75726365225d_asiSafe1__._undefined1989319910__WEBPACK_MODULE_REFERENCE__47_5b226372656174654572726f7248616e646c6572225d_call_directImport_asiSafe1__._undefined1993019947__WEBPACK_MODULE_REFERENCE__47_5b224572726f7248616e646c6572536f75726365225d_asiSafe1__._undefined2125821277__WEBPACK_MODULE_REFERENCE__5_5b227374726970496e7465726e616c51756572696573225d_call_directImport_asiSafe1__._undefined2132421333__WEBPACK_MODULE_REFERENCE__6_5b225253435f484541444552225d_call_asiSafe1__._undefined2142621452__WEBPACK_MODULE_REFERENCE__6_5b224e4558545f524f555445525f50524546455443485f484541444552225d_call_asiSafe1__._undefined2205922084__WEBPACK_MODULE_REFERENCE__89_5b226973496e74657263657074696f6e526f75746541707050617468225d_call_directImport_asiSafe1__._undefined2213422166__WEBPACK_MODULE_REFERENCE__54_5b227061727365416e6456616c6964617465466c69676874526f757465725374617465225d_call_directImport_asiSafe1__._undefined2218022201__WEBPACK_MODULE_REFERENCE__6_5b224e4558545f524f555445525f53544154455f54524545225d_call_asiSafe1__._undefined2239322427trueundefined2248422557{}undefined2432324346__WEBPACK_MODULE_REFERENCE__51_5b226765745363726970744e6f6e636546726f6d486561646572225d_call_directImport_asiSafe1__._undefined2443124437__webpack_require__undefined24439244924190undefined2470524728__WEBPACK_MODULE_REFERENCE__67_5b22637265617465536572766572496e73657274656448544d4c225d_call_directImport_asiSafe1__._undefined2477324781__WEBPACK_MODULE_REFERENCE__28_5b22676574547261636572225d_call_directImport_asiSafe1__._undefined2491824926__WEBPACK_MODULE_REFERENCE__28_5b22676574547261636572225d_call_directImport_asiSafe1__._undefined2493524947__WEBPACK_MODULE_REFERENCE__29_5b2241707052656e6465725370616e225d_asiSafe1__._undefined2534525363__WEBPACK_MODULE_REFERENCE__78_5b2267657441737365745175657279537472696e67225d_call_directImport_asiSafe1__._undefined2566925686__WEBPACK_MODULE_REFERENCE__70_5b22676574526571756972656453637269707473225d_call_directImport_asiSafe1__._undefined2577025788__WEBPACK_MODULE_REFERENCE__78_5b2267657441737365745175657279537472696e67225d_call_directImport_asiSafe1__._undefined2617126174__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2658326586__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2674326746__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2681826821__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2793927963__WEBPACK_MODULE_REFERENCE__74_5b226d616b65476574536572766572496e73657274656448544d4c225d_call_directImport_asiSafe1__._undefined2816028179__WEBPACK_MODULE_REFERENCE__87_5b2263726561746553746174696352656e6465726572225d_call_directImport_asiSafe1__._undefined3010030114__WEBPACK_MODULE_REFERENCE__34_5b227573656444796e616d696341504973225d_call_directImport_asiSafe1__._undefined3029830325__WEBPACK_MODULE_REFERENCE__87_5b2267657444796e616d696348544d4c506f7374706f6e65645374617465225d_call_directImport_asiSafe1__._undefined3048630513__WEBPACK_MODULE_REFERENCE__87_5b2267657444796e616d696344617461506f7374706f6e65645374617465225d_call_directImport_asiSafe1__._undefined3107431097__WEBPACK_MODULE_REFERENCE__3_5b22636f6e74696e756544796e616d696350726572656e646572225d_call_directImport_asiSafe1__._undefined3156731586__WEBPACK_MODULE_REFERENCE__88_5b22666c6967687452656e646572436f6d706c657465225d_call_directImport_asiSafe1__._undefined3162431638__WEBPACK_MODULE_REFERENCE__34_5b227573656444796e616d696341504973225d_call_directImport_asiSafe1__._undefined3195531982__WEBPACK_MODULE_REFERENCE__87_5b2267657444796e616d696348544d4c506f7374706f6e65645374617465225d_call_directImport_asiSafe1__._undefined3215532182__WEBPACK_MODULE_REFERENCE__87_5b2267657444796e616d696344617461506f7374706f6e65645374617465225d_call_directImport_asiSafe1__._undefined3277132794__WEBPACK_MODULE_REFERENCE__3_5b22636f6e74696e756544796e616d696350726572656e646572225d_call_directImport_asiSafe1__._undefined3329433314__WEBPACK_MODULE_REFERENCE__83_5b2253746174696347656e4261696c6f75744572726f72225d_directImport_asiSafe1__._undefined3381333832__WEBPACK_MODULE_REFERENCE__87_5b2263726561746553746174696352656e6465726572225d_call_directImport_asiSafe1__._undefined3398134008__WEBPACK_MODULE_REFERENCE__87_5b2267657444796e616d696348544d4c506f7374706f6e65645374617465225d_call_directImport_asiSafe1__._undefined3411534140__WEBPACK_MODULE_REFERENCE__34_5b22637265617465506f7374706f6e656441626f72745369676e616c225d_call_directImport_asiSafe1__._undefined3468934692__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined3494934952__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined3504435047__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined3574935760__WEBPACK_MODULE_REFERENCE__3_5b22636861696e53747265616d73225d_call_directImport_asiSafe1__._undefined3588635908__WEBPACK_MODULE_REFERENCE__3_5b22636f6e74696e756553746174696350726572656e646572225d_call_directImport_asiSafe1__._undefined3598336013__WEBPACK_MODULE_REFERENCE__88_5b22637265617465496e6c696e6564446174615265616461626c6553747265616d225d_call_directImport_asiSafe1__._undefined3638036410__WEBPACK_MODULE_REFERENCE__88_5b22637265617465496e6c696e6564446174615265616461626c6553747265616d225d_call_directImport_asiSafe1__._undefined3664036664__WEBPACK_MODULE_REFERENCE__3_5b22636f6e74696e756544796e616d696348544d4c526573756d65225d_call_directImport_asiSafe1__._undefined3703137055__WEBPACK_MODULE_REFERENCE__3_5b22636f6e74696e756544796e616d696344617461526573756d65225d_call_directImport_asiSafe1__._undefined3752637543__WEBPACK_MODULE_REFERENCE__3_5b22636f6e74696e756546697a7a53747265616d225d_call_directImport_asiSafe1__._undefined3759837628__WEBPACK_MODULE_REFERENCE__88_5b22637265617465496e6c696e6564446174615265616461626c6553747265616d225d_call_directImport_asiSafe1__._undefined3798938011__WEBPACK_MODULE_REFERENCE__83_5b22697353746174696347656e4261696c6f75744572726f72225d_call_directImport_asiSafe1__._undefined3852138540__WEBPACK_MODULE_REFERENCE__43_5b22697344796e616d69635365727665724572726f72225d_call_directImport_asiSafe1__._undefined3875138769__WEBPACK_MODULE_REFERENCE__44_5b2269734261696c6f7574546f4353524572726f72225d_call_directImport_asiSafe1__._undefined3884538871__WEBPACK_MODULE_REFERENCE__41_5b22676574537461636b576974686f75744572726f724d657373616765225d_call_directImport_asiSafe1__._undefined3897638980__WEBPACK_MODULE_REFERENCE__20_5b226572726f72225d_call_directImport_asiSafe1__._undefined3921739220__WEBPACK_MODULE_REFERENCE__20_5b227761726e225d_call_directImport_asiSafe1__._undefined3942539439__WEBPACK_MODULE_REFERENCE__31_5b2269734e6f74466f756e644572726f72225d_call_directImport_asiSafe1__._undefined3955939573__WEBPACK_MODULE_REFERENCE__36_5b22697352656469726563744572726f72225d_call_directImport_asiSafe1__._undefined3965739686__WEBPACK_MODULE_REFERENCE__36_5b226765745265646972656374537461747573436f646546726f6d4572726f72225d_call_directImport_asiSafe1__._undefined3992939948__WEBPACK_MODULE_REFERENCE__58_5b22617070656e644d757461626c65436f6f6b696573225d_call_directImport_asiSafe1__._undefined4014140153__WEBPACK_MODULE_REFERENCE__71_5b2261646450617468507265666978225d_call_directImport_asiSafe1__._undefined4015540177__WEBPACK_MODULE_REFERENCE__36_5b2267657455524c46726f6d52656469726563744572726f72225d_call_directImport_asiSafe1__._undefined4061240629__WEBPACK_MODULE_REFERENCE__70_5b22676574526571756972656453637269707473225d_call_directImport_asiSafe1__._undefined4071340731__WEBPACK_MODULE_REFERENCE__78_5b2267657441737365745175657279537472696e67225d_call_directImport_asiSafe1__._undefined4084240845__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined4114441168__WEBPACK_MODULE_REFERENCE__3_5b2272656e646572546f496e697469616c46697a7a53747265616d225d_call_directImport_asiSafe1__._undefined4120841214__webpack_require__undefined41216412389183undefined4128541288__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined4212442141__WEBPACK_MODULE_REFERENCE__3_5b22636f6e74696e756546697a7a53747265616d225d_call_directImport_asiSafe1__._undefined4220042230__WEBPACK_MODULE_REFERENCE__88_5b22637265617465496e6c696e6564446174615265616461626c6553747265616d225d_call_directImport_asiSafe1__._undefined4256342587__WEBPACK_MODULE_REFERENCE__74_5b226d616b65476574536572766572496e73657274656448544d4c225d_call_directImport_asiSafe1__._undefined4301843084falseundefined4308743265{}undefined4345443465__WEBPACK_MODULE_REFERENCE__65_5b2268616e646c65416374696f6e225d_call_directImport_asiSafe1__._undefined4404544056__WEBPACK_MODULE_REFERENCE__2_5b2264656661756c74225d_directImport_asiSafe1__._undefined4489644910__WEBPACK_MODULE_REFERENCE__38_5b22616464496d706c6963697454616773225d_call_directImport_asiSafe1__._undefined4512445135__WEBPACK_MODULE_REFERENCE__2_5b2264656661756c74225d_directImport_asiSafe1__._undefined4576345777__WEBPACK_MODULE_REFERENCE__34_5b227573656444796e616d696341504973225d_call_directImport_asiSafe1__._undefined4598545988__WEBPACK_MODULE_REFERENCE__20_5b227761726e225d_call_directImport_asiSafe1__._undefined4606546088__WEBPACK_MODULE_REFERENCE__34_5b22666f726d617444796e616d69634150494163636573736573225d_call_directImport_asiSafe1__._undefined4614246145__WEBPACK_MODULE_REFERENCE__20_5b227761726e225d_call_directImport_asiSafe1__._undefined4733347344__WEBPACK_MODULE_REFERENCE__2_5b2264656661756c74225d_directImport_asiSafe1__._undefined4737547381undefined4752747537__WEBPACK_MODULE_REFERENCE__55_5b2276616c696461746555524c225d_call_directImport_asiSafe1__._undefined4756047585__WEBPACK_MODULE_REFERENCE__33_5b22526571756573744173796e6353746f7261676557726170706572225d_call_asiSafe1__._undefined4770747741__WEBPACK_MODULE_REFERENCE__35_5b2253746174696347656e65726174696f6e4173796e6353746f7261676557726170706572225d_call_asiSafe1__._undefined8  8941006(0,match_segments/* canSegmentBeOverridden */.W)undefined18791978(0,get_segment_param/* getSegmentParam */.R)undefined27402838dynamicParamTypesundefined33303447getShortDynamicParamTypeundefined40924166(0,jsx_runtime.jsx)undefined50185135createMetadataComponentsundefined54455572walkTreeWithFlightRouterStateundefined58745950(0,jsx_runtime.jsxs)undefined59526031jsx_runtime.Fragmentundefined60986172(0,jsx_runtime.jsx)undefined62776351(0,jsx_runtime.jsx)undefined67116785(0,jsx_runtime.jsx)undefined74027502FlightRenderResultundefined89389081createFlightRouterStateFromLoaderTreeundefined91689285createMetadataComponentsundefined96719778createComponentTreeundefined1009410168(0,jsx_runtime.jsx)undefined1064410723app_router_headers/* NEXT_URL */.TPundefined1075210828(0,jsx_runtime.jsxs)undefined1083010909jsx_runtime.Fragmentundefined1098011054(0,jsx_runtime.jsx)undefined1153011606(0,jsx_runtime.jsxs)undefined1160811687jsx_runtime.Fragmentundefined1176211836(0,jsx_runtime.jsx)undefined1195312027(0,jsx_runtime.jsx)undefined1278412901createMetadataComponentsundefined1318913265(0,jsx_runtime.jsxs)undefined1326713346jsx_runtime.Fragmentundefined1339713471(0,jsx_runtime.jsx)undefined1355213626(0,jsx_runtime.jsx)undefined1373813881createFlightRouterStateFromLoaderTreeundefined1414414220(0,jsx_runtime.jsxs)undefined1432014394(0,jsx_runtime.jsx)undefined1443914513(0,jsx_runtime.jsx)undefined1459814672(0,jsx_runtime.jsx)undefined1522715326useFlightStreamundefined1539115472react.useundefined1651316632(0,client_component_renderer_logger/* wrapClientComponentLoader */.B)undefined1701517146(0,client_component_renderer_logger/* getClientComponentLoaderMetrics */.R)undefined1725317340(0,tracer/* getTracer */.Yz)undefined1735417441constants/* NextNodeServerSpan */.Xyundefined1811318224(0,action_utils/* createServerModuleMap */.w)undefined1830518434(0,encryption_utils/* setReferenceManifestsSingleton */.Mo)undefined1907519180createErrorHandlerundefined1920019287ErrorHandlerSourceundefined1951419619createErrorHandlerundefined1963919726ErrorHandlerSourceundefined1994120046createErrorHandlerundefined2006620153ErrorHandlerSourceundefined2146421572(0,internal_utils/* stripInternalQueries */.Q3)undefined2161921694app_router_headers/* RSC_HEADER */.Aundefined2178721896app_router_headers/* NEXT_ROUTER_PREFETCH_HEADER */.qwundefined2250322624(0,interception_routes/* isInterceptionRouteAppPath */.Ag)undefined2267422809parseAndValidateFlightRouterStateundefined2282322922app_router_headers/* NEXT_ROUTER_STATE_TREE */.phundefined2494125058getScriptNonceFromHeaderundefined2537925496createServerInsertedHTMLundefined2554125628(0,tracer/* getTracer */.Yz)undefined2576525852(0,tracer/* getTracer */.Yz)undefined2586125938constants/* AppRenderSpan */.k0undefined2633626443getAssetQueryStringundefined2674926854getRequiredScriptsundefined2693827045getAssetQueryStringundefined2742827502(0,jsx_runtime.jsx)undefined2791127985(0,jsx_runtime.jsx)undefined2814228216(0,jsx_runtime.jsx)undefined2828828362(0,jsx_runtime.jsx)undefined2948029599makeGetServerInsertedHTMLundefined2979629905createStaticRendererundefined3182631925(0,dynamic_rendering/* usedDynamicAPIs */.tK)undefined3210932234getDynamicHTMLPostponedStateundefined3239532520getDynamicDataPostponedStateundefined3308133197(0,node_web_streams_helper/* continueDynamicPrerender */._W)undefined3366733776flightRenderCompleteundefined3381433913(0,dynamic_rendering/* usedDynamicAPIs */.tK)undefined3423034355getDynamicHTMLPostponedStateundefined3452834653getDynamicDataPostponedStateundefined3524235358(0,node_web_streams_helper/* continueDynamicPrerender */._W)undefined3585835964static_generation_bailout/* StaticGenBailoutError */.Gundefined3646336572createStaticRendererundefined3672136846getDynamicHTMLPostponedStateundefined3695337074(0,dynamic_rendering/* createPostponedAbortSignal */.Su)undefined3762337697(0,jsx_runtime.jsx)undefined3795438028(0,jsx_runtime.jsx)undefined3812038194(0,jsx_runtime.jsx)undefined3889638988(0,node_web_streams_helper/* chainStreams */.QW)undefined3911439228(0,node_web_streams_helper/* continueStaticPrerender */.Jm)undefined3930339434createInlinedDataReadableStreamundefined3980139932createInlinedDataReadableStreamundefined4016240280(0,node_web_streams_helper/* continueDynamicHTMLResume */.Bb)undefined4064740765(0,node_web_streams_helper/* continueDynamicDataResume */.J$)undefined4123641340(0,node_web_streams_helper/* continueFizzStream */.eN)undefined4139541526createInlinedDataReadableStreamundefined4188742002(0,static_generation_bailout/* isStaticGenBailoutError */.q)undefined4251242621(0,hooks_server_context/* isDynamicServerError */.j)undefined4283242939(0,bailout_to_csr/* isBailoutToCSRError */.D)undefined4301543138getStackWithoutErrorMessageundefined4324343322(0,log/* error */.vU)undefined4355943636(0,log/* warn */.ZK)undefined4384143940(0,not_found/* isNotFoundError */.X)undefined4406044159(0,redirect/* isRedirectError */.eo)undefined4424344372(0,redirect/* getRedirectStatusCodeFromError */.j2)undefined4461544724(0,request_cookies/* appendMutableCookies */._5)undefined4491745012(0,add_path_prefix/* addPathPrefix */.V)undefined4501445129(0,redirect/* getURLFromRedirectError */.M6)undefined4556445669getRequiredScriptsundefined4575345860getAssetQueryStringundefined4597146045(0,jsx_runtime.jsx)undefined4634446462(0,node_web_streams_helper/* renderToInitialFizzStream */.MY)undefined4657246646(0,jsx_runtime.jsx)undefined4748247586(0,node_web_streams_helper/* continueFizzStream */.eN)undefined4764547776createInlinedDataReadableStreamundefined4810948228makeGetServerInsertedHTMLundefined4885648949handleActionundefined4952949606render_result/* default */.Zundefined5044650545addImplicitTagsundefined5075950836render_result/* default */.Zundefined5146451563(0,dynamic_rendering/* usedDynamicAPIs */.tK)undefined5177151848(0,log/* warn */.ZK)undefined5192552042(0,dynamic_rendering/* formatDynamicAPIAccesses */.gS)undefined5209652173(0,log/* warn */.ZK)undefined5336153438render_result/* default */.Zundefined5361453705validateURLundefined5372853836request_async_storage_wrapper/* RequestAsyncStorageWrapper */.Bundefined5395854084StaticGenerationAsyncStorageWrapperundefinedûóÿÿØóÿÿ   ,

/***/ 8255:
   Š  «webpack/lib/util/registerExternalSerializerœwebpack-sources/ConcatSource€«webpack/lib/util/registerExternalSerializer™webpack-sources/RawSource_   /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
«webpack/lib/util/registerExternalSerializerœwebpack-sources/CachedSource   è,  «webpack/lib/util/registerExternalSerializerœwebpack-sources/ConcatSource€«webpack/lib/util/registerExternalSerializer™webpack-sources/RawSourceÊ  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FI: () => (/* binding */ createPrerenderState),
/* harmony export */   Su: () => (/* binding */ createPostponedAbortSignal),
/* harmony export */   TP: () => (/* binding */ trackDynamicDataAccessed),
/* harmony export */   gS: () => (/* binding */ formatDynamicAPIAccesses),
/* harmony export */   tK: () => (/* binding */ usedDynamicAPIs)
/* harmony export */ });
/* unused harmony exports markCurrentScopeAsDynamic, Postpone, trackDynamicFetch */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2428);
/* harmony import */ var _client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2726);
/* harmony import */ var _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7997);
/* harmony import */ var _lib_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8890);
«webpack/lib/util/registerExternalSerializerwebpack-sources/ReplaceSource«webpack/lib/util/registerExternalSerializeržwebpack-sources/OriginalSourceÝ$  /**
 * The functions provided by this module are used to communicate certain properties
 * about the currently running code so that Next.js can make decisions on how to handle
 * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.
 *
 * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.
 * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts
 * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of
 * Dynamic indications.
 *
 * The first is simply an intention to be dynamic. unstable_noStore is an example of this where
 * the currently executing code simply declares that the current scope is dynamic but if you use it
 * inside unstable_cache it can still be cached. This type of indication can be removed if we ever
 * make the default dynamic to begin with because the only way you would ever be static is inside
 * a cache scope which this indication does not affect.
 *
 * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic
 * because it means that it is inappropriate to cache this at all. using a dynamic data source inside
 * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should
 * read that data outside the cache and pass it in as an argument to the cached function.
 */ // Once postpone is in stable we should switch to importing the postpone export directly
import React from "react";
import { DynamicServerError } from "../../client/components/hooks-server-context";
import { StaticGenBailoutError } from "../../client/components/static-generation-bailout";
import { getPathname } from "../../lib/url";
const hasPostpone = typeof React.unstable_postpone === "function";
export function createPrerenderState(isDebugSkeleton) {
    return {
        isDebugSkeleton,
        dynamicAccesses: []
    };
}
/**
 * This function communicates that the current scope should be treated as dynamic.
 *
 * In most cases this function is a no-op but if called during
 * a PPR prerender it will postpone the current sub-tree.
 */ export function markCurrentScopeAsDynamic(store, expression) {
    const pathname = getPathname(store.urlPathname);
    if (store.isUnstableCacheCallback) {
        // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope
        // creates a cache boundary. This is subtly different from reading a dynamic data source which is
        // forbidden inside a cache scope.
        return;
    } else if (store.dynamicShouldError) {
        throw new StaticGenBailoutError(`Route ${pathname} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);
    } else if (// We are in a prerender (PPR enabled, during build)
    store.prerenderState) {
        // We track that we had a dynamic scope that postponed.
        // This will be used by the renderer to decide whether
        // the prerender requires a resume
        postponeWithTracking(store.prerenderState, expression, pathname);
    } else {
        store.revalidate = 0;
        if (store.isStaticGeneration) {
            // We aren't prerendering but we are generating a static page. We need to bail out of static generation
            const err = new DynamicServerError(`Route ${pathname} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);
            store.dynamicUsageDescription = expression;
            store.dynamicUsageStack = err.stack;
            throw err;
        }
    }
}
/**
 * This function communicates that some dynamic data was read. This typically would refer to accessing
 * a Request specific data store such as cookies or headers. This function is not how end-users will
 * describe reading from dynamic data sources which are valid to cache and up to the author to make
 * a determination of when to do so.
 *
 * If we are inside a cache scope we error
 * Also during a PPR Prerender we postpone
 */ export function trackDynamicDataAccessed(store, expression) {
    const pathname = getPathname(store.urlPathname);
    if (store.isUnstableCacheCallback) {
        throw new Error(`Route ${pathname} used "${expression}" inside a function cached with "unstable_cache(...)". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "${expression}" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`);
    } else if (store.dynamicShouldError) {
        throw new StaticGenBailoutError(`Route ${pathname} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);
    } else if (// We are in a prerender (PPR enabled, during build)
    store.prerenderState) {
        // We track that we had a dynamic scope that postponed.
        // This will be used by the renderer to decide whether
        // the prerender requires a resume
        postponeWithTracking(store.prerenderState, expression, pathname);
    } else {
        store.revalidate = 0;
        if (store.isStaticGeneration) {
            // We aren't prerendering but we are generating a static page. We need to bail out of static generation
            const err = new DynamicServerError(`Route ${pathname} couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);
            store.dynamicUsageDescription = expression;
            store.dynamicUsageStack = err.stack;
            throw err;
        }
    }
}
export function Postpone({ reason, prerenderState, pathname }) {
    postponeWithTracking(prerenderState, reason, pathname);
}
// @TODO refactor patch-fetch and this function to better model dynamic semantics. Currently this implementation
// is too explicit about postponing if we are in a prerender and patch-fetch contains a lot of logic for determining
// what makes the fetch "dynamic". It also doesn't handle Non PPR cases so it is isn't as consistent with the other
// dynamic-rendering methods.
export function trackDynamicFetch(store, expression) {
    if (store.prerenderState) {
        postponeWithTracking(store.prerenderState, expression, store.urlPathname);
    }
}
function postponeWithTracking(prerenderState, expression, pathname) {
    assertPostpone();
    const reason = `Route ${pathname} needs to bail out of prerendering at this point because it used ${expression}. ` + `React throws this special object to indicate where. It should not be caught by ` + `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;
    prerenderState.dynamicAccesses.push({
        // When we aren't debugging, we don't need to create another error for the
        // stack trace.
        stack: prerenderState.isDebugSkeleton ? new Error().stack : undefined,
        expression
    });
    React.unstable_postpone(reason);
}
export function usedDynamicAPIs(prerenderState) {
    return prerenderState.dynamicAccesses.length > 0;
}
export function formatDynamicAPIAccesses(prerenderState) {
    return prerenderState.dynamicAccesses.filter((access)=>typeof access.stack === "string" && access.stack.length > 0).map(({ expression, stack })=>{
        stack = stack.split("\n")// Remove the "Error: " prefix from the first line of the stack trace as
        // well as the first 4 lines of the stack trace which is the distance
        // from the user code and the `new Error().stack` call.
        .slice(4).filter((line)=>{
            // Exclude Next.js internals from the stack trace.
            if (line.includes("node_modules/next/")) {
                return false;
            }
            // Exclude anonymous functions from the stack trace.
            if (line.includes(" (<anonymous>)")) {
                return false;
            }
            // Exclude Node.js internals from the stack trace.
            if (line.includes(" (node:")) {
                return false;
            }
            return true;
        }).join("\n");
        return `Dynamic API Usage Debug - ${expression}:\n${stack}`;
    });
}
function assertPostpone() {
    if (!hasPostpone) {
        throw new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`);
    }
}
/**
 * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's
 * abort semantics slightly.
 */ export function createPostponedAbortSignal(reason) {
    assertPostpone();
    const controller = new AbortController();
    // We get our hands on a postpone instance by calling postpone and catching the throw
    try {
        React.unstable_postpone(reason);
    } catch (x) {
        controller.abort(x);
    }
    return controller.signal;
}

//# sourceMappingURL=dynamic-rendering.js.map  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/dynamic-rendering.js|ssr`_)  B  D  •  —  ð  ò    :  >  b  h  ¼  Â  Õ  Û  (  2  [  o  •  ¦  Ý  ã  Ô  Ú      *  0  ”  š  CT#  Z#  9$  =$  €€€€¢react__WEBPACK_IMPORTED_MODULE_0__€€€¾(0,_lib_url__WEBPACK_IMPORTED_MODULE_3__/* .getPathname */ .R)è_client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_2__/* .StaticGenBailoutError */ .Gà_client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_1__/* .DynamicServerError */ .$€€ü€€€ü€†buffer†source„size„maps„hash¨(  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FI: () => (/* binding */ createPrerenderState),
/* harmony export */   Su: () => (/* binding */ createPostponedAbortSignal),
/* harmony export */   TP: () => (/* binding */ trackDynamicDataAccessed),
/* harmony export */   gS: () => (/* binding */ formatDynamicAPIAccesses),
/* harmony export */   tK: () => (/* binding */ usedDynamicAPIs)
/* harmony export */ });
/* unused harmony exports markCurrentScopeAsDynamic, Postpone, trackDynamicFetch */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2428);
/* harmony import */ var _client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2726);
/* harmony import */ var _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7997);
/* harmony import */ var _lib_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8890);
/**
 * The functions provided by this module are used to communicate certain properties
 * about the currently running code so that Next.js can make decisions on how to handle
 * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.
 *
 * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.
 * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts
 * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of
 * Dynamic indications.
 *
 * The first is simply an intention to be dynamic. unstable_noStore is an example of this where
 * the currently executing code simply declares that the current scope is dynamic but if you use it
 * inside unstable_cache it can still be cached. This type of indication can be removed if we ever
 * make the default dynamic to begin with because the only way you would ever be static is inside
 * a cache scope which this indication does not affect.
 *
 * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic
 * because it means that it is inappropriate to cache this at all. using a dynamic data source inside
 * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should
 * read that data outside the cache and pass it in as an argument to the cached function.
 */ // Once postpone is in stable we should switch to importing the postpone export directly




const hasPostpone = typeof react__WEBPACK_IMPORTED_MODULE_0__.unstable_postpone === "function";
function createPrerenderState(isDebugSkeleton) {
    return {
        isDebugSkeleton,
        dynamicAccesses: []
    };
}
/**
 * This function communicates that the current scope should be treated as dynamic.
 *
 * In most cases this function is a no-op but if called during
 * a PPR prerender it will postpone the current sub-tree.
 */ function markCurrentScopeAsDynamic(store, expression) {
    const pathname = getPathname(store.urlPathname);
    if (store.isUnstableCacheCallback) {
        // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope
        // creates a cache boundary. This is subtly different from reading a dynamic data source which is
        // forbidden inside a cache scope.
        return;
    } else if (store.dynamicShouldError) {
        throw new StaticGenBailoutError(`Route ${pathname} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);
    } else if (// We are in a prerender (PPR enabled, during build)
    store.prerenderState) {
        // We track that we had a dynamic scope that postponed.
        // This will be used by the renderer to decide whether
        // the prerender requires a resume
        postponeWithTracking(store.prerenderState, expression, pathname);
    } else {
        store.revalidate = 0;
        if (store.isStaticGeneration) {
            // We aren't prerendering but we are generating a static page. We need to bail out of static generation
            const err = new DynamicServerError(`Route ${pathname} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);
            store.dynamicUsageDescription = expression;
            store.dynamicUsageStack = err.stack;
            throw err;
        }
    }
}
/**
 * This function communicates that some dynamic data was read. This typically would refer to accessing
 * a Request specific data store such as cookies or headers. This function is not how end-users will
 * describe reading from dynamic data sources which are valid to cache and up to the author to make
 * a determination of when to do so.
 *
 * If we are inside a cache scope we error
 * Also during a PPR Prerender we postpone
 */ function trackDynamicDataAccessed(store, expression) {
    const pathname = (0,_lib_url__WEBPACK_IMPORTED_MODULE_3__/* .getPathname */ .R)(store.urlPathname);
    if (store.isUnstableCacheCallback) {
        throw new Error(`Route ${pathname} used "${expression}" inside a function cached with "unstable_cache(...)". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "${expression}" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`);
    } else if (store.dynamicShouldError) {
        throw new _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_2__/* .StaticGenBailoutError */ .G(`Route ${pathname} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);
    } else if (// We are in a prerender (PPR enabled, during build)
    store.prerenderState) {
        // We track that we had a dynamic scope that postponed.
        // This will be used by the renderer to decide whether
        // the prerender requires a resume
        postponeWithTracking(store.prerenderState, expression, pathname);
    } else {
        store.revalidate = 0;
        if (store.isStaticGeneration) {
            // We aren't prerendering but we are generating a static page. We need to bail out of static generation
            const err = new _client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_1__/* .DynamicServerError */ .$(`Route ${pathname} couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);
            store.dynamicUsageDescription = expression;
            store.dynamicUsageStack = err.stack;
            throw err;
        }
    }
}
function Postpone({ reason, prerenderState, pathname }) {
    postponeWithTracking(prerenderState, reason, pathname);
}
// @TODO refactor patch-fetch and this function to better model dynamic semantics. Currently this implementation
// is too explicit about postponing if we are in a prerender and patch-fetch contains a lot of logic for determining
// what makes the fetch "dynamic". It also doesn't handle Non PPR cases so it is isn't as consistent with the other
// dynamic-rendering methods.
function trackDynamicFetch(store, expression) {
    if (store.prerenderState) {
        postponeWithTracking(store.prerenderState, expression, store.urlPathname);
    }
}
function postponeWithTracking(prerenderState, expression, pathname) {
    assertPostpone();
    const reason = `Route ${pathname} needs to bail out of prerendering at this point because it used ${expression}. ` + `React throws this special object to indicate where. It should not be caught by ` + `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;
    prerenderState.dynamicAccesses.push({
        // When we aren't debugging, we don't need to create another error for the
        // stack trace.
        stack: prerenderState.isDebugSkeleton ? new Error().stack : undefined,
        expression
    });
    react__WEBPACK_IMPORTED_MODULE_0__.unstable_postpone(reason);
}
function usedDynamicAPIs(prerenderState) {
    return prerenderState.dynamicAccesses.length > 0;
}
function formatDynamicAPIAccesses(prerenderState) {
    return prerenderState.dynamicAccesses.filter((access)=>typeof access.stack === "string" && access.stack.length > 0).map(({ expression, stack })=>{
        stack = stack.split("\n")// Remove the "Error: " prefix from the first line of the stack trace as
        // well as the first 4 lines of the stack trace which is the distance
        // from the user code and the `new Error().stack` call.
        .slice(4).filter((line)=>{
            // Exclude Next.js internals from the stack trace.
            if (line.includes("node_modules/next/")) {
                return false;
            }
            // Exclude anonymous functions from the stack trace.
            if (line.includes(" (<anonymous>)")) {
                return false;
            }
            // Exclude Node.js internals from the stack trace.
            if (line.includes(" (node:")) {
                return false;
            }
            return true;
        }).join("\n");
        return `Dynamic API Usage Debug - ${expression}:\n${stack}`;
    });
}
function assertPostpone() {
    if (!hasPostpone) {
        throw new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`);
    }
}
/**
 * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's
 * abort semantics slightly.
 */ function createPostponedAbortSignal(reason) {
    assertPostpone();
    const controller = new AbortController();
    // We get our hands on a postpone instance by calling postpone and catching the throw
    try {
        react__WEBPACK_IMPORTED_MODULE_0__.unstable_postpone(reason);
    } catch (x) {
        controller.abort(x);
    }
    return controller.signal;
}

//# sourceMappingURL=dynamic-rendering.js.map€”{"finalSource":true}ƒmap‹bufferedMap‡version„fileˆmappings‡sourcesŽsourcesContent…namesxŸ  ;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0B;AACwD;AACQ;AAC9C;AAC5C,2BAA2B,kCAAK;AACzB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,iDAAiD,UAAU,+EAA+E,WAAW;AACrJ,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,wDAAwD,UAAU,kDAAkD,WAAW;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAW;AACX,qBAAqB,8DAAW;AAChC;AACA,iCAAiC,UAAU,QAAQ,WAAW,mLAAmL,WAAW;AAC5P,MAAM;AACN,kBAAkB,wGAAqB,UAAU,UAAU,+EAA+E,WAAW;AACrJ,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,4BAA4B,gGAAkB,UAAU,UAAU,oDAAoD,WAAW;AACjI;AACA;AACA;AACA;AACA;AACA;AACO,oBAAoB,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU,kEAAkE,WAAW;AACnH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,kCAAK;AACT;AACO;AACP;AACA;AACO;AACP,+HAA+H,mBAAmB;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4CAA4C,WAAW,KAAK,MAAM;AAClE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAW;AACX;AACA;AACA;AACA;AACA,QAAQ,kCAAK;AACb,MAAM;AACN;AACA;AACA;AACA;;AAEA  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/dynamic-rendering.js|ssrÝ$  /**
 * The functions provided by this module are used to communicate certain properties
 * about the currently running code so that Next.js can make decisions on how to handle
 * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.
 *
 * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.
 * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts
 * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of
 * Dynamic indications.
 *
 * The first is simply an intention to be dynamic. unstable_noStore is an example of this where
 * the currently executing code simply declares that the current scope is dynamic but if you use it
 * inside unstable_cache it can still be cached. This type of indication can be removed if we ever
 * make the default dynamic to begin with because the only way you would ever be static is inside
 * a cache scope which this indication does not affect.
 *
 * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic
 * because it means that it is inappropriate to cache this at all. using a dynamic data source inside
 * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should
 * read that data outside the cache and pass it in as an argument to the cached function.
 */ // Once postpone is in stable we should switch to importing the postpone export directly
import React from "react";
import { DynamicServerError } from "../../client/components/hooks-server-context";
import { StaticGenBailoutError } from "../../client/components/static-generation-bailout";
import { getPathname } from "../../lib/url";
const hasPostpone = typeof React.unstable_postpone === "function";
export function createPrerenderState(isDebugSkeleton) {
    return {
        isDebugSkeleton,
        dynamicAccesses: []
    };
}
/**
 * This function communicates that the current scope should be treated as dynamic.
 *
 * In most cases this function is a no-op but if called during
 * a PPR prerender it will postpone the current sub-tree.
 */ export function markCurrentScopeAsDynamic(store, expression) {
    const pathname = getPathname(store.urlPathname);
    if (store.isUnstableCacheCallback) {
        // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope
        // creates a cache boundary. This is subtly different from reading a dynamic data source which is
        // forbidden inside a cache scope.
        return;
    } else if (store.dynamicShouldError) {
        throw new StaticGenBailoutError(`Route ${pathname} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);
    } else if (// We are in a prerender (PPR enabled, during build)
    store.prerenderState) {
        // We track that we had a dynamic scope that postponed.
        // This will be used by the renderer to decide whether
        // the prerender requires a resume
        postponeWithTracking(store.prerenderState, expression, pathname);
    } else {
        store.revalidate = 0;
        if (store.isStaticGeneration) {
            // We aren't prerendering but we are generating a static page. We need to bail out of static generation
            const err = new DynamicServerError(`Route ${pathname} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);
            store.dynamicUsageDescription = expression;
            store.dynamicUsageStack = err.stack;
            throw err;
        }
    }
}
/**
 * This function communicates that some dynamic data was read. This typically would refer to accessing
 * a Request specific data store such as cookies or headers. This function is not how end-users will
 * describe reading from dynamic data sources which are valid to cache and up to the author to make
 * a determination of when to do so.
 *
 * If we are inside a cache scope we error
 * Also during a PPR Prerender we postpone
 */ export function trackDynamicDataAccessed(store, expression) {
    const pathname = getPathname(store.urlPathname);
    if (store.isUnstableCacheCallback) {
        throw new Error(`Route ${pathname} used "${expression}" inside a function cached with "unstable_cache(...)". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "${expression}" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`);
    } else if (store.dynamicShouldError) {
        throw new StaticGenBailoutError(`Route ${pathname} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);
    } else if (// We are in a prerender (PPR enabled, during build)
    store.prerenderState) {
        // We track that we had a dynamic scope that postponed.
        // This will be used by the renderer to decide whether
        // the prerender requires a resume
        postponeWithTracking(store.prerenderState, expression, pathname);
    } else {
        store.revalidate = 0;
        if (store.isStaticGeneration) {
            // We aren't prerendering but we are generating a static page. We need to bail out of static generation
            const err = new DynamicServerError(`Route ${pathname} couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);
            store.dynamicUsageDescription = expression;
            store.dynamicUsageStack = err.stack;
            throw err;
        }
    }
}
export function Postpone({ reason, prerenderState, pathname }) {
    postponeWithTracking(prerenderState, reason, pathname);
}
// @TODO refactor patch-fetch and this function to better model dynamic semantics. Currently this implementation
// is too explicit about postponing if we are in a prerender and patch-fetch contains a lot of logic for determining
// what makes the fetch "dynamic". It also doesn't handle Non PPR cases so it is isn't as consistent with the other
// dynamic-rendering methods.
export function trackDynamicFetch(store, expression) {
    if (store.prerenderState) {
        postponeWithTracking(store.prerenderState, expression, store.urlPathname);
    }
}
function postponeWithTracking(prerenderState, expression, pathname) {
    assertPostpone();
    const reason = `Route ${pathname} needs to bail out of prerendering at this point because it used ${expression}. ` + `React throws this special object to indicate where. It should not be caught by ` + `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;
    prerenderState.dynamicAccesses.push({
        // When we aren't debugging, we don't need to create another error for the
        // stack trace.
        stack: prerenderState.isDebugSkeleton ? new Error().stack : undefined,
        expression
    });
    React.unstable_postpone(reason);
}
export function usedDynamicAPIs(prerenderState) {
    return prerenderState.dynamicAccesses.length > 0;
}
export function formatDynamicAPIAccesses(prerenderState) {
    return prerenderState.dynamicAccesses.filter((access)=>typeof access.stack === "string" && access.stack.length > 0).map(({ expression, stack })=>{
        stack = stack.split("\n")// Remove the "Error: " prefix from the first line of the stack trace as
        // well as the first 4 lines of the stack trace which is the distance
        // from the user code and the `new Error().stack` call.
        .slice(4).filter((line)=>{
            // Exclude Next.js internals from the stack trace.
            if (line.includes("node_modules/next/")) {
                return false;
            }
            // Exclude anonymous functions from the stack trace.
            if (line.includes(" (<anonymous>)")) {
                return false;
            }
            // Exclude Node.js internals from the stack trace.
            if (line.includes(" (node:")) {
                return false;
            }
            return true;
        }).join("\n");
        return `Dynamic API Usage Debug - ${expression}:\n${stack}`;
    });
}
function assertPostpone() {
    if (!hasPostpone) {
        throw new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`);
    }
}
/**
 * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's
 * abort semantics slightly.
 */ export function createPostponedAbortSignal(reason) {
    assertPostpone();
    const controller = new AbortController();
    // We get our hands on a postpone instance by calling postpone and catching the throw
    try {
        React.unstable_postpone(reason);
    } catch (x) {
        controller.abort(x);
    }
    return controller.signal;
}

//# sourceMappingURL=dynamic-rendering.js.map    ConcatSourceRawSourceÊ  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FI: () => (/* binding */ createPrerenderState),
/* harmony export */   Su: () => (/* binding */ createPostponedAbortSignal),
/* harmony export */   TP: () => (/* binding */ trackDynamicDataAccessed),
/* harmony export */   gS: () => (/* binding */ formatDynamicAPIAccesses),
/* harmony export */   tK: () => (/* binding */ usedDynamicAPIs)
/* harmony export */ });
/* unused harmony exports markCurrentScopeAsDynamic, Postpone, trackDynamicFetch */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2428);
/* harmony import */ var _client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2726);
/* harmony import */ var _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7997);
/* harmony import */ var _lib_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8890);
   ReplaceSourceOriginalSource÷º  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/dynamic-rendering.js|ssr15771602undefined16041685undefined16871776undefined17781821undefined18501854react__WEBPACK_IMPORTED_MODULE_0__undefined18901896undefined22362242undefined43094315undefined43924402(0,_lib_url__WEBPACK_IMPORTED_MODULE_3__/* .getPathname */ .R)undefined49554975_client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_2__/* .StaticGenBailoutError */ .Gundefined57815798_client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_1__/* .DynamicServerError */ .$undefined61096115undefined66126618undefined74317435react__WEBPACK_IMPORTED_MODULE_0__undefined74667472undefined75727578undefined90449050undefined92739277react__WEBPACK_IMPORTED_MODULE_0__undefined
   

/***/ })¹óÿÿ)  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FI: () => (/* binding */ createPrerenderState),
/* harmony export */   Su: () => (/* binding */ createPostponedAbortSignal),
/* harmony export */   TP: () => (/* binding */ trackDynamicDataAccessed),
/* harmony export */   gS: () => (/* binding */ formatDynamicAPIAccesses),
/* harmony export */   tK: () => (/* binding */ usedDynamicAPIs)
/* harmony export */ });
/* unused harmony exports markCurrentScopeAsDynamic, Postpone, trackDynamicFetch */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2428);
/* harmony import */ var _client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2726);
/* harmony import */ var _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7997);
/* harmony import */ var _lib_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8890);
/**
 * The functions provided by this module are used to communicate certain properties
 * about the currently running code so that Next.js can make decisions on how to handle
 * the current execution in different rendering modes such as pre-rendering, resuming, and SSR.
 *
 * Today Next.js treats all code as potentially static. Certain APIs may only make sense when dynamically rendering.
 * Traditionally this meant deopting the entire render to dynamic however with PPR we can now deopt parts
 * of a React tree as dynamic while still keeping other parts static. There are really two different kinds of
 * Dynamic indications.
 *
 * The first is simply an intention to be dynamic. unstable_noStore is an example of this where
 * the currently executing code simply declares that the current scope is dynamic but if you use it
 * inside unstable_cache it can still be cached. This type of indication can be removed if we ever
 * make the default dynamic to begin with because the only way you would ever be static is inside
 * a cache scope which this indication does not affect.
 *
 * The second is an indication that a dynamic data source was read. This is a stronger form of dynamic
 * because it means that it is inappropriate to cache this at all. using a dynamic data source inside
 * unstable_cache should error. If you want to use some dynamic data inside unstable_cache you should
 * read that data outside the cache and pass it in as an argument to the cached function.
 */ // Once postpone is in stable we should switch to importing the postpone export directly




const hasPostpone = typeof react__WEBPACK_IMPORTED_MODULE_0__.unstable_postpone === "function";
function createPrerenderState(isDebugSkeleton) {
    return {
        isDebugSkeleton,
        dynamicAccesses: []
    };
}
/**
 * This function communicates that the current scope should be treated as dynamic.
 *
 * In most cases this function is a no-op but if called during
 * a PPR prerender it will postpone the current sub-tree.
 */ function markCurrentScopeAsDynamic(store, expression) {
    const pathname = getPathname(store.urlPathname);
    if (store.isUnstableCacheCallback) {
        // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope
        // creates a cache boundary. This is subtly different from reading a dynamic data source which is
        // forbidden inside a cache scope.
        return;
    } else if (store.dynamicShouldError) {
        throw new StaticGenBailoutError(`Route ${pathname} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);
    } else if (// We are in a prerender (PPR enabled, during build)
    store.prerenderState) {
        // We track that we had a dynamic scope that postponed.
        // This will be used by the renderer to decide whether
        // the prerender requires a resume
        postponeWithTracking(store.prerenderState, expression, pathname);
    } else {
        store.revalidate = 0;
        if (store.isStaticGeneration) {
            // We aren't prerendering but we are generating a static page. We need to bail out of static generation
            const err = new DynamicServerError(`Route ${pathname} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);
            store.dynamicUsageDescription = expression;
            store.dynamicUsageStack = err.stack;
            throw err;
        }
    }
}
/**
 * This function communicates that some dynamic data was read. This typically would refer to accessing
 * a Request specific data store such as cookies or headers. This function is not how end-users will
 * describe reading from dynamic data sources which are valid to cache and up to the author to make
 * a determination of when to do so.
 *
 * If we are inside a cache scope we error
 * Also during a PPR Prerender we postpone
 */ function trackDynamicDataAccessed(store, expression) {
    const pathname = (0,_lib_url__WEBPACK_IMPORTED_MODULE_3__/* .getPathname */ .R)(store.urlPathname);
    if (store.isUnstableCacheCallback) {
        throw new Error(`Route ${pathname} used "${expression}" inside a function cached with "unstable_cache(...)". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "${expression}" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`);
    } else if (store.dynamicShouldError) {
        throw new _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_2__/* .StaticGenBailoutError */ .G(`Route ${pathname} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);
    } else if (// We are in a prerender (PPR enabled, during build)
    store.prerenderState) {
        // We track that we had a dynamic scope that postponed.
        // This will be used by the renderer to decide whether
        // the prerender requires a resume
        postponeWithTracking(store.prerenderState, expression, pathname);
    } else {
        store.revalidate = 0;
        if (store.isStaticGeneration) {
            // We aren't prerendering but we are generating a static page. We need to bail out of static generation
            const err = new _client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_1__/* .DynamicServerError */ .$(`Route ${pathname} couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);
            store.dynamicUsageDescription = expression;
            store.dynamicUsageStack = err.stack;
            throw err;
        }
    }
}
function Postpone({ reason, prerenderState, pathname }) {
    postponeWithTracking(prerenderState, reason, pathname);
}
// @TODO refactor patch-fetch and this function to better model dynamic semantics. Currently this implementation
// is too explicit about postponing if we are in a prerender and patch-fetch contains a lot of logic for determining
// what makes the fetch "dynamic". It also doesn't handle Non PPR cases so it is isn't as consistent with the other
// dynamic-rendering methods.
function trackDynamicFetch(store, expression) {
    if (store.prerenderState) {
        postponeWithTracking(store.prerenderState, expression, store.urlPathname);
    }
}
function postponeWithTracking(prerenderState, expression, pathname) {
    assertPostpone();
    const reason = `Route ${pathname} needs to bail out of prerendering at this point because it used ${expression}. ` + `React throws this special object to indicate where. It should not be caught by ` + `your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;
    prerenderState.dynamicAccesses.push({
        // When we aren't debugging, we don't need to create another error for the
        // stack trace.
        stack: prerenderState.isDebugSkeleton ? new Error().stack : undefined,
        expression
    });
    react__WEBPACK_IMPORTED_MODULE_0__.unstable_postpone(reason);
}
function usedDynamicAPIs(prerenderState) {
    return prerenderState.dynamicAccesses.length > 0;
}
function formatDynamicAPIAccesses(prerenderState) {
    return prerenderState.dynamicAccesses.filter((access)=>typeof access.stack === "string" && access.stack.length > 0).map(({ expression, stack })=>{
        stack = stack.split("\n")// Remove the "Error: " prefix from the first line of the stack trace as
        // well as the first 4 lines of the stack trace which is the distance
        // from the user code and the `new Error().stack` call.
        .slice(4).filter((line)=>{
            // Exclude Next.js internals from the stack trace.
            if (line.includes("node_modules/next/")) {
                return false;
            }
            // Exclude anonymous functions from the stack trace.
            if (line.includes(" (<anonymous>)")) {
                return false;
            }
            // Exclude Node.js internals from the stack trace.
            if (line.includes(" (node:")) {
                return false;
            }
            return true;
        }).join("\n");
        return `Dynamic API Usage Debug - ${expression}:\n${stack}`;
    });
}
function assertPostpone() {
    if (!hasPostpone) {
        throw new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`);
    }
}
/**
 * This is a bit of a hack to allow us to abort a render using a Postpone instance instead of an Error which changes React's
 * abort semantics slightly.
 */ function createPostponedAbortSignal(reason) {
    assertPostpone();
    const controller = new AbortController();
    // We get our hands on a postpone instance by calling postpone and catching the throw
    try {
        react__WEBPACK_IMPORTED_MODULE_0__.unstable_postpone(reason);
    } catch (x) {
        controller.abort(x);
    }
    return controller.signal;
}

//# sourceMappingURL=dynamic-rendering.js.map

/***/ })ºóÿÿ½óÿÿÄóÿÿx¥  ;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0B;AACwD;AACQ;AAC9C;AAC5C,2BAA2B,kCAAK;AACzB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,iDAAiD,UAAU,+EAA+E,WAAW;AACrJ,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,wDAAwD,UAAU,kDAAkD,WAAW;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAW;AACX,qBAAqB,8DAAW;AAChC;AACA,iCAAiC,UAAU,QAAQ,WAAW,mLAAmL,WAAW;AAC5P,MAAM;AACN,kBAAkB,wGAAqB,UAAU,UAAU,+EAA+E,WAAW;AACrJ,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,4BAA4B,gGAAkB,UAAU,UAAU,oDAAoD,WAAW;AACjI;AACA;AACA;AACA;AACA;AACA;AACO,oBAAoB,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU,kEAAkE,WAAW;AACnH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,kCAAK;AACT;AACO;AACP;AACA;AACO;AACP,+HAA+H,mBAAmB;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4CAA4C,WAAW,KAAK,MAAM;AAClE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAW;AACX;AACA;AACA;AACA;AACA,QAAQ,kCAAK;AACb,MAAM;AACN;AACA;AACA;AACA;;AAEA,6C  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/dynamic-rendering.js|ssrÉôÿÿ 	Æóÿÿ'öÿÿÆóÿÿÊ  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FI: () => (/* binding */ createPrerenderState),
/* harmony export */   Su: () => (/* binding */ createPostponedAbortSignal),
/* harmony export */   TP: () => (/* binding */ trackDynamicDataAccessed),
/* harmony export */   gS: () => (/* binding */ formatDynamicAPIAccesses),
/* harmony export */   tK: () => (/* binding */ usedDynamicAPIs)
/* harmony export */ });
/* unused harmony exports markCurrentScopeAsDynamic, Postpone, trackDynamicFetch */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2428);
/* harmony import */ var _client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2726);
/* harmony import */ var _client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7997);
/* harmony import */ var _lib_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8890);
êóÿÿÃôÿÿº  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/dynamic-rendering.js|ssr15771602undefined16041685undefined16871776undefined17781821undefined18501854react__WEBPACK_IMPORTED_MODULE_0__undefined18901896undefined22362242undefined43094315undefined43924402(0,_lib_url__WEBPACK_IMPORTED_MODULE_3__/* .getPathname */ .R)undefined49554975_client_components_static_generation_bailout__WEBPACK_IMPORTED_MODULE_2__/* .StaticGenBailoutError */ .Gundefined57815798_client_components_hooks_server_context__WEBPACK_IMPORTED_MODULE_1__/* .DynamicServerError */ .$undefined61096115undefined66126618undefined74317435react__WEBPACK_IMPORTED_MODULE_0__undefined74667472undefined75727578undefined90449050undefined92739277react__WEBPACK_IMPORTED_MODULE_0__undefinedëóÿÿÈóÿÿ   ,

/***/ 1318:
   ÅF  «webpack/lib/util/registerExternalSerializerœwebpack-sources/ConcatSource€«webpack/lib/util/registerExternalSerializer™webpack-sources/RawSource_   /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
«webpack/lib/util/registerExternalSerializerœwebpack-sources/CachedSource   Þ  «webpack/lib/util/registerExternalSerializerœwebpack-sources/ConcatSource€«webpack/lib/util/registerExternalSerializer™webpack-sources/RawSourcep  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mo: () => (/* binding */ setReferenceManifestsSingleton)
/* harmony export */ });
/* unused harmony exports arrayBufferToString, stringToUint8Array, encrypt, decrypt, generateEncryptionKeyBase64, getServerModuleMap, getClientReferenceManifestSingleton, getActionEncryptionKey */
«webpack/lib/util/registerExternalSerializerwebpack-sources/ReplaceSource«webpack/lib/util/registerExternalSerializeržwebpack-sources/OriginalSource´  // Keep the key in memory as it should never change during the lifetime of the server in
// both development and production.
let __next_encryption_key_generation_promise = null;
let __next_loaded_action_key;
let __next_internal_development_raw_action_key;
export function arrayBufferToString(buffer) {
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    // @anonrig: V8 has a limit of 65535 arguments in a function.
    // For len < 65535, this is faster.
    // https://github.com/vercel/next.js/pull/56377#pullrequestreview-1656181623
    if (len < 65535) {
        return String.fromCharCode.apply(null, bytes);
    }
    let binary = "";
    for(let i = 0; i < len; i++){
        binary += String.fromCharCode(bytes[i]);
    }
    return binary;
}
export function stringToUint8Array(binary) {
    const len = binary.length;
    const arr = new Uint8Array(len);
    for(let i = 0; i < len; i++){
        arr[i] = binary.charCodeAt(i);
    }
    return arr;
}
export function encrypt(key, iv, data) {
    return crypto.subtle.encrypt({
        name: "AES-GCM",
        iv
    }, key, data);
}
export function decrypt(key, iv, data) {
    return crypto.subtle.decrypt({
        name: "AES-GCM",
        iv
    }, key, data);
}
export async function generateEncryptionKeyBase64(dev) {
    // For development, we just keep one key in memory for all actions.
    // This makes things faster.
    if (dev) {
        if (typeof __next_internal_development_raw_action_key !== "undefined") {
            return __next_internal_development_raw_action_key;
        }
    }
    // This avoids it being generated multiple times in parallel.
    if (!__next_encryption_key_generation_promise) {
        __next_encryption_key_generation_promise = new Promise(async (resolve, reject)=>{
            try {
                const key = await crypto.subtle.generateKey({
                    name: "AES-GCM",
                    length: 256
                }, true, [
                    "encrypt",
                    "decrypt"
                ]);
                const exported = await crypto.subtle.exportKey("raw", key);
                const b64 = btoa(arrayBufferToString(exported));
                resolve([
                    key,
                    b64
                ]);
            } catch (error) {
                reject(error);
            }
        });
    }
    const [key, b64] = await __next_encryption_key_generation_promise;
    __next_loaded_action_key = key;
    if (dev) {
        __next_internal_development_raw_action_key = b64;
    }
    return b64;
}
// This is a global singleton that is used to encode/decode the action bound args from
// the closure. This can't be using a AsyncLocalStorage as it might happen on the module
// level. Since the client reference manifest won't be mutated, let's use a global singleton
// to keep it.
const SERVER_ACTION_MANIFESTS_SINGLETON = Symbol.for("next.server.action-manifests");
export function setReferenceManifestsSingleton({ clientReferenceManifest, serverActionsManifest, serverModuleMap }) {
    // @ts-ignore
    globalThis[SERVER_ACTION_MANIFESTS_SINGLETON] = {
        clientReferenceManifest,
        serverActionsManifest,
        serverModuleMap
    };
}
export function getServerModuleMap() {
    const serverActionsManifestSingleton = globalThis[SERVER_ACTION_MANIFESTS_SINGLETON];
    if (!serverActionsManifestSingleton) {
        throw new Error("Missing manifest for Server Actions. This is a bug in Next.js");
    }
    return serverActionsManifestSingleton.serverModuleMap;
}
export function getClientReferenceManifestSingleton() {
    const serverActionsManifestSingleton = globalThis[SERVER_ACTION_MANIFESTS_SINGLETON];
    if (!serverActionsManifestSingleton) {
        throw new Error("Missing manifest for Server Actions. This is a bug in Next.js");
    }
    return serverActionsManifestSingleton.clientReferenceManifest;
}
export async function getActionEncryptionKey() {
    if (__next_loaded_action_key) {
        return __next_loaded_action_key;
    }
    const serverActionsManifestSingleton = globalThis[SERVER_ACTION_MANIFESTS_SINGLETON];
    if (!serverActionsManifestSingleton) {
        throw new Error("Missing manifest for Server Actions. This is a bug in Next.js");
    }
    const rawKey = process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY || serverActionsManifestSingleton.serverActionsManifest.encryptionKey;
    if (rawKey === undefined) {
        throw new Error("Missing encryption key for Server Actions");
    }
    __next_loaded_action_key = await crypto.subtle.importKey("raw", stringToUint8Array(atob(rawKey)), "AES-GCM", true, [
        "encrypt",
        "decrypt"
    ]);
    return __next_loaded_action_key;
}

//# sourceMappingURL=encryption-utils.js.map  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/encryption-utils.js|ssr	Q         Þ  ä  c  i  è  î  ’  ˜  ±  ·  ú     \  b  €€€€€€€€€€†buffer†source„size„maps„hashå  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mo: () => (/* binding */ setReferenceManifestsSingleton)
/* harmony export */ });
/* unused harmony exports arrayBufferToString, stringToUint8Array, encrypt, decrypt, generateEncryptionKeyBase64, getServerModuleMap, getClientReferenceManifestSingleton, getActionEncryptionKey */
// Keep the key in memory as it should never change during the lifetime of the server in
// both development and production.
let __next_encryption_key_generation_promise = null;
let __next_loaded_action_key;
let __next_internal_development_raw_action_key;
function arrayBufferToString(buffer) {
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    // @anonrig: V8 has a limit of 65535 arguments in a function.
    // For len < 65535, this is faster.
    // https://github.com/vercel/next.js/pull/56377#pullrequestreview-1656181623
    if (len < 65535) {
        return String.fromCharCode.apply(null, bytes);
    }
    let binary = "";
    for(let i = 0; i < len; i++){
        binary += String.fromCharCode(bytes[i]);
    }
    return binary;
}
function stringToUint8Array(binary) {
    const len = binary.length;
    const arr = new Uint8Array(len);
    for(let i = 0; i < len; i++){
        arr[i] = binary.charCodeAt(i);
    }
    return arr;
}
function encrypt(key, iv, data) {
    return crypto.subtle.encrypt({
        name: "AES-GCM",
        iv
    }, key, data);
}
function decrypt(key, iv, data) {
    return crypto.subtle.decrypt({
        name: "AES-GCM",
        iv
    }, key, data);
}
async function generateEncryptionKeyBase64(dev) {
    // For development, we just keep one key in memory for all actions.
    // This makes things faster.
    if (dev) {
        if (typeof __next_internal_development_raw_action_key !== "undefined") {
            return __next_internal_development_raw_action_key;
        }
    }
    // This avoids it being generated multiple times in parallel.
    if (!__next_encryption_key_generation_promise) {
        __next_encryption_key_generation_promise = new Promise(async (resolve, reject)=>{
            try {
                const key = await crypto.subtle.generateKey({
                    name: "AES-GCM",
                    length: 256
                }, true, [
                    "encrypt",
                    "decrypt"
                ]);
                const exported = await crypto.subtle.exportKey("raw", key);
                const b64 = btoa(arrayBufferToString(exported));
                resolve([
                    key,
                    b64
                ]);
            } catch (error) {
                reject(error);
            }
        });
    }
    const [key, b64] = await __next_encryption_key_generation_promise;
    __next_loaded_action_key = key;
    if (dev) {
        __next_internal_development_raw_action_key = b64;
    }
    return b64;
}
// This is a global singleton that is used to encode/decode the action bound args from
// the closure. This can't be using a AsyncLocalStorage as it might happen on the module
// level. Since the client reference manifest won't be mutated, let's use a global singleton
// to keep it.
const SERVER_ACTION_MANIFESTS_SINGLETON = Symbol.for("next.server.action-manifests");
function setReferenceManifestsSingleton({ clientReferenceManifest, serverActionsManifest, serverModuleMap }) {
    // @ts-ignore
    globalThis[SERVER_ACTION_MANIFESTS_SINGLETON] = {
        clientReferenceManifest,
        serverActionsManifest,
        serverModuleMap
    };
}
function getServerModuleMap() {
    const serverActionsManifestSingleton = globalThis[SERVER_ACTION_MANIFESTS_SINGLETON];
    if (!serverActionsManifestSingleton) {
        throw new Error("Missing manifest for Server Actions. This is a bug in Next.js");
    }
    return serverActionsManifestSingleton.serverModuleMap;
}
function getClientReferenceManifestSingleton() {
    const serverActionsManifestSingleton = globalThis[SERVER_ACTION_MANIFESTS_SINGLETON];
    if (!serverActionsManifestSingleton) {
        throw new Error("Missing manifest for Server Actions. This is a bug in Next.js");
    }
    return serverActionsManifestSingleton.clientReferenceManifest;
}
async function getActionEncryptionKey() {
    if (__next_loaded_action_key) {
        return __next_loaded_action_key;
    }
    const serverActionsManifestSingleton = globalThis[SERVER_ACTION_MANIFESTS_SINGLETON];
    if (!serverActionsManifestSingleton) {
        throw new Error("Missing manifest for Server Actions. This is a bug in Next.js");
    }
    const rawKey = process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY || serverActionsManifestSingleton.serverActionsManifest.encryptionKey;
    if (rawKey === undefined) {
        throw new Error("Missing encryption key for Server Actions");
    }
    __next_loaded_action_key = await crypto.subtle.importKey("raw", stringToUint8Array(atob(rawKey)), "AES-GCM", true, [
        "encrypt",
        "decrypt"
    ]);
    return __next_loaded_action_key;
}

//# sourceMappingURL=encryption-utils.js.map€”{"finalSource":true}ƒmap‹bufferedMap‡version„fileˆmappings‡sourcesŽsourcesContent…namesx°  ;;;;AAAA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0CAA0C,iEAAiE;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/encryption-utils.js|ssr´  // Keep the key in memory as it should never change during the lifetime of the server in
// both development and production.
let __next_encryption_key_generation_promise = null;
let __next_loaded_action_key;
let __next_internal_development_raw_action_key;
export function arrayBufferToString(buffer) {
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    // @anonrig: V8 has a limit of 65535 arguments in a function.
    // For len < 65535, this is faster.
    // https://github.com/vercel/next.js/pull/56377#pullrequestreview-1656181623
    if (len < 65535) {
        return String.fromCharCode.apply(null, bytes);
    }
    let binary = "";
    for(let i = 0; i < len; i++){
        binary += String.fromCharCode(bytes[i]);
    }
    return binary;
}
export function stringToUint8Array(binary) {
    const len = binary.length;
    const arr = new Uint8Array(len);
    for(let i = 0; i < len; i++){
        arr[i] = binary.charCodeAt(i);
    }
    return arr;
}
export function encrypt(key, iv, data) {
    return crypto.subtle.encrypt({
        name: "AES-GCM",
        iv
    }, key, data);
}
export function decrypt(key, iv, data) {
    return crypto.subtle.decrypt({
        name: "AES-GCM",
        iv
    }, key, data);
}
export async function generateEncryptionKeyBase64(dev) {
    // For development, we just keep one key in memory for all actions.
    // This makes things faster.
    if (dev) {
        if (typeof __next_internal_development_raw_action_key !== "undefined") {
            return __next_internal_development_raw_action_key;
        }
    }
    // This avoids it being generated multiple times in parallel.
    if (!__next_encryption_key_generation_promise) {
        __next_encryption_key_generation_promise = new Promise(async (resolve, reject)=>{
            try {
                const key = await crypto.subtle.generateKey({
                    name: "AES-GCM",
                    length: 256
                }, true, [
                    "encrypt",
                    "decrypt"
                ]);
                const exported = await crypto.subtle.exportKey("raw", key);
                const b64 = btoa(arrayBufferToString(exported));
                resolve([
                    key,
                    b64
                ]);
            } catch (error) {
                reject(error);
            }
        });
    }
    const [key, b64] = await __next_encryption_key_generation_promise;
    __next_loaded_action_key = key;
    if (dev) {
        __next_internal_development_raw_action_key = b64;
    }
    return b64;
}
// This is a global singleton that is used to encode/decode the action bound args from
// the closure. This can't be using a AsyncLocalStorage as it might happen on the module
// level. Since the client reference manifest won't be mutated, let's use a global singleton
// to keep it.
const SERVER_ACTION_MANIFESTS_SINGLETON = Symbol.for("next.server.action-manifests");
export function setReferenceManifestsSingleton({ clientReferenceManifest, serverActionsManifest, serverModuleMap }) {
    // @ts-ignore
    globalThis[SERVER_ACTION_MANIFESTS_SINGLETON] = {
        clientReferenceManifest,
        serverActionsManifest,
        serverModuleMap
    };
}
export function getServerModuleMap() {
    const serverActionsManifestSingleton = globalThis[SERVER_ACTION_MANIFESTS_SINGLETON];
    if (!serverActionsManifestSingleton) {
        throw new Error("Missing manifest for Server Actions. This is a bug in Next.js");
    }
    return serverActionsManifestSingleton.serverModuleMap;
}
export function getClientReferenceManifestSingleton() {
    const serverActionsManifestSingleton = globalThis[SERVER_ACTION_MANIFESTS_SINGLETON];
    if (!serverActionsManifestSingleton) {
        throw new Error("Missing manifest for Server Actions. This is a bug in Next.js");
    }
    return serverActionsManifestSingleton.clientReferenceManifest;
}
export async function getActionEncryptionKey() {
    if (__next_loaded_action_key) {
        return __next_loaded_action_key;
    }
    const serverActionsManifestSingleton = globalThis[SERVER_ACTION_MANIFESTS_SINGLETON];
    if (!serverActionsManifestSingleton) {
        throw new Error("Missing manifest for Server Actions. This is a bug in Next.js");
    }
    const rawKey = process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY || serverActionsManifestSingleton.serverActionsManifest.encryptionKey;
    if (rawKey === undefined) {
        throw new Error("Missing encryption key for Server Actions");
    }
    __next_loaded_action_key = await crypto.subtle.importKey("raw", stringToUint8Array(atob(rawKey)), "AES-GCM", true, [
        "encrypt",
        "decrypt"
    ]);
    return __next_loaded_action_key;
}

//# sourceMappingURL=encryption-utils.js.map    ConcatSourceRawSourcep  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mo: () => (/* binding */ setReferenceManifestsSingleton)
/* harmony export */ });
/* unused harmony exports arrayBufferToString, stringToUint8Array, encrypt, decrypt, generateEncryptionKeyBase64, getServerModuleMap, getClientReferenceManifestSingleton, getActionEncryptionKey */
   ReplaceSourceOriginalSource÷®  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/encryption-utils.js|ssr256262undefined780786undefined990996undefined11231129undefined12561262undefined29622968undefined32493255undefined35783584undefined39323938undefined
   

/***/ })©óÿÿN  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mo: () => (/* binding */ setReferenceManifestsSingleton)
/* harmony export */ });
/* unused harmony exports arrayBufferToString, stringToUint8Array, encrypt, decrypt, generateEncryptionKeyBase64, getServerModuleMap, getClientReferenceManifestSingleton, getActionEncryptionKey */
// Keep the key in memory as it should never change during the lifetime of the server in
// both development and production.
let __next_encryption_key_generation_promise = null;
let __next_loaded_action_key;
let __next_internal_development_raw_action_key;
function arrayBufferToString(buffer) {
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    // @anonrig: V8 has a limit of 65535 arguments in a function.
    // For len < 65535, this is faster.
    // https://github.com/vercel/next.js/pull/56377#pullrequestreview-1656181623
    if (len < 65535) {
        return String.fromCharCode.apply(null, bytes);
    }
    let binary = "";
    for(let i = 0; i < len; i++){
        binary += String.fromCharCode(bytes[i]);
    }
    return binary;
}
function stringToUint8Array(binary) {
    const len = binary.length;
    const arr = new Uint8Array(len);
    for(let i = 0; i < len; i++){
        arr[i] = binary.charCodeAt(i);
    }
    return arr;
}
function encrypt(key, iv, data) {
    return crypto.subtle.encrypt({
        name: "AES-GCM",
        iv
    }, key, data);
}
function decrypt(key, iv, data) {
    return crypto.subtle.decrypt({
        name: "AES-GCM",
        iv
    }, key, data);
}
async function generateEncryptionKeyBase64(dev) {
    // For development, we just keep one key in memory for all actions.
    // This makes things faster.
    if (dev) {
        if (typeof __next_internal_development_raw_action_key !== "undefined") {
            return __next_internal_development_raw_action_key;
        }
    }
    // This avoids it being generated multiple times in parallel.
    if (!__next_encryption_key_generation_promise) {
        __next_encryption_key_generation_promise = new Promise(async (resolve, reject)=>{
            try {
                const key = await crypto.subtle.generateKey({
                    name: "AES-GCM",
                    length: 256
                }, true, [
                    "encrypt",
                    "decrypt"
                ]);
                const exported = await crypto.subtle.exportKey("raw", key);
                const b64 = btoa(arrayBufferToString(exported));
                resolve([
                    key,
                    b64
                ]);
            } catch (error) {
                reject(error);
            }
        });
    }
    const [key, b64] = await __next_encryption_key_generation_promise;
    __next_loaded_action_key = key;
    if (dev) {
        __next_internal_development_raw_action_key = b64;
    }
    return b64;
}
// This is a global singleton that is used to encode/decode the action bound args from
// the closure. This can't be using a AsyncLocalStorage as it might happen on the module
// level. Since the client reference manifest won't be mutated, let's use a global singleton
// to keep it.
const SERVER_ACTION_MANIFESTS_SINGLETON = Symbol.for("next.server.action-manifests");
function setReferenceManifestsSingleton({ clientReferenceManifest, serverActionsManifest, serverModuleMap }) {
    // @ts-ignore
    globalThis[SERVER_ACTION_MANIFESTS_SINGLETON] = {
        clientReferenceManifest,
        serverActionsManifest,
        serverModuleMap
    };
}
function getServerModuleMap() {
    const serverActionsManifestSingleton = globalThis[SERVER_ACTION_MANIFESTS_SINGLETON];
    if (!serverActionsManifestSingleton) {
        throw new Error("Missing manifest for Server Actions. This is a bug in Next.js");
    }
    return serverActionsManifestSingleton.serverModuleMap;
}
function getClientReferenceManifestSingleton() {
    const serverActionsManifestSingleton = globalThis[SERVER_ACTION_MANIFESTS_SINGLETON];
    if (!serverActionsManifestSingleton) {
        throw new Error("Missing manifest for Server Actions. This is a bug in Next.js");
    }
    return serverActionsManifestSingleton.clientReferenceManifest;
}
async function getActionEncryptionKey() {
    if (__next_loaded_action_key) {
        return __next_loaded_action_key;
    }
    const serverActionsManifestSingleton = globalThis[SERVER_ACTION_MANIFESTS_SINGLETON];
    if (!serverActionsManifestSingleton) {
        throw new Error("Missing manifest for Server Actions. This is a bug in Next.js");
    }
    const rawKey = process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY || serverActionsManifestSingleton.serverActionsManifest.encryptionKey;
    if (rawKey === undefined) {
        throw new Error("Missing encryption key for Server Actions");
    }
    __next_loaded_action_key = await crypto.subtle.importKey("raw", stringToUint8Array(atob(rawKey)), "AES-GCM", true, [
        "encrypt",
        "decrypt"
    ]);
    return __next_loaded_action_key;
}

//# sourceMappingURL=encryption-utils.js.map

/***/ })ªóÿÿ­óÿÿ´óÿÿx¶  ;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0CAA0C,iEAAiE;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4C  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/encryption-utils.js|ssr´  // Keep the key in memory as it should never change during the lifetime of the server in
// both development and production.
let __next_encryption_key_generation_promise = null;
let __next_loaded_action_key;
let __next_internal_development_raw_action_key;
export function arrayBufferToString(buffer) {
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    // @anonrig: V8 has a limit of 65535 arguments in a function.
    // For len < 65535, this is faster.
    // https://github.com/vercel/next.js/pull/56377#pullrequestreview-1656181623
    if (len < 65535) {
        return String.fromCharCode.apply(null, bytes);
    }
    let binary = "";
    for(let i = 0; i < len; i++){
        binary += String.fromCharCode(bytes[i]);
    }
    return binary;
}
export function stringToUint8Array(binary) {
    const len = binary.length;
    const arr = new Uint8Array(len);
    for(let i = 0; i < len; i++){
        arr[i] = binary.charCodeAt(i);
    }
    return arr;
}
export function encrypt(key, iv, data) {
    return crypto.subtle.encrypt({
        name: "AES-GCM",
        iv
    }, key, data);
}
export function decrypt(key, iv, data) {
    return crypto.subtle.decrypt({
        name: "AES-GCM",
        iv
    }, key, data);
}
export async function generateEncryptionKeyBase64(dev) {
    // For development, we just keep one key in memory for all actions.
    // This makes things faster.
    if (dev) {
        if (typeof __next_internal_development_raw_action_key !== "undefined") {
            return __next_internal_development_raw_action_key;
        }
    }
    // This avoids it being generated multiple times in parallel.
    if (!__next_encryption_key_generation_promise) {
        __next_encryption_key_generation_promise = new Promise(async (resolve, reject)=>{
            try {
                const key = await crypto.subtle.generateKey({
                    name: "AES-GCM",
                    length: 256
                }, true, [
                    "encrypt",
                    "decrypt"
                ]);
                const exported = await crypto.subtle.exportKey("raw", key);
                const b64 = btoa(arrayBufferToString(exported));
                resolve([
                    key,
                    b64
                ]);
            } catch (error) {
                reject(error);
            }
        });
    }
    const [key, b64] = await __next_encryption_key_generation_promise;
    __next_loaded_action_key = key;
    if (dev) {
        __next_internal_development_raw_action_key = b64;
    }
    return b64;
}
// This is a global singleton that is used to encode/decode the action bound args from
// the closure. This can't be using a AsyncLocalStorage as it might happen on the module
// level. Since the client reference manifest won't be mutated, let's use a global singleton
// to keep it.
const SERVER_ACTION_MANIFESTS_SINGLETON = Symbol.for("next.server.action-manifests");
export function setReferenceManifestsSingleton({ clientReferenceManifest, serverActionsManifest, serverModuleMap }) {
    // @ts-ignore
    globalThis[SERVER_ACTION_MANIFESTS_SINGLETON] = {
        clientReferenceManifest,
        serverActionsManifest,
        serverModuleMap
    };
}
export function getServerModuleMap() {
    const serverActionsManifestSingleton = globalThis[SERVER_ACTION_MANIFESTS_SINGLETON];
    if (!serverActionsManifestSingleton) {
        throw new Error("Missing manifest for Server Actions. This is a bug in Next.js");
    }
    return serverActionsManifestSingleton.serverModuleMap;
}
export function getClientReferenceManifestSingleton() {
    const serverActionsManifestSingleton = globalThis[SERVER_ACTION_MANIFESTS_SINGLETON];
    if (!serverActionsManifestSingleton) {
        throw new Error("Missing manifest for Server Actions. This is a bug in Next.js");
    }
    return serverActionsManifestSingleton.clientReferenceManifest;
}
export async function getActionEncryptionKey() {
    if (__next_loaded_action_key) {
        return __next_loaded_action_key;
    }
    const serverActionsManifestSingleton = globalThis[SERVER_ACTION_MANIFESTS_SINGLETON];
    if (!serverActionsManifestSingleton) {
        throw new Error("Missing manifest for Server Actions. This is a bug in Next.js");
    }
    const rawKey = process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY || serverActionsManifestSingleton.serverActionsManifest.encryptionKey;
    if (rawKey === undefined) {
        throw new Error("Missing encryption key for Server Actions");
    }
    __next_loaded_action_key = await crypto.subtle.importKey("raw", stringToUint8Array(atob(rawKey)), "AES-GCM", true, [
        "encrypt",
        "decrypt"
    ]);
    return __next_loaded_action_key;
}

//# sourceMappingURL=encryption-utils.js.map 	µóÿÿöÿÿµóÿÿp  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mo: () => (/* binding */ setReferenceManifestsSingleton)
/* harmony export */ });
/* unused harmony exports arrayBufferToString, stringToUint8Array, encrypt, decrypt, generateEncryptionKeyBase64, getServerModuleMap, getClientReferenceManifestSingleton, getActionEncryptionKey */
Ùóÿÿù®  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/encryption-utils.js|ssr256262undefined780786undefined990996undefined11231129undefined12561262undefined29622968undefined32493255undefined35783584undefined39323938undefinedÚóÿÿ·óÿÿ   ,

/***/ 7126:
   ´  «webpack/lib/util/registerExternalSerializerœwebpack-sources/ConcatSource€«webpack/lib/util/registerExternalSerializer™webpack-sources/RawSource_   /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
«webpack/lib/util/registerExternalSerializerœwebpack-sources/CachedSource   2	  «webpack/lib/util/registerExternalSerializerœwebpack-sources/ConcatSource€«webpack/lib/util/registerExternalSerializer™webpack-sources/RawSource  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ getSegmentParam)
/* harmony export */ });
/* harmony import */ var _future_helpers_interception_routes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(117);
«webpack/lib/util/registerExternalSerializerwebpack-sources/ReplaceSource«webpack/lib/util/registerExternalSerializeržwebpack-sources/OriginalSourceB  import { INTERCEPTION_ROUTE_MARKERS } from "../future/helpers/interception-routes";
/**
 * Parse dynamic route segment to type of parameter
 */ export function getSegmentParam(segment) {
    const interceptionMarker = INTERCEPTION_ROUTE_MARKERS.find((marker)=>segment.startsWith(marker));
    // if an interception marker is part of the path segment, we need to jump ahead
    // to the relevant portion for param parsing
    if (interceptionMarker) {
        segment = segment.slice(interceptionMarker.length);
    }
    if (segment.startsWith("[[...") && segment.endsWith("]]")) {
        return {
            // TODO-APP: Optional catchall does not currently work with parallel routes,
            // so for now aren't handling a potential interception marker.
            type: "optional-catchall",
            param: segment.slice(5, -2)
        };
    }
    if (segment.startsWith("[...") && segment.endsWith("]")) {
        return {
            type: interceptionMarker ? "catchall-intercepted" : "catchall",
            param: segment.slice(4, -1)
        };
    }
    if (segment.startsWith("[") && segment.endsWith("]")) {
        return {
            type: interceptionMarker ? "dynamic-intercepted" : "dynamic",
            param: segment.slice(1, -1)
        };
    }
    return null;
}

//# sourceMappingURL=get-segment-param.js.map  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-segment-param.js|ssr `RC   –   Ú   ó   €€å_future_helpers_interception_routes__WEBPACK_IMPORTED_MODULE_0__/* .INTERCEPTION_ROUTE_MARKERS */ .Wz€†buffer†source„size„maps„hashD  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ getSegmentParam)
/* harmony export */ });
/* harmony import */ var _future_helpers_interception_routes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(117);

/**
 * Parse dynamic route segment to type of parameter
 */ function getSegmentParam(segment) {
    const interceptionMarker = _future_helpers_interception_routes__WEBPACK_IMPORTED_MODULE_0__/* .INTERCEPTION_ROUTE_MARKERS */ .Wz.find((marker)=>segment.startsWith(marker));
    // if an interception marker is part of the path segment, we need to jump ahead
    // to the relevant portion for param parsing
    if (interceptionMarker) {
        segment = segment.slice(interceptionMarker.length);
    }
    if (segment.startsWith("[[...") && segment.endsWith("]]")) {
        return {
            // TODO-APP: Optional catchall does not currently work with parallel routes,
            // so for now aren't handling a potential interception marker.
            type: "optional-catchall",
            param: segment.slice(5, -2)
        };
    }
    if (segment.startsWith("[...") && segment.endsWith("]")) {
        return {
            type: interceptionMarker ? "catchall-intercepted" : "catchall",
            param: segment.slice(4, -1)
        };
    }
    if (segment.startsWith("[") && segment.endsWith("]")) {
        return {
            type: interceptionMarker ? "dynamic-intercepted" : "dynamic",
            param: segment.slice(1, -1)
        };
    }
    return null;
}

//# sourceMappingURL=get-segment-param.js.map€”{"finalSource":true}ƒmap‹bufferedMap‡version„fileˆmappings‡sourcesŽsourcesContent…namesx¿   ;;;;AAAmF;AACnF;AACA;AACA,IAAW;AACX,+BAA+B,qGAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-segment-param.js|ssrB  import { INTERCEPTION_ROUTE_MARKERS } from "../future/helpers/interception-routes";
/**
 * Parse dynamic route segment to type of parameter
 */ export function getSegmentParam(segment) {
    const interceptionMarker = INTERCEPTION_ROUTE_MARKERS.find((marker)=>segment.startsWith(marker));
    // if an interception marker is part of the path segment, we need to jump ahead
    // to the relevant portion for param parsing
    if (interceptionMarker) {
        segment = segment.slice(interceptionMarker.length);
    }
    if (segment.startsWith("[[...") && segment.endsWith("]]")) {
        return {
            // TODO-APP: Optional catchall does not currently work with parallel routes,
            // so for now aren't handling a potential interception marker.
            type: "optional-catchall",
            param: segment.slice(5, -2)
        };
    }
    if (segment.startsWith("[...") && segment.endsWith("]")) {
        return {
            type: interceptionMarker ? "catchall-intercepted" : "catchall",
            param: segment.slice(4, -1)
        };
    }
    if (segment.startsWith("[") && segment.endsWith("]")) {
        return {
            type: interceptionMarker ? "dynamic-intercepted" : "dynamic",
            param: segment.slice(1, -1)
        };
    }
    return null;
}

//# sourceMappingURL=get-segment-param.js.map    ConcatSourceRawSource  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ getSegmentParam)
/* harmony export */ });
/* harmony import */ var _future_helpers_interception_routes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(117);
   ReplaceSourceOriginalSource÷«  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-segment-param.js|ssr082undefined144150undefined218243_future_helpers_interception_routes__WEBPACK_IMPORTED_MODULE_0__/* .INTERCEPTION_ROUTE_MARKERS */ .Wzundefined
   

/***/ })˜óÿÿ­  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ getSegmentParam)
/* harmony export */ });
/* harmony import */ var _future_helpers_interception_routes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(117);

/**
 * Parse dynamic route segment to type of parameter
 */ function getSegmentParam(segment) {
    const interceptionMarker = _future_helpers_interception_routes__WEBPACK_IMPORTED_MODULE_0__/* .INTERCEPTION_ROUTE_MARKERS */ .Wz.find((marker)=>segment.startsWith(marker));
    // if an interception marker is part of the path segment, we need to jump ahead
    // to the relevant portion for param parsing
    if (interceptionMarker) {
        segment = segment.slice(interceptionMarker.length);
    }
    if (segment.startsWith("[[...") && segment.endsWith("]]")) {
        return {
            // TODO-APP: Optional catchall does not currently work with parallel routes,
            // so for now aren't handling a potential interception marker.
            type: "optional-catchall",
            param: segment.slice(5, -2)
        };
    }
    if (segment.startsWith("[...") && segment.endsWith("]")) {
        return {
            type: interceptionMarker ? "catchall-intercepted" : "catchall",
            param: segment.slice(4, -1)
        };
    }
    if (segment.startsWith("[") && segment.endsWith("]")) {
        return {
            type: interceptionMarker ? "dynamic-intercepted" : "dynamic",
            param: segment.slice(1, -1)
        };
    }
    return null;
}

//# sourceMappingURL=get-segment-param.js.map

/***/ })™óÿÿœóÿÿ£óÿÿxÅ   ;;;;;;;AAAmF;AACnF;AACA;AACA,IAAW;AACX,+BAA+B,qGAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6C  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-segment-param.js|ssrB  import { INTERCEPTION_ROUTE_MARKERS } from "../future/helpers/interception-routes";
/**
 * Parse dynamic route segment to type of parameter
 */ export function getSegmentParam(segment) {
    const interceptionMarker = INTERCEPTION_ROUTE_MARKERS.find((marker)=>segment.startsWith(marker));
    // if an interception marker is part of the path segment, we need to jump ahead
    // to the relevant portion for param parsing
    if (interceptionMarker) {
        segment = segment.slice(interceptionMarker.length);
    }
    if (segment.startsWith("[[...") && segment.endsWith("]]")) {
        return {
            // TODO-APP: Optional catchall does not currently work with parallel routes,
            // so for now aren't handling a potential interception marker.
            type: "optional-catchall",
            param: segment.slice(5, -2)
        };
    }
    if (segment.startsWith("[...") && segment.endsWith("]")) {
        return {
            type: interceptionMarker ? "catchall-intercepted" : "catchall",
            param: segment.slice(4, -1)
        };
    }
    if (segment.startsWith("[") && segment.endsWith("]")) {
        return {
            type: interceptionMarker ? "dynamic-intercepted" : "dynamic",
            param: segment.slice(1, -1)
        };
    }
    return null;
}

//# sourceMappingURL=get-segment-param.js.map 	¤óÿÿöÿÿ¤óÿÿ  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   R: () => (/* binding */ getSegmentParam)
/* harmony export */ });
/* harmony import */ var _future_helpers_interception_routes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(117);
Èóÿÿù«  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/app-render/get-segment-param.js|ssr082undefined144150undefined218243_future_helpers_interception_routes__WEBPACK_IMPORTED_MODULE_0__/* .INTERCEPTION_ROUTE_MARKERS */ .WzundefinedÉóÿÿ¦óÿÿ   ,

/***/ 4569:
   ›¨  «webpack/lib/util/registerExternalSerializerœwebpack-sources/ConcatSource€«webpack/lib/util/registerExternalSerializer™webpack-sources/RawSource_   /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
«webpack/lib/util/registerExternalSerializerœwebpack-sources/CachedSource   Èa  «webpack/lib/util/registerExternalSerializerœwebpack-sources/ConcatSource€«webpack/lib/util/registerExternalSerializer™webpack-sources/RawSource  
// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  B: () => (/* binding */ RequestAsyncStorageWrapper)
});

// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/app-router-headers.js
var app_router_headers = __webpack_require__(3185);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/adapters/headers.js
var adapters_headers = __webpack_require__(3581);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/adapters/request-cookies.js
var request_cookies = __webpack_require__(4488);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/cookies.js
var spec_extension_cookies = __webpack_require__(9474);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/api-utils/index.js
var api_utils = __webpack_require__(2533);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/async-storage/draft-mode-provider.js
«webpack/lib/util/registerExternalSerializerwebpack-sources/ReplaceSource«webpack/lib/util/registerExternalSerializerœwebpack-sources/CachedSource     «webpack/lib/util/registerExternalSerializerwebpack-sources/ReplaceSource«webpack/lib/util/registerExternalSerializeržwebpack-sources/OriginalSourceÉ  import { COOKIE_NAME_PRERENDER_BYPASS, checkIsOnDemandRevalidate } from "../api-utils";
export class DraftModeProvider {
    constructor(previewProps, req, cookies, mutableCookies){
        var _cookies_get;
        // The logic for draftMode() is very similar to tryGetPreviewData()
        // but Draft Mode does not have any data associated with it.
        const isOnDemandRevalidate = previewProps && checkIsOnDemandRevalidate(req, previewProps).isOnDemandRevalidate;
        const cookieValue = (_cookies_get = cookies.get(COOKIE_NAME_PRERENDER_BYPASS)) == null ? void 0 : _cookies_get.value;
        this.isEnabled = Boolean(!isOnDemandRevalidate && cookieValue && previewProps && cookieValue === previewProps.previewModeId);
        this._previewModeId = previewProps == null ? void 0 : previewProps.previewModeId;
        this._mutableCookies = mutableCookies;
    }
    enable() {
        if (!this._previewModeId) {
            throw new Error("Invariant: previewProps missing previewModeId this should never happen");
        }
        this._mutableCookies.set({
            name: COOKIE_NAME_PRERENDER_BYPASS,
            value: this._previewModeId,
            httpOnly: true,
            sameSite: process.env.NODE_ENV !== "development" ? "none" : "lax",
            secure: process.env.NODE_ENV !== "development",
            path: "/"
        });
    }
    disable() {
        // To delete a cookie, set `expires` to a date in the past:
        // https://tools.ietf.org/html/rfc6265#section-4.1.1
        // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.
        this._mutableCookies.set({
            name: COOKIE_NAME_PRERENDER_BYPASS,
            value: "",
            httpOnly: true,
            sameSite: process.env.NODE_ENV !== "development" ? "none" : "lax",
            secure: process.env.NODE_ENV !== "development",
            path: "/",
            expires: new Date(0)
        });
    }
}

//# sourceMappingURL=draft-mode-provider.js.map!  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/async-storage/draft-mode-provider.js|ssrd VX^S–  ®    ,  E  `  ½  â  ï  ó  
    q  Œ  Ø  ý  
    %  8  €€÷__WEBPACK_MODULE_REFERENCE__4_5b22636865636b49734f6e44656d616e64526576616c6964617465225d_call_directImport_asiSafe1__._ø__WEBPACK_MODULE_REFERENCE__4_5b22434f4f4b49455f4e414d455f50524552454e4445525f425950415353225d_directImport_asiSafe1__._ÿ… true0Œ"production"ýþ0ÿ€†buffer†source„size„maps„hashƒ  
class DraftModeProvider {
    constructor(previewProps, req, cookies, mutableCookies){
        var _cookies_get;
        // The logic for draftMode() is very similar to tryGetPreviewData()
        // but Draft Mode does not have any data associated with it.
        const isOnDemandRevalidate = previewProps && __WEBPACK_MODULE_REFERENCE__4_5b22636865636b49734f6e44656d616e64526576616c6964617465225d_call_directImport_asiSafe1__._(req, previewProps).isOnDemandRevalidate;
        const cookieValue = (_cookies_get = cookies.get(__WEBPACK_MODULE_REFERENCE__4_5b22434f4f4b49455f4e414d455f50524552454e4445525f425950415353225d_directImport_asiSafe1__._)) == null ? void 0 : _cookies_get.value;
        this.isEnabled = Boolean(!isOnDemandRevalidate && cookieValue && previewProps && cookieValue === previewProps.previewModeId);
        this._previewModeId = previewProps == null ? void 0 : previewProps.previewModeId;
        this._mutableCookies = mutableCookies;
    }
    enable() {
        if (!this._previewModeId) {
            throw new Error("Invariant: previewProps missing previewModeId this should never happen");
        }
        this._mutableCookies.set({
            name: __WEBPACK_MODULE_REFERENCE__4_5b22434f4f4b49455f4e414d455f50524552454e4445525f425950415353225d_directImport_asiSafe1__._,
            value: this._previewModeId,
            httpOnly: true,
            sameSite:  true ? "none" : 0,
            secure: "production" !== "development",
            path: "/"
        });
    }
    disable() {
        // To delete a cookie, set `expires` to a date in the past:
        // https://tools.ietf.org/html/rfc6265#section-4.1.1
        // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.
        this._mutableCookies.set({
            name: __WEBPACK_MODULE_REFERENCE__4_5b22434f4f4b49455f4e414d455f50524552454e4445525f425950415353225d_directImport_asiSafe1__._,
            value: "",
            httpOnly: true,
            sameSite:  true ? "none" : 0,
            secure: "production" !== "development",
            path: "/",
            expires: new Date(0)
        });
    }
}

//# sourceMappingURL=draft-mode-provider.js.map€•{"finalSource":false}ƒmap‹bufferedMap‡version„fileˆmappings‡sourcesŽsourcesContent…namesxa  AAAuF;AAChF;AACP;AACA;AACA;AACA;AACA,qDAAqD,uHAAyB;AAC9E,wDAAwD,wHAA4B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wHAA4B;AAC9C;AACA;AACA,sBAAsB,KAAsC,YAAY,CAAK;AAC7E,oBAAoB,YAAoB;AACxC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wHAA4B;AAC9C;AACA;AACA,sBAAsB,KAAsC,YAAY,CAAK;AAC7E,oBAAoB,YAAoB;AACxC;AACA;AACA,SAAS;AACT;AACA;;AAEA!  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/async-storage/draft-mode-provider.js|ssrÉ  import { COOKIE_NAME_PRERENDER_BYPASS, checkIsOnDemandRevalidate } from "../api-utils";
export class DraftModeProvider {
    constructor(previewProps, req, cookies, mutableCookies){
        var _cookies_get;
        // The logic for draftMode() is very similar to tryGetPreviewData()
        // but Draft Mode does not have any data associated with it.
        const isOnDemandRevalidate = previewProps && checkIsOnDemandRevalidate(req, previewProps).isOnDemandRevalidate;
        const cookieValue = (_cookies_get = cookies.get(COOKIE_NAME_PRERENDER_BYPASS)) == null ? void 0 : _cookies_get.value;
        this.isEnabled = Boolean(!isOnDemandRevalidate && cookieValue && previewProps && cookieValue === previewProps.previewModeId);
        this._previewModeId = previewProps == null ? void 0 : previewProps.previewModeId;
        this._mutableCookies = mutableCookies;
    }
    enable() {
        if (!this._previewModeId) {
            throw new Error("Invariant: previewProps missing previewModeId this should never happen");
        }
        this._mutableCookies.set({
            name: COOKIE_NAME_PRERENDER_BYPASS,
            value: this._previewModeId,
            httpOnly: true,
            sameSite: process.env.NODE_ENV !== "development" ? "none" : "lax",
            secure: process.env.NODE_ENV !== "development",
            path: "/"
        });
    }
    disable() {
        // To delete a cookie, set `expires` to a date in the past:
        // https://tools.ietf.org/html/rfc6265#section-4.1.1
        // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.
        this._mutableCookies.set({
            name: COOKIE_NAME_PRERENDER_BYPASS,
            value: "",
            httpOnly: true,
            sameSite: process.env.NODE_ENV !== "development" ? "none" : "lax",
            secure: process.env.NODE_ENV !== "development",
            path: "/",
            expires: new Date(0)
        });
    }
}

//# sourceMappingURL=draft-mode-provider.js.map    ReplaceSourceOriginalSourceùã  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/async-storage/draft-mode-provider.js|ssr086undefined8894undefined406430__WEBPACK_MODULE_REFERENCE__4_5b22636865636b49734f6e44656d616e64526576616c6964617465225d_call_directImport_asiSafe1__._undefined529556__WEBPACK_MODULE_REFERENCE__4_5b22434f4f4b49455f4e414d455f50524552454e4445525f425950415353225d_directImport_asiSafe1__._undefined10931120__WEBPACK_MODULE_REFERENCE__4_5b22434f4f4b49455f4e414d455f50524552454e4445525f425950415353225d_directImport_asiSafe1__._undefined12131250 trueundefined126312670undefined12901309"production"undefined16491676__WEBPACK_MODULE_REFERENCE__4_5b22434f4f4b49455f4e414d455f50524552454e4445525f425950415353225d_directImport_asiSafe1__._undefined17521789 trueundefined180218060undefined18291848"production"undefinedG8  ®    ˆ  ¡    ü  s  ¯(0,api_utils/* checkIsOnDemandRevalidate */.Iq)®api_utils/* COOKIE_NAME_PRERENDER_BYPASS */.dSÿÿm   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/async-storage/request-async-storage-wrapper.js
   3  «webpack/lib/util/registerExternalSerializerwebpack-sources/ReplaceSource«webpack/lib/util/registerExternalSerializeržwebpack-sources/OriginalSource  import { FLIGHT_PARAMETERS } from "../../client/components/app-router-headers";
import { HeadersAdapter } from "../web/spec-extension/adapters/headers";
import { MutableRequestCookiesAdapter, RequestCookiesAdapter } from "../web/spec-extension/adapters/request-cookies";
import { RequestCookies } from "../web/spec-extension/cookies";
import { DraftModeProvider } from "./draft-mode-provider";
function getHeaders(headers) {
    const cleaned = HeadersAdapter.from(headers);
    for (const param of FLIGHT_PARAMETERS){
        cleaned.delete(param.toString().toLowerCase());
    }
    return HeadersAdapter.seal(cleaned);
}
function getCookies(headers) {
    const cookies = new RequestCookies(HeadersAdapter.from(headers));
    return RequestCookiesAdapter.seal(cookies);
}
function getMutableCookies(headers, onUpdateCookies) {
    const cookies = new RequestCookies(HeadersAdapter.from(headers));
    return MutableRequestCookiesAdapter.wrap(cookies, onUpdateCookies);
}
export const RequestAsyncStorageWrapper = {
    /**
   * Wrap the callback with the given store so it can access the underlying
   * store using hooks.
   *
   * @param storage underlying storage object returned by the module
   * @param context context to seed the store
   * @param callback function to call within the scope of the context
   * @returns the result returned by the callback
   */ wrap (storage, { req, res, renderOpts }, callback) {
        let previewProps = undefined;
        if (renderOpts && "previewProps" in renderOpts) {
            // TODO: investigate why previewProps isn't on RenderOpts
            previewProps = renderOpts.previewProps;
        }
        function defaultOnUpdateCookies(cookies) {
            if (res) {
                res.setHeader("Set-Cookie", cookies);
            }
        }
        const cache = {};
        const store = {
            get headers () {
                if (!cache.headers) {
                    // Seal the headers object that'll freeze out any methods that could
                    // mutate the underlying data.
                    cache.headers = getHeaders(req.headers);
                }
                return cache.headers;
            },
            get cookies () {
                if (!cache.cookies) {
                    // Seal the cookies object that'll freeze out any methods that could
                    // mutate the underlying data.
                    cache.cookies = getCookies(req.headers);
                }
                return cache.cookies;
            },
            get mutableCookies () {
                if (!cache.mutableCookies) {
                    cache.mutableCookies = getMutableCookies(req.headers, (renderOpts == null ? void 0 : renderOpts.onUpdateCookies) || (res ? defaultOnUpdateCookies : undefined));
                }
                return cache.mutableCookies;
            },
            get draftMode () {
                if (!cache.draftMode) {
                    cache.draftMode = new DraftModeProvider(previewProps, req, this.cookies, this.mutableCookies);
                }
                return cache.draftMode;
            },
            reactLoadableManifest: (renderOpts == null ? void 0 : renderOpts.reactLoadableManifest) || {},
            assetPrefix: (renderOpts == null ? void 0 : renderOpts.assetPrefix) || ""
        };
        return storage.run(store, callback, store);
    }
};

//# sourceMappingURL=request-async-storage-wrapper.js.map+  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/async-storage/request-async-storage-wrapper.js|ssrc NP\—   ™       M  O  ˆ  ½  Ê  ó    P  ]  §  ´  ¶  Ã  à  ô  V  c  e  r    ª  Î  Ô  ª  º  €€€€€Ô__WEBPACK_MODULE_REFERENCE__1_5b224865616465727341646170746572225d_call_asiSafe1__._â__WEBPACK_MODULE_REFERENCE__0_5b22464c494748545f504152414d4554455253225d_directImport_asiSafe1__._þÜ__WEBPACK_MODULE_REFERENCE__3_5b2252657175657374436f6f6b696573225d_directImport_asiSafe1__._ýâ__WEBPACK_MODULE_REFERENCE__2_5b2252657175657374436f6f6b69657341646170746572225d_call_asiSafe1__._þüð__WEBPACK_MODULE_REFERENCE__2_5b224d757461626c6552657175657374436f6f6b69657341646170746572225d_call_asiSafe1__._€â__WEBPACK_MODULE_REFERENCE__5_5b2244726166744d6f646550726f7669646572225d_directImport_asiSafe1__._àê  




function getHeaders(headers) {
    const cleaned = __WEBPACK_MODULE_REFERENCE__1_5b224865616465727341646170746572225d_call_asiSafe1__._.from(headers);
    for (const param of __WEBPACK_MODULE_REFERENCE__0_5b22464c494748545f504152414d4554455253225d_directImport_asiSafe1__._){
        cleaned.delete(param.toString().toLowerCase());
    }
    return __WEBPACK_MODULE_REFERENCE__1_5b224865616465727341646170746572225d_call_asiSafe1__._.seal(cleaned);
}
function getCookies(headers) {
    const cookies = new __WEBPACK_MODULE_REFERENCE__3_5b2252657175657374436f6f6b696573225d_directImport_asiSafe1__._(__WEBPACK_MODULE_REFERENCE__1_5b224865616465727341646170746572225d_call_asiSafe1__._.from(headers));
    return __WEBPACK_MODULE_REFERENCE__2_5b2252657175657374436f6f6b69657341646170746572225d_call_asiSafe1__._.seal(cookies);
}
function getMutableCookies(headers, onUpdateCookies) {
    const cookies = new __WEBPACK_MODULE_REFERENCE__3_5b2252657175657374436f6f6b696573225d_directImport_asiSafe1__._(__WEBPACK_MODULE_REFERENCE__1_5b224865616465727341646170746572225d_call_asiSafe1__._.from(headers));
    return __WEBPACK_MODULE_REFERENCE__2_5b224d757461626c6552657175657374436f6f6b69657341646170746572225d_call_asiSafe1__._.wrap(cookies, onUpdateCookies);
}
const RequestAsyncStorageWrapper = {
    /**
   * Wrap the callback with the given store so it can access the underlying
   * store using hooks.
   *
   * @param storage underlying storage object returned by the module
   * @param context context to seed the store
   * @param callback function to call within the scope of the context
   * @returns the result returned by the callback
   */ wrap (storage, { req, res, renderOpts }, callback) {
        let previewProps = undefined;
        if (renderOpts && "previewProps" in renderOpts) {
            // TODO: investigate why previewProps isn't on RenderOpts
            previewProps = renderOpts.previewProps;
        }
        function defaultOnUpdateCookies(cookies) {
            if (res) {
                res.setHeader("Set-Cookie", cookies);
            }
        }
        const cache = {};
        const store = {
            get headers () {
                if (!cache.headers) {
                    // Seal the headers object that'll freeze out any methods that could
                    // mutate the underlying data.
                    cache.headers = getHeaders(req.headers);
                }
                return cache.headers;
            },
            get cookies () {
                if (!cache.cookies) {
                    // Seal the cookies object that'll freeze out any methods that could
                    // mutate the underlying data.
                    cache.cookies = getCookies(req.headers);
                }
                return cache.cookies;
            },
            get mutableCookies () {
                if (!cache.mutableCookies) {
                    cache.mutableCookies = getMutableCookies(req.headers, (renderOpts == null ? void 0 : renderOpts.onUpdateCookies) || (res ? defaultOnUpdateCookies : undefined));
                }
                return cache.mutableCookies;
            },
            get draftMode () {
                if (!cache.draftMode) {
                    cache.draftMode = new __WEBPACK_MODULE_REFERENCE__5_5b2244726166744d6f646550726f7669646572225d_directImport_asiSafe1__._(previewProps, req, this.cookies, this.mutableCookies);
                }
                return cache.draftMode;
            },
            reactLoadableManifest: (renderOpts == null ? void 0 : renderOpts.reactLoadableManifest) || {},
            assetPrefix: (renderOpts == null ? void 0 : renderOpts.assetPrefix) || ""
        };
        return storage.run(store, callback, store);
    }
};

//# sourceMappingURL=request-async-storage-wrapper.js.mapáäëx4  AAA+E;AACP;AAC6C;AACtD;AACL;AAC1D;AACA,oBAAoB,oFAAc;AAClC,wBAAwB,kGAAiB;AACzC;AACA;AACA,WAAW,oFAAc;AACzB;AACA;AACA,wBAAwB,4FAAc,CAAC,oFAAc;AACrD,WAAW,kGAAqB;AAChC;AACA;AACA,wBAAwB,4FAAc,CAAC,oFAAc;AACrD,WAAW,gHAA4B;AACvC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,0CAA0C,kGAAiB;AAC3D;AACA;AACA,aAAa;AACb,yGAAyG;AACzG;AACA;AACA;AACA;AACA;;AAEA+  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/async-storage/request-async-storage-wrapper.js|ssr  import { FLIGHT_PARAMETERS } from "../../client/components/app-router-headers";
import { HeadersAdapter } from "../web/spec-extension/adapters/headers";
import { MutableRequestCookiesAdapter, RequestCookiesAdapter } from "../web/spec-extension/adapters/request-cookies";
import { RequestCookies } from "../web/spec-extension/cookies";
import { DraftModeProvider } from "./draft-mode-provider";
function getHeaders(headers) {
    const cleaned = HeadersAdapter.from(headers);
    for (const param of FLIGHT_PARAMETERS){
        cleaned.delete(param.toString().toLowerCase());
    }
    return HeadersAdapter.seal(cleaned);
}
function getCookies(headers) {
    const cookies = new RequestCookies(HeadersAdapter.from(headers));
    return RequestCookiesAdapter.seal(cookies);
}
function getMutableCookies(headers, onUpdateCookies) {
    const cookies = new RequestCookies(HeadersAdapter.from(headers));
    return MutableRequestCookiesAdapter.wrap(cookies, onUpdateCookies);
}
export const RequestAsyncStorageWrapper = {
    /**
   * Wrap the callback with the given store so it can access the underlying
   * store using hooks.
   *
   * @param storage underlying storage object returned by the module
   * @param context context to seed the store
   * @param callback function to call within the scope of the context
   * @returns the result returned by the callback
   */ wrap (storage, { req, res, renderOpts }, callback) {
        let previewProps = undefined;
        if (renderOpts && "previewProps" in renderOpts) {
            // TODO: investigate why previewProps isn't on RenderOpts
            previewProps = renderOpts.previewProps;
        }
        function defaultOnUpdateCookies(cookies) {
            if (res) {
                res.setHeader("Set-Cookie", cookies);
            }
        }
        const cache = {};
        const store = {
            get headers () {
                if (!cache.headers) {
                    // Seal the headers object that'll freeze out any methods that could
                    // mutate the underlying data.
                    cache.headers = getHeaders(req.headers);
                }
                return cache.headers;
            },
            get cookies () {
                if (!cache.cookies) {
                    // Seal the cookies object that'll freeze out any methods that could
                    // mutate the underlying data.
                    cache.cookies = getCookies(req.headers);
                }
                return cache.cookies;
            },
            get mutableCookies () {
                if (!cache.mutableCookies) {
                    cache.mutableCookies = getMutableCookies(req.headers, (renderOpts == null ? void 0 : renderOpts.onUpdateCookies) || (res ? defaultOnUpdateCookies : undefined));
                }
                return cache.mutableCookies;
            },
            get draftMode () {
                if (!cache.draftMode) {
                    cache.draftMode = new DraftModeProvider(previewProps, req, this.cookies, this.mutableCookies);
                }
                return cache.draftMode;
            },
            reactLoadableManifest: (renderOpts == null ? void 0 : renderOpts.reactLoadableManifest) || {},
            assetPrefix: (renderOpts == null ? void 0 : renderOpts.assetPrefix) || ""
        };
        return storage.run(store, callback, store);
    }
};

//# sourceMappingURL=request-async-storage-wrapper.js.map ìú·  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/async-storage/request-async-storage-wrapper.js|ssr078undefined80151undefined153269undefined271333undefined335392undefined445458__WEBPACK_MODULE_REFERENCE__1_5b224865616465727341646170746572225d_call_asiSafe1__._undefined499515__WEBPACK_MODULE_REFERENCE__0_5b22464c494748545f504152414d4554455253225d_directImport_asiSafe1__._undefined592605__WEBPACK_MODULE_REFERENCE__1_5b224865616465727341646170746572225d_call_asiSafe1__._undefined679692__WEBPACK_MODULE_REFERENCE__3_5b2252657175657374436f6f6b696573225d_directImport_asiSafe1__._undefined694707__WEBPACK_MODULE_REFERENCE__1_5b224865616465727341646170746572225d_call_asiSafe1__._undefined736756__WEBPACK_MODULE_REFERENCE__2_5b2252657175657374436f6f6b69657341646170746572225d_call_asiSafe1__._undefined854867__WEBPACK_MODULE_REFERENCE__3_5b2252657175657374436f6f6b696573225d_directImport_asiSafe1__._undefined869882__WEBPACK_MODULE_REFERENCE__1_5b224865616465727341646170746572225d_call_asiSafe1__._undefined911938__WEBPACK_MODULE_REFERENCE__2_5b224d757461626c6552657175657374436f6f6b69657341646170746572225d_call_asiSafe1__._undefined974980undefined29863002__WEBPACK_MODULE_REFERENCE__5_5b2244726166744d6f646550726f7669646572225d_directImport_asiSafe1__._undefined
`8R‹   ´     b  µ  ÿ  Z  \  ¯  Ì  -    ê  ì  ?  \  Ë  Ä  %  ¦adapters_headers/* HeadersAdapter */.h¬app_router_headers/* FLIGHT_PARAMETERS */.vuþ¬spec_extension_cookies/* RequestCookies */.qý­request_cookies/* RequestCookiesAdapter */.Qbþü´request_cookies/* MutableRequestCookiesAdapter */.vr‘DraftModeProvider€†buffer†source„size„maps„hash4  
// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  B: () => (/* binding */ RequestAsyncStorageWrapper)
});

// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/app-router-headers.js
var app_router_headers = __webpack_require__(3185);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/adapters/headers.js
var adapters_headers = __webpack_require__(3581);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/adapters/request-cookies.js
var request_cookies = __webpack_require__(4488);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/cookies.js
var spec_extension_cookies = __webpack_require__(9474);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/api-utils/index.js
var api_utils = __webpack_require__(2533);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/async-storage/draft-mode-provider.js

class DraftModeProvider {
    constructor(previewProps, req, cookies, mutableCookies){
        var _cookies_get;
        // The logic for draftMode() is very similar to tryGetPreviewData()
        // but Draft Mode does not have any data associated with it.
        const isOnDemandRevalidate = previewProps && (0,api_utils/* checkIsOnDemandRevalidate */.Iq)(req, previewProps).isOnDemandRevalidate;
        const cookieValue = (_cookies_get = cookies.get(api_utils/* COOKIE_NAME_PRERENDER_BYPASS */.dS)) == null ? void 0 : _cookies_get.value;
        this.isEnabled = Boolean(!isOnDemandRevalidate && cookieValue && previewProps && cookieValue === previewProps.previewModeId);
        this._previewModeId = previewProps == null ? void 0 : previewProps.previewModeId;
        this._mutableCookies = mutableCookies;
    }
    enable() {
        if (!this._previewModeId) {
            throw new Error("Invariant: previewProps missing previewModeId this should never happen");
        }
        this._mutableCookies.set({
            name: api_utils/* COOKIE_NAME_PRERENDER_BYPASS */.dS,
            value: this._previewModeId,
            httpOnly: true,
            sameSite:  true ? "none" : 0,
            secure: "production" !== "development",
            path: "/"
        });
    }
    disable() {
        // To delete a cookie, set `expires` to a date in the past:
        // https://tools.ietf.org/html/rfc6265#section-4.1.1
        // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.
        this._mutableCookies.set({
            name: api_utils/* COOKIE_NAME_PRERENDER_BYPASS */.dS,
            value: "",
            httpOnly: true,
            sameSite:  true ? "none" : 0,
            secure: "production" !== "development",
            path: "/",
            expires: new Date(0)
        });
    }
}

//# sourceMappingURL=draft-mode-provider.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/async-storage/request-async-storage-wrapper.js





function getHeaders(headers) {
    const cleaned = adapters_headers/* HeadersAdapter */.h.from(headers);
    for (const param of app_router_headers/* FLIGHT_PARAMETERS */.vu){
        cleaned.delete(param.toString().toLowerCase());
    }
    return adapters_headers/* HeadersAdapter */.h.seal(cleaned);
}
function getCookies(headers) {
    const cookies = new spec_extension_cookies/* RequestCookies */.q(adapters_headers/* HeadersAdapter */.h.from(headers));
    return request_cookies/* RequestCookiesAdapter */.Qb.seal(cookies);
}
function getMutableCookies(headers, onUpdateCookies) {
    const cookies = new spec_extension_cookies/* RequestCookies */.q(adapters_headers/* HeadersAdapter */.h.from(headers));
    return request_cookies/* MutableRequestCookiesAdapter */.vr.wrap(cookies, onUpdateCookies);
}
const RequestAsyncStorageWrapper = {
    /**
   * Wrap the callback with the given store so it can access the underlying
   * store using hooks.
   *
   * @param storage underlying storage object returned by the module
   * @param context context to seed the store
   * @param callback function to call within the scope of the context
   * @returns the result returned by the callback
   */ wrap (storage, { req, res, renderOpts }, callback) {
        let previewProps = undefined;
        if (renderOpts && "previewProps" in renderOpts) {
            // TODO: investigate why previewProps isn't on RenderOpts
            previewProps = renderOpts.previewProps;
        }
        function defaultOnUpdateCookies(cookies) {
            if (res) {
                res.setHeader("Set-Cookie", cookies);
            }
        }
        const cache = {};
        const store = {
            get headers () {
                if (!cache.headers) {
                    // Seal the headers object that'll freeze out any methods that could
                    // mutate the underlying data.
                    cache.headers = getHeaders(req.headers);
                }
                return cache.headers;
            },
            get cookies () {
                if (!cache.cookies) {
                    // Seal the cookies object that'll freeze out any methods that could
                    // mutate the underlying data.
                    cache.cookies = getCookies(req.headers);
                }
                return cache.cookies;
            },
            get mutableCookies () {
                if (!cache.mutableCookies) {
                    cache.mutableCookies = getMutableCookies(req.headers, (renderOpts == null ? void 0 : renderOpts.onUpdateCookies) || (res ? defaultOnUpdateCookies : undefined));
                }
                return cache.mutableCookies;
            },
            get draftMode () {
                if (!cache.draftMode) {
                    cache.draftMode = new DraftModeProvider(previewProps, req, this.cookies, this.mutableCookies);
                }
                return cache.draftMode;
            },
            reactLoadableManifest: (renderOpts == null ? void 0 : renderOpts.reactLoadableManifest) || {},
            assetPrefix: (renderOpts == null ? void 0 : renderOpts.assetPrefix) || ""
        };
        return storage.run(store, callback, store);
    }
};

//# sourceMappingURL=request-async-storage-wrapper.js.map€”{"finalSource":true}ƒmap‹bufferedMap‡version„fileˆmappings‡sourcesŽsourcesContent…namesx¬  ;;;;;;;;;;;;;;;;;AAAuF;AAChF;AACP;AACA;AACA;AACA;AACA,qDAAqD,+CAAyB;AAC9E,wDAAwD,8CAA4B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8CAA4B;AAC9C;AACA;AACA,sBAAsB,KAAsC,YAAY,CAAK;AAC7E,oBAAoB,YAAoB;AACxC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8CAA4B;AAC9C;AACA;AACA,sBAAsB,KAAsC,YAAY,CAAK;AAC7E,oBAAoB,YAAoB;AACxC;AACA;AACA,SAAS;AACT;AACA;;AAEA,+C;;ACzC+E;AACP;AAC6C;AACtD;AACL;AAC1D;AACA,oBAAoB,sCAAc;AAClC,wBAAwB,4CAAiB;AACzC;AACA;AACA,WAAW,sCAAc;AACzB;AACA;AACA,wBAAwB,4CAAc,CAAC,sCAAc;AACrD,WAAW,6CAAqB;AAChC;AACA;AACA,wBAAwB,4CAAc,CAAC,sCAAc;AACrD,WAAW,oDAA4B;AACvC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,0CAA0C,iBAAiB;AAC3D;AACA;AACA,aAAa;AACb,yGAAyG;AACzG;AACA;AACA;AACA;AACA;;AAEA!  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/async-storage/draft-mode-provider.js|ssr+  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/async-storage/request-async-storage-wrapper.js|ssrÉ  import { COOKIE_NAME_PRERENDER_BYPASS, checkIsOnDemandRevalidate } from "../api-utils";
export class DraftModeProvider {
    constructor(previewProps, req, cookies, mutableCookies){
        var _cookies_get;
        // The logic for draftMode() is very similar to tryGetPreviewData()
        // but Draft Mode does not have any data associated with it.
        const isOnDemandRevalidate = previewProps && checkIsOnDemandRevalidate(req, previewProps).isOnDemandRevalidate;
        const cookieValue = (_cookies_get = cookies.get(COOKIE_NAME_PRERENDER_BYPASS)) == null ? void 0 : _cookies_get.value;
        this.isEnabled = Boolean(!isOnDemandRevalidate && cookieValue && previewProps && cookieValue === previewProps.previewModeId);
        this._previewModeId = previewProps == null ? void 0 : previewProps.previewModeId;
        this._mutableCookies = mutableCookies;
    }
    enable() {
        if (!this._previewModeId) {
            throw new Error("Invariant: previewProps missing previewModeId this should never happen");
        }
        this._mutableCookies.set({
            name: COOKIE_NAME_PRERENDER_BYPASS,
            value: this._previewModeId,
            httpOnly: true,
            sameSite: process.env.NODE_ENV !== "development" ? "none" : "lax",
            secure: process.env.NODE_ENV !== "development",
            path: "/"
        });
    }
    disable() {
        // To delete a cookie, set `expires` to a date in the past:
        // https://tools.ietf.org/html/rfc6265#section-4.1.1
        // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.
        this._mutableCookies.set({
            name: COOKIE_NAME_PRERENDER_BYPASS,
            value: "",
            httpOnly: true,
            sameSite: process.env.NODE_ENV !== "development" ? "none" : "lax",
            secure: process.env.NODE_ENV !== "development",
            path: "/",
            expires: new Date(0)
        });
    }
}

//# sourceMappingURL=draft-mode-provider.js.map  import { FLIGHT_PARAMETERS } from "../../client/components/app-router-headers";
import { HeadersAdapter } from "../web/spec-extension/adapters/headers";
import { MutableRequestCookiesAdapter, RequestCookiesAdapter } from "../web/spec-extension/adapters/request-cookies";
import { RequestCookies } from "../web/spec-extension/cookies";
import { DraftModeProvider } from "./draft-mode-provider";
function getHeaders(headers) {
    const cleaned = HeadersAdapter.from(headers);
    for (const param of FLIGHT_PARAMETERS){
        cleaned.delete(param.toString().toLowerCase());
    }
    return HeadersAdapter.seal(cleaned);
}
function getCookies(headers) {
    const cookies = new RequestCookies(HeadersAdapter.from(headers));
    return RequestCookiesAdapter.seal(cookies);
}
function getMutableCookies(headers, onUpdateCookies) {
    const cookies = new RequestCookies(HeadersAdapter.from(headers));
    return MutableRequestCookiesAdapter.wrap(cookies, onUpdateCookies);
}
export const RequestAsyncStorageWrapper = {
    /**
   * Wrap the callback with the given store so it can access the underlying
   * store using hooks.
   *
   * @param storage underlying storage object returned by the module
   * @param context context to seed the store
   * @param callback function to call within the scope of the context
   * @returns the result returned by the callback
   */ wrap (storage, { req, res, renderOpts }, callback) {
        let previewProps = undefined;
        if (renderOpts && "previewProps" in renderOpts) {
            // TODO: investigate why previewProps isn't on RenderOpts
            previewProps = renderOpts.previewProps;
        }
        function defaultOnUpdateCookies(cookies) {
            if (res) {
                res.setHeader("Set-Cookie", cookies);
            }
        }
        const cache = {};
        const store = {
            get headers () {
                if (!cache.headers) {
                    // Seal the headers object that'll freeze out any methods that could
                    // mutate the underlying data.
                    cache.headers = getHeaders(req.headers);
                }
                return cache.headers;
            },
            get cookies () {
                if (!cache.cookies) {
                    // Seal the cookies object that'll freeze out any methods that could
                    // mutate the underlying data.
                    cache.cookies = getCookies(req.headers);
                }
                return cache.cookies;
            },
            get mutableCookies () {
                if (!cache.mutableCookies) {
                    cache.mutableCookies = getMutableCookies(req.headers, (renderOpts == null ? void 0 : renderOpts.onUpdateCookies) || (res ? defaultOnUpdateCookies : undefined));
                }
                return cache.mutableCookies;
            },
            get draftMode () {
                if (!cache.draftMode) {
                    cache.draftMode = new DraftModeProvider(previewProps, req, this.cookies, this.mutableCookies);
                }
                return cache.draftMode;
            },
            reactLoadableManifest: (renderOpts == null ? void 0 : renderOpts.reactLoadableManifest) || {},
            assetPrefix: (renderOpts == null ? void 0 : renderOpts.assetPrefix) || ""
        };
        return storage.run(store, callback, store);
    }
};

//# sourceMappingURL=request-async-storage-wrapper.js.map `   ConcatSourceRawSource  
// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  B: () => (/* binding */ RequestAsyncStorageWrapper)
});

// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/app-router-headers.js
var app_router_headers = __webpack_require__(3185);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/adapters/headers.js
var adapters_headers = __webpack_require__(3581);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/adapters/request-cookies.js
var request_cookies = __webpack_require__(4488);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/cookies.js
var spec_extension_cookies = __webpack_require__(9474);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/api-utils/index.js
var api_utils = __webpack_require__(2533);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/async-storage/draft-mode-provider.js
   ReplaceSource   ReplaceSourceOriginalSourceõã  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/async-storage/draft-mode-provider.js|ssr086undefined8894undefined406430__WEBPACK_MODULE_REFERENCE__4_5b22636865636b49734f6e44656d616e64526576616c6964617465225d_call_directImport_asiSafe1__._undefined529556__WEBPACK_MODULE_REFERENCE__4_5b22434f4f4b49455f4e414d455f50524552454e4445525f425950415353225d_directImport_asiSafe1__._undefined10931120__WEBPACK_MODULE_REFERENCE__4_5b22434f4f4b49455f4e414d455f50524552454e4445525f425950415353225d_directImport_asiSafe1__._undefined12131250 trueundefined126312670undefined12901309"production"undefined16491676__WEBPACK_MODULE_REFERENCE__4_5b22434f4f4b49455f4e414d455f50524552454e4445525f425950415353225d_directImport_asiSafe1__._undefined17521789 trueundefined180218060undefined18291848"production"undefined  312430(0,api_utils/* checkIsOnDemandRevalidate */.Iq)undefined529648api_utils/* COOKIE_NAME_PRERENDER_BYPASS */.dSundefined11851304api_utils/* COOKIE_NAME_PRERENDER_BYPASS */.dSundefined17881907api_utils/* COOKIE_NAME_PRERENDER_BYPASS */.dSundefinedRawSourcem   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/async-storage/request-async-storage-wrapper.js
ûüó·  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/async-storage/request-async-storage-wrapper.js|ssr078undefined80151undefined153269undefined271333undefined335392undefined445458__WEBPACK_MODULE_REFERENCE__1_5b224865616465727341646170746572225d_call_asiSafe1__._undefined499515__WEBPACK_MODULE_REFERENCE__0_5b22464c494748545f504152414d4554455253225d_directImport_asiSafe1__._undefined592605__WEBPACK_MODULE_REFERENCE__1_5b224865616465727341646170746572225d_call_asiSafe1__._undefined679692__WEBPACK_MODULE_REFERENCE__3_5b2252657175657374436f6f6b696573225d_directImport_asiSafe1__._undefined694707__WEBPACK_MODULE_REFERENCE__1_5b224865616465727341646170746572225d_call_asiSafe1__._undefined736756__WEBPACK_MODULE_REFERENCE__2_5b2252657175657374436f6f6b69657341646170746572225d_call_asiSafe1__._undefined854867__WEBPACK_MODULE_REFERENCE__3_5b2252657175657374436f6f6b696573225d_directImport_asiSafe1__._undefined869882__WEBPACK_MODULE_REFERENCE__1_5b224865616465727341646170746572225d_call_asiSafe1__._undefined911938__WEBPACK_MODULE_REFERENCE__2_5b224d757461626c6552657175657374436f6f6b69657341646170746572225d_call_asiSafe1__._undefined974980undefined29863002__WEBPACK_MODULE_REFERENCE__5_5b2244726166744d6f646550726f7669646572225d_directImport_asiSafe1__._undefined*  56139adapters_headers/* HeadersAdapter */.hundefined180277app_router_headers/* FLIGHT_PARAMETERS */.vuundefined354437adapters_headers/* HeadersAdapter */.hundefined511602spec_extension_cookies/* RequestCookies */.qundefined604687adapters_headers/* HeadersAdapter */.hundefined716813request_cookies/* RequestCookiesAdapter */.Qbundefined9111002spec_extension_cookies/* RequestCookies */.qundefined10041087adapters_headers/* HeadersAdapter */.hundefined11161227request_cookies/* MutableRequestCookiesAdapter */.vrundefined32683365DraftModeProviderundefined
   

/***/ })‡óÿÿ  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  B: () => (/* binding */ RequestAsyncStorageWrapper)
});

// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/app-router-headers.js
var app_router_headers = __webpack_require__(3185);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/adapters/headers.js
var adapters_headers = __webpack_require__(3581);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/adapters/request-cookies.js
var request_cookies = __webpack_require__(4488);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/cookies.js
var spec_extension_cookies = __webpack_require__(9474);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/api-utils/index.js
var api_utils = __webpack_require__(2533);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/async-storage/draft-mode-provider.js

class DraftModeProvider {
    constructor(previewProps, req, cookies, mutableCookies){
        var _cookies_get;
        // The logic for draftMode() is very similar to tryGetPreviewData()
        // but Draft Mode does not have any data associated with it.
        const isOnDemandRevalidate = previewProps && (0,api_utils/* checkIsOnDemandRevalidate */.Iq)(req, previewProps).isOnDemandRevalidate;
        const cookieValue = (_cookies_get = cookies.get(api_utils/* COOKIE_NAME_PRERENDER_BYPASS */.dS)) == null ? void 0 : _cookies_get.value;
        this.isEnabled = Boolean(!isOnDemandRevalidate && cookieValue && previewProps && cookieValue === previewProps.previewModeId);
        this._previewModeId = previewProps == null ? void 0 : previewProps.previewModeId;
        this._mutableCookies = mutableCookies;
    }
    enable() {
        if (!this._previewModeId) {
            throw new Error("Invariant: previewProps missing previewModeId this should never happen");
        }
        this._mutableCookies.set({
            name: api_utils/* COOKIE_NAME_PRERENDER_BYPASS */.dS,
            value: this._previewModeId,
            httpOnly: true,
            sameSite:  true ? "none" : 0,
            secure: "production" !== "development",
            path: "/"
        });
    }
    disable() {
        // To delete a cookie, set `expires` to a date in the past:
        // https://tools.ietf.org/html/rfc6265#section-4.1.1
        // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.
        this._mutableCookies.set({
            name: api_utils/* COOKIE_NAME_PRERENDER_BYPASS */.dS,
            value: "",
            httpOnly: true,
            sameSite:  true ? "none" : 0,
            secure: "production" !== "development",
            path: "/",
            expires: new Date(0)
        });
    }
}

//# sourceMappingURL=draft-mode-provider.js.map
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/server/async-storage/request-async-storage-wrapper.js





function getHeaders(headers) {
    const cleaned = adapters_headers/* HeadersAdapter */.h.from(headers);
    for (const param of app_router_headers/* FLIGHT_PARAMETERS */.vu){
        cleaned.delete(param.toString().toLowerCase());
    }
    return adapters_headers/* HeadersAdapter */.h.seal(cleaned);
}
function getCookies(headers) {
    const cookies = new spec_extension_cookies/* RequestCookies */.q(adapters_headers/* HeadersAdapter */.h.from(headers));
    return request_cookies/* RequestCookiesAdapter */.Qb.seal(cookies);
}
function getMutableCookies(headers, onUpdateCookies) {
    const cookies = new spec_extension_cookies/* RequestCookies */.q(adapters_headers/* HeadersAdapter */.h.from(headers));
    return request_cookies/* MutableRequestCookiesAdapter */.vr.wrap(cookies, onUpdateCookies);
}
const RequestAsyncStorageWrapper = {
    /**
   * Wrap the callback with the given store so it can access the underlying
   * store using hooks.
   *
   * @param storage underlying storage object returned by the module
   * @param context context to seed the store
   * @param callback function to call within the scope of the context
   * @returns the result returned by the callback
   */ wrap (storage, { req, res, renderOpts }, callback) {
        let previewProps = undefined;
        if (renderOpts && "previewProps" in renderOpts) {
            // TODO: investigate why previewProps isn't on RenderOpts
            previewProps = renderOpts.previewProps;
        }
        function defaultOnUpdateCookies(cookies) {
            if (res) {
                res.setHeader("Set-Cookie", cookies);
            }
        }
        const cache = {};
        const store = {
            get headers () {
                if (!cache.headers) {
                    // Seal the headers object that'll freeze out any methods that could
                    // mutate the underlying data.
                    cache.headers = getHeaders(req.headers);
                }
                return cache.headers;
            },
            get cookies () {
                if (!cache.cookies) {
                    // Seal the cookies object that'll freeze out any methods that could
                    // mutate the underlying data.
                    cache.cookies = getCookies(req.headers);
                }
                return cache.cookies;
            },
            get mutableCookies () {
                if (!cache.mutableCookies) {
                    cache.mutableCookies = getMutableCookies(req.headers, (renderOpts == null ? void 0 : renderOpts.onUpdateCookies) || (res ? defaultOnUpdateCookies : undefined));
                }
                return cache.mutableCookies;
            },
            get draftMode () {
                if (!cache.draftMode) {
                    cache.draftMode = new DraftModeProvider(previewProps, req, this.cookies, this.mutableCookies);
                }
                return cache.draftMode;
            },
            reactLoadableManifest: (renderOpts == null ? void 0 : renderOpts.reactLoadableManifest) || {},
            assetPrefix: (renderOpts == null ? void 0 : renderOpts.assetPrefix) || ""
        };
        return storage.run(store, callback, store);
    }
};

//# sourceMappingURL=request-async-storage-wrapper.js.map

/***/ })ˆóÿÿ‹óÿÿ’óÿÿx¯  ;;;;;;;;;;;;;;;;;;;;AAAuF;AAChF;AACP;AACA;AACA;AACA;AACA,qDAAqD,+CAAyB;AAC9E,wDAAwD,8CAA4B;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8CAA4B;AAC9C;AACA;AACA,sBAAsB,KAAsC,YAAY,CAAK;AAC7E,oBAAoB,YAAoB;AACxC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8CAA4B;AAC9C;AACA;AACA,sBAAsB,KAAsC,YAAY,CAAK;AAC7E,oBAAoB,YAAoB;AACxC;AACA;AACA,SAAS;AACT;AACA;;AAEA;;ACzC+E;AACP;AAC6C;AACtD;AACL;AAC1D;AACA,oBAAoB,sCAAc;AAClC,wBAAwB,4CAAiB;AACzC;AACA;AACA,WAAW,sCAAc;AACzB;AACA;AACA,wBAAwB,4CAAc,CAAC,sCAAc;AACrD,WAAW,6CAAqB;AAChC;AACA;AACA,wBAAwB,4CAAc,CAAC,sCAAc;AACrD,WAAW,oDAA4B;AACvC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,0CAA0C,iBAAiB;AAC3D;AACA;AACA,aAAa;AACb,yGAAyG;AACzG;AACA;AACA;AACA;AACA;;AAEA,yD!  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/async-storage/draft-mode-provider.js|ssr+  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/server/async-storage/request-async-storage-wrapper.js|ssrÉ  import { COOKIE_NAME_PRERENDER_BYPASS, checkIsOnDemandRevalidate } from "../api-utils";
export class DraftModeProvider {
    constructor(previewProps, req, cookies, mutableCookies){
        var _cookies_get;
        // The logic for draftMode() is very similar to tryGetPreviewData()
        // but Draft Mode does not have any data associated with it.
        const isOnDemandRevalidate = previewProps && checkIsOnDemandRevalidate(req, previewProps).isOnDemandRevalidate;
        const cookieValue = (_cookies_get = cookies.get(COOKIE_NAME_PRERENDER_BYPASS)) == null ? void 0 : _cookies_get.value;
        this.isEnabled = Boolean(!isOnDemandRevalidate && cookieValue && previewProps && cookieValue === previewProps.previewModeId);
        this._previewModeId = previewProps == null ? void 0 : previewProps.previewModeId;
        this._mutableCookies = mutableCookies;
    }
    enable() {
        if (!this._previewModeId) {
            throw new Error("Invariant: previewProps missing previewModeId this should never happen");
        }
        this._mutableCookies.set({
            name: COOKIE_NAME_PRERENDER_BYPASS,
            value: this._previewModeId,
            httpOnly: true,
            sameSite: process.env.NODE_ENV !== "development" ? "none" : "lax",
            secure: process.env.NODE_ENV !== "development",
            path: "/"
        });
    }
    disable() {
        // To delete a cookie, set `expires` to a date in the past:
        // https://tools.ietf.org/html/rfc6265#section-4.1.1
        // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.
        this._mutableCookies.set({
            name: COOKIE_NAME_PRERENDER_BYPASS,
            value: "",
            httpOnly: true,
            sameSite: process.env.NODE_ENV !== "development" ? "none" : "lax",
            secure: process.env.NODE_ENV !== "development",
            path: "/",
            expires: new Date(0)
        });
    }
}

//# sourceMappingURL=draft-mode-provider.js.map  import { FLIGHT_PARAMETERS } from "../../client/components/app-router-headers";
import { HeadersAdapter } from "../web/spec-extension/adapters/headers";
import { MutableRequestCookiesAdapter, RequestCookiesAdapter } from "../web/spec-extension/adapters/request-cookies";
import { RequestCookies } from "../web/spec-extension/cookies";
import { DraftModeProvider } from "./draft-mode-provider";
function getHeaders(headers) {
    const cleaned = HeadersAdapter.from(headers);
    for (const param of FLIGHT_PARAMETERS){
        cleaned.delete(param.toString().toLowerCase());
    }
    return HeadersAdapter.seal(cleaned);
}
function getCookies(headers) {
    const cookies = new RequestCookies(HeadersAdapter.from(headers));
    return RequestCookiesAdapter.seal(cookies);
}
function getMutableCookies(headers, onUpdateCookies) {
    const cookies = new RequestCookies(HeadersAdapter.from(headers));
    return MutableRequestCookiesAdapter.wrap(cookies, onUpdateCookies);
}
export const RequestAsyncStorageWrapper = {
    /**
   * Wrap the callback with the given store so it can access the underlying
   * store using hooks.
   *
   * @param storage underlying storage object returned by the module
   * @param context context to seed the store
   * @param callback function to call within the scope of the context
   * @returns the result returned by the callback
   */ wrap (storage, { req, res, renderOpts }, callback) {
        let previewProps = undefined;
        if (renderOpts && "previewProps" in renderOpts) {
            // TODO: investigate why previewProps isn't on RenderOpts
            previewProps = renderOpts.previewProps;
        }
        function defaultOnUpdateCookies(cookies) {
            if (res) {
                res.setHeader("Set-Cookie", cookies);
            }
        }
        const cache = {};
        const store = {
            get headers () {
                if (!cache.headers) {
                    // Seal the headers object that'll freeze out any methods that could
                    // mutate the underlying data.
                    cache.headers = getHeaders(req.headers);
                }
                return cache.headers;
            },
            get cookies () {
                if (!cache.cookies) {
                    // Seal the cookies object that'll freeze out any methods that could
                    // mutate the underlying data.
                    cache.cookies = getCookies(req.headers);
                }
                return cac