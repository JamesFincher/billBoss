É”createRouterCacheKey˜PrefetchCacheEntryStatusfillLazyItemsTillLeafWithHeadˆnewCacheexistingCache‹routerState‘cacheNodeSeedData„headprefetchEntryisLastSegment†Object„keys†lengthƒkey’parallelRouteState—segmentForParallelRouteˆcacheKeyparallelSeedData‰undefinedŸexistingParallelRoutesCacheNodeŽparallelRoutesƒget“hasReusablePrefetch„kind†statusˆreusable–parallelRouteCacheNodeƒMap‘existingCacheNodeŒnewCacheNodeˆseedNode‡loadingˆlazyDataƒrsc‹prefetchRscŒprefetchHeadlazyDataResolvedƒset–existingParallelRoutesœinvalidateCacheByRouterState›fillCacheWithNewSubTreeDataŽflightDataPath‹isLastEntryparallelRouteKey‡segment—existingChildSegmentMapchildSegmentMap–existingChildCacheNodeŽchildCacheNodeˆseedData…sliceapplyFlightData…cache‰treePatch“fetchServerResponsePAGE_SEGMENT_KEYŸrefreshInactiveParallelSegments‡optionsfetchedSegmentsƒSet£refreshInactiveParallelSegmentsImplˆrootTree‹updatedTree…param…stateŒupdatedCacheŽincludeNextUrlŒcanonicalUrl‹refetchPathrefetchMarkerfetchPromisesƒhasƒaddŒfetchPromiseƒURLˆlocation†origin‡nextUrl‡buildId„thenfetchResponseŠflightData„push”parallelFetchPromise‡Promiseƒall¨addRefreshMarkerToActiveParallelSegments„tree„pathˆincludes“DEFAULT_SEGMENT_KEYŒmatchSegmentŠapplyPatch‹initialTree‰patchTree‘flightSegmentPathŽinitialSegment•initialParallelRoutesŒpatchSegment“patchParallelRoutes‘newParallelRoutes›isInPatchTreeParallelRoutes›applyRouterStatePatchToTree‘flightRouterState‡refetchŒisRootLayoutŽcurrentSegment‹lastSegment’parallelRoutePatch_Ÿ_class_private_field_loose_base_maxConcurrencyž_class_private_field_loose_key_runningCount†_queueŒ_processNextŒPromiseQueue‡enqueue‰promiseFn‹taskResolveŠtaskReject‹taskPromise‡resolve†reject„taskŒrunningCount†result…error‹processNextenqueueResult…queue„bump…index‰findIndex„itemŠbumpedItem†splice‡unshift‹constructorŽmaxConcurrencyŽdefineProperty†forced¬_class_private_field_loose_base__queue_shift…shiftŒPrefetchKindprefetchQueue–createPrefetchCacheKeypathnameFromUrlgetOrCreatePrefetchCacheEntryprefetchCache’existingCacheEntry”interceptionCacheKeyinterceptionDataprefetchCacheKeyŒprefetchData›getPrefetchEntryCacheStatus–switchedToFullPrefetch„FULL—createLazyPrefetchEntry‰TEMPORARY‡process„AUTO prefixExistingPrefetchCacheEntryexistingCacheKey‹newCacheKey†delete¦createPrefetchCacheEntryForInitialLoad„data‰intercept”treeAtTimeOfPrefetchŒprefetchTime„DateƒnowŒlastUsedTime…freshprefetchResponse‹intercepted’prunePrefetchCache„href’prefetchCacheEntry‡expired”DYNAMIC_STALETIME_MS†Numberƒenv¦__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME“STATIC_STALETIME_MS¥__NEXT_CLIENT_ROUTER_STATIC_STALETIME…stale”NEXT_RSC_UNION_QUERYprefetchReducer†actionŒsearchParams›updateCacheNodeOnNavigationŒoldCacheNodeŽoldRouterStateŽnewRouterState–oldRouterStateChildren–newRouterStateChildren”prefetchDataChildren‘oldParallelRoutes–prefetchParallelRoutesšpatchedRouterStateChildrenŒtaskChildren“newRouterStateChild“oldRouterStateChild’oldSegmentMapChild‘prefetchDataChildnewSegmentChild’newSegmentKeyChildoldSegmentChild‘oldCacheNodeChild‰taskChildspawnPendingTaskspawnReusedTask—spawnTaskForMissingData‘newCacheNodeChild„node’newSegmentMapChild…routeŸpatchRouterStateWithNewChildrenˆchildrenbaseRouterState‹newChildren…clonependingCacheNode–createPendingCacheNode‘reusedRouterState—listenForDynamicRequestresponsePromiseˆresponse‹segmentPath‘serverRouterState‹dynamicData‹dynamicHeadŸwriteDynamicDataIntoPendingTask‰abortTaskˆrootTaski‹taskSegment¡finishTaskUsingDynamicDataPayloadˆtaskNode–finishPendingCacheNodeŽserverChildren“dynamicDataChildren–serverRouterStateChilddynamicDataChild“routerStateChildrenrouterStateChildŒsegmentChildsegmentKeyChildisLeafSegmentÎþÿÿmaybePrefetchRsc”maybePrefetchLoading‘createDeferredRsc‰cacheNode‰taskState‹serverState‘taskStateChildren“serverStateChildrenŒdataChildrenŽtaskStateChildserverStateChild‰dataChildsegmentMapChildtaskSegmentChild“taskSegmentKeyChildŽcacheNodeChild•abortPendingCacheNode’dynamicSegmentDataisDeferredRsc†values¤updateCacheNodeOnPopstateRestoration‘shouldUsePrefetchˆDEFERRED†Symbol…valueƒtagŠpendingRscƒresƒrejŒfulfilledRsc‹rejectedRsc†reason¥invalidateCacheBelowFlightSegmentPath’shouldHardNavigate›isNavigatingToNewRootLayouthandleMutable”createEmptyCacheNode clearCacheNodeDataForSegmentPath‘handleExternalUrl‡mutable‹pendingPushmpaNavigation’scrollableSegments™generateSegmentsFromPatch‘flightRouterPatchˆsegmentsparallelRoute‡entriesŒchildSegmentŸtriggerLazyFetchForLeafSegmentsŒcurrentCacheŒappliedPatch’segmentPathsToFillŸþÿÿŒsegmentPathsnavigateReducerŠ__NEXT_PPR“navigateReducer_PPR•navigateReducer_noPPRisExternalUrlŒnavigateTypeŒshouldScrollšpreserveCustomHistoryStateˆtoStringŽprefetchValues”canonicalUrlOverride‹isFirstReadˆdocumentŽgetElementById‹currentTree¡flightSegmentPathWithLeadingEmpty‡newTree‡appliedŒhardNavigateŠsubSegment•scrollableSegmentPath‹patchedTreeŒhashFragmentŠ_postponedŽprefetchedTree’patchedRouterState•handleSegmentMismatch‡console„warn„type„JSON‰stringify’serverPatchReducerŽserverResponse”overrideCanonicalUrl‡pushRef˜canonicalUrlOverrideHref extractPathFromFlightRouterStateŽrestoreReducertreeToRestoreˆoldCache‘focusAndScrollRef¡hasInterceptionRouteInCurrentTreeŽrefreshReducerƒlog–fastRefreshReducerImpl–fastRefreshReducerNoop‡_action’fastRefreshReducerŠcallServer†ACTION–NEXT_ROUTER_STATE_TREEˆNEXT_URL—RSC_CONTENT_TYPE_HEADERcreateFromFetch‹encodeReplyŒNEXT_RUNTIME‡require‹addBasePath‘fetchServerActionˆactionIdŠactionArgs„body…fetch†method‡headers†Accept’encodeURIComponent’NEXT_DEPLOYMENT_IDrevalidatedParts‘revalidatedHeader…parse…paths†cookieeredirectLocation†windowisFlightResponseactionFlightDataŒactionResult“serverActionReducer”inFlightServerAction‡newHref‡BooleanACTION_NAVIGATE“ACTION_SERVER_PATCHŽACTION_RESTOREŽACTION_REFRESHACTION_PREFETCH“ACTION_FAST_REFRESH”ACTION_SERVER_ACTIONclientReducer…ErrorserverReducer‡reducerŠisThenable…ReactstartTransition’ActionQueueContextcreateContext“runRemainingActions‹actionQueueˆsetState‡pending„next‰runActionŒneedsRefreshˆdispatch‰prevState‡payloadŒhandleResult‰nextState‰discardeddevToolsInstance„sendƒerrŽdispatchAction‰resolversdeferredPromise‰newAction„last˜createMutableActionQueueƒuseŠuseContext†useRef‰useEffect‹useCallback”normalizeRouterStateƒvalƒobjˆ$$typeofŽ_bundlerConfigŽhasOwnProperty…Array‡isArrayŽuseUnwrapStateŸuseReducerWithReduxDevtoolsNoopŒinitialStateŸuseReducerWithReduxDevtoolsImplˆuseState•devtoolsConnectionRefŠenabledRef„syncresolvedState‡current›useReducerWithReduxDevtoolsšINTERCEPTION_ROUTE_MARKERSŽisGroupSegment’removeLeadingSlash‘segmentToPathname‘normalizeSegments†reduceƒacc„somemŠstartsWithŒchildrenPath‰childPath–computeChangedPathImpl…treeA…treeBˆsegmentAparallelRoutesAˆsegmentBparallelRoutesB’normalizedSegmentA’normalizedSegmentB‘parallelRouterKey‹changedPath’computeChangedPath…split˜createInitialRouterStateinitialSeedData“initialCanonicalUrl‹initialHead’couldBeInterceptedˆisServer…applyŽonlyHashChange‘initialFlightData“removeTrailingSlash‰parsePathšnormalizePathTrailingSlashœ__NEXT_MANUAL_TRAILING_SLASH…query•__NEXT_TRAILING_SLASH„testˆendsWithaddPathPrefixˆbasePath–__NEXT_ROUTER_BASEPATHˆrequiredž__NEXT_MANUAL_CLIENT_BASE_PATHŒcreatePortalŽANNOUNCER_TYPEŒANNOUNCER_IDgetAnnouncerNode‘existingAnnouncer‘getElementsByNameŠshadowRootŠchildNodes‰containercreateElement…style‡cssText‰announcerˆariaLive‚id„role†shadowŒattachShadow„mode‹appendChild’AppRouterAnnouncerŠportalNodesetPortalNode‘routeAnnouncement”setRouteAnnouncementpreviousTitlefindHeadInCache“findHeadInCacheImpl‰keyPrefixŠisLastItem“childParallelRoutes‹hasBasePathŽremoveBasePathpathHasPrefix…_jsxs‡useMemo’useInsertionEffectAppRouterContext“LayoutRouterContext™GlobalLayoutRouterContext’MissingSlotContext“SearchParamsContextPathnameContextErrorBoundary…isBotRedirectBoundary’unresolvedThenableœglobalServerActionDispatcher™getServerActionDispatcherglobalMutable›urlToUrlWithoutFlightMarkeršurlWithoutFlightParameters”__NEXT_CONFIG_OUTPUT‘getSelectedParams†params’isDynamicParameterŒsegmentValueŠisCatchAllisExternalURLŽHistoryUpdaterŒhistoryStateŽappRouterState‡history„__NAŸ__PRIVATE_NEXTJS_INTERNALS_TREE‰pushStateŒreplaceState™useServerActionDispatcheractionPayload–serverActionDispatcherŒpreviousTree‹useNavigateŽlocationSearchŒcurrentState„HeadheadCacheNode“resolvedPrefetchRscuseDeferredValue‹assetPrefixŒmissingSlotsŒreducerStateˆnavigate‰appRouterŽrouterInstance„back‡forwardˆprefetch‰navigator‰userAgent_options_kind‡replace_options_scroll†scroll‡refresh‹fastRefresh‰location1†assignŽpendingMpaPathŒmatchingHeadŠpathParams‡headKey—DevRootNotFoundBoundary‡content„_jsxˆProvider‹HotReloader–changeByServerResponse”globalErrorComponent…props„restŽerrorComponent†Router@Ø      ConcatSourceRawSource0  // ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  createEmptyCacheNode: () => (/* binding */ app_router_createEmptyCacheNode),
  "default": () => (/* binding */ AppRouter),
  getServerActionDispatcher: () => (/* binding */ getServerActionDispatcher),
  urlToUrlWithoutFlightMarker: () => (/* binding */ urlToUrlWithoutFlightMarker)
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5486);
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__(2428);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/app-router-context.shared-runtime.js
var app_router_context_shared_runtime = __webpack_require__(6099);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/router-reducer-types.js
var router_reducer_types = __webpack_require__(2642);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/create-href-from-url.js
   ReplaceSource   ReplaceSourceSourceMapSourceã   export function createHrefFromUrl(url, includeHash) {
    if (includeHash === void 0) includeHash = true;
    return url.pathname + url.search + (includeHash ? url.hash : "");
} //# sourceMappingURL=create-href-from-url.js.map
x  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/create-href-from-url.ts"],"names":["createHrefFromUrl","url","includeHash","pathname","search","hash"],"mappings":"AAAA,OAAO,SAASA,kBACdC,GAA8C,EAC9CC,WAA2B;IAA3BA,IAAAA,gBAAAA,KAAAA,GAAAA,cAAuB;IAEvB,OAAOD,IAAIE,QAAQ,GAAGF,IAAIG,MAAM,GAAIF,CAAAA,cAAcD,IAAII,IAAI,GAAG,EAAA;AAC/D","file":"x"}   false06undefined;   925create_href_from_url_createHrefFromUrlundefinedRawSourcel  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/hooks-client-context.shared-runtime.js
var hooks_client_context_shared_runtime = __webpack_require__(498);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/fetch-server-response.js
var fetch_server_response = __webpack_require__(10);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/create-router-cache-key.js
var create_router_cache_key = __webpack_require__(2505);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js
ùú   import { createRouterCacheKey } from "./create-router-cache-key";
import { PrefetchCacheEntryStatus } from "./router-reducer-types";
export function fillLazyItemsTillLeafWithHead(newCache, existingCache, routerState, cacheNodeSeedData, head, prefetchEntry) {
    const isLastSegment = Object.keys(routerState[1]).length === 0;
    if (isLastSegment) {
        newCache.head = head;
        return;
    }
    // Remove segment that we got data for so that it is filled in during rendering of rsc.
    for(const key in routerState[1]){
        const parallelRouteState = routerState[1][key];
        const segmentForParallelRoute = parallelRouteState[0];
        const cacheKey = createRouterCacheKey(segmentForParallelRoute);
        // TODO: We should traverse the cacheNodeSeedData tree instead of the router
        // state tree. Ideally, they would always be the same shape, but because of
        // the loading.js pattern, cacheNodeSeedData sometimes only represents a
        // partial tree. That's why this node is sometimes null. Once PPR lands,
        // loading.js will no longer have special behavior and we can traverse the
        // data tree instead.
        //
        // We should also consider merging the router state tree and the data tree
        // in the response format, so that we don't have to send the keys twice.
        // Then the client can convert them into separate representations.
        const parallelSeedData = cacheNodeSeedData !== null && cacheNodeSeedData[1][key] !== undefined ? cacheNodeSeedData[1][key] : null;
        if (existingCache) {
            const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);
            if (existingParallelRoutesCacheNode) {
                const hasReusablePrefetch = (prefetchEntry == null ? void 0 : prefetchEntry.kind) === "auto" && prefetchEntry.status === PrefetchCacheEntryStatus.reusable;
                let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);
                const existingCacheNode = parallelRouteCacheNode.get(cacheKey);
                let newCacheNode;
                if (parallelSeedData !== null) {
                    // New data was sent from the server.
                    const seedNode = parallelSeedData[2];
                    const loading = parallelSeedData[3];
                    newCacheNode = {
                        lazyData: null,
                        rsc: seedNode,
                        // This is a PPR-only field. When PPR is enabled, we shouldn't hit
                        // this path during a navigation, but until PPR is fully implemented
                        // yet it's possible the existing node does have a non-null
                        // `prefetchRsc`. As an incremental step, we'll just de-opt to the
                        // old behavior â€” no PPR value.
                        prefetchRsc: null,
                        head: null,
                        prefetchHead: null,
                        loading,
                        parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes),
                        lazyDataResolved: false
                    };
                } else if (hasReusablePrefetch && existingCacheNode) {
                    // No new data was sent from the server, but the existing cache node
                    // was prefetched, so we should reuse that.
                    newCacheNode = {
                        lazyData: existingCacheNode.lazyData,
                        rsc: existingCacheNode.rsc,
                        // This is a PPR-only field. Unlike the previous branch, since we're
                        // just cloning the existing cache node, we might as well keep the
                        // PPR value, if it exists.
                        prefetchRsc: existingCacheNode.prefetchRsc,
                        head: existingCacheNode.head,
                        prefetchHead: existingCacheNode.prefetchHead,
                        parallelRoutes: new Map(existingCacheNode.parallelRoutes),
                        lazyDataResolved: existingCacheNode.lazyDataResolved,
                        loading: existingCacheNode.loading
                    };
                } else {
                    // No data available for this node. This will trigger a lazy fetch
                    // during render.
                    newCacheNode = {
                        lazyData: null,
                        rsc: null,
                        prefetchRsc: null,
                        head: null,
                        prefetchHead: null,
                        parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes),
                        lazyDataResolved: false,
                        loading: null
                    };
                }
                // Overrides the cache key with the new cache node.
                parallelRouteCacheNode.set(cacheKey, newCacheNode);
                // Traverse deeper to apply the head / fill lazy items till the head.
                fillLazyItemsTillLeafWithHead(newCacheNode, existingCacheNode, parallelRouteState, parallelSeedData ? parallelSeedData : null, head, prefetchEntry);
                newCache.parallelRoutes.set(key, parallelRouteCacheNode);
                continue;
            }
        }
        let newCacheNode;
        if (parallelSeedData !== null) {
            // New data was sent from the server.
            const seedNode = parallelSeedData[2];
            const loading = parallelSeedData[3];
            newCacheNode = {
                lazyData: null,
                rsc: seedNode,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                lazyDataResolved: false,
                loading
            };
        } else {
            // No data available for this node. This will trigger a lazy fetch
            // during render.
            newCacheNode = {
                lazyData: null,
                rsc: null,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                lazyDataResolved: false,
                loading: null
            };
        }
        const existingParallelRoutes = newCache.parallelRoutes.get(key);
        if (existingParallelRoutes) {
            existingParallelRoutes.set(cacheKey, newCacheNode);
        } else {
            newCache.parallelRoutes.set(key, new Map([
                [
                    cacheKey,
                    newCacheNode
                ]
            ]));
        }
        fillLazyItemsTillLeafWithHead(newCacheNode, undefined, parallelRouteState, parallelSeedData, head, prefetchEntry);
    }
} //# sourceMappingURL=fill-lazy-items-till-leaf-with-head.js.map
¢  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.ts"],"names":["createRouterCacheKey","PrefetchCacheEntryStatus","fillLazyItemsTillLeafWithHead","newCache","existingCache","routerState","cacheNodeSeedData","head","prefetchEntry","isLastSegment","Object","keys","length","key","parallelRouteState","segmentForParallelRoute","cacheKey","parallelSeedData","undefined","existingParallelRoutesCacheNode","parallelRoutes","get","hasReusablePrefetch","kind","status","reusable","parallelRouteCacheNode","Map","existingCacheNode","newCacheNode","seedNode","loading","lazyData","rsc","prefetchRsc","prefetchHead","lazyDataResolved","set","existingParallelRoutes"],"mappings":"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","file":"x"}  false064undefined66131undefined133139undefined678697__WEBPACK_MODULE_REFERENCE__7_5b22637265617465526f7574657243616368654b6579225d_call_directImport_asiSafe1__._undefined18661889__WEBPACK_MODULE_REFERENCE__3_5b2250726566657463684361636865456e747279537461747573225d_asiSafe1__._undefined‡  1139fill_lazy_items_till_leaf_with_head_fillLazyItemsTillLeafWithHeadundefined540648(0,create_router_cache_key/* createRouterCacheKey */.d)undefined18171915router_reducer_types/* PrefetchCacheEntryStatus */.T7undefined51455173fill_lazy_items_till_leaf_with_head_fillLazyItemsTillLeafWithHeadundefined67816809fill_lazy_items_till_leaf_with_head_fillLazyItemsTillLeafWithHeadundefinedRawSource|   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/fill-cache-with-new-subtree-data.js
ôõ  import { invalidateCacheByRouterState } from "./invalidate-cache-by-router-state";
import { fillLazyItemsTillLeafWithHead } from "./fill-lazy-items-till-leaf-with-head";
import { createRouterCacheKey } from "./create-router-cache-key";
/**
 * Fill cache with rsc based on flightDataPath
 */ export function fillCacheWithNewSubTreeData(newCache, existingCache, flightDataPath, prefetchEntry) {
    const isLastEntry = flightDataPath.length <= 5;
    const [parallelRouteKey, segment] = flightDataPath;
    const cacheKey = createRouterCacheKey(segment);
    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);
    if (!existingChildSegmentMap) {
        // Bailout because the existing cache does not have the path to the leaf node
        // Will trigger lazy fetch in layout-router because of missing segment
        return;
    }
    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);
    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {
        childSegmentMap = new Map(existingChildSegmentMap);
        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);
    }
    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);
    let childCacheNode = childSegmentMap.get(cacheKey);
    if (isLastEntry) {
        if (!childCacheNode || !childCacheNode.lazyData || childCacheNode === existingChildCacheNode) {
            const seedData = flightDataPath[3];
            const rsc = seedData[2];
            const loading = seedData[3];
            childCacheNode = {
                lazyData: null,
                rsc,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                loading,
                // Ensure segments other than the one we got data for are preserved.
                parallelRoutes: existingChildCacheNode ? new Map(existingChildCacheNode.parallelRoutes) : new Map(),
                lazyDataResolved: false
            };
            if (existingChildCacheNode) {
                invalidateCacheByRouterState(childCacheNode, existingChildCacheNode, flightDataPath[2]);
            }
            fillLazyItemsTillLeafWithHead(childCacheNode, existingChildCacheNode, flightDataPath[2], seedData, flightDataPath[4], prefetchEntry);
            childSegmentMap.set(cacheKey, childCacheNode);
        }
        return;
    }
    if (!childCacheNode || !existingChildCacheNode) {
        // Bailout because the existing cache does not have the path to the leaf node
        // Will trigger lazy fetch in layout-router because of missing segment
        return;
    }
    if (childCacheNode === existingChildCacheNode) {
        childCacheNode = {
            lazyData: childCacheNode.lazyData,
            rsc: childCacheNode.rsc,
            prefetchRsc: childCacheNode.prefetchRsc,
            head: childCacheNode.head,
            prefetchHead: childCacheNode.prefetchHead,
            parallelRoutes: new Map(childCacheNode.parallelRoutes),
            lazyDataResolved: false,
            loading: childCacheNode.loading
        };
        childSegmentMap.set(cacheKey, childCacheNode);
    }
    fillCacheWithNewSubTreeData(childCacheNode, existingChildCacheNode, flightDataPath.slice(2), prefetchEntry);
} //# sourceMappingURL=fill-cache-with-new-subtree-data.js.map
‰  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/fill-cache-with-new-subtree-data.ts"],"names":["invalidateCacheByRouterState","fillLazyItemsTillLeafWithHead","createRouterCacheKey","fillCacheWithNewSubTreeData","newCache","existingCache","flightDataPath","prefetchEntry","isLastEntry","length","parallelRouteKey","segment","cacheKey","existingChildSegmentMap","parallelRoutes","get","childSegmentMap","Map","set","existingChildCacheNode","childCacheNode","lazyData","seedData","rsc","loading","prefetchRsc","head","prefetchHead","lazyDataResolved","slice"],"mappings":"AAKA,SAASA,4BAA4B,QAAQ,qCAAoC;AACjF,SAASC,6BAA6B,QAAQ,wCAAuC;AACrF,SAASC,oBAAoB,QAAQ,4BAA2B;AAGhE;;CAEC,GACD,OAAO,SAASC,4BACdC,QAAmB,EACnBC,aAAwB,EACxBC,cAA8B,EAC9BC,aAAkC;IAElC,MAAMC,cAAcF,eAAeG,MAAM,IAAI;IAC7C,MAAM,CAACC,kBAAkBC,QAAQ,GAAGL;IAEpC,MAAMM,WAAWV,qBAAqBS;IAEtC,MAAME,0BACJR,cAAcS,cAAc,CAACC,GAAG,CAACL;IAEnC,IAAI,CAACG,yBAAyB;QAC5B,6EAA6E;QAC7E,sEAAsE;QACtE;IACF;IAEA,IAAIG,kBAAkBZ,SAASU,cAAc,CAACC,GAAG,CAACL;IAClD,IAAI,CAACM,mBAAmBA,oBAAoBH,yBAAyB;QACnEG,kBAAkB,IAAIC,IAAIJ;QAC1BT,SAASU,cAAc,CAACI,GAAG,CAACR,kBAAkBM;IAChD;IAEA,MAAMG,yBAAyBN,wBAAwBE,GAAG,CAACH;IAC3D,IAAIQ,iBAAiBJ,gBAAgBD,GAAG,CAACH;IAEzC,IAAIJ,aAAa;QACf,IACE,CAACY,kBACD,CAACA,eAAeC,QAAQ,IACxBD,mBAAmBD,wBACnB;YACA,MAAMG,WAA8BhB,cAAc,CAAC,EAAE;YACrD,MAAMiB,MAAMD,QAAQ,CAAC,EAAE;YACvB,MAAME,UAAUF,QAAQ,CAAC,EAAE;YAC3BF,iBAAiB;gBACfC,UAAU;gBACVE;gBACAE,aAAa;gBACbC,MAAM;gBACNC,cAAc;gBACdH;gBACA,oEAAoE;gBACpEV,gBAAgBK,yBACZ,IAAIF,IAAIE,uBAAuBL,cAAc,IAC7C,IAAIG;gBACRW,kBAAkB;YACpB;YAEA,IAAIT,wBAAwB;gBAC1BnB,6BACEoB,gBACAD,wBACAb,cAAc,CAAC,EAAE;YAErB;YAEAL,8BACEmB,gBACAD,wBACAb,cAAc,CAAC,EAAE,EACjBgB,UACAhB,cAAc,CAAC,EAAE,EACjBC;YAGFS,gBAAgBE,GAAG,CAACN,UAAUQ;QAChC;QACA;IACF;IAEA,IAAI,CAACA,kBAAkB,CAACD,wBAAwB;QAC9C,6EAA6E;QAC7E,sEAAsE;QACtE;IACF;IAEA,IAAIC,mBAAmBD,wBAAwB;QAC7CC,iBAAiB;YACfC,UAAUD,eAAeC,QAAQ;YACjCE,KAAKH,eAAeG,GAAG;YACvBE,aAAaL,eAAeK,WAAW;YACvCC,MAAMN,eAAeM,IAAI;YACzBC,cAAcP,eAAeO,YAAY;YACzCb,gBAAgB,IAAIG,IAAIG,eAAeN,cAAc;YACrDc,kBAAkB;YAClBJ,SAASJ,eAAeI,OAAO;QACjC;QACAR,gBAAgBE,GAAG,CAACN,UAAUQ;IAChC;IAEAjB,4BACEiB,gBACAD,wBACAb,eAAeuB,KAAK,CAAC,IACrBtB;AAEJ","file":"x"}=   false081undefined83168undefined170234undefined291297undefinedŸ   6793fill_cache_with_new_subtree_data_fillCacheWithNewSubTreeDataundefined29332959fill_cache_with_new_subtree_data_fillCacheWithNewSubTreeDataundefinedRawSourcem   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/apply-flight-data.js
ïð  import { fillLazyItemsTillLeafWithHead } from "./fill-lazy-items-till-leaf-with-head";
import { fillCacheWithNewSubTreeData } from "./fill-cache-with-new-subtree-data";
export function applyFlightData(existingCache, cache, flightDataPath, prefetchEntry) {
    // The one before last item is the router state tree patch
    const [treePatch, cacheNodeSeedData, head] = flightDataPath.slice(-3);
    // Handles case where prefetch only returns the router tree patch without rendered components.
    if (cacheNodeSeedData === null) {
        return false;
    }
    if (flightDataPath.length === 3) {
        const rsc = cacheNodeSeedData[2];
        const loading = cacheNodeSeedData[3];
        cache.loading = loading;
        cache.rsc = rsc;
        // This is a PPR-only field. When PPR is enabled, we shouldn't hit
        // this path during a navigation, but until PPR is fully implemented
        // yet it's possible the existing node does have a non-null
        // `prefetchRsc`. As an incremental step, we'll just de-opt to the
        // old behavior â€” no PPR value.
        cache.prefetchRsc = null;
        fillLazyItemsTillLeafWithHead(cache, existingCache, treePatch, cacheNodeSeedData, head, prefetchEntry);
    } else {
        // Copy rsc for the root node of the cache.
        cache.rsc = existingCache.rsc;
        // This is a PPR-only field. Unlike the previous branch, since we're
        // just cloning the existing cache node, we might as well keep the
        // PPR value, if it exists.
        cache.prefetchRsc = existingCache.prefetchRsc;
        cache.parallelRoutes = new Map(existingCache.parallelRoutes);
        cache.loading = existingCache.loading;
        // Create a copy of the existing cache with the rsc applied.
        fillCacheWithNewSubTreeData(cache, existingCache, flightDataPath, prefetchEntry);
    }
    return true;
} //# sourceMappingURL=apply-flight-data.js.map
¶  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/apply-flight-data.ts"],"names":["fillLazyItemsTillLeafWithHead","fillCacheWithNewSubTreeData","applyFlightData","existingCache","cache","flightDataPath","prefetchEntry","treePatch","cacheNodeSeedData","head","slice","length","rsc","loading","prefetchRsc","parallelRoutes","Map"],"mappings":"AAEA,SAASA,6BAA6B,QAAQ,wCAAuC;AACrF,SAASC,2BAA2B,QAAQ,qCAAoC;AAGhF,OAAO,SAASC,gBACdC,aAAwB,EACxBC,KAAgB,EAChBC,cAA8B,EAC9BC,aAAkC;IAElC,0DAA0D;IAC1D,MAAM,CAACC,WAAWC,mBAAmBC,KAAK,GAAGJ,eAAeK,KAAK,CAAC,CAAC;IAEnE,8FAA8F;IAC9F,IAAIF,sBAAsB,MAAM;QAC9B,OAAO;IACT;IAEA,IAAIH,eAAeM,MAAM,KAAK,GAAG;QAC/B,MAAMC,MAAMJ,iBAAiB,CAAC,EAAE;QAChC,MAAMK,UAAUL,iBAAiB,CAAC,EAAE;QACpCJ,MAAMS,OAAO,GAAGA;QAChBT,MAAMQ,GAAG,GAAGA;QACZ,kEAAkE;QAClE,oEAAoE;QACpE,2DAA2D;QAC3D,kEAAkE;QAClE,+BAA+B;QAC/BR,MAAMU,WAAW,GAAG;QACpBd,8BACEI,OACAD,eACAI,WACAC,mBACAC,MACAH;IAEJ,OAAO;QACL,2CAA2C;QAC3CF,MAAMQ,GAAG,GAAGT,cAAcS,GAAG;QAC7B,oEAAoE;QACpE,kEAAkE;QAClE,2BAA2B;QAC3BR,MAAMU,WAAW,GAAGX,cAAcW,WAAW;QAC7CV,MAAMW,cAAc,GAAG,IAAIC,IAAIb,cAAcY,cAAc;QAC3DX,MAAMS,OAAO,GAAGV,cAAcU,OAAO;QACrC,4DAA4D;QAC5DZ,4BACEG,OACAD,eACAE,gBACAC;IAEJ;IAEA,OAAO;AACT","file":"x"}.   false085undefined87167undefined169175undefined7   1125apply_flight_data_applyFlightDataundefinedRawSourceò   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/segment.js
var lib_segment = __webpack_require__(8478);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/refetch-inactive-parallel-segments.js
êëS  import { applyFlightData } from "./apply-flight-data";
import { fetchServerResponse } from "./fetch-server-response";
import { PAGE_SEGMENT_KEY } from "../../../shared/lib/segment";
/**
 * Refreshes inactive segments that are still in the current FlightRouterState.
 * A segment is considered "inactive" when the server response indicates it didn't match to a page component.
 * This happens during a soft-navigation, where the server will want to patch in the segment
 * with the "default" component, but we explicitly ignore the server in this case
 * and keep the existing state for that segment. New data for inactive segments are inherently
 * not part of the server response when we patch the tree, because they were associated with a response
 * from an earlier navigation/request. For each segment, once it becomes "active", we encode the URL that provided
 * the data for it. This function traverses parallel routes looking for these markers so that it can re-fetch
 * and patch the new data into the tree.
 */ export async function refreshInactiveParallelSegments(options) {
    const fetchedSegments = new Set();
    await refreshInactiveParallelSegmentsImpl({
        ...options,
        rootTree: options.updatedTree,
        fetchedSegments
    });
}
async function refreshInactiveParallelSegmentsImpl(param) {
    let { state, updatedTree, updatedCache, includeNextUrl, fetchedSegments, rootTree = updatedTree, canonicalUrl } = param;
    const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree;
    const fetchPromises = [];
    if (refetchPath && refetchPath !== canonicalUrl && refetchMarker === "refresh" && // it's possible for the tree to contain multiple segments that contain data at the same URL
    // we keep track of them so we can dedupe the requests
    !fetchedSegments.has(refetchPath)) {
        fetchedSegments.add(refetchPath) // Mark this URL as fetched
        ;
        // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate
        // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.
        const fetchPromise = fetchServerResponse(new URL(refetchPath, location.origin), // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)
        [
            rootTree[0],
            rootTree[1],
            rootTree[2],
            "refetch"
        ], includeNextUrl ? state.nextUrl : null, state.buildId).then((fetchResponse)=>{
            const flightData = fetchResponse[0];
            if (typeof flightData !== "string") {
                for (const flightDataPath of flightData){
                    // we only pass the new cache as this function is called after clearing the router cache
                    // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's
                    // just been created & has been written to, but hasn't been "committed" yet.
                    applyFlightData(updatedCache, updatedCache, flightDataPath);
                }
            } else {
            // When flightData is a string, it suggests that the server response should have triggered an MPA navigation
            // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect
            // when refreshing on-screen data, so handling this has been ommitted.
            }
        });
        fetchPromises.push(fetchPromise);
    }
    for(const key in parallelRoutes){
        const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({
            state,
            updatedTree: parallelRoutes[key],
            updatedCache,
            includeNextUrl,
            fetchedSegments,
            rootTree,
            canonicalUrl
        });
        fetchPromises.push(parallelFetchPromise);
    }
    await Promise.all(fetchPromises);
}
/**
 * Walks the current parallel segments to determine if they are "active".
 * An active parallel route will have a `__PAGE__` segment in the FlightRouterState.
 * As opposed to a `__DEFAULT__` segment, which means there was no match for that parallel route.
 * We add a special marker here so that we know how to refresh its data when the router is revalidated.
 */ export function addRefreshMarkerToActiveParallelSegments(tree, path) {
    const [segment, parallelRoutes, , refetchMarker] = tree;
    // a page segment might also contain concatenated search params, so we do a partial match on the key
    if (segment.includes(PAGE_SEGMENT_KEY) && refetchMarker !== "refresh") {
        tree[2] = path;
        tree[3] = "refresh";
    }
    for(const key in parallelRoutes){
        addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path);
    }
} //# sourceMappingURL=refetch-inactive-parallel-segments.js.map
	  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/refetch-inactive-parallel-segments.ts"],"names":["applyFlightData","fetchServerResponse","PAGE_SEGMENT_KEY","refreshInactiveParallelSegments","options","fetchedSegments","Set","refreshInactiveParallelSegmentsImpl","rootTree","updatedTree","param","state","updatedCache","includeNextUrl","canonicalUrl","parallelRoutes","refetchPath","refetchMarker","fetchPromises","has","add","fetchPromise","URL","location","origin","nextUrl","buildId","then","fetchResponse","flightData","flightDataPath","push","key","parallelFetchPromise","Promise","all","addRefreshMarkerToActiveParallelSegments","tree","path","segment","includes"],"mappings":"AAGA,SAASA,eAAe,QAAQ,sBAAqB;AACrD,SAASC,mBAAmB,QAAQ,0BAAyB;AAC7D,SAASC,gBAAgB,QAAQ,8BAA6B;AAU9D;;;;;;;;;;CAUC,GACD,OAAO,eAAeC,gCACpBC,OAAwC;IAExC,MAAMC,kBAAkB,IAAIC;IAC5B,MAAMC,oCAAoC;QACxC,GAAGH,OAAO;QACVI,UAAUJ,QAAQK,WAAW;QAC7BJ;IACF;AACF;AAEA,eAAeE,oCAAoCG,KAWlD;IAXkD,IAAA,EACjDC,KAAK,EACLF,WAAW,EACXG,YAAY,EACZC,cAAc,EACdR,eAAe,EACfG,WAAWC,WAAW,EACtBK,YAAY,EAIb,GAXkDJ;IAYjD,MAAM,GAAGK,gBAAgBC,aAAaC,cAAc,GAAGR;IACvD,MAAMS,gBAAgB,EAAE;IAExB,IACEF,eACAA,gBAAgBF,gBAChBG,kBAAkB,aAClB,4FAA4F;IAC5F,sDAAsD;IACtD,CAACZ,gBAAgBc,GAAG,CAACH,cACrB;QACAX,gBAAgBe,GAAG,CAACJ,aAAa,2BAA2B;;QAE5D,wHAAwH;QACxH,kIAAkI;QAClI,MAAMK,eAAepB,oBACnB,IAAIqB,IAAIN,aAAaO,SAASC,MAAM,GAEpC,8HAA8H;QAC9H;YAAChB,QAAQ,CAAC,EAAE;YAAEA,QAAQ,CAAC,EAAE;YAAEA,QAAQ,CAAC,EAAE;YAAE;SAAU,EAClDK,iBAAiBF,MAAMc,OAAO,GAAG,MACjCd,MAAMe,OAAO,EACbC,IAAI,CAAC,CAACC;YACN,MAAMC,aAAaD,aAAa,CAAC,EAAE;YACnC,IAAI,OAAOC,eAAe,UAAU;gBAClC,KAAK,MAAMC,kBAAkBD,WAAY;oBACvC,wFAAwF;oBACxF,4GAA4G;oBAC5G,4EAA4E;oBAC5E7B,gBAAgBY,cAAcA,cAAckB;gBAC9C;YACF,OAAO;YACL,4GAA4G;YAC5G,+GAA+G;YAC/G,sEAAsE;YACxE;QACF;QAEAZ,cAAca,IAAI,CAACV;IACrB;IAEA,IAAK,MAAMW,OAAOjB,eAAgB;QAChC,MAAMkB,uBAAuB1B,oCAAoC;YAC/DI;YACAF,aAAaM,cAAc,CAACiB,IAAI;YAChCpB;YACAC;YACAR;YACAG;YACAM;QACF;QAEAI,cAAca,IAAI,CAACE;IACrB;IAEA,MAAMC,QAAQC,GAAG,CAACjB;AACpB;AAEA;;;;;CAKC,GACD,OAAO,SAASkB,yCACdC,IAAuB,EACvBC,IAAY;IAEZ,MAAM,CAACC,SAASxB,kBAAkBE,cAAc,GAAGoB;IACnD,oGAAoG;IACpG,IAAIE,QAAQC,QAAQ,CAACtC,qBAAqBe,kBAAkB,WAAW;QACrEoB,IAAI,CAAC,EAAE,GAAGC;QACVD,IAAI,CAAC,EAAE,GAAG;IACZ;IAEA,IAAK,MAAML,OAAOjB,eAAgB;QAChCqB,yCAAyCrB,cAAc,CAACiB,IAAI,EAAEM;IAChE;AACF","file":"x"}Â   false053undefined55116undefined118180undefined10201026undefined43884394undefined46504665__WEBPACK_MODULE_REFERENCE__11_5b22504147455f5345474d454e545f4b4559225d_directImport_asiSafe1__._undefinedG  856886refetch_inactive_parallel_segments_refreshInactiveParallelSegmentsundefined42114250refetch_inactive_parallel_segments_addRefreshMarkerToActiveParallelSegmentsundefined44574553lib_segment/* PAGE_SEGMENT_KEY */.GCundefined46954734refetch_inactive_parallel_segments_addRefreshMarkerToActiveParallelSegmentsundefinedRawSource|   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/apply-router-state-patch-to-tree.js
åæ¶  import { DEFAULT_SEGMENT_KEY } from "../../../shared/lib/segment";
import { matchSegment } from "../match-segments";
import { addRefreshMarkerToActiveParallelSegments } from "./refetch-inactive-parallel-segments";
/**
 * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.
 */ function applyPatch(initialTree, patchTree, flightSegmentPath) {
    const [initialSegment, initialParallelRoutes] = initialTree;
    const [patchSegment, patchParallelRoutes] = patchTree;
    // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree
    // this is because the __DEFAULT__ segment is used as a placeholder on navigation
    if (patchSegment === DEFAULT_SEGMENT_KEY && initialSegment !== DEFAULT_SEGMENT_KEY) {
        return initialTree;
    }
    if (matchSegment(initialSegment, patchSegment)) {
        const newParallelRoutes = {};
        for(const key in initialParallelRoutes){
            const isInPatchTreeParallelRoutes = typeof patchParallelRoutes[key] !== "undefined";
            if (isInPatchTreeParallelRoutes) {
                newParallelRoutes[key] = applyPatch(initialParallelRoutes[key], patchParallelRoutes[key], flightSegmentPath);
            } else {
                newParallelRoutes[key] = initialParallelRoutes[key];
            }
        }
        for(const key in patchParallelRoutes){
            if (newParallelRoutes[key]) {
                continue;
            }
            newParallelRoutes[key] = patchParallelRoutes[key];
        }
        const tree = [
            initialSegment,
            newParallelRoutes
        ];
        // Copy over the existing tree
        if (initialTree[2]) {
            tree[2] = initialTree[2];
        }
        if (initialTree[3]) {
            tree[3] = initialTree[3];
        }
        if (initialTree[4]) {
            tree[4] = initialTree[4];
        }
        return tree;
    }
    return patchTree;
}
/**
 * Apply the router state from the Flight response, but skip patching default segments.
 * Useful for patching the router cache when navigating, where we persist the existing default segment if there isn't a new one.
 * Creates a new router state tree.
 */ export function applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch, path) {
    const [segment, parallelRoutes, url, refetch, isRootLayout] = flightRouterState;
    // Root refresh
    if (flightSegmentPath.length === 1) {
        const tree = applyPatch(flightRouterState, treePatch, flightSegmentPath);
        addRefreshMarkerToActiveParallelSegments(tree, path);
        return tree;
    }
    const [currentSegment, parallelRouteKey] = flightSegmentPath;
    // Tree path returned from the server should always match up with the current tree in the browser
    if (!matchSegment(currentSegment, segment)) {
        return null;
    }
    const lastSegment = flightSegmentPath.length === 2;
    let parallelRoutePatch;
    if (lastSegment) {
        parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch, flightSegmentPath);
    } else {
        parallelRoutePatch = applyRouterStatePatchToTree(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch, path);
        if (parallelRoutePatch === null) {
            return null;
        }
    }
    const tree = [
        flightSegmentPath[0],
        {
            ...parallelRoutes,
            [parallelRouteKey]: parallelRoutePatch
        },
        url,
        refetch
    ];
    // Current segment is the root layout
    if (isRootLayout) {
        tree[4] = true;
    }
    addRefreshMarkerToActiveParallelSegments(tree, path);
    return tree;
} //# sourceMappingURL=apply-router-state-patch-to-tree.js.map
ò	  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/apply-router-state-patch-to-tree.ts"],"names":["DEFAULT_SEGMENT_KEY","matchSegment","addRefreshMarkerToActiveParallelSegments","applyPatch","initialTree","patchTree","flightSegmentPath","initialSegment","initialParallelRoutes","patchSegment","patchParallelRoutes","newParallelRoutes","key","isInPatchTreeParallelRoutes","tree","applyRouterStatePatchToTree","flightRouterState","treePatch","path","segment","parallelRoutes","url","refetch","isRootLayout","length","currentSegment","parallelRouteKey","lastSegment","parallelRoutePatch","slice"],"mappings":"AAIA,SAASA,mBAAmB,QAAQ,8BAA6B;AACjE,SAASC,YAAY,QAAQ,oBAAmB;AAChD,SAASC,wCAAwC,QAAQ,uCAAsC;AAE/F;;CAEC,GACD,SAASC,WACPC,WAA8B,EAC9BC,SAA4B,EAC5BC,iBAAoC;IAEpC,MAAM,CAACC,gBAAgBC,sBAAsB,GAAGJ;IAChD,MAAM,CAACK,cAAcC,oBAAoB,GAAGL;IAE5C,kGAAkG;IAClG,iFAAiF;IACjF,IACEI,iBAAiBT,uBACjBO,mBAAmBP,qBACnB;QACA,OAAOI;IACT;IAEA,IAAIH,aAAaM,gBAAgBE,eAAe;QAC9C,MAAME,oBAA0C,CAAC;QACjD,IAAK,MAAMC,OAAOJ,sBAAuB;YACvC,MAAMK,8BACJ,OAAOH,mBAAmB,CAACE,IAAI,KAAK;YACtC,IAAIC,6BAA6B;gBAC/BF,iBAAiB,CAACC,IAAI,GAAGT,WACvBK,qBAAqB,CAACI,IAAI,EAC1BF,mBAAmB,CAACE,IAAI,EACxBN;YAEJ,OAAO;gBACLK,iBAAiB,CAACC,IAAI,GAAGJ,qBAAqB,CAACI,IAAI;YACrD;QACF;QAEA,IAAK,MAAMA,OAAOF,oBAAqB;YACrC,IAAIC,iBAAiB,CAACC,IAAI,EAAE;gBAC1B;YACF;YAEAD,iBAAiB,CAACC,IAAI,GAAGF,mBAAmB,CAACE,IAAI;QACnD;QAEA,MAAME,OAA0B;YAACP;YAAgBI;SAAkB;QAEnE,8BAA8B;QAC9B,IAAIP,WAAW,CAAC,EAAE,EAAE;YAClBU,IAAI,CAAC,EAAE,GAAGV,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBU,IAAI,CAAC,EAAE,GAAGV,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBU,IAAI,CAAC,EAAE,GAAGV,WAAW,CAAC,EAAE;QAC1B;QAEA,OAAOU;IACT;IAEA,OAAOT;AACT;AAEA;;;;CAIC,GACD,OAAO,SAASU,4BACdT,iBAAoC,EACpCU,iBAAoC,EACpCC,SAA4B,EAC5BC,IAAY;IAEZ,MAAM,CAACC,SAASC,gBAAgBC,KAAKC,SAASC,aAAa,GACzDP;IAEF,eAAe;IACf,IAAIV,kBAAkBkB,MAAM,KAAK,GAAG;QAClC,MAAMV,OAA0BX,WAC9Ba,mBACAC,WACAX;QAGFJ,yCAAyCY,MAAMI;QAE/C,OAAOJ;IACT;IAEA,MAAM,CAACW,gBAAgBC,iBAAiB,GAAGpB;IAE3C,iGAAiG;IACjG,IAAI,CAACL,aAAawB,gBAAgBN,UAAU;QAC1C,OAAO;IACT;IAEA,MAAMQ,cAAcrB,kBAAkBkB,MAAM,KAAK;IAEjD,IAAII;IACJ,IAAID,aAAa;QACfC,qBAAqBzB,WACnBiB,cAAc,CAACM,iBAAiB,EAChCT,WACAX;IAEJ,OAAO;QACLsB,qBAAqBb,4BACnBT,kBAAkBuB,KAAK,CAAC,IACxBT,cAAc,CAACM,iBAAiB,EAChCT,WACAC;QAGF,IAAIU,uBAAuB,MAAM;YAC/B,OAAO;QACT;IACF;IAEA,MAAMd,OAA0B;QAC9BR,iBAAiB,CAAC,EAAE;QACpB;YACE,GAAGc,cAAc;YACjB,CAACM,iBAAiB,EAAEE;QACtB;QACAP;QACAC;KACD;IAED,qCAAqC;IACrC,IAAIC,cAAc;QAChBT,IAAI,CAAC,EAAE,GAAG;IACZ;IAEAZ,yCAAyCY,MAAMI;IAE/C,OAAOJ;AACT","file":"x"}?   false065undefined67115undefined117212undefined22342240undefined£   20322058apply_router_state_patch_to_tree_applyRouterStatePatchToTreeundefined29342960apply_router_state_patch_to_tree_applyRouterStatePatchToTreeundefinedRawSourceê   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/app-router-headers.js
var app_router_headers = __webpack_require__(3185);
;// CONCATENATED MODULE: ./node_modules/@swc/helpers/esm/_class_private_field_loose_base.js
à   ReplaceSourceOriginalSourcesýÿÿ4  webpack://javascript/esm|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/@swc/helpers/esm/_class_private_field_loose_base.js|ssr06undefined252299undefined	   RawSource\   
;// CONCATENATED MODULE: ./node_modules/@swc/helpers/esm/_class_private_field_loose_key.js
Üüqýÿÿ5  webpack://javascript/esm|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/@swc/helpers/esm/_class_private_field_loose_key.js|ssr1319undefined115161undefinedýZ   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/promise-queue.js
ÚÛ€  /*
    This is a simple promise queue that allows you to limit the number of concurrent promises
    that are running at any given time. It's used to limit the number of concurrent
    prefetch requests that are being made to the server but could be used for other
    things as well.
*/ import { _ as _class_private_field_loose_base } from "@swc/helpers/_/_class_private_field_loose_base";
import { _ as _class_private_field_loose_key } from "@swc/helpers/_/_class_private_field_loose_key";
var _maxConcurrency = /*#__PURE__*/ _class_private_field_loose_key("_maxConcurrency"), _runningCount = /*#__PURE__*/ _class_private_field_loose_key("_runningCount"), _queue = /*#__PURE__*/ _class_private_field_loose_key("_queue"), _processNext = /*#__PURE__*/ _class_private_field_loose_key("_processNext");
export class PromiseQueue {
    enqueue(promiseFn) {
        let taskResolve;
        let taskReject;
        const taskPromise = new Promise((resolve, reject)=>{
            taskResolve = resolve;
            taskReject = reject;
        });
        const task = async ()=>{
            try {
                _class_private_field_loose_base(this, _runningCount)[_runningCount]++;
                const result = await promiseFn();
                taskResolve(result);
            } catch (error) {
                taskReject(error);
            } finally{
                _class_private_field_loose_base(this, _runningCount)[_runningCount]--;
                _class_private_field_loose_base(this, _processNext)[_processNext]();
            }
        };
        const enqueueResult = {
            promiseFn: taskPromise,
            task
        };
        // wonder if we should take a LIFO approach here
        _class_private_field_loose_base(this, _queue)[_queue].push(enqueueResult);
        _class_private_field_loose_base(this, _processNext)[_processNext]();
        return taskPromise;
    }
    bump(promiseFn) {
        const index = _class_private_field_loose_base(this, _queue)[_queue].findIndex((item)=>item.promiseFn === promiseFn);
        if (index > -1) {
            const bumpedItem = _class_private_field_loose_base(this, _queue)[_queue].splice(index, 1)[0];
            _class_private_field_loose_base(this, _queue)[_queue].unshift(bumpedItem);
            _class_private_field_loose_base(this, _processNext)[_processNext](true);
        }
    }
    constructor(maxConcurrency = 5){
        Object.defineProperty(this, _processNext, {
            value: processNext
        });
        Object.defineProperty(this, _maxConcurrency, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _runningCount, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _queue, {
            writable: true,
            value: void 0
        });
        _class_private_field_loose_base(this, _maxConcurrency)[_maxConcurrency] = maxConcurrency;
        _class_private_field_loose_base(this, _runningCount)[_runningCount] = 0;
        _class_private_field_loose_base(this, _queue)[_queue] = [];
    }
}
function processNext(forced) {
    if (forced === void 0) forced = false;
    if ((_class_private_field_loose_base(this, _runningCount)[_runningCount] < _class_private_field_loose_base(this, _maxConcurrency)[_maxConcurrency] || forced) && _class_private_field_loose_base(this, _queue)[_queue].length > 0) {
        var _class_private_field_loose_base__queue_shift;
        (_class_private_field_loose_base__queue_shift = _class_private_field_loose_base(this, _queue)[_queue].shift()) == null ? void 0 : _class_private_field_loose_base__queue_shift.task();
    }
} //# sourceMappingURL=promise-queue.js.map
¼	  {"version":3,"sources":["webpack://../../../src/client/components/promise-queue.ts"],"names":["_","_class_private_field_loose_base","_maxConcurrency","_class_private_field_loose_key","_runningCount","_queue","_processNext","PromiseQueue","enqueue","promiseFn","taskResolve","taskReject","taskPromise","Promise","resolve","reject","task","runningCount","result","error","processNext","enqueueResult","queue","push","bump","index","findIndex","item","bumpedItem","splice","unshift","constructor","maxConcurrency","Object","defineProperty","forced","length","_class_private_field_loose_base__queue_shift","shift"],"mappings":"AAAA;;;;;AAKA,GAAA,SAAAA,KAAAC,+BAAA,QAAA,iDAAA;;IAEEC,kBAAA,WAAA,GAAAC,+BAAA,oBACAC,gBAAA,WAAA,GAAAD,+BAAA,kBACAE,SAAA,WAAA,GAAAF,+BAAA,WAmDAG,eAAA,WAAA,GAAAH,+BAAA;AAtDF,OAAO,MAAMI;IAcXC,QAAWC,SAA2B,EAAc;QAClD,IAAIC;QACJ,IAAIC;QAEJ,MAAMC,cAAc,IAAIC,QAAQ,CAACC,SAASC;YACxCL,cAAcI;YACdH,aAAaI;QACf;QAEA,MAAMC,OAAO;YACX,IAAI;gBACFf,gCAAA,IAAI,EAAEgB,cAAAA,CAAAA,cAAAA;gBACN,MAAMC,SAAS,MAAMT;gBACrBC,YAAYQ;YACd,EAAE,OAAOC,OAAO;gBACdR,WAAWQ;YACb,SAAU;gBACRlB,gCAAA,IAAI,EAAEgB,cAAAA,CAAAA,cAAAA;gBACNhB,gCAAA,IAAI,EAAEmB,aAAAA,CAAAA,aAAAA;YACR;QACF;QAEA,MAAMC,gBAAgB;YAAEZ,WAAWG;YAAaI;QAAK;QACrD,gDAAgD;QAChDf,gCAAA,IAAI,EAAEqB,OAAAA,CAAAA,OAAAA,CAAMC,IAAI,CAACF;QACjBpB,gCAAA,IAAI,EAAEmB,aAAAA,CAAAA,aAAAA;QAEN,OAAOR;IACT;IAEAY,KAAKf,SAAuB,EAAE;QAC5B,MAAMgB,QAAQxB,gCAAA,IAAI,EAAEqB,OAAAA,CAAAA,OAAAA,CAAMI,SAAS,CAAC,CAACC,OAASA,KAAKlB,SAAS,KAAKA;QAEjE,IAAIgB,QAAQ,CAAC,GAAG;YACd,MAAMG,aAAa3B,gCAAA,IAAI,EAAEqB,OAAAA,CAAAA,OAAAA,CAAMO,MAAM,CAACJ,OAAO,EAAE,CAAC,EAAE;YAClDxB,gCAAA,IAAI,EAAEqB,OAAAA,CAAAA,OAAAA,CAAMQ,OAAO,CAACF;YACpB3B,gCAAA,IAAI,EAAEmB,aAAAA,CAAAA,aAAAA,CAAY;QACpB;IACF;IA5CAW,YAAYC,iBAAiB,CAAC,CAAE;QA8ChCC,OAAAC,cAAA,CAAA,IAAA,EAAA5B,cAAA;mBAAAc;;QArDAa,OAAAC,cAAA,CAAA,IAAA,EAAAhC,iBAAA;;mBAAA,KAAA;;QACA+B,OAAAC,cAAA,CAAA,IAAA,EAAA9B,eAAA;;mBAAA,KAAA;;QACA6B,OAAAC,cAAA,CAAA,IAAA,EAAA7B,QAAA;;mBAAA,KAAA;;QAMEJ,gCAAA,IAAI,EAAE+B,gBAAAA,CAAAA,gBAAAA,GAAiBA;QACvB/B,gCAAA,IAAI,EAAEgB,cAAAA,CAAAA,cAAAA,GAAe;QACrBhB,gCAAA,IAAI,EAAEqB,OAAAA,CAAAA,OAAAA,GAAQ,EAAE;IAClB;AAkDF;AARE,SAAAF,YAAae,MAAc;IAAdA,IAAAA,WAAAA,KAAAA,GAAAA,SAAS;IACpB,IACE,AAAClC,CAAAA,gCAAA,IAAI,EAAEgB,cAAAA,CAAAA,cAAAA,GAAehB,gCAAA,IAAI,EAAE+B,gBAAAA,CAAAA,gBAAAA,IAAkBG,MAAAA,KAC9ClC,gCAAA,IAAI,EAAEqB,OAAAA,CAAAA,OAAAA,CAAMc,MAAM,GAAG,GACrB;YACAC;QAAAA,CAAAA,+CAAApC,gCAAA,IAAI,EAAEqB,OAAAA,CAAAA,OAAAA,CAAMgB,KAAK,EAAA,KAAA,OAAA,KAAA,IAAjBD,6CAAqBrB,IAAI;IAC3B;AACF","file":"x"}  false288389undefined391490undefined528557__WEBPACK_MODULE_REFERENCE__16_5b225f225d_call_directImport_asiSafe1__._undefined609638__WEBPACK_MODULE_REFERENCE__16_5b225f225d_call_directImport_asiSafe1__._undefined681710__WEBPACK_MODULE_REFERENCE__16_5b225f225d_call_directImport_asiSafe1__._undefined752781__WEBPACK_MODULE_REFERENCE__16_5b225f225d_call_directImport_asiSafe1__._undefined800806undefined11101140__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined13721402__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined14591489__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined17141744__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined17971827__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined19441974__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined21042134__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined21912221__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined22782308__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined28592889__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined29572987__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined30383068__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined31893219__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined32593289__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined33453375__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined35273557__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined½  326397_class_private_field_loose_keyundefined449520_class_private_field_loose_keyundefined563634_class_private_field_loose_keyundefined676747_class_private_field_loose_keyundefined10691140_class_private_field_loose_baseundefined13721443_class_private_field_loose_baseundefined15001571_class_private_field_loose_baseundefined17961867_class_private_field_loose_baseundefined19201991_class_private_field_loose_baseundefined21082179_class_private_field_loose_baseundefined23092380_class_private_field_loose_baseundefined24372508_class_private_field_loose_baseundefined25652636_class_private_field_loose_baseundefined31873258_class_private_field_loose_baseundefined33263397_class_private_field_loose_baseundefined34483519_class_private_field_loose_baseundefined36403711_class_private_field_loose_baseundefined37513822_class_private_field_loose_baseundefined38783949_class_private_field_loose_baseundefined41014172_class_private_field_loose_baseundefinedRawSourcep   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/prefetch-cache-utils.js
ÕÖr"  import { createHrefFromUrl } from "./create-href-from-url";
import { fetchServerResponse } from "./fetch-server-response";
import { PrefetchCacheEntryStatus, PrefetchKind } from "./router-reducer-types";
import { prefetchQueue } from "./reducers/prefetch-reducer";
/**
 * Creates a cache key for the router prefetch cache
 *
 * @param url - The URL being navigated to
 * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.
 * @return The generated prefetch cache key.
 */ function createPrefetchCacheKey(url, nextUrl) {
    const pathnameFromUrl = createHrefFromUrl(url, false);
    // nextUrl is used as a cache key delimiter since entries can vary based on the Next-URL header
    if (nextUrl) {
        return nextUrl + "%" + pathnameFromUrl;
    }
    return pathnameFromUrl;
}
/**
 * Returns a prefetch cache entry if one exists. Otherwise creates a new one and enqueues a fetch request
 * to retrieve the prefetch data from the server.
 */ export function getOrCreatePrefetchCacheEntry(param) {
    let { url, nextUrl, tree, buildId, prefetchCache, kind } = param;
    let existingCacheEntry = undefined;
    // We first check if there's a more specific interception route prefetch entry
    // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)
    // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.
    const interceptionCacheKey = createPrefetchCacheKey(url, nextUrl);
    const interceptionData = prefetchCache.get(interceptionCacheKey);
    if (interceptionData) {
        existingCacheEntry = interceptionData;
    } else {
        // If we dont find a more specific interception route prefetch entry, we check for a regular prefetch entry
        const prefetchCacheKey = createPrefetchCacheKey(url);
        const prefetchData = prefetchCache.get(prefetchCacheKey);
        if (prefetchData) {
            existingCacheEntry = prefetchData;
        }
    }
    if (existingCacheEntry) {
        // Grab the latest status of the cache entry and update it
        existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);
        // when `kind` is provided, an explicit prefetch was requested.
        // if the requested prefetch is "full" and the current cache entry wasn't, we want to re-prefetch with the new intent
        const switchedToFullPrefetch = existingCacheEntry.kind !== PrefetchKind.FULL && kind === PrefetchKind.FULL;
        if (switchedToFullPrefetch) {
            return createLazyPrefetchEntry({
                tree,
                url,
                buildId,
                nextUrl,
                prefetchCache,
                // If we didn't get an explicit prefetch kind, we want to set a temporary kind
                // rather than assuming the same intent as the previous entry, to be consistent with how we
                // lazily create prefetch entries when intent is left unspecified.
                kind: kind != null ? kind : PrefetchKind.TEMPORARY
            });
        }
        // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,
        // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.
        if (kind && existingCacheEntry.kind === PrefetchKind.TEMPORARY) {
            existingCacheEntry.kind = kind;
        }
        // We've determined that the existing entry we found is still valid, so we return it.
        return existingCacheEntry;
    }
    // If we didn't return an entry, create a new one.
    return createLazyPrefetchEntry({
        tree,
        url,
        buildId,
        nextUrl,
        prefetchCache,
        kind: kind || // in dev, there's never gonna be a prefetch entry so we want to prefetch here
        ("production" === "development" ? PrefetchKind.AUTO : PrefetchKind.TEMPORARY)
    });
}
/*
 * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.
 * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).
 */ function prefixExistingPrefetchCacheEntry(param) {
    let { url, nextUrl, prefetchCache } = param;
    const existingCacheKey = createPrefetchCacheKey(url);
    const existingCacheEntry = prefetchCache.get(existingCacheKey);
    if (!existingCacheEntry) {
        // no-op -- there wasn't an entry to move
        return;
    }
    const newCacheKey = createPrefetchCacheKey(url, nextUrl);
    prefetchCache.set(newCacheKey, existingCacheEntry);
    prefetchCache.delete(existingCacheKey);
}
/**
 * Use to seed the prefetch cache with data that has already been fetched.
 */ export function createPrefetchCacheEntryForInitialLoad(param) {
    let { nextUrl, tree, prefetchCache, url, kind, data } = param;
    const [, , , intercept] = data;
    // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key
    const prefetchCacheKey = intercept ? createPrefetchCacheKey(url, nextUrl) : createPrefetchCacheKey(url);
    const prefetchEntry = {
        treeAtTimeOfPrefetch: tree,
        data: Promise.resolve(data),
        kind,
        prefetchTime: Date.now(),
        lastUsedTime: Date.now(),
        key: prefetchCacheKey,
        status: PrefetchCacheEntryStatus.fresh
    };
    prefetchCache.set(prefetchCacheKey, prefetchEntry);
    return prefetchEntry;
}
/**
 * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.
 */ function createLazyPrefetchEntry(param) {
    let { url, kind, tree, nextUrl, buildId, prefetchCache } = param;
    const prefetchCacheKey = createPrefetchCacheKey(url);
    // initiates the fetch request for the prefetch and attaches a listener
    // to the promise to update the prefetch cache entry when the promise resolves (if necessary)
    const data = prefetchQueue.enqueue(()=>fetchServerResponse(url, tree, nextUrl, buildId, kind).then((prefetchResponse)=>{
            // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations
            // to avoid drift between this cache key prefixing logic
            // (which is currently directly influenced by the server response)
            const [, , , intercepted] = prefetchResponse;
            if (intercepted) {
                prefixExistingPrefetchCacheEntry({
                    url,
                    nextUrl,
                    prefetchCache
                });
            }
            return prefetchResponse;
        }));
    const prefetchEntry = {
        treeAtTimeOfPrefetch: tree,
        data,
        kind,
        prefetchTime: Date.now(),
        lastUsedTime: null,
        key: prefetchCacheKey,
        status: PrefetchCacheEntryStatus.fresh
    };
    prefetchCache.set(prefetchCacheKey, prefetchEntry);
    return prefetchEntry;
}
export function prunePrefetchCache(prefetchCache) {
    for (const [href, prefetchCacheEntry] of prefetchCache){
        if (getPrefetchEntryCacheStatus(prefetchCacheEntry) === PrefetchCacheEntryStatus.expired) {
            prefetchCache.delete(href);
        }
    }
}
// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)
// and default to 5 minutes (static) / 30 seconds (dynamic)
const DYNAMIC_STALETIME_MS = Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000;
const STATIC_STALETIME_MS = Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME) * 1000;
function getPrefetchEntryCacheStatus(param) {
    let { kind, prefetchTime, lastUsedTime } = param;
    // We will re-use the cache entry data for up to the `dynamic` staletime window.
    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {
        return lastUsedTime ? PrefetchCacheEntryStatus.reusable : PrefetchCacheEntryStatus.fresh;
    }
    // For "auto" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.
    // A stale entry will only re-use the `loading` boundary, not the full data.
    // This will trigger a "lazy fetch" for the full data.
    if (kind === "auto") {
        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {
            return PrefetchCacheEntryStatus.stale;
        }
    }
    // for "full" prefetching, we'll re-use the cache entry data for up to `static` staletime window.
    if (kind === "full") {
        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {
            return PrefetchCacheEntryStatus.reusable;
        }
    }
    return PrefetchCacheEntryStatus.expired;
} //# sourceMappingURL=prefetch-cache-utils.js.map
{  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/prefetch-cache-utils.ts"],"names":["createHrefFromUrl","fetchServerResponse","PrefetchCacheEntryStatus","PrefetchKind","prefetchQueue","createPrefetchCacheKey","url","nextUrl","pathnameFromUrl","getOrCreatePrefetchCacheEntry","param","tree","buildId","prefetchCache","kind","existingCacheEntry","undefined","interceptionCacheKey","interceptionData","get","prefetchCacheKey","prefetchData","status","getPrefetchEntryCacheStatus","switchedToFullPrefetch","FULL","createLazyPrefetchEntry","TEMPORARY","process","AUTO","prefixExistingPrefetchCacheEntry","existingCacheKey","newCacheKey","set","delete","createPrefetchCacheEntryForInitialLoad","data","intercept","prefetchEntry","treeAtTimeOfPrefetch","Promise","resolve","prefetchTime","Date","now","lastUsedTime","key","fresh","enqueue","then","prefetchResponse","intercepted","prunePrefetchCache","href","prefetchCacheEntry","expired","DYNAMIC_STALETIME_MS","Number","env","__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME","STATIC_STALETIME_MS","__NEXT_CLIENT_ROUTER_STATIC_STALETIME","reusable","stale"],"mappings":"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","file":"x"}¬  false058undefined60121undefined123202undefined204263undefined585601__WEBPACK_MODULE_REFERENCE__4_5b226372656174654872656646726f6d55726c225d_call_directImport_asiSafe1__._undefined983989undefined39884017 falseundefined402140370undefined48644870undefined54765499__WEBPACK_MODULE_REFERENCE__3_5b2250726566657463684361636865456e747279537461747573225d_asiSafe1__._undefined70517057undefined75137562"30"undefined76087656"300"undefinedý   324426create_href_from_url_createHrefFromUrlundefined817845prefetch_cache_utils_getOrCreatePrefetchCacheEntryundefined52475345router_reducer_types/* PrefetchCacheEntryStatus */.T7undefined69066923prefetch_cache_utils_prunePrefetchCacheundefinedRawSourceu   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/prefetch-reducer.js
ÐÑ  import { NEXT_RSC_UNION_QUERY } from "../../app-router-headers";
import { PromiseQueue } from "../../promise-queue";
import { getOrCreatePrefetchCacheEntry, prunePrefetchCache } from "../prefetch-cache-utils";
export const prefetchQueue = new PromiseQueue(5);
export function prefetchReducer(state, action) {
    // let's prune the prefetch cache before we do anything else
    prunePrefetchCache(state.prefetchCache);
    const { url } = action;
    url.searchParams.delete(NEXT_RSC_UNION_QUERY);
    getOrCreatePrefetchCacheEntry({
        url,
        nextUrl: state.nextUrl,
        prefetchCache: state.prefetchCache,
        kind: action.kind,
        tree: state.tree,
        buildId: state.buildId
    });
    return state;
} //# sourceMappingURL=prefetch-reducer.js.map
>  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/prefetch-reducer.ts"],"names":["NEXT_RSC_UNION_QUERY","PromiseQueue","getOrCreatePrefetchCacheEntry","prunePrefetchCache","prefetchQueue","prefetchReducer","state","action","prefetchCache","url","searchParams","delete","nextUrl","kind","tree","buildId"],"mappings":"AAKA,SAASA,oBAAoB,QAAQ,2BAA0B;AAC/D,SAASC,YAAY,QAAQ,sBAAqB;AAClD,SACEC,6BAA6B,EAC7BC,kBAAkB,QACb,0BAAyB;AAEhC,OAAO,MAAMC,gBAAgB,IAAIH,aAAa,GAAE;AAEhD,OAAO,SAASI,gBACdC,KAA2B,EAC3BC,MAAsB;IAEtB,4DAA4D;IAC5DJ,mBAAmBG,MAAME,aAAa;IAEtC,MAAM,EAAEC,GAAG,EAAE,GAAGF;IAChBE,IAAIC,YAAY,CAACC,MAAM,CAACX;IAExBE,8BAA8B;QAC5BO;QACAG,SAASN,MAAMM,OAAO;QACtBJ,eAAeF,MAAME,aAAa;QAClCK,MAAMN,OAAOM,IAAI;QACjBC,MAAMR,MAAMQ,IAAI;QAChBC,SAAST,MAAMS,OAAO;IACxB;IAEA,OAAOT;AACT","file":"x"}´   false063undefined65115undefined117208undefined210216undefined243254__WEBPACK_MODULE_REFERENCE__17_5b2250726f6d6973655175657565225d_directImport_asiSafe1__._undefined260266undefined|   921prefetch_reducer_prefetchQueueundefined29117PromiseQueueundefined132146prefetch_reducer_prefetchReducerundefinedRawSourcek   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/ppr-navigations.js
ËÌÑs  import { DEFAULT_SEGMENT_KEY, PAGE_SEGMENT_KEY } from "../../../shared/lib/segment";
import { matchSegment } from "../match-segments";
import { createRouterCacheKey } from "./create-router-cache-key";
// Creates a new Cache Node tree (i.e. copy-on-write) that represents the
// optimistic result of a navigation, using both the current Cache Node tree and
// data that was prefetched prior to navigation.
//
// At the moment we call this function, we haven't yet received the navigation
// response from the server. It could send back something completely different
// from the tree that was prefetched â€” due to rewrites, default routes, parallel
// routes, etc.
//
// But in most cases, it will return the same tree that we prefetched, just with
// the dynamic holes filled in. So we optimistically assume this will happen,
// and accept that the real result could be arbitrarily different.
//
// We'll reuse anything that was already in the previous tree, since that's what
// the server does.
//
// New segments (ones that don't appear in the old tree) are assigned an
// unresolved promise. The data for these promises will be fulfilled later, when
// the navigation response is received.
//
// The tree can be rendered immediately after it is created (that's why this is
// a synchronous function). Any new trees that do not have prefetch data will
// suspend during rendering, until the dynamic data streams in.
//
// Returns a Task object, which contains both the updated Cache Node and a path
// to the pending subtrees that need to be resolved by the navigation response.
//
// A return value of `null` means there were no changes, and the previous tree
// can be reused without initiating a server request.
export function updateCacheNodeOnNavigation(oldCacheNode, oldRouterState, newRouterState, prefetchData, prefetchHead) {
    // Diff the old and new trees to reuse the shared layouts.
    const oldRouterStateChildren = oldRouterState[1];
    const newRouterStateChildren = newRouterState[1];
    const prefetchDataChildren = prefetchData[1];
    const oldParallelRoutes = oldCacheNode.parallelRoutes;
    // Clone the current set of segment children, even if they aren't active in
    // the new tree.
    // TODO: We currently retain all the inactive segments indefinitely, until
    // there's an explicit refresh, or a parent layout is lazily refreshed. We
    // rely on this for popstate navigations, which update the Router State Tree
    // but do not eagerly perform a data fetch, because they expect the segment
    // data to already be in the Cache Node tree. For highly static sites that
    // are mostly read-only, this may happen only rarely, causing memory to
    // leak. We should figure out a better model for the lifetime of inactive
    // segments, so we can maintain instant back/forward navigations without
    // leaking memory indefinitely.
    const prefetchParallelRoutes = new Map(oldParallelRoutes);
    // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)
    // the Route Tree that was returned by the server â€” for example, in the case
    // of default parallel routes, we preserve the currently active segment. To
    // avoid mutating the original tree, we clone the router state children along
    // the return path.
    let patchedRouterStateChildren = {};
    let taskChildren = null;
    for(let parallelRouteKey in newRouterStateChildren){
        const newRouterStateChild = newRouterStateChildren[parallelRouteKey];
        const oldRouterStateChild = oldRouterStateChildren[parallelRouteKey];
        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);
        const prefetchDataChild = prefetchDataChildren[parallelRouteKey];
        const newSegmentChild = newRouterStateChild[0];
        const newSegmentKeyChild = createRouterCacheKey(newSegmentChild);
        const oldSegmentChild = oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined;
        const oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;
        let taskChild;
        if (newSegmentChild === PAGE_SEGMENT_KEY) {
            // This is a leaf segment â€” a page, not a shared layout. We always apply
            // its data.
            taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);
        } else if (newSegmentChild === DEFAULT_SEGMENT_KEY) {
            // This is another kind of leaf segment â€” a default route.
            //
            // Default routes have special behavior. When there's no matching segment
            // for a parallel route, Next.js preserves the currently active segment
            // during a client navigation â€” but not for initial render. The server
            // leaves it to the client to account for this. So we need to handle
            // it here.
            if (oldRouterStateChild !== undefined) {
                // Reuse the existing Router State for this segment. We spawn a "task"
                // just to keep track of the updated router state; unlike most, it's
                // already fulfilled and won't be affected by the dynamic response.
                taskChild = spawnReusedTask(oldRouterStateChild);
            } else {
                // There's no currently active segment. Switch to the "create" path.
                taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);
            }
        } else if (oldSegmentChild !== undefined && matchSegment(newSegmentChild, oldSegmentChild)) {
            if (oldCacheNodeChild !== undefined && oldRouterStateChild !== undefined) {
                // This segment exists in both the old and new trees.
                if (prefetchDataChild !== undefined && prefetchDataChild !== null) {
                    // Recursively update the children.
                    taskChild = updateCacheNodeOnNavigation(oldCacheNodeChild, oldRouterStateChild, newRouterStateChild, prefetchDataChild, prefetchHead);
                } else {
                    // The server didn't send any prefetch data for this segment. This
                    // shouldn't happen because the Route Tree and the Seed Data tree
                    // should always be the same shape, but until we unify those types
                    // it's still possible. For now we're going to deopt and trigger a
                    // lazy fetch during render.
                    taskChild = spawnTaskForMissingData(newRouterStateChild);
                }
            } else {
                // Either there's no existing Cache Node for this segment, or this
                // segment doesn't exist in the old Router State tree. Switch to the
                // "create" path.
                taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);
            }
        } else {
            // This is a new tree. Switch to the "create" path.
            taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);
        }
        if (taskChild !== null) {
            // Something changed in the child tree. Keep track of the child task.
            if (taskChildren === null) {
                taskChildren = new Map();
            }
            taskChildren.set(parallelRouteKey, taskChild);
            const newCacheNodeChild = taskChild.node;
            if (newCacheNodeChild !== null) {
                const newSegmentMapChild = new Map(oldSegmentMapChild);
                newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);
                prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild);
            }
            // The child tree's route state may be different from the prefetched
            // route sent by the server. We need to clone it as we traverse back up
            // the tree.
            patchedRouterStateChildren[parallelRouteKey] = taskChild.route;
        } else {
            // The child didn't change. We can use the prefetched router state.
            patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild;
        }
    }
    if (taskChildren === null) {
        // No new tasks were spawned.
        return null;
    }
    const newCacheNode = {
        lazyData: null,
        rsc: oldCacheNode.rsc,
        // We intentionally aren't updating the prefetchRsc field, since this node
        // is already part of the current tree, because it would be weird for
        // prefetch data to be newer than the final data. It probably won't ever be
        // observable anyway, but it could happen if the segment is unmounted then
        // mounted again, because LayoutRouter will momentarily switch to rendering
        // prefetchRsc, via useDeferredValue.
        prefetchRsc: oldCacheNode.prefetchRsc,
        head: oldCacheNode.head,
        prefetchHead: oldCacheNode.prefetchHead,
        loading: oldCacheNode.loading,
        // Everything is cloned except for the children, which we computed above.
        parallelRoutes: prefetchParallelRoutes,
        lazyDataResolved: false
    };
    return {
        // Return a cloned copy of the router state with updated children.
        route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),
        node: newCacheNode,
        children: taskChildren
    };
}
function patchRouterStateWithNewChildren(baseRouterState, newChildren) {
    const clone = [
        baseRouterState[0],
        newChildren
    ];
    // Based on equivalent logic in apply-router-state-patch-to-tree, but should
    // confirm whether we need to copy all of these fields. Not sure the server
    // ever sends, e.g. the refetch marker.
    if (2 in baseRouterState) {
        clone[2] = baseRouterState[2];
    }
    if (3 in baseRouterState) {
        clone[3] = baseRouterState[3];
    }
    if (4 in baseRouterState) {
        clone[4] = baseRouterState[4];
    }
    return clone;
}
function spawnPendingTask(routerState, prefetchData, prefetchHead) {
    // Create a task that will later be fulfilled by data from the server.
    const pendingCacheNode = createPendingCacheNode(routerState, prefetchData, prefetchHead);
    return {
        route: routerState,
        node: pendingCacheNode,
        children: null
    };
}
function spawnReusedTask(reusedRouterState) {
    // Create a task that reuses an existing segment, e.g. when reusing
    // the current active segment in place of a default route.
    return {
        route: reusedRouterState,
        node: null,
        children: null
    };
}
function spawnTaskForMissingData(routerState) {
    // Create a task for a new subtree that wasn't prefetched by the server.
    // This shouldn't really ever happen but it's here just in case the Seed Data
    // Tree and the Router State Tree disagree unexpectedly.
    const pendingCacheNode = createPendingCacheNode(routerState, null, null);
    return {
        route: routerState,
        node: pendingCacheNode,
        children: null
    };
}
// Writes a dynamic server response into the tree created by
// updateCacheNodeOnNavigation. All pending promises that were spawned by the
// navigation will be resolved, either with dynamic data from the server, or
// `null` to indicate that the data is missing.
//
// A `null` value will trigger a lazy fetch during render, which will then patch
// up the tree using the same mechanism as the non-PPR implementation
// (serverPatchReducer).
//
// Usually, the server will respond with exactly the subset of data that we're
// waiting for â€” everything below the nearest shared layout. But technically,
// the server can return anything it wants.
//
// This does _not_ create a new tree; it modifies the existing one in place.
// Which means it must follow the Suspense rules of cache safety.
export function listenForDynamicRequest(task, responsePromise) {
    responsePromise.then((response)=>{
        const flightData = response[0];
        for (const flightDataPath of flightData){
            const segmentPath = flightDataPath.slice(0, -3);
            const serverRouterState = flightDataPath[flightDataPath.length - 3];
            const dynamicData = flightDataPath[flightDataPath.length - 2];
            const dynamicHead = flightDataPath[flightDataPath.length - 1];
            if (typeof segmentPath === "string") {
                continue;
            }
            writeDynamicDataIntoPendingTask(task, segmentPath, serverRouterState, dynamicData, dynamicHead);
        }
        // Now that we've exhausted all the data we received from the server, if
        // there are any remaining pending tasks in the tree, abort them now.
        // If there's any missing data, it will trigger a lazy fetch.
        abortTask(task, null);
    }, (error)=>{
        // This will trigger an error during render
        abortTask(task, error);
    });
}
function writeDynamicDataIntoPendingTask(rootTask, segmentPath, serverRouterState, dynamicData, dynamicHead) {
    // The data sent by the server represents only a subtree of the app. We need
    // to find the part of the task tree that matches the server response, and
    // fulfill it using the dynamic data.
    //
    // segmentPath represents the parent path of subtree. It's a repeating pattern
    // of parallel route key and segment:
    //
    //   [string, Segment, string, Segment, string, Segment, ...]
    //
    // Iterate through the path and finish any tasks that match this payload.
    let task = rootTask;
    for(let i = 0; i < segmentPath.length; i += 2){
        const parallelRouteKey = segmentPath[i];
        const segment = segmentPath[i + 1];
        const taskChildren = task.children;
        if (taskChildren !== null) {
            const taskChild = taskChildren.get(parallelRouteKey);
            if (taskChild !== undefined) {
                const taskSegment = taskChild.route[0];
                if (matchSegment(segment, taskSegment)) {
                    // Found a match for this task. Keep traversing down the task tree.
                    task = taskChild;
                    continue;
                }
            }
        }
        // We didn't find a child task that matches the server data. Exit. We won't
        // abort the task, though, because a different FlightDataPath may be able to
        // fulfill it (see loop in listenForDynamicRequest). We only abort tasks
        // once we've run out of data.
        return;
    }
    finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead);
}
function finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead) {
    // dynamicData may represent a larger subtree than the task. Before we can
    // finish the task, we need to line them up.
    const taskChildren = task.children;
    const taskNode = task.node;
    if (taskChildren === null) {
        // We've reached the leaf node of the pending task. The server data tree
        // lines up the pending Cache Node tree. We can now switch to the
        // normal algorithm.
        if (taskNode !== null) {
            finishPendingCacheNode(taskNode, task.route, serverRouterState, dynamicData, dynamicHead);
            // Null this out to indicate that the task is complete.
            task.node = null;
        }
        return;
    }
    // The server returned more data than we need to finish the task. Skip over
    // the extra segments until we reach the leaf task node.
    const serverChildren = serverRouterState[1];
    const dynamicDataChildren = dynamicData[1];
    for(const parallelRouteKey in serverRouterState){
        const serverRouterStateChild = serverChildren[parallelRouteKey];
        const dynamicDataChild = dynamicDataChildren[parallelRouteKey];
        const taskChild = taskChildren.get(parallelRouteKey);
        if (taskChild !== undefined) {
            const taskSegment = taskChild.route[0];
            if (matchSegment(serverRouterStateChild[0], taskSegment) && dynamicDataChild !== null && dynamicDataChild !== undefined) {
                // Found a match for this task. Keep traversing down the task tree.
                return finishTaskUsingDynamicDataPayload(taskChild, serverRouterStateChild, dynamicDataChild, dynamicHead);
            }
        }
    // We didn't find a child task that matches the server data. We won't abort
    // the task, though, because a different FlightDataPath may be able to
    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks
    // once we've run out of data.
    }
}
function createPendingCacheNode(routerState, prefetchData, prefetchHead) {
    const routerStateChildren = routerState[1];
    const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null;
    const parallelRoutes = new Map();
    for(let parallelRouteKey in routerStateChildren){
        const routerStateChild = routerStateChildren[parallelRouteKey];
        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;
        const segmentChild = routerStateChild[0];
        const segmentKeyChild = createRouterCacheKey(segmentChild);
        const newCacheNodeChild = createPendingCacheNode(routerStateChild, prefetchDataChild === undefined ? null : prefetchDataChild, prefetchHead);
        const newSegmentMapChild = new Map();
        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);
        parallelRoutes.set(parallelRouteKey, newSegmentMapChild);
    }
    // The head is assigned to every leaf segment delivered by the server. Based
    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts
    const isLeafSegment = parallelRoutes.size === 0;
    const maybePrefetchRsc = prefetchData !== null ? prefetchData[2] : null;
    const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null;
    return {
        lazyData: null,
        parallelRoutes: parallelRoutes,
        prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,
        prefetchHead: isLeafSegment ? prefetchHead : null,
        loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,
        // Create a deferred promise. This will be fulfilled once the dynamic
        // response is received from the server.
        rsc: createDeferredRsc(),
        head: isLeafSegment ? createDeferredRsc() : null,
        lazyDataResolved: false
    };
}
function finishPendingCacheNode(cacheNode, taskState, serverState, dynamicData, dynamicHead) {
    // Writes a dynamic response into an existing Cache Node tree. This does _not_
    // create a new tree, it updates the existing tree in-place. So it must follow
    // the Suspense rules of cache safety â€” it can resolve pending promises, but
    // it cannot overwrite existing data. It can add segments to the tree (because
    // a missing segment will cause the layout router to suspend).
    // but it cannot delete them.
    //
    // We must resolve every promise in the tree, or else it will suspend
    // indefinitely. If we did not receive data for a segment, we will resolve its
    // data promise to `null` to trigger a lazy fetch during render.
    const taskStateChildren = taskState[1];
    const serverStateChildren = serverState[1];
    const dataChildren = dynamicData[1];
    // The router state that we traverse the tree with (taskState) is the same one
    // that we used to construct the pending Cache Node tree. That way we're sure
    // to resolve all the pending promises.
    const parallelRoutes = cacheNode.parallelRoutes;
    for(let parallelRouteKey in taskStateChildren){
        const taskStateChild = taskStateChildren[parallelRouteKey];
        const serverStateChild = serverStateChildren[parallelRouteKey];
        const dataChild = dataChildren[parallelRouteKey];
        const segmentMapChild = parallelRoutes.get(parallelRouteKey);
        const taskSegmentChild = taskStateChild[0];
        const taskSegmentKeyChild = createRouterCacheKey(taskSegmentChild);
        const cacheNodeChild = segmentMapChild !== undefined ? segmentMapChild.get(taskSegmentKeyChild) : undefined;
        if (cacheNodeChild !== undefined) {
            if (serverStateChild !== undefined && matchSegment(taskSegmentChild, serverStateChild[0])) {
                if (dataChild !== undefined && dataChild !== null) {
                    // This is the happy path. Recursively update all the children.
                    finishPendingCacheNode(cacheNodeChild, taskStateChild, serverStateChild, dataChild, dynamicHead);
                } else {
                    // The server never returned data for this segment. Trigger a lazy
                    // fetch during render. This shouldn't happen because the Route Tree
                    // and the Seed Data tree sent by the server should always be the same
                    // shape when part of the same server response.
                    abortPendingCacheNode(taskStateChild, cacheNodeChild, null);
                }
            } else {
                // The server never returned data for this segment. Trigger a lazy
                // fetch during render.
                abortPendingCacheNode(taskStateChild, cacheNodeChild, null);
            }
        } else {
        // The server response matches what was expected to receive, but there's
        // no matching Cache Node in the task tree. This is a bug in the
        // implementation because we should have created a node for every
        // segment in the tree that's associated with this task.
        }
    }
    // Use the dynamic data from the server to fulfill the deferred RSC promise
    // on the Cache Node.
    const rsc = cacheNode.rsc;
    const dynamicSegmentData = dynamicData[2];
    if (rsc === null) {
        // This is a lazy cache node. We can overwrite it. This is only safe
        // because we know that the LayoutRouter suspends if `rsc` is `null`.
        cacheNode.rsc = dynamicSegmentData;
    } else if (isDeferredRsc(rsc)) {
        // This is a deferred RSC promise. We can fulfill it with the data we just
        // received from the server. If it was already resolved by a different
        // navigation, then this does nothing because we can't overwrite data.
        rsc.resolve(dynamicSegmentData);
    } else {
    // This is not a deferred RSC promise, nor is it empty, so it must have
    // been populated by a different navigation. We must not overwrite it.
    }
    // Check if this is a leaf segment. If so, it will have a `head` property with
    // a pending promise that needs to be resolved with the dynamic head from
    // the server.
    const head = cacheNode.head;
    if (isDeferredRsc(head)) {
        head.resolve(dynamicHead);
    }
}
export function abortTask(task, error) {
    const cacheNode = task.node;
    if (cacheNode === null) {
        // This indicates the task is already complete.
        return;
    }
    const taskChildren = task.children;
    if (taskChildren === null) {
        // Reached the leaf task node. This is the root of a pending cache
        // node tree.
        abortPendingCacheNode(task.route, cacheNode, error);
    } else {
        // This is an intermediate task node. Keep traversing until we reach a
        // task node with no children. That will be the root of the cache node tree
        // that needs to be resolved.
        for (const taskChild of taskChildren.values()){
            abortTask(taskChild, error);
        }
    }
    // Null this out to indicate that the task is complete.
    task.node = null;
}
function abortPendingCacheNode(routerState, cacheNode, error) {
    // For every pending segment in the tree, resolve its `rsc` promise to `null`
    // to trigger a lazy fetch during render.
    //
    // Or, if an error object is provided, it will error instead.
    const routerStateChildren = routerState[1];
    const parallelRoutes = cacheNode.parallelRoutes;
    for(let parallelRouteKey in routerStateChildren){
        const routerStateChild = routerStateChildren[parallelRouteKey];
        const segmentMapChild = parallelRoutes.get(parallelRouteKey);
        if (segmentMapChild === undefined) {
            continue;
        }
        const segmentChild = routerStateChild[0];
        const segmentKeyChild = createRouterCacheKey(segmentChild);
        const cacheNodeChild = segmentMapChild.get(segmentKeyChild);
        if (cacheNodeChild !== undefined) {
            abortPendingCacheNode(routerStateChild, cacheNodeChild, error);
        } else {
        // This shouldn't happen because we're traversing the same tree that was
        // used to construct the cache nodes in the first place.
        }
    }
    const rsc = cacheNode.rsc;
    if (isDeferredRsc(rsc)) {
        if (error === null) {
            // This will trigger a lazy fetch during render.
            rsc.resolve(null);
        } else {
            // This will trigger an error during rendering.
            rsc.reject(error);
        }
    }
    // Check if this is a leaf segment. If so, it will have a `head` property with
    // a pending promise that needs to be resolved. If an error was provided, we
    // will not resolve it with an error, since this is rendered at the root of
    // the app. We want the segment to error, not the entire app.
    const head = cacheNode.head;
    if (isDeferredRsc(head)) {
        head.resolve(null);
    }
}
export function updateCacheNodeOnPopstateRestoration(oldCacheNode, routerState) {
    // A popstate navigation reads data from the local cache. It does not issue
    // new network requests (unless the cache entries have been evicted). So, we
    // update the cache to drop the prefetch  data for any segment whose dynamic
    // data was already received. This prevents an unnecessary flash back to PPR
    // state during a back/forward navigation.
    //
    // This function clones the entire cache node tree and sets the `prefetchRsc`
    // field to `null` to prevent it from being rendered. We can't mutate the node
    // in place because this is a concurrent data structure.
    const routerStateChildren = routerState[1];
    const oldParallelRoutes = oldCacheNode.parallelRoutes;
    const newParallelRoutes = new Map(oldParallelRoutes);
    for(let parallelRouteKey in routerStateChildren){
        const routerStateChild = routerStateChildren[parallelRouteKey];
        const segmentChild = routerStateChild[0];
        const segmentKeyChild = createRouterCacheKey(segmentChild);
        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);
        if (oldSegmentMapChild !== undefined) {
            const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild);
            if (oldCacheNodeChild !== undefined) {
                const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(oldCacheNodeChild, routerStateChild);
                const newSegmentMapChild = new Map(oldSegmentMapChild);
                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);
                newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);
            }
        }
    }
    // Only show prefetched data if the dynamic data is still pending.
    //
    // Tehnically, what we're actually checking is whether the dynamic network
    // response was received. But since it's a streaming response, this does not
    // mean that all the dynamic data has fully streamed in. It just means that
    // _some_ of the dynamic data was received. But as a heuristic, we assume that
    // the rest dynamic data will stream in quickly, so it's still better to skip
    // the prefetch state.
    const rsc = oldCacheNode.rsc;
    const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === "pending";
    return {
        lazyData: null,
        rsc,
        head: oldCacheNode.head,
        prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : null,
        prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,
        loading: shouldUsePrefetch ? oldCacheNode.loading : null,
        // These are the cloned children we computed above
        parallelRoutes: newParallelRoutes,
        lazyDataResolved: false
    };
}
const DEFERRED = Symbol();
// This type exists to distinguish a DeferredRsc from a Flight promise. It's a
// compromise to avoid adding an extra field on every Cache Node, which would be
// awkward because the pre-PPR parts of codebase would need to account for it,
// too. We can remove it once type Cache Node type is more settled.
function isDeferredRsc(value) {
    return value && value.tag === DEFERRED;
}
function createDeferredRsc() {
    let resolve;
    let reject;
    const pendingRsc = new Promise((res, rej)=>{
        resolve = res;
        reject = rej;
    });
    pendingRsc.status = "pending";
    pendingRsc.resolve = (value)=>{
        if (pendingRsc.status === "pending") {
            const fulfilledRsc = pendingRsc;
            fulfilledRsc.status = "fulfilled";
            fulfilledRsc.value = value;
            resolve(value);
        }
    };
    pendingRsc.reject = (error)=>{
        if (pendingRsc.status === "pending") {
            const rejectedRsc = pendingRsc;
            rejectedRsc.status = "rejected";
            rejectedRsc.reason = error;
            reject(error);
        }
    };
    pendingRsc.tag = DEFERRED;
    return pendingRsc;
} //# sourceMappingURL=ppr-navigations.js.map
)6  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/ppr-navigations.ts"],"names":["DEFAULT_SEGMENT_KEY","PAGE_SEGMENT_KEY","matchSegment","createRouterCacheKey","updateCacheNodeOnNavigation","oldCacheNode","oldRouterState","newRouterState","prefetchData","prefetchHead","oldRouterStateChildren","newRouterStateChildren","prefetchDataChildren","oldParallelRoutes","parallelRoutes","prefetchParallelRoutes","Map","patchedRouterStateChildren","taskChildren","parallelRouteKey","newRouterStateChild","oldRouterStateChild","oldSegmentMapChild","get","prefetchDataChild","newSegmentChild","newSegmentKeyChild","oldSegmentChild","undefined","oldCacheNodeChild","taskChild","spawnPendingTask","spawnReusedTask","spawnTaskForMissingData","set","newCacheNodeChild","node","newSegmentMapChild","route","newCacheNode","lazyData","rsc","prefetchRsc","head","loading","lazyDataResolved","patchRouterStateWithNewChildren","children","baseRouterState","newChildren","clone","routerState","pendingCacheNode","createPendingCacheNode","reusedRouterState","listenForDynamicRequest","task","responsePromise","then","response","flightData","flightDataPath","segmentPath","slice","serverRouterState","length","dynamicData","dynamicHead","writeDynamicDataIntoPendingTask","abortTask","error","rootTask","i","segment","taskSegment","finishTaskUsingDynamicDataPayload","taskNode","finishPendingCacheNode","serverChildren","dynamicDataChildren","serverRouterStateChild","dynamicDataChild","routerStateChildren","routerStateChild","segmentChild","segmentKeyChild","isLeafSegment","size","maybePrefetchRsc","maybePrefetchLoading","createDeferredRsc","cacheNode","taskState","serverState","taskStateChildren","serverStateChildren","dataChildren","taskStateChild","serverStateChild","dataChild","segmentMapChild","taskSegmentChild","taskSegmentKeyChild","cacheNodeChild","abortPendingCacheNode","dynamicSegmentData","isDeferredRsc","resolve","values","reject","updateCacheNodeOnPopstateRestoration","newParallelRoutes","shouldUsePrefetch","status","DEFERRED","Symbol","value","tag","pendingRsc","Promise","res","rej","fulfilledRsc","rejectedRsc","reason"],"mappings":"AAWA,SACEA,mBAAmB,EACnBC,gBAAgB,QACX,8BAA6B;AACpC,SAASC,YAAY,QAAQ,oBAAmB;AAChD,SAASC,oBAAoB,QAAQ,4BAA2B;AAmBhE,yEAAyE;AACzE,gFAAgF;AAChF,gDAAgD;AAChD,EAAE;AACF,8EAA8E;AAC9E,8EAA8E;AAC9E,gFAAgF;AAChF,eAAe;AACf,EAAE;AACF,gFAAgF;AAChF,6EAA6E;AAC7E,kEAAkE;AAClE,EAAE;AACF,gFAAgF;AAChF,mBAAmB;AACnB,EAAE;AACF,wEAAwE;AACxE,gFAAgF;AAChF,uCAAuC;AACvC,EAAE;AACF,+EAA+E;AAC/E,6EAA6E;AAC7E,+DAA+D;AAC/D,EAAE;AACF,+EAA+E;AAC/E,+EAA+E;AAC/E,EAAE;AACF,8EAA8E;AAC9E,qDAAqD;AACrD,OAAO,SAASC,4BACdC,YAAuB,EACvBC,cAAiC,EACjCC,cAAiC,EACjCC,YAA+B,EAC/BC,YAA6B;IAE7B,0DAA0D;IAC1D,MAAMC,yBAAyBJ,cAAc,CAAC,EAAE;IAChD,MAAMK,yBAAyBJ,cAAc,CAAC,EAAE;IAChD,MAAMK,uBAAuBJ,YAAY,CAAC,EAAE;IAE5C,MAAMK,oBAAoBR,aAAaS,cAAc;IAErD,2EAA2E;IAC3E,gBAAgB;IAChB,0EAA0E;IAC1E,0EAA0E;IAC1E,4EAA4E;IAC5E,2EAA2E;IAC3E,0EAA0E;IAC1E,uEAAuE;IACvE,yEAAyE;IACzE,wEAAwE;IACxE,+BAA+B;IAC/B,MAAMC,yBAAyB,IAAIC,IAAIH;IAEvC,4EAA4E;IAC5E,4EAA4E;IAC5E,2EAA2E;IAC3E,6EAA6E;IAC7E,mBAAmB;IACnB,IAAII,6BAEA,CAAC;IACL,IAAIC,eAAe;IACnB,IAAK,IAAIC,oBAAoBR,uBAAwB;QACnD,MAAMS,sBACJT,sBAAsB,CAACQ,iBAAiB;QAC1C,MAAME,sBACJX,sBAAsB,CAACS,iBAAiB;QAC1C,MAAMG,qBAAqBT,kBAAkBU,GAAG,CAACJ;QACjD,MAAMK,oBACJZ,oBAAoB,CAACO,iBAAiB;QAExC,MAAMM,kBAAkBL,mBAAmB,CAAC,EAAE;QAC9C,MAAMM,qBAAqBvB,qBAAqBsB;QAEhD,MAAME,kBACJN,wBAAwBO,YAAYP,mBAAmB,CAAC,EAAE,GAAGO;QAE/D,MAAMC,oBACJP,uBAAuBM,YACnBN,mBAAmBC,GAAG,CAACG,sBACvBE;QAEN,IAAIE;QACJ,IAAIL,oBAAoBxB,kBAAkB;YACxC,wEAAwE;YACxE,YAAY;YACZ6B,YAAYC,iBACVX,qBACAI,sBAAsBI,YAAYJ,oBAAoB,MACtDf;QAEJ,OAAO,IAAIgB,oBAAoBzB,qBAAqB;YAClD,0DAA0D;YAC1D,EAAE;YACF,yEAAyE;YACzE,uEAAuE;YACvE,sEAAsE;YACtE,oEAAoE;YACpE,WAAW;YACX,IAAIqB,wBAAwBO,WAAW;gBACrC,sEAAsE;gBACtE,oEAAoE;gBACpE,mEAAmE;gBACnEE,YAAYE,gBAAgBX;YAC9B,OAAO;gBACL,oEAAoE;gBACpES,YAAYC,iBACVX,qBACAI,sBAAsBI,YAAYJ,oBAAoB,MACtDf;YAEJ;QACF,OAAO,IACLkB,oBAAoBC,aACpB1B,aAAauB,iBAAiBE,kBAC9B;YACA,IACEE,sBAAsBD,aACtBP,wBAAwBO,WACxB;gBACA,qDAAqD;gBACrD,IAAIJ,sBAAsBI,aAAaJ,sBAAsB,MAAM;oBACjE,mCAAmC;oBACnCM,YAAY1B,4BACVyB,mBACAR,qBACAD,qBACAI,mBACAf;gBAEJ,OAAO;oBACL,kEAAkE;oBAClE,iEAAiE;oBACjE,kEAAkE;oBAClE,kEAAkE;oBAClE,4BAA4B;oBAC5BqB,YAAYG,wBAAwBb;gBACtC;YACF,OAAO;gBACL,kEAAkE;gBAClE,oEAAoE;gBACpE,iBAAiB;gBACjBU,YAAYC,iBACVX,qBACAI,sBAAsBI,YAAYJ,oBAAoB,MACtDf;YAEJ;QACF,OAAO;YACL,mDAAmD;YACnDqB,YAAYC,iBACVX,qBACAI,sBAAsBI,YAAYJ,oBAAoB,MACtDf;QAEJ;QAEA,IAAIqB,cAAc,MAAM;YACtB,qEAAqE;YACrE,IAAIZ,iBAAiB,MAAM;gBACzBA,eAAe,IAAIF;YACrB;YACAE,aAAagB,GAAG,CAACf,kBAAkBW;YACnC,MAAMK,oBAAoBL,UAAUM,IAAI;YACxC,IAAID,sBAAsB,MAAM;gBAC9B,MAAME,qBAAsC,IAAIrB,IAAIM;gBACpDe,mBAAmBH,GAAG,CAACR,oBAAoBS;gBAC3CpB,uBAAuBmB,GAAG,CAACf,kBAAkBkB;YAC/C;YAEA,oEAAoE;YACpE,uEAAuE;YACvE,YAAY;YACZpB,0BAA0B,CAACE,iBAAiB,GAAGW,UAAUQ,KAAK;QAChE,OAAO;YACL,mEAAmE;YACnErB,0BAA0B,CAACE,iBAAiB,GAAGC;QACjD;IACF;IAEA,IAAIF,iBAAiB,MAAM;QACzB,6BAA6B;QAC7B,OAAO;IACT;IAEA,MAAMqB,eAA+B;QACnCC,UAAU;QACVC,KAAKpC,aAAaoC,GAAG;QACrB,0EAA0E;QAC1E,qEAAqE;QACrE,2EAA2E;QAC3E,0EAA0E;QAC1E,2EAA2E;QAC3E,qCAAqC;QACrCC,aAAarC,aAAaqC,WAAW;QACrCC,MAAMtC,aAAasC,IAAI;QACvBlC,cAAcJ,aAAaI,YAAY;QACvCmC,SAASvC,aAAauC,OAAO;QAE7B,yEAAyE;QACzE9B,gBAAgBC;QAChB8B,kBAAkB;IACpB;IAEA,OAAO;QACL,kEAAkE;QAClEP,OAAOQ,gCACLvC,gBACAU;QAEFmB,MAAMG;QACNQ,UAAU7B;IACZ;AACF;AAEA,SAAS4B,gCACPE,eAAkC,EAClCC,WAA8D;IAE9D,MAAMC,QAA2B;QAACF,eAAe,CAAC,EAAE;QAAEC;KAAY;IAClE,4EAA4E;IAC5E,2EAA2E;IAC3E,uCAAuC;IACvC,IAAI,KAAKD,iBAAiB;QACxBE,KAAK,CAAC,EAAE,GAAGF,eAAe,CAAC,EAAE;IAC/B;IACA,IAAI,KAAKA,iBAAiB;QACxBE,KAAK,CAAC,EAAE,GAAGF,eAAe,CAAC,EAAE;IAC/B;IACA,IAAI,KAAKA,iBAAiB;QACxBE,KAAK,CAAC,EAAE,GAAGF,eAAe,CAAC,EAAE;IAC/B;IACA,OAAOE;AACT;AAEA,SAASnB,iBACPoB,WAA8B,EAC9B3C,YAAsC,EACtCC,YAA6B;IAE7B,sEAAsE;IACtE,MAAM2C,mBAAmBC,uBACvBF,aACA3C,cACAC;IAEF,OAAO;QACL6B,OAAOa;QACPf,MAAMgB;QACNL,UAAU;IACZ;AACF;AAEA,SAASf,gBAAgBsB,iBAAoC;IAC3D,mEAAmE;IACnE,0DAA0D;IAC1D,OAAO;QACLhB,OAAOgB;QACPlB,MAAM;QACNW,UAAU;IACZ;AACF;AAEA,SAASd,wBAAwBkB,WAA8B;IAC7D,wEAAwE;IACxE,6EAA6E;IAC7E,wDAAwD;IACxD,MAAMC,mBAAmBC,uBAAuBF,aAAa,MAAM;IACnE,OAAO;QACLb,OAAOa;QACPf,MAAMgB;QACNL,UAAU;IACZ;AACF;AAEA,4DAA4D;AAC5D,6EAA6E;AAC7E,4EAA4E;AAC5E,+CAA+C;AAC/C,EAAE;AACF,gFAAgF;AAChF,qEAAqE;AACrE,wBAAwB;AACxB,EAAE;AACF,8EAA8E;AAC9E,6EAA6E;AAC7E,2CAA2C;AAC3C,EAAE;AACF,4EAA4E;AAC5E,iEAAiE;AACjE,OAAO,SAASQ,wBACdC,IAAU,EACVC,eAAmD;IAEnDA,gBAAgBC,IAAI,CAClB,CAACC;QACC,MAAMC,aAAaD,QAAQ,CAAC,EAAE;QAC9B,KAAK,MAAME,kBAAkBD,WAAY;YACvC,MAAME,cAAcD,eAAeE,KAAK,CAAC,GAAG,CAAC;YAC7C,MAAMC,oBAAoBH,cAAc,CAACA,eAAeI,MAAM,GAAG,EAAE;YACnE,MAAMC,cAAcL,cAAc,CAACA,eAAeI,MAAM,GAAG,EAAE;YAC7D,MAAME,cAAcN,cAAc,CAACA,eAAeI,MAAM,GAAG,EAAE;YAE7D,IAAI,OAAOH,gBAAgB,UAAU;gBAInC;YACF;YAEAM,gCACEZ,MACAM,aACAE,mBACAE,aACAC;QAEJ;QAEA,wEAAwE;QACxE,qEAAqE;QACrE,6DAA6D;QAC7DE,UAAUb,MAAM;IAClB,GACA,CAACc;QACC,2CAA2C;QAC3CD,UAAUb,MAAMc;IAClB;AAEJ;AAEA,SAASF,gCACPG,QAAc,EACdT,WAA8B,EAC9BE,iBAAoC,EACpCE,WAA8B,EAC9BC,WAA4B;IAE5B,4EAA4E;IAC5E,0EAA0E;IAC1E,qCAAqC;IACrC,EAAE;IACF,8EAA8E;IAC9E,qCAAqC;IACrC,EAAE;IACF,6DAA6D;IAC7D,EAAE;IACF,yEAAyE;IACzE,IAAIX,OAAOe;IACX,IAAK,IAAIC,IAAI,GAAGA,IAAIV,YAAYG,MAAM,EAAEO,KAAK,EAAG;QAC9C,MAAMrD,mBAA2B2C,WAAW,CAACU,EAAE;QAC/C,MAAMC,UAAmBX,WAAW,CAACU,IAAI,EAAE;QAC3C,MAAMtD,eAAesC,KAAKT,QAAQ;QAClC,IAAI7B,iBAAiB,MAAM;YACzB,MAAMY,YAAYZ,aAAaK,GAAG,CAACJ;YACnC,IAAIW,cAAcF,WAAW;gBAC3B,MAAM8C,cAAc5C,UAAUQ,KAAK,CAAC,EAAE;gBACtC,IAAIpC,aAAauE,SAASC,cAAc;oBACtC,mEAAmE;oBACnElB,OAAO1B;oBACP;gBACF;YACF;QACF;QACA,2EAA2E;QAC3E,4EAA4E;QAC5E,wEAAwE;QACxE,8BAA8B;QAC9B;IACF;IAEA6C,kCACEnB,MACAQ,mBACAE,aACAC;AAEJ;AAEA,SAASQ,kCACPnB,IAAU,EACVQ,iBAAoC,EACpCE,WAA8B,EAC9BC,WAA4B;IAE5B,0EAA0E;IAC1E,4CAA4C;IAC5C,MAAMjD,eAAesC,KAAKT,QAAQ;IAClC,MAAM6B,WAAWpB,KAAKpB,IAAI;IAC1B,IAAIlB,iBAAiB,MAAM;QACzB,wEAAwE;QACxE,iEAAiE;QACjE,oBAAoB;QACpB,IAAI0D,aAAa,MAAM;YACrBC,uBACED,UACApB,KAAKlB,KAAK,EACV0B,mBACAE,aACAC;YAEF,uDAAuD;YACvDX,KAAKpB,IAAI,GAAG;QACd;QACA;IACF;IACA,2EAA2E;IAC3E,wDAAwD;IACxD,MAAM0C,iBAAiBd,iBAAiB,CAAC,EAAE;IAC3C,MAAMe,sBAAsBb,WAAW,CAAC,EAAE;IAE1C,IAAK,MAAM/C,oBAAoB6C,kBAAmB;QAChD,MAAMgB,yBACJF,cAAc,CAAC3D,iBAAiB;QAClC,MAAM8D,mBACJF,mBAAmB,CAAC5D,iBAAiB;QAEvC,MAAMW,YAAYZ,aAAaK,GAAG,CAACJ;QACnC,IAAIW,cAAcF,WAAW;YAC3B,MAAM8C,cAAc5C,UAAUQ,KAAK,CAAC,EAAE;YACtC,IACEpC,aAAa8E,sBAAsB,CAAC,EAAE,EAAEN,gBACxCO,qBAAqB,QACrBA,qBAAqBrD,WACrB;gBACA,mEAAmE;gBACnE,OAAO+C,kCACL7C,WACAkD,wBACAC,kBACAd;YAEJ;QACF;IACA,2EAA2E;IAC3E,sEAAsE;IACtE,wEAAwE;IACxE,8BAA8B;IAChC;AACF;AAEA,SAASd,uBACPF,WAA8B,EAC9B3C,YAAsC,EACtCC,YAA6B;IAE7B,MAAMyE,sBAAsB/B,WAAW,CAAC,EAAE;IAC1C,MAAMvC,uBAAuBJ,iBAAiB,OAAOA,YAAY,CAAC,EAAE,GAAG;IAEvE,MAAMM,iBAAiB,IAAIE;IAC3B,IAAK,IAAIG,oBAAoB+D,oBAAqB;QAChD,MAAMC,mBACJD,mBAAmB,CAAC/D,iBAAiB;QACvC,MAAMK,oBACJZ,yBAAyB,OACrBA,oBAAoB,CAACO,iBAAiB,GACtC;QAEN,MAAMiE,eAAeD,gBAAgB,CAAC,EAAE;QACxC,MAAME,kBAAkBlF,qBAAqBiF;QAE7C,MAAMjD,oBAAoBkB,uBACxB8B,kBACA3D,sBAAsBI,YAAY,OAAOJ,mBACzCf;QAGF,MAAM4B,qBAAsC,IAAIrB;QAChDqB,mBAAmBH,GAAG,CAACmD,iBAAiBlD;QACxCrB,eAAeoB,GAAG,CAACf,kBAAkBkB;IACvC;IAEA,4EAA4E;IAC5E,mEAAmE;IACnE,MAAMiD,gBAAgBxE,eAAeyE,IAAI,KAAK;IAE9C,MAAMC,mBAAmBhF,iBAAiB,OAAOA,YAAY,CAAC,EAAE,GAAG;IACnE,MAAMiF,uBAAuBjF,iBAAiB,OAAOA,YAAY,CAAC,EAAE,GAAG;IACvE,OAAO;QACLgC,UAAU;QACV1B,gBAAgBA;QAEhB4B,aAAa8C,qBAAqB5D,YAAY4D,mBAAmB;QACjE/E,cAAc6E,gBAAgB7E,eAAe;QAC7CmC,SAAS6C,yBAAyB7D,YAAY6D,uBAAuB;QAErE,qEAAqE;QACrE,wCAAwC;QACxChD,KAAKiD;QACL/C,MAAM2C,gBAAgBI,sBAAsB;QAC5C7C,kBAAkB;IACpB;AACF;AAEA,SAASgC,uBACPc,SAAoB,EACpBC,SAA4B,EAC5BC,WAA8B,EAC9B3B,WAA8B,EAC9BC,WAA4B;IAE5B,8EAA8E;IAC9E,8EAA8E;IAC9E,4EAA4E;IAC5E,8EAA8E;IAC9E,8DAA8D;IAC9D,6BAA6B;IAC7B,EAAE;IACF,qEAAqE;IACrE,8EAA8E;IAC9E,gEAAgE;IAChE,MAAM2B,oBAAoBF,SAAS,CAAC,EAAE;IACtC,MAAMG,sBAAsBF,WAAW,CAAC,EAAE;IAC1C,MAAMG,eAAe9B,WAAW,CAAC,EAAE;IAEnC,8EAA8E;IAC9E,6EAA6E;IAC7E,uCAAuC;IACvC,MAAMpD,iBAAiB6E,UAAU7E,cAAc;IAC/C,IAAK,IAAIK,oBAAoB2E,kBAAmB;QAC9C,MAAMG,iBACJH,iBAAiB,CAAC3E,iBAAiB;QACrC,MAAM+E,mBACJH,mBAAmB,CAAC5E,iBAAiB;QACvC,MAAMgF,YACJH,YAAY,CAAC7E,iBAAiB;QAEhC,MAAMiF,kBAAkBtF,eAAeS,GAAG,CAACJ;QAC3C,MAAMkF,mBAAmBJ,cAAc,CAAC,EAAE;QAC1C,MAAMK,sBAAsBnG,qBAAqBkG;QAEjD,MAAME,iBACJH,oBAAoBxE,YAChBwE,gBAAgB7E,GAAG,CAAC+E,uBACpB1E;QAEN,IAAI2E,mBAAmB3E,WAAW;YAChC,IACEsE,qBAAqBtE,aACrB1B,aAAamG,kBAAkBH,gBAAgB,CAAC,EAAE,GAClD;gBACA,IAAIC,cAAcvE,aAAauE,cAAc,MAAM;oBACjD,+DAA+D;oBAC/DtB,uBACE0B,gBACAN,gBACAC,kBACAC,WACAhC;gBAEJ,OAAO;oBACL,kEAAkE;oBAClE,oEAAoE;oBACpE,sEAAsE;oBACtE,+CAA+C;oBAC/CqC,sBAAsBP,gBAAgBM,gBAAgB;gBACxD;YACF,OAAO;gBACL,kEAAkE;gBAClE,uBAAuB;gBACvBC,sBAAsBP,gBAAgBM,gBAAgB;YACxD;QACF,OAAO;QACL,wEAAwE;QACxE,gEAAgE;QAChE,iEAAiE;QACjE,wDAAwD;QAC1D;IACF;IAEA,2EAA2E;IAC3E,qBAAqB;IACrB,MAAM9D,MAAMkD,UAAUlD,GAAG;IACzB,MAAMgE,qBAAqBvC,WAAW,CAAC,EAAE;IACzC,IAAIzB,QAAQ,MAAM;QAChB,oEAAoE;QACpE,qEAAqE;QACrEkD,UAAUlD,GAAG,GAAGgE;IAClB,OAAO,IAAIC,cAAcjE,MAAM;QAC7B,0EAA0E;QAC1E,sEAAsE;QACtE,sEAAsE;QACtEA,IAAIkE,OAAO,CAACF;IACd,OAAO;IACL,uEAAuE;IACvE,sEAAsE;IACxE;IAEA,8EAA8E;IAC9E,yEAAyE;IACzE,cAAc;IACd,MAAM9D,OAAOgD,UAAUhD,IAAI;IAC3B,IAAI+D,cAAc/D,OAAO;QACvBA,KAAKgE,OAAO,CAACxC;IACf;AACF;AAEA,OAAO,SAASE,UAAUb,IAAU,EAAEc,KAAU;IAC9C,MAAMqB,YAAYnC,KAAKpB,IAAI;IAC3B,IAAIuD,cAAc,MAAM;QACtB,+CAA+C;QAC/C;IACF;IAEA,MAAMzE,eAAesC,KAAKT,QAAQ;IAClC,IAAI7B,iBAAiB,MAAM;QACzB,kEAAkE;QAClE,aAAa;QACbsF,sBAAsBhD,KAAKlB,KAAK,EAAEqD,WAAWrB;IAC/C,OAAO;QACL,sEAAsE;QACtE,2EAA2E;QAC3E,6BAA6B;QAC7B,KAAK,MAAMxC,aAAaZ,aAAa0F,MAAM,GAAI;YAC7CvC,UAAUvC,WAAWwC;QACvB;IACF;IAEA,uDAAuD;IACvDd,KAAKpB,IAAI,GAAG;AACd;AAEA,SAASoE,sBACPrD,WAA8B,EAC9BwC,SAAoB,EACpBrB,KAAU;IAEV,6EAA6E;IAC7E,yCAAyC;IACzC,EAAE;IACF,6DAA6D;IAC7D,MAAMY,sBAAsB/B,WAAW,CAAC,EAAE;IAC1C,MAAMrC,iBAAiB6E,UAAU7E,cAAc;IAC/C,IAAK,IAAIK,oBAAoB+D,oBAAqB;QAChD,MAAMC,mBACJD,mBAAmB,CAAC/D,iBAAiB;QACvC,MAAMiF,kBAAkBtF,eAAeS,GAAG,CAACJ;QAC3C,IAAIiF,oBAAoBxE,WAAW;YAGjC;QACF;QACA,MAAMwD,eAAeD,gBAAgB,CAAC,EAAE;QACxC,MAAME,kBAAkBlF,qBAAqBiF;QAC7C,MAAMmB,iBAAiBH,gBAAgB7E,GAAG,CAAC8D;QAC3C,IAAIkB,mBAAmB3E,WAAW;YAChC4E,sBAAsBrB,kBAAkBoB,gBAAgBjC;QAC1D,OAAO;QACL,wEAAwE;QACxE,wDAAwD;QAC1D;IACF;IACA,MAAM7B,MAAMkD,UAAUlD,GAAG;IACzB,IAAIiE,cAAcjE,MAAM;QACtB,IAAI6B,UAAU,MAAM;YAClB,gDAAgD;YAChD7B,IAAIkE,OAAO,CAAC;QACd,OAAO;YACL,+CAA+C;YAC/ClE,IAAIoE,MAAM,CAACvC;QACb;IACF;IAEA,8EAA8E;IAC9E,4EAA4E;IAC5E,2EAA2E;IAC3E,6DAA6D;IAC7D,MAAM3B,OAAOgD,UAAUhD,IAAI;IAC3B,IAAI+D,cAAc/D,OAAO;QACvBA,KAAKgE,OAAO,CAAC;IACf;AACF;AAEA,OAAO,SAASG,qCACdzG,YAAuB,EACvB8C,WAA8B;IAE9B,2EAA2E;IAC3E,4EAA4E;IAC5E,4EAA4E;IAC5E,4EAA4E;IAC5E,0CAA0C;IAC1C,EAAE;IACF,6EAA6E;IAC7E,8EAA8E;IAC9E,wDAAwD;IAExD,MAAM+B,sBAAsB/B,WAAW,CAAC,EAAE;IAC1C,MAAMtC,oBAAoBR,aAAaS,cAAc;IACrD,MAAMiG,oBAAoB,IAAI/F,IAAIH;IAClC,IAAK,IAAIM,oBAAoB+D,oBAAqB;QAChD,MAAMC,mBACJD,mBAAmB,CAAC/D,iBAAiB;QACvC,MAAMiE,eAAeD,gBAAgB,CAAC,EAAE;QACxC,MAAME,kBAAkBlF,qBAAqBiF;QAC7C,MAAM9D,qBAAqBT,kBAAkBU,GAAG,CAACJ;QACjD,IAAIG,uBAAuBM,WAAW;YACpC,MAAMC,oBAAoBP,mBAAmBC,GAAG,CAAC8D;YACjD,IAAIxD,sBAAsBD,WAAW;gBACnC,MAAMO,oBAAoB2E,qCACxBjF,mBACAsD;gBAEF,MAAM9C,qBAAqB,IAAIrB,IAAIM;gBACnCe,mBAAmBH,GAAG,CAACmD,iBAAiBlD;gBACxC4E,kBAAkB7E,GAAG,CAACf,kBAAkBkB;YAC1C;QACF;IACF;IAEA,kEAAkE;IAClE,EAAE;IACF,0EAA0E;IAC1E,4EAA4E;IAC5E,2EAA2E;IAC3E,8EAA8E;IAC9E,6EAA6E;IAC7E,sBAAsB;IACtB,MAAMI,MAAMpC,aAAaoC,GAAG;IAC5B,MAAMuE,oBAAoBN,cAAcjE,QAAQA,IAAIwE,MAAM,KAAK;IAE/D,OAAO;QACLzE,UAAU;QACVC;QACAE,MAAMtC,aAAasC,IAAI;QAEvBlC,cAAcuG,oBAAoB3G,aAAaI,YAAY,GAAG;QAC9DiC,aAAasE,oBAAoB3G,aAAaqC,WAAW,GAAG;QAC5DE,SAASoE,oBAAoB3G,aAAauC,OAAO,GAAG;QAEpD,kDAAkD;QAClD9B,gBAAgBiG;QAChBlE,kBAAkB;IACpB;AACF;AAEA,MAAMqE,WAAWC;AA8BjB,8EAA8E;AAC9E,gFAAgF;AAChF,8EAA8E;AAC9E,mEAAmE;AACnE,SAAST,cAAcU,KAAU;IAC/B,OAAOA,SAASA,MAAMC,GAAG,KAAKH;AAChC;AAEA,SAASxB;IACP,IAAIiB;IACJ,IAAIE;IACJ,MAAMS,aAAa,IAAIC,QAAyB,CAACC,KAAKC;QACpDd,UAAUa;QACVX,SAASY;IACX;IACAH,WAAWL,MAAM,GAAG;IACpBK,WAAWX,OAAO,GAAG,CAACS;QACpB,IAAIE,WAAWL,MAAM,KAAK,WAAW;YACnC,MAAMS,eAAqCJ;YAC3CI,aAAaT,MAAM,GAAG;YACtBS,aAAaN,KAAK,GAAGA;YACrBT,QAAQS;QACV;IACF;IACAE,WAAWT,MAAM,GAAG,CAACvC;QACnB,IAAIgD,WAAWL,MAAM,KAAK,WAAW;YACnC,MAAMU,cAAmCL;YACzCK,YAAYV,MAAM,GAAG;YACrBU,YAAYC,MAAM,GAAGtD;YACrBuC,OAAOvC;QACT;IACF;IACAgD,WAAWD,GAAG,GAAGH;IACjB,OAAOI;AACT","file":"x"}x   false083undefined85133undefined135199undefined17171723undefined1200112007undefined2295722963undefined2562325629undefined»   15281554ppr_navigations_updateCacheNodeOnNavigationundefined57785804ppr_navigations_updateCacheNodeOnNavigationundefined1180511827ppr_navigations_listenForDynamicRequestundefinedRawSourceu   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/navigate-reducer.js
ÆÇÙN  import { fetchServerResponse } from "../fetch-server-response";
import { createHrefFromUrl } from "../create-href-from-url";
import { invalidateCacheBelowFlightSegmentPath } from "../invalidate-cache-below-flight-segmentpath";
import { applyRouterStatePatchToTree } from "../apply-router-state-patch-to-tree";
import { shouldHardNavigate } from "../should-hard-navigate";
import { isNavigatingToNewRootLayout } from "../is-navigating-to-new-root-layout";
import { PrefetchCacheEntryStatus } from "../router-reducer-types";
import { handleMutable } from "../handle-mutable";
import { applyFlightData } from "../apply-flight-data";
import { prefetchQueue } from "./prefetch-reducer";
import { createEmptyCacheNode } from "../../app-router";
import { DEFAULT_SEGMENT_KEY } from "../../../../shared/lib/segment";
import { listenForDynamicRequest, updateCacheNodeOnNavigation } from "../ppr-navigations";
import { getOrCreatePrefetchCacheEntry, prunePrefetchCache } from "../prefetch-cache-utils";
import { clearCacheNodeDataForSegmentPath } from "../clear-cache-node-data-for-segment-path";
export function handleExternalUrl(state, mutable, url, pendingPush) {
    mutable.mpaNavigation = true;
    mutable.canonicalUrl = url;
    mutable.pendingPush = pendingPush;
    mutable.scrollableSegments = undefined;
    return handleMutable(state, mutable);
}
function generateSegmentsFromPatch(flightRouterPatch) {
    const segments = [];
    const [segment, parallelRoutes] = flightRouterPatch;
    if (Object.keys(parallelRoutes).length === 0) {
        return [
            [
                segment
            ]
        ];
    }
    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){
        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){
            // If the segment is empty, it means we are at the root of the tree
            if (segment === "") {
                segments.push([
                    parallelRouteKey,
                    ...childSegment
                ]);
            } else {
                segments.push([
                    segment,
                    parallelRouteKey,
                    ...childSegment
                ]);
            }
        }
    }
    return segments;
}
function triggerLazyFetchForLeafSegments(newCache, currentCache, flightSegmentPath, treePatch) {
    let appliedPatch = false;
    newCache.rsc = currentCache.rsc;
    newCache.prefetchRsc = currentCache.prefetchRsc;
    newCache.loading = currentCache.loading;
    newCache.parallelRoutes = new Map(currentCache.parallelRoutes);
    const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map((segment)=>[
            ...flightSegmentPath,
            ...segment
        ]);
    for (const segmentPaths of segmentPathsToFill){
        clearCacheNodeDataForSegmentPath(newCache, currentCache, segmentPaths);
        appliedPatch = true;
    }
    return appliedPatch;
}
// These implementations are expected to diverge significantly, so I've forked
// the entire function. The one that's disabled should be dead code eliminated
// because the check here is statically inlined at build time.
export const navigateReducer = process.env.__NEXT_PPR ? navigateReducer_PPR : navigateReducer_noPPR;
// This is the implementation when PPR is disabled. We can assume its behavior
// is relatively stable because it's been running in production for a while.
function navigateReducer_noPPR(state, action) {
    const { url, isExternalUrl, navigateType, shouldScroll } = action;
    const mutable = {};
    const { hash } = url;
    const href = createHrefFromUrl(url);
    const pendingPush = navigateType === "push";
    // we want to prune the prefetch cache on every navigation to avoid it growing too large
    prunePrefetchCache(state.prefetchCache);
    mutable.preserveCustomHistoryState = false;
    if (isExternalUrl) {
        return handleExternalUrl(state, mutable, url.toString(), pendingPush);
    }
    const prefetchValues = getOrCreatePrefetchCacheEntry({
        url,
        nextUrl: state.nextUrl,
        tree: state.tree,
        buildId: state.buildId,
        prefetchCache: state.prefetchCache
    });
    const { treeAtTimeOfPrefetch, data } = prefetchValues;
    prefetchQueue.bump(data);
    return data.then((param)=>{
        let [flightData, canonicalUrlOverride] = param;
        let isFirstRead = false;
        // we only want to mark this once
        if (!prefetchValues.lastUsedTime) {
            // important: we should only mark the cache node as dirty after we unsuspend from the call above
            prefetchValues.lastUsedTime = Date.now();
            isFirstRead = true;
        }
        // Handle case when navigating to page in `pages` from `app`
        if (typeof flightData === "string") {
            return handleExternalUrl(state, mutable, flightData, pendingPush);
        }
        // Handles case where `<meta http-equiv="refresh">` tag is present,
        // which will trigger an MPA navigation.
        if (document.getElementById("__next-page-redirect")) {
            return handleExternalUrl(state, mutable, href, pendingPush);
        }
        let currentTree = state.tree;
        let currentCache = state.cache;
        let scrollableSegments = [];
        for (const flightDataPath of flightData){
            const flightSegmentPath = flightDataPath.slice(0, -4);
            // The one before last item is the router state tree patch
            const treePatch = flightDataPath.slice(-3)[0];
            // TODO-APP: remove ''
            const flightSegmentPathWithLeadingEmpty = [
                "",
                ...flightSegmentPath
            ];
            // Create new tree based on the flightSegmentPath and router state patch
            let newTree = applyRouterStatePatchToTree(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);
            // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch
            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.
            if (newTree === null) {
                newTree = applyRouterStatePatchToTree(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);
            }
            if (newTree !== null) {
                if (isNavigatingToNewRootLayout(currentTree, newTree)) {
                    return handleExternalUrl(state, mutable, href, pendingPush);
                }
                const cache = createEmptyCacheNode();
                let applied = false;
                if (prefetchValues.status === PrefetchCacheEntryStatus.stale && !isFirstRead) {
                    // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations
                    // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,
                    // while copying over the `loading` for the segment that contains the page data.
                    // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.
                    applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);
                    // since we re-used the stale cache's loading state & refreshed the data,
                    // update the `lastUsedTime` so that it can continue to be re-used for the next 30s
                    prefetchValues.lastUsedTime = Date.now();
                } else {
                    applied = applyFlightData(currentCache, cache, flightDataPath, prefetchValues);
                }
                const hardNavigate = shouldHardNavigate(flightSegmentPathWithLeadingEmpty, currentTree);
                if (hardNavigate) {
                    // Copy rsc for the root node of the cache.
                    cache.rsc = currentCache.rsc;
                    cache.prefetchRsc = currentCache.prefetchRsc;
                    invalidateCacheBelowFlightSegmentPath(cache, currentCache, flightSegmentPath);
                    // Ensure the existing cache value is used when the cache was not invalidated.
                    mutable.cache = cache;
                } else if (applied) {
                    mutable.cache = cache;
                    // If we applied the cache, we update the "current cache" value so any other
                    // segments in the FlightDataPath will be able to reference the updated cache.
                    currentCache = cache;
                }
                currentTree = newTree;
                for (const subSegment of generateSegmentsFromPatch(treePatch)){
                    const scrollableSegmentPath = [
                        ...flightSegmentPath,
                        ...subSegment
                    ];
                    // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.
                    if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== DEFAULT_SEGMENT_KEY) {
                        scrollableSegments.push(scrollableSegmentPath);
                    }
                }
            }
        }
        mutable.patchedTree = currentTree;
        mutable.canonicalUrl = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : href;
        mutable.pendingPush = pendingPush;
        mutable.scrollableSegments = scrollableSegments;
        mutable.hashFragment = hash;
        mutable.shouldScroll = shouldScroll;
        return handleMutable(state, mutable);
    }, ()=>state);
}
// This is the experimental PPR implementation. It's closer to the behavior we
// want, but is likelier to include accidental regressions because it rewrites
// existing functionality.
function navigateReducer_PPR(state, action) {
    const { url, isExternalUrl, navigateType, shouldScroll } = action;
    const mutable = {};
    const { hash } = url;
    const href = createHrefFromUrl(url);
    const pendingPush = navigateType === "push";
    // we want to prune the prefetch cache on every navigation to avoid it growing too large
    prunePrefetchCache(state.prefetchCache);
    mutable.preserveCustomHistoryState = false;
    if (isExternalUrl) {
        return handleExternalUrl(state, mutable, url.toString(), pendingPush);
    }
    const prefetchValues = getOrCreatePrefetchCacheEntry({
        url,
        nextUrl: state.nextUrl,
        tree: state.tree,
        buildId: state.buildId,
        prefetchCache: state.prefetchCache
    });
    const { treeAtTimeOfPrefetch, data } = prefetchValues;
    prefetchQueue.bump(data);
    return data.then((param)=>{
        let [flightData, canonicalUrlOverride, _postponed] = param;
        let isFirstRead = false;
        // we only want to mark this once
        if (!prefetchValues.lastUsedTime) {
            // important: we should only mark the cache node as dirty after we unsuspend from the call above
            prefetchValues.lastUsedTime = Date.now();
            isFirstRead = true;
        }
        // Handle case when navigating to page in `pages` from `app`
        if (typeof flightData === "string") {
            return handleExternalUrl(state, mutable, flightData, pendingPush);
        }
        // Handles case where `<meta http-equiv="refresh">` tag is present,
        // which will trigger an MPA navigation.
        if (document.getElementById("__next-page-redirect")) {
            return handleExternalUrl(state, mutable, href, pendingPush);
        }
        let currentTree = state.tree;
        let currentCache = state.cache;
        let scrollableSegments = [];
        // TODO: In practice, this is always a single item array. We probably
        // aren't going to every send multiple segments, at least not in this
        // format. So we could remove the extra wrapper for now until
        // that settles.
        for (const flightDataPath of flightData){
            const flightSegmentPath = flightDataPath.slice(0, -4);
            // The one before last item is the router state tree patch
            const treePatch = flightDataPath.slice(-3)[0];
            // TODO-APP: remove ''
            const flightSegmentPathWithLeadingEmpty = [
                "",
                ...flightSegmentPath
            ];
            // Create new tree based on the flightSegmentPath and router state patch
            let newTree = applyRouterStatePatchToTree(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);
            // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch
            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.
            if (newTree === null) {
                newTree = applyRouterStatePatchToTree(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);
            }
            if (newTree !== null) {
                if (isNavigatingToNewRootLayout(currentTree, newTree)) {
                    return handleExternalUrl(state, mutable, href, pendingPush);
                }
                if (// will always send back a static response that's rendered from
                // the root. If for some reason it doesn't, we fall back to the
                // non-PPR implementation.
                // TODO: We should get rid of the else branch and do all navigations
                // via updateCacheNodeOnNavigation. The current structure is just
                // an incremental step.
                flightDataPath.length === 3) {
                    const prefetchedTree = flightDataPath[0];
                    const seedData = flightDataPath[1];
                    const head = flightDataPath[2];
                    const task = updateCacheNodeOnNavigation(currentCache, currentTree, prefetchedTree, seedData, head);
                    if (task !== null && task.node !== null) {
                        // We've created a new Cache Node tree that contains a prefetched
                        // version of the next page. This can be rendered instantly.
                        // Use the tree computed by updateCacheNodeOnNavigation instead
                        // of the one computed by applyRouterStatePatchToTree.
                        // TODO: We should remove applyRouterStatePatchToTree
                        // from the PPR path entirely.
                        const patchedRouterState = task.route;
                        newTree = patchedRouterState;
                        const newCache = task.node;
                        // The prefetched tree has dynamic holes in it. We initiate a
                        // dynamic request to fill them in.
                        //
                        // Do not block on the result. We'll immediately render the Cache
                        // Node tree and suspend on the dynamic parts. When the request
                        // comes in, we'll fill in missing data and ping React to
                        // re-render. Unlike the lazy fetching model in the non-PPR
                        // implementation, this is modeled as a single React update +
                        // streaming, rather than multiple top-level updates. (However,
                        // even in the new model, we'll still need to sometimes update the
                        // root multiple times per navigation, like if the server sends us
                        // a different response than we expected. For now, we revert back
                        // to the lazy fetching mechanism in that case.)
                        listenForDynamicRequest(task, fetchServerResponse(url, currentTree, state.nextUrl, state.buildId));
                        mutable.cache = newCache;
                    } else {
                        // Nothing changed, so reuse the old cache.
                        // TODO: What if the head changed but not any of the segment data?
                        // Is that possible? If so, we should clone the whole tree and
                        // update the head.
                        newTree = prefetchedTree;
                    }
                } else {
                    // The static response does not include any dynamic holes, so
                    // there's no need to do a second request.
                    // TODO: As an incremental step this just reverts back to the
                    // non-PPR implementation. We can simplify this branch further,
                    // given that PPR prefetches are always static and return the whole
                    // tree. Or in the meantime we could factor it out into a
                    // separate function.
                    const cache = createEmptyCacheNode();
                    let applied = false;
                    if (prefetchValues.status === PrefetchCacheEntryStatus.stale && !isFirstRead) {
                        // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations
                        // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,
                        // while copying over the `loading` for the segment that contains the page data.
                        // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.
                        applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);
                        // since we re-used the stale cache's loading state & refreshed the data,
                        // update the `lastUsedTime` so that it can continue to be re-used for the next 30s
                        prefetchValues.lastUsedTime = Date.now();
                    } else {
                        applied = applyFlightData(currentCache, cache, flightDataPath, prefetchValues);
                    }
                    const hardNavigate = shouldHardNavigate(flightSegmentPathWithLeadingEmpty, currentTree);
                    if (hardNavigate) {
                        // Copy rsc for the root node of the cache.
                        cache.rsc = currentCache.rsc;
                        cache.prefetchRsc = currentCache.prefetchRsc;
                        invalidateCacheBelowFlightSegmentPath(cache, currentCache, flightSegmentPath);
                        // Ensure the existing cache value is used when the cache was not invalidated.
                        mutable.cache = cache;
                    } else if (applied) {
                        mutable.cache = cache;
                        // If we applied the cache, we update the "current cache" value so any other
                        // segments in the FlightDataPath will be able to reference the updated cache.
                        currentCache = cache;
                    }
                }
                currentTree = newTree;
                for (const subSegment of generateSegmentsFromPatch(treePatch)){
                    const scrollableSegmentPath = [
                        ...flightSegmentPath,
                        ...subSegment
                    ];
                    // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.
                    if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== DEFAULT_SEGMENT_KEY) {
                        scrollableSegments.push(scrollableSegmentPath);
                    }
                }
            }
        }
        mutable.patchedTree = currentTree;
        mutable.canonicalUrl = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : href;
        mutable.pendingPush = pendingPush;
        mutable.scrollableSegments = scrollableSegments;
        mutable.hashFragment = hash;
        mutable.shouldScroll = shouldScroll;
        return handleMutable(state, mutable);
    }, ()=>state);
} //# sourceMappingURL=navigate-reducer.js.map
&  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/navigate-reducer.ts"],"names":["fetchServerResponse","createHrefFromUrl","invalidateCacheBelowFlightSegmentPath","applyRouterStatePatchToTree","shouldHardNavigate","isNavigatingToNewRootLayout","PrefetchCacheEntryStatus","handleMutable","applyFlightData","prefetchQueue","createEmptyCacheNode","DEFAULT_SEGMENT_KEY","listenForDynamicRequest","updateCacheNodeOnNavigation","getOrCreatePrefetchCacheEntry","prunePrefetchCache","clearCacheNodeDataForSegmentPath","handleExternalUrl","state","mutable","url","pendingPush","mpaNavigation","canonicalUrl","scrollableSegments","undefined","generateSegmentsFromPatch","flightRouterPatch","segments","segment","parallelRoutes","Object","keys","length","parallelRouteKey","parallelRoute","entries","childSegment","push","triggerLazyFetchForLeafSegments","newCache","currentCache","flightSegmentPath","treePatch","appliedPatch","rsc","prefetchRsc","loading","Map","segmentPathsToFill","map","segmentPaths","navigateReducer","process","env","__NEXT_PPR","navigateReducer_PPR","navigateReducer_noPPR","action","isExternalUrl","navigateType","shouldScroll","hash","href","prefetchCache","preserveCustomHistoryState","toString","prefetchValues","nextUrl","tree","buildId","treeAtTimeOfPrefetch","data","bump","then","param","flightData","canonicalUrlOverride","isFirstRead","lastUsedTime","Date","now","document","getElementById","currentTree","cache","flightDataPath","slice","flightSegmentPathWithLeadingEmpty","newTree","applied","status","stale","hardNavigate","subSegment","scrollableSegmentPath","patchedTree","hashFragment","_postponed","prefetchedTree","seedData","head","task","node","patchedRouterState","route"],"mappings":"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","file":"x"}‚  false062undefined64123undefined125225undefined227308undefined310370undefined372453undefined455521undefined523572undefined574628undefined630680undefined682737undefined739807undefined809898undefined900991undefined9931085undefined10871093undefined31573163undefined31883187(/* unused pure expression or super */ null && (undefined31883209 falseundefined321332310undefined32563255))undefined  2440navigate_reducer_handleExternalUrlundefined20842098navigate_reducer_navigateReducerundefined28292845navigate_reducer_handleExternalUrlundefined37473763navigate_reducer_handleExternalUrlundefined40244040navigate_reducer_handleExternalUrlundefined53985414navigate_reducer_handleExternalUrlundefined92859301navigate_reducer_handleExternalUrlundefined1021510231navigate_reducer_handleExternalUrlundefined1049210508navigate_reducer_handleExternalUrlundefined1211712133navigate_reducer_handleExternalUrlundefinedRawSources   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/handle-segment-mismatch.js
ÁÂ[  import { handleExternalUrl } from "./reducers/navigate-reducer";
/**
 * Handles the case where the client router attempted to patch the tree but, due to a mismatch, the patch failed.
 * This will perform an MPA navigation to return the router to a valid state.
 */ export function handleSegmentMismatch(state, action, treePatch) {
    if ("production" === "development") {
        console.warn("Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.\n\n" + "Reason: Segment mismatch\n" + ("Last Action: " + action.type + "\n\n") + ("Current Tree: " + JSON.stringify(state.tree) + "\n\n") + ("Tree Patch Payload: " + JSON.stringify(treePatch)));
    }
    return handleExternalUrl(state, {}, state.canonicalUrl, true);
} //# sourceMappingURL=handle-segment-mismatch.js.map
  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/handle-segment-mismatch.ts"],"names":["handleExternalUrl","handleSegmentMismatch","state","action","treePatch","process","console","warn","type","JSON","stringify","tree","canonicalUrl"],"mappings":"AACA,SAASA,iBAAiB,QAAQ,8BAA6B;AAM/D;;;CAGC,GACD,OAAO,SAASC,sBACdC,KAA2B,EAC3BC,MAAsB,EACtBC,SAA4B;IAE5B,IAAIC,AAfN,iBAe+B,eAAe;QAC1CC,QAAQC,IAAI,CACV,sJACE,+BACA,CAAA,kBAAgBJ,OAAOK,IAAI,GAAC,MAAA,IAC5B,CAAA,mBAAiBC,KAAKC,SAAS,CAACR,MAAMS,IAAI,IAAE,MAAA,IAC5C,CAAA,yBAAuBF,KAAKC,SAAS,CAACN,UAAAA;IAE5C;IAEA,OAAOJ,kBAAkBE,OAAO,CAAC,GAAGA,MAAMU,YAAY,EAAE;AAC1D","file":"x"}E   false063undefined265271undefined339368falseundefined371736{}undefinedE   210230handle_segment_mismatch_handleSegmentMismatchundefinedRawSourcey   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/server-patch-reducer.js
¼½ë  import { createHrefFromUrl } from "../create-href-from-url";
import { applyRouterStatePatchToTree } from "../apply-router-state-patch-to-tree";
import { isNavigatingToNewRootLayout } from "../is-navigating-to-new-root-layout";
import { handleExternalUrl } from "./navigate-reducer";
import { applyFlightData } from "../apply-flight-data";
import { handleMutable } from "../handle-mutable";
import { createEmptyCacheNode } from "../../app-router";
import { handleSegmentMismatch } from "../handle-segment-mismatch";
export function serverPatchReducer(state, action) {
    const { serverResponse } = action;
    const [flightData, overrideCanonicalUrl] = serverResponse;
    const mutable = {};
    mutable.preserveCustomHistoryState = false;
    // Handle case when navigating to page in `pages` from `app`
    if (typeof flightData === "string") {
        return handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);
    }
    let currentTree = state.tree;
    let currentCache = state.cache;
    for (const flightDataPath of flightData){
        // Slices off the last segment (which is at -4) as it doesn't exist in the tree yet
        const flightSegmentPath = flightDataPath.slice(0, -4);
        const [treePatch] = flightDataPath.slice(-3, -2);
        const newTree = applyRouterStatePatchToTree([
            "",
            ...flightSegmentPath
        ], currentTree, treePatch, state.canonicalUrl);
        if (newTree === null) {
            return handleSegmentMismatch(state, action, treePatch);
        }
        if (isNavigatingToNewRootLayout(currentTree, newTree)) {
            return handleExternalUrl(state, mutable, state.canonicalUrl, state.pushRef.pendingPush);
        }
        const canonicalUrlOverrideHref = overrideCanonicalUrl ? createHrefFromUrl(overrideCanonicalUrl) : undefined;
        if (canonicalUrlOverrideHref) {
            mutable.canonicalUrl = canonicalUrlOverrideHref;
        }
        const cache = createEmptyCacheNode();
        applyFlightData(currentCache, cache, flightDataPath);
        mutable.patchedTree = newTree;
        mutable.cache = cache;
        currentCache = cache;
        currentTree = newTree;
    }
    return handleMutable(state, mutable);
} //# sourceMappingURL=server-patch-reducer.js.map
W  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/server-patch-reducer.ts"],"names":["createHrefFromUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleExternalUrl","applyFlightData","handleMutable","createEmptyCacheNode","handleSegmentMismatch","serverPatchReducer","state","action","serverResponse","flightData","overrideCanonicalUrl","mutable","preserveCustomHistoryState","pushRef","pendingPush","currentTree","tree","currentCache","cache","flightDataPath","flightSegmentPath","slice","treePatch","newTree","canonicalUrl","canonicalUrlOverrideHref","undefined","patchedTree"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,0BAAyB;AAC3D,SAASC,2BAA2B,QAAQ,sCAAqC;AACjF,SAASC,2BAA2B,QAAQ,sCAAqC;AAOjF,SAASC,iBAAiB,QAAQ,qBAAoB;AACtD,SAASC,eAAe,QAAQ,uBAAsB;AACtD,SAASC,aAAa,QAAQ,oBAAmB;AAEjD,SAASC,oBAAoB,QAAQ,mBAAkB;AACvD,SAASC,qBAAqB,QAAQ,6BAA4B;AAElE,OAAO,SAASC,mBACdC,KAA2B,EAC3BC,MAAyB;IAEzB,MAAM,EAAEC,cAAc,EAAE,GAAGD;IAC3B,MAAM,CAACE,YAAYC,qBAAqB,GAAGF;IAE3C,MAAMG,UAAmB,CAAC;IAE1BA,QAAQC,0BAA0B,GAAG;IAErC,4DAA4D;IAC5D,IAAI,OAAOH,eAAe,UAAU;QAClC,OAAOT,kBACLM,OACAK,SACAF,YACAH,MAAMO,OAAO,CAACC,WAAW;IAE7B;IAEA,IAAIC,cAAcT,MAAMU,IAAI;IAC5B,IAAIC,eAAeX,MAAMY,KAAK;IAE9B,KAAK,MAAMC,kBAAkBV,WAAY;QACvC,mFAAmF;QACnF,MAAMW,oBAAoBD,eAAeE,KAAK,CAAC,GAAG,CAAC;QAEnD,MAAM,CAACC,UAAU,GAAGH,eAAeE,KAAK,CAAC,CAAC,GAAG,CAAC;QAC9C,MAAME,UAAUzB,4BAEd;YAAC;eAAOsB;SAAkB,EAC1BL,aACAO,WACAhB,MAAMkB,YAAY;QAGpB,IAAID,YAAY,MAAM;YACpB,OAAOnB,sBAAsBE,OAAOC,QAAQe;QAC9C;QAEA,IAAIvB,4BAA4BgB,aAAaQ,UAAU;YACrD,OAAOvB,kBACLM,OACAK,SACAL,MAAMkB,YAAY,EAClBlB,MAAMO,OAAO,CAACC,WAAW;QAE7B;QAEA,MAAMW,2BAA2Bf,uBAC7Bb,kBAAkBa,wBAClBgB;QAEJ,IAAID,0BAA0B;YAC5Bd,QAAQa,YAAY,GAAGC;QACzB;QAEA,MAAMP,QAAmBf;QACzBF,gBAAgBgB,cAAcC,OAAOC;QAErCR,QAAQgB,WAAW,GAAGJ;QACtBZ,QAAQO,KAAK,GAAGA;QAEhBD,eAAeC;QACfH,cAAcQ;IAChB;IAEA,OAAOrB,cAAcI,OAAOK;AAC9B","file":"x"}ˆ   false059undefined61142undefined144225undefined227281undefined283337undefined339388undefined390445undefined447513undefined515521undefined=   1734server_patch_reducer_serverPatchReducerundefinedRawSourcet   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/restore-reducer.js
·¸µ  import { createHrefFromUrl } from "../create-href-from-url";
import { extractPathFromFlightRouterState } from "../compute-changed-path";
import { updateCacheNodeOnPopstateRestoration } from "../ppr-navigations";
export function restoreReducer(state, action) {
    const { url, tree } = action;
    const href = createHrefFromUrl(url);
    // This action is used to restore the router state from the history state.
    // However, it's possible that the history state no longer contains the `FlightRouterState`.
    // We will copy over the internal state on pushState/replaceState events, but if a history entry
    // occurred before hydration, or if the user navigated to a hash using a regular anchor link,
    // the history state will not contain the `FlightRouterState`.
    // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.
    const treeToRestore = tree || state.tree;
    const oldCache = state.cache;
    const newCache = process.env.__NEXT_PPR ? // prevents an unnecessary flash back to PPR state during a
    // back/forward navigation.
    updateCacheNodeOnPopstateRestoration(oldCache, treeToRestore) : oldCache;
    var _extractPathFromFlightRouterState;
    return {
        buildId: state.buildId,
        // Set canonical url
        canonicalUrl: href,
        pushRef: {
            pendingPush: false,
            mpaNavigation: false,
            // Ensures that the custom history state that was set is preserved when applying this update.
            preserveCustomHistoryState: true
        },
        focusAndScrollRef: state.focusAndScrollRef,
        cache: newCache,
        prefetchCache: state.prefetchCache,
        // Restore provided tree
        tree: treeToRestore,
        nextUrl: (_extractPathFromFlightRouterState = extractPathFromFlightRouterState(treeToRestore)) != null ? _extractPathFromFlightRouterState : url.pathname
    };
} //# sourceMappingURL=restore-reducer.js.map
ý  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/restore-reducer.ts"],"names":["createHrefFromUrl","extractPathFromFlightRouterState","updateCacheNodeOnPopstateRestoration","restoreReducer","state","action","url","tree","href","treeToRestore","oldCache","cache","newCache","process","env","__NEXT_PPR","buildId","canonicalUrl","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","prefetchCache","nextUrl","pathname"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,0BAAyB;AAM3D,SAASC,gCAAgC,QAAQ,0BAAyB;AAC1E,SAASC,oCAAoC,QAAQ,qBAAoB;AAEzE,OAAO,SAASC,eACdC,KAA2B,EAC3BC,MAAqB;IAErB,MAAM,EAAEC,GAAG,EAAEC,IAAI,EAAE,GAAGF;IACtB,MAAMG,OAAOR,kBAAkBM;IAC/B,0EAA0E;IAC1E,4FAA4F;IAC5F,gGAAgG;IAChG,6FAA6F;IAC7F,8DAA8D;IAC9D,yGAAyG;IACzG,MAAMG,gBAAgBF,QAAQH,MAAMG,IAAI;IAExC,MAAMG,WAAWN,MAAMO,KAAK;IAC5B,MAAMC,WAAWC,QAAQC,GAAG,CAACC,UAAU,GAGnC,2DAA2D;IAC3D,2BAA2B;IAC3Bb,qCAAqCQ,UAAUD,iBAC/CC;QAiBOT;IAfX,OAAO;QACLe,SAASZ,MAAMY,OAAO;QACtB,oBAAoB;QACpBC,cAAcT;QACdU,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,6FAA6F;YAC7FC,4BAA4B;QAC9B;QACAC,mBAAmBlB,MAAMkB,iBAAiB;QAC1CX,OAAOC;QACPW,eAAenB,MAAMmB,aAAa;QAClC,wBAAwB;QACxBhB,MAAME;QACNe,SAASvB,CAAAA,oCAAAA,iCAAiCQ,cAAAA,KAAAA,OAAjCR,oCAAmDK,IAAImB,QAAQ;IAC1E;AACF","file":"x"}e   false059undefined61135undefined137210undefined212218undefined9881009 falseundefined110911690undefined4   1225restore_reducer_restoreReducerundefinedRawSourcet   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/refresh-reducer.js
²³.  import { fetchServerResponse } from "../fetch-server-response";
import { createHrefFromUrl } from "../create-href-from-url";
import { applyRouterStatePatchToTree } from "../apply-router-state-patch-to-tree";
import { isNavigatingToNewRootLayout } from "../is-navigating-to-new-root-layout";
import { handleExternalUrl } from "./navigate-reducer";
import { handleMutable } from "../handle-mutable";
import { fillLazyItemsTillLeafWithHead } from "../fill-lazy-items-till-leaf-with-head";
import { createEmptyCacheNode } from "../../app-router";
import { handleSegmentMismatch } from "../handle-segment-mismatch";
import { hasInterceptionRouteInCurrentTree } from "./has-interception-route-in-current-tree";
import { refreshInactiveParallelSegments } from "../refetch-inactive-parallel-segments";
export function refreshReducer(state, action) {
    const { origin } = action;
    const mutable = {};
    const href = state.canonicalUrl;
    let currentTree = state.tree;
    mutable.preserveCustomHistoryState = false;
    const cache = createEmptyCacheNode();
    // If the current tree was intercepted, the nextUrl should be included in the request.
    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.
    const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree);
    // TODO-APP: verify that `href` is not an external url.
    // Fetch data from the root of the tree.
    cache.lazyData = fetchServerResponse(new URL(href, origin), [
        currentTree[0],
        currentTree[1],
        currentTree[2],
        "refetch"
    ], includeNextUrl ? state.nextUrl : null, state.buildId);
    return cache.lazyData.then(async (param)=>{
        let [flightData, canonicalUrlOverride] = param;
        // Handle case when navigating to page in `pages` from `app`
        if (typeof flightData === "string") {
            return handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);
        }
        // Remove cache.lazyData as it has been resolved at this point.
        cache.lazyData = null;
        for (const flightDataPath of flightData){
            // FlightDataPath with more than two items means unexpected Flight data was returned
            if (flightDataPath.length !== 3) {
                // TODO-APP: handle this case better
                console.log("REFRESH FAILED");
                return state;
            }
            // Given the path can only have two items the items are only the router state and rsc for the root.
            const [treePatch] = flightDataPath;
            const newTree = applyRouterStatePatchToTree([
                ""
            ], currentTree, treePatch, state.canonicalUrl);
            if (newTree === null) {
                return handleSegmentMismatch(state, action, treePatch);
            }
            if (isNavigatingToNewRootLayout(currentTree, newTree)) {
                return handleExternalUrl(state, mutable, href, state.pushRef.pendingPush);
            }
            const canonicalUrlOverrideHref = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : undefined;
            if (canonicalUrlOverride) {
                mutable.canonicalUrl = canonicalUrlOverrideHref;
            }
            // The one before last item is the router state tree patch
            const [cacheNodeSeedData, head] = flightDataPath.slice(-2);
            // Handles case where prefetch only returns the router tree patch without rendered components.
            if (cacheNodeSeedData !== null) {
                const rsc = cacheNodeSeedData[2];
                cache.rsc = rsc;
                cache.prefetchRsc = null;
                fillLazyItemsTillLeafWithHead(cache, undefined, treePatch, cacheNodeSeedData, head);
                mutable.prefetchCache = new Map();
            }
            await refreshInactiveParallelSegments({
                state,
                updatedTree: newTree,
                updatedCache: cache,
                includeNextUrl,
                canonicalUrl: mutable.canonicalUrl || state.canonicalUrl
            });
            mutable.cache = cache;
            mutable.patchedTree = newTree;
            mutable.canonicalUrl = href;
            currentTree = newTree;
        }
        return handleMutable(state, mutable);
    }, ()=>state);
} //# sourceMappingURL=refresh-reducer.js.map
˜  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/refresh-reducer.ts"],"names":["fetchServerResponse","createHrefFromUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleExternalUrl","handleMutable","fillLazyItemsTillLeafWithHead","createEmptyCacheNode","handleSegmentMismatch","hasInterceptionRouteInCurrentTree","refreshInactiveParallelSegments","refreshReducer","state","action","origin","mutable","href","canonicalUrl","currentTree","tree","preserveCustomHistoryState","cache","includeNextUrl","lazyData","URL","nextUrl","buildId","then","param","flightData","canonicalUrlOverride","pushRef","pendingPush","flightDataPath","length","console","log","treePatch","newTree","canonicalUrlOverrideHref","undefined","cacheNodeSeedData","head","slice","rsc","prefetchRsc","prefetchCache","Map","updatedTree","updatedCache","patchedTree"],"mappings":"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","file":"x"}µ   false062undefined64123undefined125206undefined208289undefined291345undefined347396undefined398484undefined486541undefined543609undefined611703undefined705792undefined794800undefined4   2033refresh_reducer_refreshReducerundefinedRawSourcey   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/fast-refresh-reducer.js
­®;  import { fetchServerResponse } from "../fetch-server-response";
import { createHrefFromUrl } from "../create-href-from-url";
import { applyRouterStatePatchToTree } from "../apply-router-state-patch-to-tree";
import { isNavigatingToNewRootLayout } from "../is-navigating-to-new-root-layout";
import { handleExternalUrl } from "./navigate-reducer";
import { handleMutable } from "../handle-mutable";
import { applyFlightData } from "../apply-flight-data";
import { createEmptyCacheNode } from "../../app-router";
import { handleSegmentMismatch } from "../handle-segment-mismatch";
import { hasInterceptionRouteInCurrentTree } from "./has-interception-route-in-current-tree";
// A version of refresh reducer that keeps the cache around instead of wiping all of it.
function fastRefreshReducerImpl(state, action) {
    const { origin } = action;
    const mutable = {};
    const href = state.canonicalUrl;
    mutable.preserveCustomHistoryState = false;
    const cache = createEmptyCacheNode();
    // If the current tree was intercepted, the nextUrl should be included in the request.
    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.
    const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree);
    // TODO-APP: verify that `href` is not an external url.
    // Fetch data from the root of the tree.
    cache.lazyData = fetchServerResponse(new URL(href, origin), [
        state.tree[0],
        state.tree[1],
        state.tree[2],
        "refetch"
    ], includeNextUrl ? state.nextUrl : null, state.buildId);
    return cache.lazyData.then((param)=>{
        let [flightData, canonicalUrlOverride] = param;
        // Handle case when navigating to page in `pages` from `app`
        if (typeof flightData === "string") {
            return handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);
        }
        // Remove cache.lazyData as it has been resolved at this point.
        cache.lazyData = null;
        let currentTree = state.tree;
        let currentCache = state.cache;
        for (const flightDataPath of flightData){
            // FlightDataPath with more than two items means unexpected Flight data was returned
            if (flightDataPath.length !== 3) {
                // TODO-APP: handle this case better
                console.log("REFRESH FAILED");
                return state;
            }
            // Given the path can only have two items the items are only the router state and rsc for the root.
            const [treePatch] = flightDataPath;
            const newTree = applyRouterStatePatchToTree([
                ""
            ], currentTree, treePatch, state.canonicalUrl);
            if (newTree === null) {
                return handleSegmentMismatch(state, action, treePatch);
            }
            if (isNavigatingToNewRootLayout(currentTree, newTree)) {
                return handleExternalUrl(state, mutable, href, state.pushRef.pendingPush);
            }
            const canonicalUrlOverrideHref = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : undefined;
            if (canonicalUrlOverride) {
                mutable.canonicalUrl = canonicalUrlOverrideHref;
            }
            const applied = applyFlightData(currentCache, cache, flightDataPath);
            if (applied) {
                mutable.cache = cache;
                currentCache = cache;
            }
            mutable.patchedTree = newTree;
            mutable.canonicalUrl = href;
            currentTree = newTree;
        }
        return handleMutable(state, mutable);
    }, ()=>state);
}
function fastRefreshReducerNoop(state, _action) {
    return state;
}
export const fastRefreshReducer = "production" === "production" ? fastRefreshReducerNoop : fastRefreshReducerImpl; //# sourceMappingURL=fast-refresh-reducer.js.map
Ã
  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/fast-refresh-reducer.ts"],"names":["fetchServerResponse","createHrefFromUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleExternalUrl","handleMutable","applyFlightData","createEmptyCacheNode","handleSegmentMismatch","hasInterceptionRouteInCurrentTree","fastRefreshReducerImpl","state","action","origin","mutable","href","canonicalUrl","preserveCustomHistoryState","cache","includeNextUrl","tree","lazyData","URL","nextUrl","buildId","then","param","flightData","canonicalUrlOverride","pushRef","pendingPush","currentTree","currentCache","flightDataPath","length","console","log","treePatch","newTree","canonicalUrlOverrideHref","undefined","applied","patchedTree","fastRefreshReducerNoop","_action","fastRefreshReducer","process"],"mappings":"AAAA,SAASA,mBAAmB,QAAQ,2BAA0B;AAC9D,SAASC,iBAAiB,QAAQ,0BAAyB;AAC3D,SAASC,2BAA2B,QAAQ,sCAAqC;AACjF,SAASC,2BAA2B,QAAQ,sCAAqC;AAOjF,SAASC,iBAAiB,QAAQ,qBAAoB;AACtD,SAASC,aAAa,QAAQ,oBAAmB;AACjD,SAASC,eAAe,QAAQ,uBAAsB;AAEtD,SAASC,oBAAoB,QAAQ,mBAAkB;AACvD,SAASC,qBAAqB,QAAQ,6BAA4B;AAClE,SAASC,iCAAiC,QAAQ,2CAA0C;AAE5F,wFAAwF;AACxF,SAASC,uBACPC,KAA2B,EAC3BC,MAAyB;IAEzB,MAAM,EAAEC,MAAM,EAAE,GAAGD;IACnB,MAAME,UAAmB,CAAC;IAC1B,MAAMC,OAAOJ,MAAMK,YAAY;IAE/BF,QAAQG,0BAA0B,GAAG;IAErC,MAAMC,QAAmBX;IACzB,sFAAsF;IACtF,sHAAsH;IACtH,MAAMY,iBAAiBV,kCAAkCE,MAAMS,IAAI;IAEnE,uDAAuD;IACvD,wCAAwC;IACxCF,MAAMG,QAAQ,GAAGrB,oBACf,IAAIsB,IAAIP,MAAMF,SACd;QAACF,MAAMS,IAAI,CAAC,EAAE;QAAET,MAAMS,IAAI,CAAC,EAAE;QAAET,MAAMS,IAAI,CAAC,EAAE;QAAE;KAAU,EACxDD,iBAAiBR,MAAMY,OAAO,GAAG,MACjCZ,MAAMa,OAAO;IAGf,OAAON,MAAMG,QAAQ,CAACI,IAAI,CACxB,CAAAC;YAAC,CAACC,YAAYC,qBAAqB,GAAAF;QACjC,4DAA4D;QAC5D,IAAI,OAAOC,eAAe,UAAU;YAClC,OAAOvB,kBACLO,OACAG,SACAa,YACAhB,MAAMkB,OAAO,CAACC,WAAW;QAE7B;QAEA,+DAA+D;QAC/DZ,MAAMG,QAAQ,GAAG;QAEjB,IAAIU,cAAcpB,MAAMS,IAAI;QAC5B,IAAIY,eAAerB,MAAMO,KAAK;QAE9B,KAAK,MAAMe,kBAAkBN,WAAY;YACvC,oFAAoF;YACpF,IAAIM,eAAeC,MAAM,KAAK,GAAG;gBAC/B,oCAAoC;gBACpCC,QAAQC,GAAG,CAAC;gBACZ,OAAOzB;YACT;YAEA,mGAAmG;YACnG,MAAM,CAAC0B,UAAU,GAAGJ;YACpB,MAAMK,UAAUpC,4BAEd;gBAAC;aAAG,EACJ6B,aACAM,WACA1B,MAAMK,YAAY;YAGpB,IAAIsB,YAAY,MAAM;gBACpB,OAAO9B,sBAAsBG,OAAOC,QAAQyB;YAC9C;YAEA,IAAIlC,4BAA4B4B,aAAaO,UAAU;gBACrD,OAAOlC,kBACLO,OACAG,SACAC,MACAJ,MAAMkB,OAAO,CAACC,WAAW;YAE7B;YAEA,MAAMS,2BAA2BX,uBAC7B3B,kBAAkB2B,wBAClBY;YAEJ,IAAIZ,sBAAsB;gBACxBd,QAAQE,YAAY,GAAGuB;YACzB;YACA,MAAME,UAAUnC,gBAAgB0B,cAAcd,OAAOe;YAErD,IAAIQ,SAAS;gBACX3B,QAAQI,KAAK,GAAGA;gBAChBc,eAAed;YACjB;YAEAJ,QAAQ4B,WAAW,GAAGJ;YACtBxB,QAAQE,YAAY,GAAGD;YAEvBgB,cAAcO;QAChB;QACA,OAAOjC,cAAcM,OAAOG;IAC9B,GACA,IAAMH;AAEV;AAEA,SAASgC,uBACPhC,KAA2B,EAC3BiC,OAA0B;IAE1B,OAAOjC;AACT;AAEA,OAAO,MAAMkC,qBACXC,AA7HF,iBA6H2B,eACrBH,yBACAjC,uBAAsB","file":"x"}$  false062undefined64123undefined125206undefined208289undefined291345undefined347396undefined398452undefined454509undefined511577undefined579671undefined37353741undefined37693768(/* unused pure expression or super */ null && (undefined37693797 trueundefined382638470undefined38483847))undefinedA   30783095fast_refresh_reducer_fastRefreshReducerundefinedRawSourceö   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/app-call-server.js
var app_call_server = __webpack_require__(8283);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/server-action-reducer.js
¨©4   import { callServer } from "../../../app-call-server";
import { ACTION, NEXT_ROUTER_STATE_TREE, NEXT_URL, RSC_CONTENT_TYPE_HEADER } from "../../app-router-headers";
// // eslint-disable-next-line import/no-extraneous-dependencies
// import { createFromFetch } from 'react-server-dom-webpack/client'
// // eslint-disable-next-line import/no-extraneous-dependencies
// import { encodeReply } from 'react-server-dom-webpack/client'
const { createFromFetch, encodeReply } = !!process.env.NEXT_RUNTIME ? require("react-server-dom-webpack/client.edge") : require("react-server-dom-webpack/client");
import { addBasePath } from "../../../add-base-path";
import { createHrefFromUrl } from "../create-href-from-url";
import { handleExternalUrl } from "./navigate-reducer";
import { applyRouterStatePatchToTree } from "../apply-router-state-patch-to-tree";
import { isNavigatingToNewRootLayout } from "../is-navigating-to-new-root-layout";
import { handleMutable } from "../handle-mutable";
import { fillLazyItemsTillLeafWithHead } from "../fill-lazy-items-till-leaf-with-head";
import { createEmptyCacheNode } from "../../app-router";
import { hasInterceptionRouteInCurrentTree } from "./has-interception-route-in-current-tree";
import { handleSegmentMismatch } from "../handle-segment-mismatch";
import { refreshInactiveParallelSegments } from "../refetch-inactive-parallel-segments";
async function fetchServerAction(state, nextUrl, param) {
    let { actionId, actionArgs } = param;
    const body = await encodeReply(actionArgs);
    const res = await fetch("", {
        method: "POST",
        headers: {
            Accept: RSC_CONTENT_TYPE_HEADER,
            [ACTION]: actionId,
            [NEXT_ROUTER_STATE_TREE]: encodeURIComponent(JSON.stringify(state.tree)),
            ...process.env.NEXT_DEPLOYMENT_ID ? {
                "x-deployment-id": process.env.NEXT_DEPLOYMENT_ID
            } : {},
            ...nextUrl ? {
                [NEXT_URL]: nextUrl
            } : {}
        },
        body
    });
    const location = res.headers.get("x-action-redirect");
    let revalidatedParts;
    try {
        const revalidatedHeader = JSON.parse(res.headers.get("x-action-revalidated") || "[[],0,0]");
        revalidatedParts = {
            paths: revalidatedHeader[0] || [],
            tag: !!revalidatedHeader[1],
            cookie: revalidatedHeader[2]
        };
    } catch (e) {
        revalidatedParts = {
            paths: [],
            tag: false,
            cookie: false
        };
    }
    const redirectLocation = location ? new URL(addBasePath(location), new URL(state.canonicalUrl, window.location.href)) : undefined;
    let isFlightResponse = res.headers.get("content-type") === RSC_CONTENT_TYPE_HEADER;
    if (isFlightResponse) {
        const response = await createFromFetch(Promise.resolve(res), {
            callServer
        });
        if (location) {
            // if it was a redirection, then result is just a regular RSC payload
            const [, actionFlightData] = response != null ? response : [];
            return {
                actionFlightData: actionFlightData,
                redirectLocation,
                revalidatedParts
            };
        }
        // otherwise it's a tuple of [actionResult, actionFlightData]
        const [actionResult, [, actionFlightData]] = response != null ? response : [];
        return {
            actionResult,
            actionFlightData,
            redirectLocation,
            revalidatedParts
        };
    }
    return {
        redirectLocation,
        revalidatedParts
    };
}
/*
 * This reducer is responsible for calling the server action and processing any side-effects from the server action.
 * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.
 */ export function serverActionReducer(state, action) {
    const { resolve, reject } = action;
    const mutable = {};
    const href = state.canonicalUrl;
    let currentTree = state.tree;
    mutable.preserveCustomHistoryState = false;
    // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.
    // If the route has been intercepted, the action should be as well.
    // Otherwise the server action might be intercepted with the wrong action id
    // (ie, one that corresponds with the intercepted route)
    const nextUrl = state.nextUrl && hasInterceptionRouteInCurrentTree(state.tree) ? state.nextUrl : null;
    mutable.inFlightServerAction = fetchServerAction(state, nextUrl, action);
    return mutable.inFlightServerAction.then(async (param)=>{
        let { actionResult, actionFlightData: flightData, redirectLocation } = param;
        // Make sure the redirection is a push instead of a replace.
        // Issue: https://github.com/vercel/next.js/issues/53911
        if (redirectLocation) {
            state.pushRef.pendingPush = true;
            mutable.pendingPush = true;
        }
        if (!flightData) {
            resolve(actionResult);
            // If there is a redirect but no flight data we need to do a mpaNavigation.
            if (redirectLocation) {
                return handleExternalUrl(state, mutable, redirectLocation.href, state.pushRef.pendingPush);
            }
            return state;
        }
        if (typeof flightData === "string") {
            // Handle case when navigating to page in `pages` from `app`
            return handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);
        }
        // Remove cache.data as it has been resolved at this point.
        mutable.inFlightServerAction = null;
        if (redirectLocation) {
            const newHref = createHrefFromUrl(redirectLocation, false);
            mutable.canonicalUrl = newHref;
        }
        for (const flightDataPath of flightData){
            // FlightDataPath with more than two items means unexpected Flight data was returned
            if (flightDataPath.length !== 3) {
                // TODO-APP: handle this case better
                console.log("SERVER ACTION APPLY FAILED");
                return state;
            }
            // Given the path can only have two items the items are only the router state and rsc for the root.
            const [treePatch] = flightDataPath;
            const newTree = applyRouterStatePatchToTree([
                ""
            ], currentTree, treePatch, redirectLocation ? createHrefFromUrl(redirectLocation) : state.canonicalUrl);
            if (newTree === null) {
                return handleSegmentMismatch(state, action, treePatch);
            }
            if (isNavigatingToNewRootLayout(currentTree, newTree)) {
                return handleExternalUrl(state, mutable, href, state.pushRef.pendingPush);
            }
            // The one before last item is the router state tree patch
            const [cacheNodeSeedData, head] = flightDataPath.slice(-2);
            const rsc = cacheNodeSeedData !== null ? cacheNodeSeedData[2] : null;
            // Handles case where prefetch only returns the router tree patch without rendered components.
            if (rsc !== null) {
                const cache = createEmptyCacheNode();
                cache.rsc = rsc;
                cache.prefetchRsc = null;
                fillLazyItemsTillLeafWithHead(cache, undefined, treePatch, cacheNodeSeedData, head);
                await refreshInactiveParallelSegments({
                    state,
                    updatedTree: newTree,
                    updatedCache: cache,
                    includeNextUrl: Boolean(nextUrl),
                    canonicalUrl: mutable.canonicalUrl || state.canonicalUrl
                });
                mutable.cache = cache;
                mutable.prefetchCache = new Map();
            }
            mutable.patchedTree = newTree;
            currentTree = newTree;
        }
        resolve(actionResult);
        return handleMutable(state, mutable);
    }, (e)=>{
        // When the server action is rejected we don't update the state and instead call the reject handler of the promise.
        reject(e);
        return state;
    });
} //# sourceMappingURL=server-action-reducer.js.map
"  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/server-action-reducer.ts"],"names":["callServer","ACTION","NEXT_ROUTER_STATE_TREE","NEXT_URL","RSC_CONTENT_TYPE_HEADER","createFromFetch","encodeReply","process","env","NEXT_RUNTIME","require","addBasePath","createHrefFromUrl","handleExternalUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleMutable","fillLazyItemsTillLeafWithHead","createEmptyCacheNode","hasInterceptionRouteInCurrentTree","handleSegmentMismatch","refreshInactiveParallelSegments","fetchServerAction","state","nextUrl","param","actionId","actionArgs","body","res","fetch","method","headers","Accept","encodeURIComponent","JSON","stringify","tree","NEXT_DEPLOYMENT_ID","location","get","revalidatedParts","revalidatedHeader","parse","paths","tag","cookie","e","redirectLocation","URL","canonicalUrl","window","href","undefined","isFlightResponse","response","Promise","resolve","actionFlightData","actionResult","serverActionReducer","action","reject","mutable","currentTree","preserveCustomHistoryState","inFlightServerAction","then","flightData","pushRef","pendingPush","newHref","flightDataPath","length","console","log","treePatch","newTree","cacheNodeSeedData","head","slice","rsc","cache","prefetchRsc","updatedTree","updatedCache","includeNextUrl","Boolean","prefetchCache","Map","patchedTree"],"mappings":"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","file":"x"}`  false053undefined55163undefined470495 trueundefined499505__webpack_require__undefined5075441502undefined5495900undefined593645undefined647706undefined708762undefined764845undefined847928undefined930979undefined9811067undefined10691124undefined11261218undefined12201286undefined12881375undefined17801809 falseundefined181318930undefined38313837undefinedC   27162734server_action_reducer_serverActionReducerundefinedRawSourcej   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/router-reducer.js
£¤Ð  import { ACTION_NAVIGATE, ACTION_SERVER_PATCH, ACTION_RESTORE, ACTION_REFRESH, ACTION_PREFETCH, ACTION_FAST_REFRESH, ACTION_SERVER_ACTION } from "./router-reducer-types";
import { navigateReducer } from "./reducers/navigate-reducer";
import { serverPatchReducer } from "./reducers/server-patch-reducer";
import { restoreReducer } from "./reducers/restore-reducer";
import { refreshReducer } from "./reducers/refresh-reducer";
import { prefetchReducer } from "./reducers/prefetch-reducer";
import { fastRefreshReducer } from "./reducers/fast-refresh-reducer";
import { serverActionReducer } from "./reducers/server-action-reducer";
/**
 * Reducer that handles the app-router state updates.
 */ function clientReducer(state, action) {
    switch(action.type){
        case ACTION_NAVIGATE:
            {
                return navigateReducer(state, action);
            }
        case ACTION_SERVER_PATCH:
            {
                return serverPatchReducer(state, action);
            }
        case ACTION_RESTORE:
            {
                return restoreReducer(state, action);
            }
        case ACTION_REFRESH:
            {
                return refreshReducer(state, action);
            }
        case ACTION_FAST_REFRESH:
            {
                return fastRefreshReducer(state, action);
            }
        case ACTION_PREFETCH:
            {
                return prefetchReducer(state, action);
            }
        case ACTION_SERVER_ACTION:
            {
                return serverActionReducer(state, action);
            }
        // This case should never be hit as dispatch is strongly typed.
        default:
            throw new Error("Unknown action");
    }
}
function serverReducer(state, _action) {
    return state;
}
// we don't run the client reducer on the server, so we use a noop function for better tree shaking
export const reducer = "undefined" === "undefined" ? serverReducer : clientReducer; //# sourceMappingURL=router-reducer.js.map
j  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/router-reducer.ts"],"names":["ACTION_NAVIGATE","ACTION_SERVER_PATCH","ACTION_RESTORE","ACTION_REFRESH","ACTION_PREFETCH","ACTION_FAST_REFRESH","ACTION_SERVER_ACTION","navigateReducer","serverPatchReducer","restoreReducer","refreshReducer","prefetchReducer","fastRefreshReducer","serverActionReducer","clientReducer","state","action","type","Error","serverReducer","_action","reducer"],"mappings":"AAAA,SACEA,eAAe,EACfC,mBAAmB,EACnBC,cAAc,EACdC,cAAc,EACdC,eAAe,EACfC,mBAAmB,EACnBC,oBAAoB,QACf,yBAAwB;AAM/B,SAASC,eAAe,QAAQ,8BAA6B;AAC7D,SAASC,kBAAkB,QAAQ,kCAAiC;AACpE,SAASC,cAAc,QAAQ,6BAA4B;AAC3D,SAASC,cAAc,QAAQ,6BAA4B;AAC3D,SAASC,eAAe,QAAQ,8BAA6B;AAC7D,SAASC,kBAAkB,QAAQ,kCAAiC;AACpE,SAASC,mBAAmB,QAAQ,mCAAkC;AAEtE;;CAEC,GACD,SAASC,cACPC,KAA2B,EAC3BC,MAAsB;IAEtB,OAAQA,OAAOC,IAAI;QACjB,KAAKjB;YAAiB;gBACpB,OAAOO,gBAAgBQ,OAAOC;YAChC;QACA,KAAKf;YAAqB;gBACxB,OAAOO,mBAAmBO,OAAOC;YACnC;QACA,KAAKd;YAAgB;gBACnB,OAAOO,eAAeM,OAAOC;YAC/B;QACA,KAAKb;YAAgB;gBACnB,OAAOO,eAAeK,OAAOC;YAC/B;QACA,KAAKX;YAAqB;gBACxB,OAAOO,mBAAmBG,OAAOC;YACnC;QACA,KAAKZ;YAAiB;gBACpB,OAAOO,gBAAgBI,OAAOC;YAChC;QACA,KAAKV;YAAsB;gBACzB,OAAOO,oBAAoBE,OAAOC;YACpC;QACA,+DAA+D;QAC/D;YACE,MAAM,IAAIE,MAAM;IACpB;AACF;AAEA,SAASC,cACPJ,KAA2B,EAC3BK,OAAuB;IAEvB,OAAOL;AACT;AAEA,mGAAmG;AACnG,OAAO,MAAMM,UACX,gBAAkB,cAAcF,gBAAgBL,cAAa","file":"x"}  false0169undefined171232undefined234302undefined304363undefined365424undefined426487undefined489557undefined559629undefined18731879undefined18961895(/* unused pure expression or super */ null && (undefined18961922 trueundefined194219540undefined19551954))undefined0   12561262router_reducer_reducerundefinedRawSourceY   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/shared/lib/router/action-queue.js
žŸf  import { isThenable, ACTION_REFRESH, ACTION_SERVER_ACTION, ACTION_NAVIGATE, ACTION_RESTORE } from "../../../client/components/router-reducer/router-reducer-types";
import { reducer } from "../../../client/components/router-reducer/router-reducer";
import React, { startTransition } from "react";
export const ActionQueueContext = /*#__PURE__*/ React.createContext(null);
function runRemainingActions(actionQueue, setState) {
    if (actionQueue.pending !== null) {
        actionQueue.pending = actionQueue.pending.next;
        if (actionQueue.pending !== null) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            runAction({
                actionQueue,
                action: actionQueue.pending,
                setState
            });
        } else {
            // No more actions are pending, check if a refresh is needed
            if (actionQueue.needsRefresh) {
                actionQueue.needsRefresh = false;
                actionQueue.dispatch({
                    type: ACTION_REFRESH,
                    origin: window.location.origin
                }, setState);
            }
        }
    }
}
async function runAction(param) {
    let { actionQueue, action, setState } = param;
    const prevState = actionQueue.state;
    if (!prevState) {
        // This shouldn't happen as the state is initialized in the dispatcher if it's not set
        throw new Error("Invariant: Router state not initialized");
    }
    actionQueue.pending = action;
    const payload = action.payload;
    const actionResult = actionQueue.action(prevState, payload);
    function handleResult(nextState) {
        // if we discarded this action, the state should also be discarded
        if (action.discarded) {
            return;
        }
        actionQueue.state = nextState;
        if (actionQueue.devToolsInstance) {
            actionQueue.devToolsInstance.send(payload, nextState);
        }
        runRemainingActions(actionQueue, setState);
        action.resolve(nextState);
    }
    // if the action is a promise, set up a callback to resolve it
    if (isThenable(actionResult)) {
        actionResult.then(handleResult, (err)=>{
            runRemainingActions(actionQueue, setState);
            action.reject(err);
        });
    } else {
        handleResult(actionResult);
    }
}
function dispatchAction(actionQueue, payload, setState) {
    let resolvers = {
        resolve: setState,
        reject: ()=>{}
    };
    // most of the action types are async with the exception of restore
    // it's important that restore is handled quickly since it's fired on the popstate event
    // and we don't want to add any delay on a back/forward nav
    // this only creates a promise for the async actions
    if (payload.type !== ACTION_RESTORE) {
        // Create the promise and assign the resolvers to the object.
        const deferredPromise = new Promise((resolve, reject)=>{
            resolvers = {
                resolve,
                reject
            };
        });
        startTransition(()=>{
            // we immediately notify React of the pending promise -- the resolver is attached to the action node
            // and will be called when the associated action promise resolves
            setState(deferredPromise);
        });
    }
    const newAction = {
        payload,
        next: null,
        resolve: resolvers.resolve,
        reject: resolvers.reject
    };
    // Check if the queue is empty
    if (actionQueue.pending === null) {
        // The queue is empty, so add the action and start it immediately
        // Mark this action as the last in the queue
        actionQueue.last = newAction;
        runAction({
            actionQueue,
            action: newAction,
            setState
        });
    } else if (payload.type === ACTION_NAVIGATE || payload.type === ACTION_RESTORE) {
        // Navigations (including back/forward) take priority over any pending actions.
        // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.
        actionQueue.pending.discarded = true;
        // Mark this action as the last in the queue
        actionQueue.last = newAction;
        // if the pending action was a server action, mark the queue as needing a refresh once events are processed
        if (actionQueue.pending.payload.type === ACTION_SERVER_ACTION) {
            actionQueue.needsRefresh = true;
        }
        runAction({
            actionQueue,
            action: newAction,
            setState
        });
    } else {
        // The queue is not empty, so add the action to the end of the queue
        // It will be started by runRemainingActions after the previous action finishes
        if (actionQueue.last !== null) {
            actionQueue.last.next = newAction;
        }
        actionQueue.last = newAction;
    }
}
export function createMutableActionQueue() {
    const actionQueue = {
        state: null,
        dispatch: (payload, setState)=>dispatchAction(actionQueue, payload, setState),
        action: async (state, action)=>{
            if (state === null) {
                throw new Error("Invariant: Router state not initialized");
            }
            const result = reducer(state, action);
            return result;
        },
        pending: null,
        last: null
    };
    return actionQueue;
} //# sourceMappingURL=action-queue.js.map
²  {"version":3,"sources":["webpack://../../../../src/shared/lib/router/action-queue.ts"],"names":["isThenable","ACTION_REFRESH","ACTION_SERVER_ACTION","ACTION_NAVIGATE","ACTION_RESTORE","reducer","React","startTransition","ActionQueueContext","createContext","runRemainingActions","actionQueue","setState","pending","next","runAction","action","needsRefresh","dispatch","type","origin","window","location","param","prevState","state","Error","payload","actionResult","handleResult","nextState","discarded","devToolsInstance","send","resolve","then","err","reject","dispatchAction","resolvers","deferredPromise","Promise","newAction","last","createMutableActionQueue","result"],"mappings":"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","file":"x"}    false0162undefined164246undefined248294undefined296302undefined344343(/* unused pure expression or super */ null && (undefined369368))undefined49294935undefined4   926action_queue_ActionQueueContextundefinedRawSourcef   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/use-reducer-with-devtools.js
™ší  import React, { use, useContext } from "react";
import { useRef, useEffect, useCallback } from "react";
import { isThenable } from "./router-reducer/router-reducer-types";
import { ActionQueueContext } from "../../shared/lib/router/action-queue";
function normalizeRouterState(val) {
    if (val instanceof Map) {
        const obj = {};
        for (const [key, value] of val.entries()){
            if (typeof value === "function") {
                obj[key] = "fn()";
                continue;
            }
            if (typeof value === "object" && value !== null) {
                if (value.$$typeof) {
                    obj[key] = value.$$typeof.toString();
                    continue;
                }
                if (value._bundlerConfig) {
                    obj[key] = "FlightData";
                    continue;
                }
            }
            obj[key] = normalizeRouterState(value);
        }
        return obj;
    }
    if (typeof val === "object" && val !== null) {
        const obj = {};
        for(const key in val){
            const value = val[key];
            if (typeof value === "function") {
                obj[key] = "fn()";
                continue;
            }
            if (typeof value === "object" && value !== null) {
                if (value.$$typeof) {
                    obj[key] = value.$$typeof.toString();
                    continue;
                }
                if (value.hasOwnProperty("_bundlerConfig")) {
                    obj[key] = "FlightData";
                    continue;
                }
            }
            obj[key] = normalizeRouterState(value);
        }
        return obj;
    }
    if (Array.isArray(val)) {
        return val.map(normalizeRouterState);
    }
    return val;
}
export function useUnwrapState(state) {
    // reducer actions can be async, so sometimes we need to suspend until the state is resolved
    if (isThenable(state)) {
        const result = use(state);
        return result;
    }
    return state;
}
function useReducerWithReduxDevtoolsNoop(initialState) {
    return [
        initialState,
        ()=>{},
        ()=>{}
    ];
}
function useReducerWithReduxDevtoolsImpl(initialState) {
    const [state, setState] = React.useState(initialState);
    const actionQueue = useContext(ActionQueueContext);
    if (!actionQueue) {
        throw new Error("Invariant: Missing ActionQueueContext");
    }
    const devtoolsConnectionRef = useRef();
    const enabledRef = useRef();
    null;
    const dispatch = useCallback((action)=>{
        if (!actionQueue.state) {
            // we lazy initialize the mutable action queue state since the data needed
            // to generate the state is not available when the actionQueue context is created
            actionQueue.state = initialState;
        }
        actionQueue.dispatch(action, setState);
    }, [
        actionQueue,
        initialState
    ]);
    // Sync is called after a state update in the HistoryUpdater,
    // for debugging purposes. Since the reducer state may be a Promise,
    // we let the app router use() it and sync on the resolved value if
    // something changed.
    // Using the `state` here would be referentially unstable and cause
    // undesirable re-renders and history updates.
    const sync = useCallback((resolvedState)=>{
        if (devtoolsConnectionRef.current) {
            devtoolsConnectionRef.current.send({
                type: "RENDER_SYNC"
            }, normalizeRouterState(resolvedState));
        }
    }, []);
    return [
        state,
        dispatch,
        sync
    ];
}
export const useReducerWithReduxDevtools = "undefined" !== "undefined" ? useReducerWithReduxDevtoolsImpl : useReducerWithReduxDevtoolsNoop; //# sourceMappingURL=use-reducer-with-devtools.js.map
“
  {"version":3,"sources":["webpack://../../../src/client/components/use-reducer-with-devtools.ts"],"names":["React","use","useContext","useRef","useEffect","useCallback","isThenable","ActionQueueContext","normalizeRouterState","val","Map","obj","key","value","entries","$$typeof","toString","_bundlerConfig","hasOwnProperty","Array","isArray","map","useUnwrapState","state","result","useReducerWithReduxDevtoolsNoop","initialState","useReducerWithReduxDevtoolsImpl","setState","useState","actionQueue","Error","devtoolsConnectionRef","enabledRef","dispatch","action","sync","resolvedState","current","send","type","useReducerWithReduxDevtools"],"mappings":"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","file":"x"}N  false046undefined48102undefined104170undefined172245undefined17851791undefined19301939__WEBPACK_MODULE_REFERENCE__3_5b2269735468656e61626c65225d_call_directImport_asiSafe1__._undefined19741976__WEBPACK_MODULE_REFERENCE__1_5b22757365225d_call_directImport_asiSafe1__._undefined36273633undefined36703696 falseundefined370037300undefinedc   16801768(0,router_reducer_types/* isThenable */.J8)undefined18031877(0,react.use)undefinedRawSource“  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/error-boundary.js + 1 modules
var error_boundary = __webpack_require__(6120);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/future/helpers/interception-routes.js
var interception_routes = __webpack_require__(117);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/compute-changed-path.js
”•X  import { INTERCEPTION_ROUTE_MARKERS } from "../../../server/future/helpers/interception-routes";
import { isGroupSegment, DEFAULT_SEGMENT_KEY, PAGE_SEGMENT_KEY } from "../../../shared/lib/segment";
import { matchSegment } from "../match-segments";
const removeLeadingSlash = (segment)=>{
    return segment[0] === "/" ? segment.slice(1) : segment;
};
const segmentToPathname = (segment)=>{
    if (typeof segment === "string") {
        // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page
        // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.
        if (segment === "children") return "";
        return segment;
    }
    return segment[1];
};
function normalizeSegments(segments) {
    return segments.reduce((acc, segment)=>{
        segment = removeLeadingSlash(segment);
        if (segment === "" || isGroupSegment(segment)) {
            return acc;
        }
        return acc + "/" + segment;
    }, "") || "/";
}
export function extractPathFromFlightRouterState(flightRouterState) {
    const segment = Array.isArray(flightRouterState[0]) ? flightRouterState[0][1] : flightRouterState[0];
    if (segment === DEFAULT_SEGMENT_KEY || INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m))) return undefined;
    if (segment.startsWith(PAGE_SEGMENT_KEY)) return "";
    const segments = [
        segmentToPathname(segment)
    ];
    var _flightRouterState_;
    const parallelRoutes = (_flightRouterState_ = flightRouterState[1]) != null ? _flightRouterState_ : {};
    const childrenPath = parallelRoutes.children ? extractPathFromFlightRouterState(parallelRoutes.children) : undefined;
    if (childrenPath !== undefined) {
        segments.push(childrenPath);
    } else {
        for (const [key, value] of Object.entries(parallelRoutes)){
            if (key === "children") continue;
            const childPath = extractPathFromFlightRouterState(value);
            if (childPath !== undefined) {
                segments.push(childPath);
            }
        }
    }
    return normalizeSegments(segments);
}
function computeChangedPathImpl(treeA, treeB) {
    const [segmentA, parallelRoutesA] = treeA;
    const [segmentB, parallelRoutesB] = treeB;
    const normalizedSegmentA = segmentToPathname(segmentA);
    const normalizedSegmentB = segmentToPathname(segmentB);
    if (INTERCEPTION_ROUTE_MARKERS.some((m)=>normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m))) {
        return "";
    }
    if (!matchSegment(segmentA, segmentB)) {
        var _extractPathFromFlightRouterState;
        // once we find where the tree changed, we compute the rest of the path by traversing the tree
        return (_extractPathFromFlightRouterState = extractPathFromFlightRouterState(treeB)) != null ? _extractPathFromFlightRouterState : "";
    }
    for(const parallelRouterKey in parallelRoutesA){
        if (parallelRoutesB[parallelRouterKey]) {
            const changedPath = computeChangedPathImpl(parallelRoutesA[parallelRouterKey], parallelRoutesB[parallelRouterKey]);
            if (changedPath !== null) {
                return segmentToPathname(segmentB) + "/" + changedPath;
            }
        }
    }
    return null;
}
export function computeChangedPath(treeA, treeB) {
    const changedPath = computeChangedPathImpl(treeA, treeB);
    if (changedPath == null || changedPath === "/") {
        return changedPath;
    }
    // lightweight normalization to remove route groups
    return normalizeSegments(changedPath.split("/"));
} //# sourceMappingURL=compute-changed-path.js.map
  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/compute-changed-path.ts"],"names":["INTERCEPTION_ROUTE_MARKERS","isGroupSegment","DEFAULT_SEGMENT_KEY","PAGE_SEGMENT_KEY","matchSegment","removeLeadingSlash","segment","slice","segmentToPathname","normalizeSegments","segments","reduce","acc","extractPathFromFlightRouterState","flightRouterState","Array","isArray","some","m","startsWith","undefined","parallelRoutes","childrenPath","children","push","key","value","Object","entries","childPath","computeChangedPathImpl","treeA","treeB","segmentA","parallelRoutesA","segmentB","parallelRoutesB","normalizedSegmentA","normalizedSegmentB","parallelRouterKey","changedPath","computeChangedPath","split"],"mappings":"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","file":"x"})  false095undefined97196undefined198246undefined942955__WEBPACK_MODULE_REFERENCE__11_5b22697347726f75705365676d656e74225d_call_directImport_asiSafe1__._undefined10601066undefined12561274__WEBPACK_MODULE_REFERENCE__11_5b2244454641554c545f5345474d454e545f4b4559225d_directImport_asiSafe1__._undefined12791304__WEBPACK_MODULE_REFERENCE__33_5b22494e54455243455054494f4e5f524f5554455f4d41524b455253225d_call_asiSafe1__._undefined13851400__WEBPACK_MODULE_REFERENCE__11_5b22504147455f5345474d454e545f4b4559225d_directImport_asiSafe1__._undefined33103316undefined  697794(0,lib_segment/* isGroupSegment */.lv)undefined908939compute_changed_path_extractPathFromFlightRouterStateundefined10881190lib_segment/* DEFAULT_SEGMENT_KEY */.avundefined11951303interception_routes/* INTERCEPTION_ROUTE_MARKERS */.Wzundefined13841480lib_segment/* PAGE_SEGMENT_KEY */.GCundefined17481779compute_changed_path_extractPathFromFlightRouterStateundefined20512082compute_changed_path_extractPathFromFlightRouterStateundefined29012932compute_changed_path_extractPathFromFlightRouterStateundefinedRawSourcew   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/create-initial-router-state.js
é  import { createHrefFromUrl } from "./create-href-from-url";
import { fillLazyItemsTillLeafWithHead } from "./fill-lazy-items-till-leaf-with-head";
import { extractPathFromFlightRouterState } from "./compute-changed-path";
import { createPrefetchCacheEntryForInitialLoad } from "./prefetch-cache-utils";
import { PrefetchKind } from "./router-reducer-types";
import { addRefreshMarkerToActiveParallelSegments } from "./refetch-inactive-parallel-segments";
export function createInitialRouterState(param) {
    let { buildId, initialTree, initialSeedData, initialCanonicalUrl, initialParallelRoutes, location, initialHead, couldBeIntercepted } = param;
    const isServer = !location;
    const rsc = initialSeedData[2];
    const cache = {
        lazyData: null,
        rsc: rsc,
        prefetchRsc: null,
        head: null,
        prefetchHead: null,
        // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.
        parallelRoutes: isServer ? new Map() : initialParallelRoutes,
        lazyDataResolved: false,
        loading: initialSeedData[3]
    };
    const canonicalUrl = // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.
    location ? createHrefFromUrl(location) : initialCanonicalUrl;
    addRefreshMarkerToActiveParallelSegments(initialTree, canonicalUrl);
    const prefetchCache = new Map();
    // When the cache hasn't been seeded yet we fill the cache with the head.
    if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {
        fillLazyItemsTillLeafWithHead(cache, undefined, initialTree, initialSeedData, initialHead);
    }
    var _ref;
    const initialState = {
        buildId,
        tree: initialTree,
        cache,
        prefetchCache,
        pushRef: {
            pendingPush: false,
            mpaNavigation: false,
            // First render needs to preserve the previous window.history.state
            // to avoid it being overwritten on navigation back/forward with MPA Navigation.
            preserveCustomHistoryState: true
        },
        focusAndScrollRef: {
            apply: false,
            onlyHashChange: false,
            hashFragment: null,
            segmentPaths: []
        },
        canonicalUrl,
        nextUrl: (_ref = extractPathFromFlightRouterState(initialTree) || (location == null ? void 0 : location.pathname)) != null ? _ref : null
    };
    if (location) {
        // Seed the prefetch cache with this page's data.
        // This is to prevent needlessly re-prefetching a page that is already reusable,
        // and will avoid triggering a loading state/data fetch stall when navigating back to the page.
        const url = new URL("" + location.pathname + location.search, location.origin);
        const initialFlightData = [
            [
                "",
                initialTree,
                null,
                null
            ]
        ];
        createPrefetchCacheEntryForInitialLoad({
            url,
            kind: PrefetchKind.AUTO,
            data: [
                initialFlightData,
                undefined,
                false,
                couldBeIntercepted
            ],
            tree: initialState.tree,
            prefetchCache: initialState.prefetchCache,
            nextUrl: initialState.nextUrl
        });
    }
    return initialState;
} //# sourceMappingURL=create-initial-router-state.js.map
	  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/create-initial-router-state.ts"],"names":["createHrefFromUrl","fillLazyItemsTillLeafWithHead","extractPathFromFlightRouterState","createPrefetchCacheEntryForInitialLoad","PrefetchKind","addRefreshMarkerToActiveParallelSegments","createInitialRouterState","param","buildId","initialTree","initialSeedData","initialCanonicalUrl","initialParallelRoutes","location","initialHead","couldBeIntercepted","isServer","rsc","cache","lazyData","prefetchRsc","head","prefetchHead","parallelRoutes","Map","lazyDataResolved","loading","canonicalUrl","prefetchCache","size","undefined","initialState","tree","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","onlyHashChange","hashFragment","segmentPaths","nextUrl","pathname","url","URL","search","origin","initialFlightData","kind","AUTO","data"],"mappings":"AAQA,SAASA,iBAAiB,QAAQ,yBAAwB;AAC1D,SAASC,6BAA6B,QAAQ,wCAAuC;AACrF,SAASC,gCAAgC,QAAQ,yBAAwB;AACzE,SAASC,sCAAsC,QAAQ,yBAAwB;AAC/E,SAASC,YAAY,QAAiC,yBAAwB;AAC9E,SAASC,wCAAwC,QAAQ,uCAAsC;AAa/F,OAAO,SAASC,yBAAyBC,KASV;IATU,IAAA,EACvCC,OAAO,EACPC,WAAW,EACXC,eAAe,EACfC,mBAAmB,EACnBC,qBAAqB,EACrBC,QAAQ,EACRC,WAAW,EACXC,kBAAkB,EACW,GATUR;IAUvC,MAAMS,WAAW,CAACH;IAClB,MAAMI,MAAMP,eAAe,CAAC,EAAE;IAE9B,MAAMQ,QAAmB;QACvBC,UAAU;QACVF,KAAKA;QACLG,aAAa;QACbC,MAAM;QACNC,cAAc;QACd,oJAAoJ;QACpJC,gBAAgBP,WAAW,IAAIQ,QAAQZ;QACvCa,kBAAkB;QAClBC,SAAShB,eAAe,CAAC,EAAE;IAC7B;IAEA,MAAMiB,eAEJ,kJAAkJ;IAClJd,WAEIb,kBAAkBa,YAClBF;IAENN,yCAAyCI,aAAakB;IAEtD,MAAMC,gBAAgB,IAAIJ;IAE1B,yEAAyE;IACzE,IAAIZ,0BAA0B,QAAQA,sBAAsBiB,IAAI,KAAK,GAAG;QACtE5B,8BACEiB,OACAY,WACArB,aACAC,iBACAI;IAEJ;QAuBKZ;IArBL,MAAM6B,eAAe;QACnBvB;QACAwB,MAAMvB;QACNS;QACAU;QACAK,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,mEAAmE;YACnE,gFAAgF;YAChFC,4BAA4B;QAC9B;QACAC,mBAAmB;YACjBC,OAAO;YACPC,gBAAgB;YAChBC,cAAc;YACdC,cAAc,EAAE;QAClB;QACAd;QACAe,SAEE,AAACxC,CAAAA,OAAAA,iCAAiCO,gBAAgBI,CAAAA,YAAAA,OAAAA,KAAAA,IAAAA,SAAU8B,QAAQ,AAARA,CAAQ,KAAA,OAAnEzC,OACD;IACJ;IAEA,IAAIW,UAAU;QACZ,iDAAiD;QACjD,gFAAgF;QAChF,+FAA+F;QAC/F,MAAM+B,MAAM,IAAIC,IACd,KAAGhC,SAAS8B,QAAQ,GAAG9B,SAASiC,MAAM,EACtCjC,SAASkC,MAAM;QAGjB,MAAMC,oBAAgC;YAAC;gBAAC;gBAAIvC;gBAAa;gBAAM;aAAK;SAAC;QACrEN,uCAAuC;YACrCyC;YACAK,MAAM7C,aAAa8C,IAAI;YACvBC,MAAM;gBAACH;gBAAmBlB;gBAAW;gBAAOf;aAAmB;YAC/DiB,MAAMD,aAAaC,IAAI;YACvBJ,eAAeG,aAAaH,aAAa;YACzCc,SAASX,aAAaW,OAAO;QAC/B;IACF;IAEA,OAAOX;AACT","file":"x"}¯  false058undefined60145undefined147220undefined222301undefined303356undefined358453undefined455461undefined13461362__WEBPACK_MODULE_REFERENCE__4_5b226372656174654872656646726f6d55726c225d_call_directImport_asiSafe1__._undefined14011440__WEBPACK_MODULE_REFERENCE__12_5b22616464526566726573684d61726b6572546f416374697665506172616c6c656c5365676d656e7473225d_call_directImport_asiSafe1__._undefined16711699__WEBPACK_MODULE_REFERENCE__8_5b2266696c6c4c617a794974656d7354696c6c4c6561665769746848656164225d_call_directImport_asiSafe1__._undefined24152446__WEBPACK_MODULE_REFERENCE__34_5b22657874726163745061746846726f6d466c69676874526f757465725374617465225d_call_directImport_asiSafe1__._undefined30763113__WEBPACK_MODULE_REFERENCE__18_5b2263726561746550726566657463684361636865456e747279466f72496e697469616c4c6f6164225d_call_directImport_asiSafe1__._undefined31523163__WEBPACK_MODULE_REFERENCE__3_5b2250726566657463684b696e64225d_asiSafe1__._undefined£  890992create_href_from_url_createHrefFromUrlundefined10311180refetch_inactive_parallel_segments_addRefreshMarkerToActiveParallelSegmentsundefined14111537fill_lazy_items_till_leaf_with_head_fillLazyItemsTillLeafWithHeadundefined22532386compute_changed_path_extractPathFromFlightRouterStateundefined30163161createPrefetchCacheEntryForInitialLoadundefined32003274router_reducer_types/* PrefetchKind */.KeundefinedRawSource~  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/is-bot.js
var is_bot = __webpack_require__(5524);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/add-path-prefix.js
var add_path_prefix = __webpack_require__(7253);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/remove-trailing-slash.js
var remove_trailing_slash = __webpack_require__(1496);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/parse-path.js
var parse_path = __webpack_require__(6540);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/normalize-trailing-slash.js
Š‹§  import { removeTrailingSlash } from "../shared/lib/router/utils/remove-trailing-slash";
import { parsePath } from "../shared/lib/router/utils/parse-path";
/**
 * Normalizes the trailing slash of a path according to the `trailingSlash` option
 * in `next.config.js`.
 */ export const normalizePathTrailingSlash = (path)=>{
    if (!path.startsWith("/") || process.env.__NEXT_MANUAL_TRAILING_SLASH) {
        return path;
    }
    const { pathname, query, hash } = parsePath(path);
    if (process.env.__NEXT_TRAILING_SLASH) {
        if (/\.[^/]+\/?$/.test(pathname)) {
            return "" + removeTrailingSlash(pathname) + query + hash;
        } else if (pathname.endsWith("/")) {
            return "" + pathname + query + hash;
        } else {
            return pathname + "/" + query + hash;
        }
    }
    return "" + removeTrailingSlash(pathname) + query + hash;
}; //# sourceMappingURL=normalize-trailing-slash.js.map
C  {"version":3,"sources":["webpack://../../src/client/normalize-trailing-slash.ts"],"names":["removeTrailingSlash","parsePath","normalizePathTrailingSlash","path","startsWith","process","env","__NEXT_MANUAL_TRAILING_SLASH","pathname","query","hash","__NEXT_TRAILING_SLASH","test","endsWith"],"mappings":"AAAA,SAASA,mBAAmB,QAAQ,mDAAkD;AACtF,SAASC,SAAS,QAAQ,wCAAuC;AAEjE;;;CAGC,GACD,OAAO,MAAMC,6BAA6B,CAACC;IACzC,IAAI,CAACA,KAAKC,UAAU,CAAC,QAAQC,QAAQC,GAAG,CAACC,4BAA4B,EAAE;QACrE,OAAOJ;IACT;IAEA,MAAM,EAAEK,QAAQ,EAAEC,KAAK,EAAEC,IAAI,EAAE,GAAGT,UAAUE;IAC5C,IAAIE,QAAQC,GAAG,CAACK,qBAAqB,EAAE;QACrC,IAAI,cAAcC,IAAI,CAACJ,WAAW;YAChC,OAAO,KAAGR,oBAAoBQ,YAAYC,QAAQC;QACpD,OAAO,IAAIF,SAASK,QAAQ,CAAC,MAAM;YACjC,OAAO,KAAGL,WAAWC,QAAQC;QAC/B,OAAO;YACL,OAAOF,WAAY,MAAGC,QAAQC;QAChC;IACF;IAEA,OAAO,KAAGV,oBAAoBQ,YAAYC,QAAQC;AACpD,EAAC","file":"x"}M  false086undefined88153undefined270276undefined355394undefinedundefined464472__WEBPACK_MODULE_REFERENCE__39_5b22706172736550617468225d_call_directImport_asiSafe1__._undefined489521falseundefined524815{}undefined833851__WEBPACK_MODULE_REFERENCE__38_5b2272656d6f7665547261696c696e67536c617368225d_call_directImport_asiSafe1__._undefinedz   273360(0,parse_path/* parsePath */.c)undefined403510(0,remove_trailing_slash/* removeTrailingSlash */.Q)undefinedRawSourceO   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/add-base-path.js
…†±  import { addPathPrefix } from "../shared/lib/router/utils/add-path-prefix";
import { normalizePathTrailingSlash } from "./normalize-trailing-slash";
const basePath = process.env.__NEXT_ROUTER_BASEPATH || "";
export function addBasePath(path, required) {
    return normalizePathTrailingSlash(process.env.__NEXT_MANUAL_CLIENT_BASE_PATH && !required ? path : addPathPrefix(path, basePath));
} //# sourceMappingURL=add-base-path.js.map
ò  {"version":3,"sources":["webpack://../../src/client/add-base-path.ts"],"names":["addPathPrefix","normalizePathTrailingSlash","basePath","process","env","__NEXT_ROUTER_BASEPATH","addBasePath","path","required","__NEXT_MANUAL_CLIENT_BASE_PATH"],"mappings":"AAAA,SAASA,aAAa,QAAQ,6CAA4C;AAC1E,SAASC,0BAA0B,QAAQ,6BAA4B;AAEvE,MAAMC,WAAWC,QAASC,GAAG,CAACC,sBAAsB,IAAe;AAEnE,OAAO,SAASC,YAAYC,IAAY,EAAEC,QAAkB;IAC1D,OAAOP,2BACLE,QAAQC,GAAG,CAACK,8BAA8B,IAAI,CAACD,WAC3CD,OACAP,cAAcO,MAAML;AAE5B","file":"x"}`  false074undefined76147undefined166199 falseundefined208214undefined265290__WEBPACK_MODULE_REFERENCE__40_5b226e6f726d616c697a6550617468547261696c696e67536c617368225d_call_directImport_asiSafe1__._undefined292346 falseundefined3503530undefined357369__WEBPACK_MODULE_REFERENCE__37_5b2261646450617468507265666978225d_call_directImport_asiSafe1__._undefinedŽ   4252add_base_path_addBasePathundefined83204normalizePathTrailingSlashundefined219314(0,add_path_prefix/* addPathPrefix */.V)undefinedRawSourceñ   
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react-dom/server-rendering-stub.js
var server_rendering_stub = __webpack_require__(8754);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/app-router-announcer.js
€¯  import { useEffect, useRef, useState } from "react";
import { createPortal } from "react-dom";
const ANNOUNCER_TYPE = "next-route-announcer";
const ANNOUNCER_ID = "__next-route-announcer__";
function getAnnouncerNode() {
    var _existingAnnouncer_shadowRoot;
    const existingAnnouncer = document.getElementsByName(ANNOUNCER_TYPE)[0];
    if (existingAnnouncer == null ? void 0 : (_existingAnnouncer_shadowRoot = existingAnnouncer.shadowRoot) == null ? void 0 : _existingAnnouncer_shadowRoot.childNodes[0]) {
        return existingAnnouncer.shadowRoot.childNodes[0];
    } else {
        const container = document.createElement(ANNOUNCER_TYPE);
        container.style.cssText = "position:absolute";
        const announcer = document.createElement("div");
        announcer.ariaLive = "assertive";
        announcer.id = ANNOUNCER_ID;
        announcer.role = "alert";
        announcer.style.cssText = "position:absolute;border:0;height:1px;margin:-1px;padding:0;width:1px;clip:rect(0 0 0 0);overflow:hidden;white-space:nowrap;word-wrap:normal";
        // Use shadow DOM here to avoid any potential CSS bleed
        const shadow = container.attachShadow({
            mode: "open"
        });
        shadow.appendChild(announcer);
        document.body.appendChild(container);
        return announcer;
    }
}
export function AppRouterAnnouncer(param) {
    let { tree } = param;
    const [portalNode, setPortalNode] = useState(null);
    null;
    const [routeAnnouncement, setRouteAnnouncement] = useState("");
    const previousTitle = useRef();
    null;
    return portalNode ? /*#__PURE__*/ createPortal(routeAnnouncement, portalNode) : null;
} //# sourceMappingURL=app-router-announcer.js.map
Ý  {"version":3,"sources":["webpack://../../../src/client/components/app-router-announcer.tsx"],"names":["useEffect","useRef","useState","createPortal","ANNOUNCER_TYPE","ANNOUNCER_ID","getAnnouncerNode","existingAnnouncer","document","getElementsByName","shadowRoot","childNodes","container","createElement","style","cssText","announcer","ariaLive","id","role","shadow","attachShadow","mode","appendChild","body","AppRouterAnnouncer","param","tree","portalNode","setPortalNode","routeAnnouncement","setRouteAnnouncement","previousTitle"],"mappings":"AAAA,SAASA,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,QAAO;AACnD,SAASC,YAAY,QAAQ,YAAW;AAGxC,MAAMC,iBAAiB;AACvB,MAAMC,eAAe;AAErB,SAASC;QAEHC;IADJ,MAAMA,oBAAoBC,SAASC,iBAAiB,CAACL,eAAe,CAAC,EAAE;IACvE,IAAIG,qBAAAA,OAAAA,KAAAA,IAAAA,CAAAA,gCAAAA,kBAAmBG,UAAU,AAAVA,KAAU,OAAA,KAAA,IAA7BH,8BAA+BI,UAAU,CAAC,EAAE,EAAE;QAChD,OAAOJ,kBAAkBG,UAAU,CAACC,UAAU,CAAC,EAAE;IACnD,OAAO;QACL,MAAMC,YAAYJ,SAASK,aAAa,CAACT;QACzCQ,UAAUE,KAAK,CAACC,OAAO,GAAG;QAC1B,MAAMC,YAAYR,SAASK,aAAa,CAAC;QACzCG,UAAUC,QAAQ,GAAG;QACrBD,UAAUE,EAAE,GAAGb;QACfW,UAAUG,IAAI,GAAG;QACjBH,UAAUF,KAAK,CAACC,OAAO,GACrB;QAEF,uDAAuD;QACvD,MAAMK,SAASR,UAAUS,YAAY,CAAC;YAAEC,MAAM;QAAO;QACrDF,OAAOG,WAAW,CAACP;QACnBR,SAASgB,IAAI,CAACD,WAAW,CAACX;QAC1B,OAAOI;IACT;AACF;AAEA,OAAO,SAASS,mBAAmBC,KAAqC;IAArC,IAAA,EAAEC,IAAI,EAA+B,GAArCD;IACjC,MAAM,CAACE,YAAYC,cAAc,GAAG3B,SAA6B;;IAajE,MAAM,CAAC4B,mBAAmBC,qBAAqB,GAAG7B,SAAS;IAC3D,MAAM8B,gBAAgB/B;;IAwBtB,OAAO2B,aAAAA,WAAAA,GAAazB,aAAa2B,mBAAmBF,cAAc;AACpE","file":"x"}Ì  false051undefined5393undefined13201326undefined14301437__WEBPACK_MODULE_REFERENCE__1_5b227573655374617465225d_call_directImport_asiSafe1__._undefined15101517__WEBPACK_MODULE_REFERENCE__1_5b227573655374617465225d_call_directImport_asiSafe1__._undefined15501555__WEBPACK_MODULE_REFERENCE__1_5b22757365526566225d_call_directImport_asiSafe1__._undefined16081619__WEBPACK_MODULE_REFERENCE__42_5b22637265617465506f7274616c225d_call_directImport_asiSafe1__._undefined§   13301414(0,react.useState)undefined14871571(0,react.useState)undefined16041684(0,react.useRef)undefined17371830(0,server_rendering_stub.createPortal)undefinedRawSource  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/redirect-boundary.js
var redirect_boundary = __webpack_require__(7017);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/find-head-in-cache.js
{ÿÿÿ|ÿÿÿh  import { createRouterCacheKey } from "../create-router-cache-key";
export function findHeadInCache(cache, parallelRoutes) {
    return findHeadInCacheImpl(cache, parallelRoutes, "");
}
function findHeadInCacheImpl(cache, parallelRoutes, keyPrefix) {
    const isLastItem = Object.keys(parallelRoutes).length === 0;
    if (isLastItem) {
        // Returns the entire Cache Node of the segment whose head we will render.
        return [
            cache,
            keyPrefix
        ];
    }
    for(const key in parallelRoutes){
        const [segment, childParallelRoutes] = parallelRoutes[key];
        const childSegmentMap = cache.parallelRoutes.get(key);
        if (!childSegmentMap) {
            continue;
        }
        const cacheKey = createRouterCacheKey(segment);
        const cacheNode = childSegmentMap.get(cacheKey);
        if (!cacheNode) {
            continue;
        }
        const item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + "/" + cacheKey);
        if (item) {
            return item;
        }
    }
    return null;
} //# sourceMappingURL=find-head-in-cache.js.map
ü  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/find-head-in-cache.ts"],"names":["createRouterCacheKey","findHeadInCache","cache","parallelRoutes","findHeadInCacheImpl","keyPrefix","isLastItem","Object","keys","length","key","segment","childParallelRoutes","childSegmentMap","get","cacheKey","cacheNode","item"],"mappings":"AAEA,SAASA,oBAAoB,QAAQ,6BAA4B;AAEjE,OAAO,SAASC,gBACdC,KAAgB,EAChBC,cAAoC;IAEpC,OAAOC,oBAAoBF,OAAOC,gBAAgB;AACpD;AAEA,SAASC,oBACPF,KAAgB,EAChBC,cAAoC,EACpCE,SAAiB;IAEjB,MAAMC,aAAaC,OAAOC,IAAI,CAACL,gBAAgBM,MAAM,KAAK;IAC1D,IAAIH,YAAY;QACd,0EAA0E;QAC1E,OAAO;YAACJ;YAAOG;SAAU;IAC3B;IACA,IAAK,MAAMK,OAAOP,eAAgB;QAChC,MAAM,CAACQ,SAASC,oBAAoB,GAAGT,cAAc,CAACO,IAAI;QAC1D,MAAMG,kBAAkBX,MAAMC,cAAc,CAACW,GAAG,CAACJ;QACjD,IAAI,CAACG,iBAAiB;YACpB;QACF;QAEA,MAAME,WAAWf,qBAAqBW;QAEtC,MAAMK,YAAYH,gBAAgBC,GAAG,CAACC;QACtC,IAAI,CAACC,WAAW;YACd;QACF;QAEA,MAAMC,OAAOb,oBACXY,WACAJ,qBACAP,YAAY,MAAMU;QAEpB,IAAIE,MAAM;YACR,OAAOA;QACT;IACF;IAEA,OAAO;AACT","file":"x"}š   false065undefined6773undefined753772__WEBPACK_MODULE_REFERENCE__7_5b22637265617465526f7574657243616368654b6579225d_call_directImport_asiSafe1__._undefinedO   680788(0,create_router_cache_key/* createRouterCacheKey */.d)undefinedRawSourceá   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/unresolved-thenable.js
var unresolved_thenable = __webpack_require__(3654);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/remove-base-path.js
vÿÿÿwÿÿÿ  import { hasBasePath } from "./has-base-path";
const basePath = process.env.__NEXT_ROUTER_BASEPATH || "";
export function removeBasePath(path) {
    if (process.env.__NEXT_MANUAL_CLIENT_BASE_PATH) {
        if (!hasBasePath(path)) {
            return path;
        }
    }
    // Can't trim the basePath if it has zero length!
    if (basePath.length === 0) return path;
    path = path.slice(basePath.length);
    if (!path.startsWith("/")) path = "/" + path;
    return path;
} //# sourceMappingURL=remove-base-path.js.map
f  {"version":3,"sources":["webpack://../../src/client/remove-base-path.ts"],"names":["hasBasePath","basePath","process","env","__NEXT_ROUTER_BASEPATH","removeBasePath","path","__NEXT_MANUAL_CLIENT_BASE_PATH","length","slice","startsWith"],"mappings":"AAAA,SAASA,WAAW,QAAQ,kBAAiB;AAE7C,MAAMC,WAAWC,QAASC,GAAG,CAACC,sBAAsB,IAAe;AAEnE,OAAO,SAASC,eAAeC,IAAY;IACzC,IAAIJ,QAAQC,GAAG,CAACI,8BAA8B,EAAE;QAC9C,IAAI,CAACP,YAAYM,OAAO;YACtB,OAAOA;QACT;IACF;IAEA,iDAAiD;IACjD,IAAIL,SAASO,MAAM,KAAK,GAAG,OAAOF;IAElCA,OAAOA,KAAKG,KAAK,CAACR,SAASO,MAAM;IACjC,IAAI,CAACF,KAAKI,UAAU,CAAC,MAAMJ,OAAO,MAAIA;IACtC,OAAOA;AACT","file":"x"}X   false045undefined6497 falseundefined106112undefined153194falseundefined197272{}undefined~   714remove_base_path_basePathundefined144151remove_base_path_basePathundefined202209remove_base_path_basePathundefinedRawSourceÜ   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/path-has-prefix.js
var path_has_prefix = __webpack_require__(8506);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/has-base-path.js
qÿÿÿrÿÿÿ  import { pathHasPrefix } from "../shared/lib/router/utils/path-has-prefix";
const basePath = process.env.__NEXT_ROUTER_BASEPATH || "";
export function hasBasePath(path) {
    return pathHasPrefix(path, basePath);
} //# sourceMappingURL=has-base-path.js.map
G  {"version":3,"sources":["webpack://../../src/client/has-base-path.ts"],"names":["pathHasPrefix","basePath","process","env","__NEXT_ROUTER_BASEPATH","hasBasePath","path"],"mappings":"AAAA,SAASA,aAAa,QAAQ,6CAA4C;AAE1E,MAAMC,WAAWC,QAASC,GAAG,CAACC,sBAAsB,IAAe;AAEnE,OAAO,SAASC,YAAYC,IAAY;IACtC,OAAON,cAAcM,MAAML;AAC7B","file":"x"}£   false074undefined93126 falseundefined135141undefined182194__WEBPACK_MODULE_REFERENCE__48_5b2270617468486173507265666978225d_call_directImport_asiSafe1__._undefined†   714has_base_path_basePathundefined72167(0,path_has_prefix/* pathHasPrefix */.Y)undefined175182has_base_path_basePathundefinedRawSourceW   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/app-router.js
lÿÿÿmÿÿÿ<I  /* __next_internal_client_entry_do_not_use__ getServerActionDispatcher,urlToUrlWithoutFlightMarker,createEmptyCacheNode,default auto */ import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React, { use, useEffect, useMemo, useCallback, startTransition, useInsertionEffect, useDeferredValue } from "react";
import { AppRouterContext, LayoutRouterContext, GlobalLayoutRouterContext, MissingSlotContext } from "../../shared/lib/app-router-context.shared-runtime";
import { ACTION_FAST_REFRESH, ACTION_NAVIGATE, ACTION_PREFETCH, ACTION_REFRESH, ACTION_RESTORE, ACTION_SERVER_ACTION, ACTION_SERVER_PATCH, PrefetchKind } from "./router-reducer/router-reducer-types";
import { createHrefFromUrl } from "./router-reducer/create-href-from-url";
import { SearchParamsContext, PathnameContext, PathParamsContext } from "../../shared/lib/hooks-client-context.shared-runtime";
import { useReducerWithReduxDevtools, useUnwrapState } from "./use-reducer-with-devtools";
import { ErrorBoundary } from "./error-boundary";
import { createInitialRouterState } from "./router-reducer/create-initial-router-state";
import { isBot } from "../../shared/lib/router/utils/is-bot";
import { addBasePath } from "../add-base-path";
import { AppRouterAnnouncer } from "./app-router-announcer";
import { RedirectBoundary } from "./redirect-boundary";
import { findHeadInCache } from "./router-reducer/reducers/find-head-in-cache";
import { unresolvedThenable } from "./unresolved-thenable";
import { NEXT_RSC_UNION_QUERY } from "./app-router-headers";
import { removeBasePath } from "../remove-base-path";
import { hasBasePath } from "../has-base-path";
import { PAGE_SEGMENT_KEY } from "../../shared/lib/segment";
const isServer = "undefined" === "undefined";
// Ensure the initialParallelRoutes are not combined because of double-rendering in the browser with Strict Mode.
let initialParallelRoutes = isServer ? null : new Map();
let globalServerActionDispatcher = null;
export function getServerActionDispatcher() {
    return globalServerActionDispatcher;
}
const globalMutable = {};
export function urlToUrlWithoutFlightMarker(url) {
    const urlWithoutFlightParameters = new URL(url, location.origin);
    urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY);
    if ("production" === "production") {
        if (process.env.__NEXT_CONFIG_OUTPUT === "export" && urlWithoutFlightParameters.pathname.endsWith(".txt")) {
            const { pathname } = urlWithoutFlightParameters;
            const length = pathname.endsWith("/index.txt") ? 10 : 4;
            // Slice off `/index.txt` or `.txt` from the end of the pathname
            urlWithoutFlightParameters.pathname = pathname.slice(0, -length);
        }
    }
    return urlWithoutFlightParameters;
}
// this function performs a depth-first search of the tree to find the selected
// params
function getSelectedParams(currentTree, params) {
    if (params === void 0) params = {};
    const parallelRoutes = currentTree[1];
    for (const parallelRoute of Object.values(parallelRoutes)){
        const segment = parallelRoute[0];
        const isDynamicParameter = Array.isArray(segment);
        const segmentValue = isDynamicParameter ? segment[1] : segment;
        if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue;
        // Ensure catchAll and optional catchall are turned into an array
        const isCatchAll = isDynamicParameter && (segment[2] === "c" || segment[2] === "oc");
        if (isCatchAll) {
            params[segment[0]] = segment[1].split("/");
        } else if (isDynamicParameter) {
            params[segment[0]] = segment[1];
        }
        params = getSelectedParams(parallelRoute, params);
    }
    return params;
}
function isExternalURL(url) {
    return url.origin !== window.location.origin;
}
function HistoryUpdater(param) {
    let { appRouterState, sync } = param;
    useInsertionEffect(()=>{
        const { tree, pushRef, canonicalUrl } = appRouterState;
        const historyState = {
            ...pushRef.preserveCustomHistoryState ? window.history.state : {},
            // Identifier is shortened intentionally.
            // __NA is used to identify if the history entry can be handled by the app-router.
            // __N is used to identify if the history entry can be handled by the old router.
            __NA: true,
            __PRIVATE_NEXTJS_INTERNALS_TREE: tree
        };
        if (pushRef.pendingPush && // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.
        // This mirrors the browser behavior for normal navigation.
        createHrefFromUrl(new URL(window.location.href)) !== canonicalUrl) {
            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.
            pushRef.pendingPush = false;
            window.history.pushState(historyState, "", canonicalUrl);
        } else {
            window.history.replaceState(historyState, "", canonicalUrl);
        }
        sync(appRouterState);
    }, [
        appRouterState,
        sync
    ]);
    return null;
}
export function createEmptyCacheNode() {
    return {
        lazyData: null,
        rsc: null,
        prefetchRsc: null,
        head: null,
        prefetchHead: null,
        parallelRoutes: new Map(),
        lazyDataResolved: false,
        loading: null
    };
}
function useServerActionDispatcher(dispatch) {
    const serverActionDispatcher = useCallback((actionPayload)=>{
        startTransition(()=>{
            dispatch({
                ...actionPayload,
                type: ACTION_SERVER_ACTION
            });
        });
    }, [
        dispatch
    ]);
    globalServerActionDispatcher = serverActionDispatcher;
}
/**
 * Server response that only patches the cache and tree.
 */ function useChangeByServerResponse(dispatch) {
    return useCallback((param)=>{
        let { previousTree, serverResponse } = param;
        startTransition(()=>{
            dispatch({
                type: ACTION_SERVER_PATCH,
                previousTree,
                serverResponse
            });
        });
    }, [
        dispatch
    ]);
}
function useNavigate(dispatch) {
    return useCallback((href, navigateType, shouldScroll)=>{
        const url = new URL(addBasePath(href), location.href);
        return dispatch({
            type: ACTION_NAVIGATE,
            url,
            isExternalUrl: isExternalURL(url),
            locationSearch: location.search,
            shouldScroll: shouldScroll != null ? shouldScroll : true,
            navigateType
        });
    }, [
        dispatch
    ]);
}
function copyNextJsInternalHistoryState(data) {
    if (data == null) data = {};
    const currentState = window.history.state;
    const __NA = currentState == null ? void 0 : currentState.__NA;
    if (__NA) {
        data.__NA = __NA;
    }
    const __PRIVATE_NEXTJS_INTERNALS_TREE = currentState == null ? void 0 : currentState.__PRIVATE_NEXTJS_INTERNALS_TREE;
    if (__PRIVATE_NEXTJS_INTERNALS_TREE) {
        data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE;
    }
    return data;
}
function Head(param) {
    let { headCacheNode } = param;
    // If this segment has a `prefetchHead`, it's the statically prefetched data.
    // We should use that on initial render instead of `head`. Then we'll switch
    // to `head` when the dynamic response streams in.
    const head = headCacheNode !== null ? headCacheNode.head : null;
    const prefetchHead = headCacheNode !== null ? headCacheNode.prefetchHead : null;
    // If no prefetch data is available, then we go straight to rendering `head`.
    const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head;
    // We use `useDeferredValue` to handle switching between the prefetched and
    // final values. The second argument is returned on initial render, then it
    // re-renders with the first argument.
    //
    // @ts-expect-error The second argument to `useDeferredValue` is only
    // available in the experimental builds. When its disabled, it will always
    // return `head`.
    return useDeferredValue(head, resolvedPrefetchRsc);
}
/**
 * The global router that wraps the application components.
 */ function Router(param) {
    let { buildId, initialHead, initialTree, initialCanonicalUrl, initialSeedData, couldBeIntercepted, assetPrefix, missingSlots } = param;
    const initialState = useMemo(()=>createInitialRouterState({
            buildId,
            initialSeedData,
            initialCanonicalUrl,
            initialTree,
            initialParallelRoutes,
            location: !isServer ? window.location : null,
            initialHead,
            couldBeIntercepted
        }), [
        buildId,
        initialSeedData,
        initialCanonicalUrl,
        initialTree,
        initialHead,
        couldBeIntercepted
    ]);
    const [reducerState, dispatch, sync] = useReducerWithReduxDevtools(initialState);
    null;
    const { canonicalUrl } = useUnwrapState(reducerState);
    // Add memoized pathname/query for useSearchParams and usePathname.
    const { searchParams, pathname } = useMemo(()=>{
        const url = new URL(canonicalUrl, "undefined" === "undefined" ? "http://n" : window.location.href);
        return {
            // This is turned into a readonly class in `useSearchParams`
            searchParams: url.searchParams,
            pathname: hasBasePath(url.pathname) ? removeBasePath(url.pathname) : url.pathname
        };
    }, [
        canonicalUrl
    ]);
    const changeByServerResponse = useChangeByServerResponse(dispatch);
    const navigate = useNavigate(dispatch);
    useServerActionDispatcher(dispatch);
    /**
   * The app router that is exposed through `useRouter`. It's only concerned with dispatching actions to the reducer, does not hold state.
   */ const appRouter = useMemo(()=>{
        const routerInstance = {
            back: ()=>window.history.back(),
            forward: ()=>window.history.forward(),
            prefetch: (href, options)=>{
                // Don't prefetch for bots as they don't navigate.
                if (isBot(window.navigator.userAgent)) {
                    return;
                }
                let url;
                try {
                    url = new URL(addBasePath(href), window.location.href);
                } catch (_) {
                    throw new Error("Cannot prefetch '" + href + "' because it cannot be converted to a URL.");
                }
                // Don't prefetch during development (improves compilation performance)
                if ("production" === "development") {
                    return;
                }
                // External urls can't be prefetched in the same way.
                if (isExternalURL(url)) {
                    return;
                }
                startTransition(()=>{
                    var _options_kind;
                    dispatch({
                        type: ACTION_PREFETCH,
                        url,
                        kind: (_options_kind = options == null ? void 0 : options.kind) != null ? _options_kind : PrefetchKind.FULL
                    });
                });
            },
            replace: (href, options)=>{
                if (options === void 0) options = {};
                startTransition(()=>{
                    var _options_scroll;
                    navigate(href, "replace", (_options_scroll = options.scroll) != null ? _options_scroll : true);
                });
            },
            push: (href, options)=>{
                if (options === void 0) options = {};
                startTransition(()=>{
                    var _options_scroll;
                    navigate(href, "push", (_options_scroll = options.scroll) != null ? _options_scroll : true);
                });
            },
            refresh: ()=>{
                startTransition(()=>{
                    dispatch({
                        type: ACTION_REFRESH,
                        origin: window.location.origin
                    });
                });
            },
            fastRefresh: ()=>{
                if ("production" !== "development") {
                    throw new Error("fastRefresh can only be used in development mode. Please use refresh instead.");
                } else {
                    startTransition(()=>{
                        dispatch({
                            type: ACTION_FAST_REFRESH,
                            origin: window.location.origin
                        });
                    });
                }
            }
        };
        return routerInstance;
    }, [
        dispatch,
        navigate
    ]);
    null;
    if ("production" !== "production") {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const { cache, prefetchCache, tree } = useUnwrapState(reducerState);
        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes
        // eslint-disable-next-line react-hooks/rules-of-hooks
        null;
    }
    null;
    // When mpaNavigation flag is set do a hard navigation to the new url.
    // Infinitely suspend because we don't actually want to rerender any child
    // components with the new URL and any entangled state updates shouldn't
    // commit either (eg: useTransition isPending should stay true until the page
    // unloads).
    //
    // This is a side effect in render. Don't try this at home, kids. It's
    // probably safe because we know this is a singleton component and it's never
    // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,
    // but that's... fine?)
    const { pushRef } = useUnwrapState(reducerState);
    if (pushRef.mpaNavigation) {
        // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL
        if (globalMutable.pendingMpaPath !== canonicalUrl) {
            const location1 = window.location;
            if (pushRef.pendingPush) {
                location1.assign(canonicalUrl);
            } else {
                location1.replace(canonicalUrl);
            }
            globalMutable.pendingMpaPath = canonicalUrl;
        }
        // TODO-APP: Should we listen to navigateerror here to catch failed
        // navigations somehow? And should we call window.stop() if a SPA navigation
        // should interrupt an MPA one?
        use(unresolvedThenable);
    }
    null;
    const { cache, tree, nextUrl, focusAndScrollRef } = useUnwrapState(reducerState);
    const matchingHead = useMemo(()=>{
        return findHeadInCache(cache, tree[1]);
    }, [
        cache,
        tree
    ]);
    // Add memoized pathParams for useParams.
    const pathParams = useMemo(()=>{
        return getSelectedParams(tree);
    }, [
        tree
    ]);
    let head;
    if (matchingHead !== null) {
        // The head is wrapped in an extra component so we can use
        // `useDeferredValue` to swap between the prefetched and final versions of
        // the head. (This is what LayoutRouter does for segment data, too.)
        //
        // The `key` is used to remount the component whenever the head moves to
        // a different segment.
        const [headCacheNode, headKey] = matchingHead;
        head = /*#__PURE__*/ _jsx(Head, {
            headCacheNode: headCacheNode
        }, headKey);
    } else {
        head = null;
    }
    let content = /*#__PURE__*/ _jsxs(RedirectBoundary, {
        children: [
            head,
            cache.rsc,
            /*#__PURE__*/ _jsx(AppRouterAnnouncer, {
                tree: tree
            })
        ]
    });
    if ("production" !== "production") {
        if ("undefined" !== "undefined") {
            const DevRootNotFoundBoundary = require("./dev-root-not-found-boundary").DevRootNotFoundBoundary;
            content = /*#__PURE__*/ _jsx(DevRootNotFoundBoundary, {
                children: /*#__PURE__*/ _jsx(MissingSlotContext.Provider, {
                    value: missingSlots,
                    children: content
                })
            });
        }
        const HotReloader = require("./react-dev-overlay/app/hot-reloader-client").default;
        content = /*#__PURE__*/ _jsx(HotReloader, {
            assetPrefix: assetPrefix,
            children: content
        });
    }
    return /*#__PURE__*/ _jsxs(_Fragment, {
        children: [
            /*#__PURE__*/ _jsx(HistoryUpdater, {
                appRouterState: useUnwrapState(reducerState),
                sync: sync
            }),
            /*#__PURE__*/ _jsx(PathParamsContext.Provider, {
                value: pathParams,
                children: /*#__PURE__*/ _jsx(PathnameContext.Provider, {
                    value: pathname,
                    children: /*#__PURE__*/ _jsx(SearchParamsContext.Provider, {
                        value: searchParams,
                        children: /*#__PURE__*/ _jsx(GlobalLayoutRouterContext.Provider, {
                            value: {
                                buildId,
                                changeByServerResponse,
                                tree,
                                focusAndScrollRef,
                                nextUrl
                            },
                            children: /*#__PURE__*/ _jsx(AppRouterContext.Provider, {
                                value: appRouter,
                                children: /*#__PURE__*/ _jsx(LayoutRouterContext.Provider, {
                                    value: {
                                        childNodes: cache.parallelRoutes,
                                        tree,
                                        // Root node always has `url`
                                        // Provided in AppTreeContext to ensure it can be overwritten in layout-router
                                        url: canonicalUrl,
                                        loading: cache.loading
                                    },
                                    children: content
                                })
                            })
                        })
                    })
                })
            })
        ]
    });
}
export default function AppRouter(props) {
    const { globalErrorComponent, ...rest } = props;
    return /*#__PURE__*/ _jsx(ErrorBoundary, {
        errorComponent: globalErrorComponent,
        children: /*#__PURE__*/ _jsx(Router, {
            ...rest
        })
    });
} //# sourceMappingURL=app-router.js.map
š)  {"version":3,"sources":["webpack://../../../src/client/components/app-router.tsx"],"names":["React","use","useEffect","_jsxs","useMemo","useCallback","startTransition","useInsertionEffect","AppRouterContext","LayoutRouterContext","GlobalLayoutRouterContext","MissingSlotContext","ACTION_FAST_REFRESH","ACTION_PREFETCH","ACTION_REFRESH","ACTION_RESTORE","ACTION_SERVER_ACTION","createHrefFromUrl","ACTION_NAVIGATE","ACTION_SERVER_PATCH","PrefetchKind","SearchParamsContext","PathnameContext","useReducerWithReduxDevtools","useUnwrapState","ErrorBoundary","createInitialRouterState","isBot","addBasePath","AppRouterAnnouncer","RedirectBoundary","findHeadInCache","unresolvedThenable","NEXT_RSC_UNION_QUERY","removeBasePath","hasBasePath","PAGE_SEGMENT_KEY","isServer","window","Map","globalServerActionDispatcher","getServerActionDispatcher","globalMutable","urlToUrlWithoutFlightMarker","urlWithoutFlightParameters","URL","url","searchParams","delete","process","__NEXT_CONFIG_OUTPUT","pathname","length","endsWith","slice","getSelectedParams","params","parallelRoutes","currentTree","parallelRoute","Object","values","segment","isDynamicParameter","Array","segmentValue","startsWith","isCatchAll","split","isExternalURL","origin","location","HistoryUpdater","param","sync","pushRef","historyState","canonicalUrl","appRouterState","preserveCustomHistoryState","history","state","__NA","__PRIVATE_NEXTJS_INTERNALS_TREE","tree","pendingPush","href","pushState","replaceState","createEmptyCacheNode","lazyData","rsc","prefetchRsc","head","prefetchHead","lazyDataResolved","loading","useServerActionDispatcher","actionPayload","type","dispatch","serverActionDispatcher","previousTree","serverResponse","useNavigate","isExternalUrl","locationSearch","search","shouldScroll","navigateType","data","currentState","Head","headCacheNode","resolvedPrefetchRsc","useDeferredValue","buildId","initialHead","initialState","initialSeedData","couldBeIntercepted","assetPrefix","missingSlots","initialCanonicalUrl","initialTree","initialParallelRoutes","reducerState","navigate","appRouter","routerInstance","back","forward","prefetch","options","navigator","userAgent","_","Error","kind","_options_kind","FULL","replace","_options_scroll","scroll","push","refresh","fastRefresh","cache","prefetchCache","mpaNavigation","location1","assign","pendingMpaPath","matchingHead","focusAndScrollRef","pathParams","headKey","DevRootNotFoundBoundary","content","_jsx","Provider","value","HotReloader","changeByServerResponse","nextUrl","childNodes","globalErrorComponent","props","rest","errorComponent","Router"],"mappings":"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","file":"x"}à  false136221undefined223345undefined347500undefined502700undefined702775undefined777903undefined905994undefined9961044undefined10461133undefined11351195undefined11971243undefined12451304undefined13061360undefined13621440undefined14421500undefined15021561undefined15631615undefined16171663undefined16651724undefined19841990undefined20992105undefined22712290__WEBPACK_MODULE_REFERENCE__14_5b224e4558545f5253435f554e494f4e5f5155455259225d_directImport_asiSafe1__._undefined23022330trueundefined23472447falseundefined24502745{}undefined33073322__WEBPACK_MODULE_REFERENCE__11_5b22504147455f5345474d454e545f4b4559225d_directImport_asiSafe1__._undefined39293946__WEBPACK_MODULE_REFERENCE__1_5b22757365496e73657274696f6e456666656374225d_call_directImport_asiSafe1__._undefined46634679__WEBPACK_MODULE_REFERENCE__4_5b226372656174654872656646726f6d55726c225d_call_directImport_asiSafe1__._undefined52085214undefined55615571__WEBPACK_MODULE_REFERENCE__1_5b2275736543616c6c6261636b225d_call_directImport_asiSafe1__._undefined56005614__WEBPACK_MODULE_REFERENCE__1_5b2273746172745472616e736974696f6e225d_call_directImport_asiSafe1__._undefined57015720__WEBPACK_MODULE_REFERENCE__3_5b22414354494f4e5f5345525645525f414354494f4e225d_directImport_asiSafe1__._undefined59685978__WEBPACK_MODULE_REFERENCE__1_5b2275736543616c6c6261636b225d_call_directImport_asiSafe1__._undefined60536067__WEBPACK_MODULE_REFERENCE__1_5b2273746172745472616e736974696f6e225d_call_directImport_asiSafe1__._undefined61206138__WEBPACK_MODULE_REFERENCE__3_5b22414354494f4e5f5345525645525f5041544348225d_directImport_asiSafe1__._undefined63106320__WEBPACK_MODULE_REFERENCE__1_5b2275736543616c6c6261636b225d_call_directImport_asiSafe1__._undefined63886398__WEBPACK_MODULE_REFERENCE__41_5b226164644261736550617468225d_call_directImport_asiSafe1__._undefined64676481__WEBPACK_MODULE_REFERENCE__3_5b22414354494f4e5f4e41564947415445225d_directImport_asiSafe1__._undefined82358250__WEBPACK_MODULE_REFERENCE__1_5b22757365446566657272656456616c7565225d_call_directImport_asiSafe1__._undefined85408546__WEBPACK_MODULE_REFERENCE__1_5b227573654d656d6f225d_call_directImport_asiSafe1__._undefined85528575__WEBPACK_MODULE_REFERENCE__35_5b22637265617465496e697469616c526f757465725374617465225d_call_directImport_asiSafe1__._undefined90419067__WEBPACK_MODULE_REFERENCE__31_5b2275736552656475636572576974685265647578446576746f6f6c73225d_call_directImport_asiSafe1__._undefined91239136__WEBPACK_MODULE_REFERENCE__31_5b22757365556e777261705374617465225d_call_directImport_asiSafe1__._undefined92649270__WEBPACK_MODULE_REFERENCE__1_5b227573654d656d6f225d_call_directImport_asiSafe1__._undefined93209346 trueundefined936393820undefined95429552__WEBPACK_MODULE_REFERENCE__49_5b226861734261736550617468225d_call_directImport_asiSafe1__._undefined95709583__WEBPACK_MODULE_REFERENCE__47_5b2272656d6f76654261736550617468225d_call_directImport_asiSafe1__._undefined99919997__WEBPACK_MODULE_REFERENCE__1_5b227573654d656d6f225d_call_directImport_asiSafe1__._undefined1026210266__WEBPACK_MODULE_REFERENCE__36_5b226973426f74225d_call_directImport_asiSafe1__._undefined1042610436__WEBPACK_MODULE_REFERENCE__41_5b226164644261736550617468225d_call_directImport_asiSafe1__._undefined1073610765falseundefined1076810814{}undefined1099011004__WEBPACK_MODULE_REFERENCE__1_5b2273746172745472616e736974696f6e225d_call_directImport_asiSafe1__._undefined1111211126__WEBPACK_MODULE_REFERENCE__3_5b22414354494f4e5f5052454645544348225d_directImport_asiSafe1__._undefined1127211283__WEBPACK_MODULE_REFERENCE__3_5b2250726566657463684b696e64225d_asiSafe1__._undefined1145911473__WEBPACK_MODULE_REFERENCE__1_5b2273746172745472616e736974696f6e225d_call_directImport_asiSafe1__._undefined1178011794__WEBPACK_MODULE_REFERENCE__1_5b2273746172745472616e736974696f6e225d_call_directImport_asiSafe1__._undefined1203412048__WEBPACK_MODULE_REFERENCE__1_5b2273746172745472616e736974696f6e225d_call_directImport_asiSafe1__._undefined1211712130__WEBPACK_MODULE_REFERENCE__3_5b22414354494f4e5f52454652455348225d_directImport_asiSafe1__._undefined1229812327trueundefined1247312734{}undefined1286212890falseundefined1289313217{}undefined1385713870__WEBPACK_MODULE_REFERENCE__31_5b22757365556e777261705374617465225d_call_directImport_asiSafe1__._undefined1459614598__WEBPACK_MODULE_REFERENCE__1_5b22757365225d_call_directImport_asiSafe1__._undefined1460014617__WEBPACK_MODULE_REFERENCE__46_5b22756e7265736f6c7665645468656e61626c65225d_directImport_asiSafe1__._undefined1469314706__WEBPACK_MODULE_REFERENCE__31_5b22757365556e777261705374617465225d_call_directImport_asiSafe1__._undefined1474814754__WEBPACK_MODULE_REFERENCE__1_5b227573654d656d6f225d_call_directImport_asiSafe1__._undefined1477714791__WEBPACK_MODULE_REFERENCE__45_5b2266696e6448656164496e4361636865225d_call_directImport_asiSafe1__._undefined1492414930__WEBPACK_MODULE_REFERENCE__1_5b227573654d656d6f225d_call_directImport_asiSafe1__._undefined1549015493__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1563715641__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined1564315658__WEBPACK_MODULE_REFERENCE__44_5b225265646972656374426f756e64617279225d_directImport_asiSafe1__._undefined1575015753__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1575515772__WEBPACK_MODULE_REFERENCE__43_5b22417070526f75746572416e6e6f756e636572225d_directImport_asiSafe1__._undefined1584515873falseundefined1587616527{}undefined1655416558__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined1656016568__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined1661916622__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1667416687__WEBPACK_MODULE_REFERENCE__31_5b22757365556e777261705374617465225d_call_directImport_asiSafe1__._undefined1677316776__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1677816794__WEBPACK_MODULE_REFERENCE__5_5b2250617468506172616d73436f6e74657874225d_asiSafe1__._undefined1688316886__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1688816902__WEBPACK_MODULE_REFERENCE__5_5b22506174686e616d65436f6e74657874225d_asiSafe1__._undefined1699717000__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1700217020__WEBPACK_MODULE_REFERENCE__5_5b22536561726368506172616d73436f6e74657874225d_asiSafe1__._undefined1712717130__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1713217156__WEBPACK_MODULE_REFERENCE__2_5b22476c6f62616c4c61796f7574526f75746572436f6e74657874225d_asiSafe1__._undefined1751617519__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1752117536__WEBPACK_MODULE_REFERENCE__2_5b22417070526f75746572436f6e74657874225d_asiSafe1__._undefined1765617659__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1766117679__WEBPACK_MODULE_REFERENCE__2_5b224c61796f7574526f75746572436f6e74657874225d_asiSafe1__._undefined1843218446undefined1855318556__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1855818570__WEBPACK_MODULE_REFERENCE__32_5b224572726f72426f756e64617279225d_directImport_asiSafe1__._undefined1865318656__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined=  686790app_router_headers/* NEXT_RSC_UNION_QUERY */.H4undefined13921488lib_segment/* PAGE_SEGMENT_KEY */.GCundefined20952199(0,react.useInsertionEffect)undefined29163018create_href_from_url_createHrefFromUrlundefined35563575app_router_createEmptyCacheNodeundefined38933983(0,react.useCallback)undefined40124110(0,react.startTransition)undefined41974300router_reducer_types/* ACTION_SERVER_ACTION */.WAundefined45484638(0,react.useCallback)undefined47134811(0,react.startTransition)undefined48644965router_reducer_types/* ACTION_SERVER_PATCH */.n0undefined51375227(0,react.useCallback)undefined52955386add_base_path_addBasePathundefined54555548router_reducer_types/* ACTION_NAVIGATE */.bOundefined73027402(0,react.useDeferredValue)undefined76927774(0,react.useMemo)undefined77807897createInitialRouterStateundefined83638486useReducerWithReduxDevtoolsundefined85428639useUnwrapStateundefined87678849(0,react.useMemo)undefined90809171hasBasePathundefined91899286removeBasePathundefined96949776(0,react.useMemo)undefined1004110120(0,is_bot/* isBot */.Q)undefined1028010371add_base_path_addBasePathundefined1085510953(0,react.startTransition)undefined1106111154router_reducer_types/* ACTION_PREFETCH */.Pmundefined1130011374router_reducer_types/* PrefetchKind */.Keundefined1155011648(0,react.startTransition)undefined1195512053(0,react.startTransition)undefined1229312391(0,react.startTransition)undefined1246012551router_reducer_types/* ACTION_REFRESH */.HDundefined1364513742useUnwrapStateundefined1446814542(0,react.use)undefined1454414644unresolved_thenable/* unresolvedThenable */.cundefined1472014817useUnwrapStateundefined1485914941(0,react.useMemo)undefined1496415063findHeadInCacheundefined1519615278(0,react.useMemo)undefined1583815912(0,jsx_runtime.jsx)undefined1605616132(0,jsx_runtime.jsxs)undefined1613416230redirect_boundary/* RedirectBoundary */.Iundefined1632216396(0,jsx_runtime.jsx)undefined1639816498AppRouterAnnouncerundefined1660616682(0,jsx_runtime.jsxs)undefined1668416763jsx_runtime.Fragmentundefined1681416888(0,jsx_runtime.jsx)undefined1694017037useUnwrapStateundefined1712317197(0,jsx_runtime.jsx)undefined1719917283hooks_client_context_shared_runtime.PathParamsContextundefined1737217446(0,jsx_runtime.jsx)undefined1744817528hooks_client_context_shared_runtime.PathnameContextundefined1762317697(0,jsx_runtime.jsx)undefined1769917787hooks_client_context_shared_runtime.SearchParamsContextundefined1789417968(0,jsx_runtime.jsx)undefined1797018070app_router_context_shared_runtime.GlobalLayoutRouterContextundefined1843018504(0,jsx_runtime.jsx)undefined1850618588app_router_context_shared_runtime.AppRouterContextundefined1870818782(0,jsx_runtime.jsx)undefined1878418872app_router_context_shared_runtime.LayoutRouterContextundefined1973119805(0,jsx_runtime.jsx)undefined1980719897error_boundary.ErrorBoundaryundefined1998020054(0,jsx_runtime.jsx)undefined
   

/***/ })àùÿÿ¨3 /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  createEmptyCacheNode: () => (/* binding */ app_router_createEmptyCacheNode),
  "default": () => (/* binding */ AppRouter),
  getServerActionDispatcher: () => (/* binding */ getServerActionDispatcher),
  urlToUrlWithoutFlightMarker: () => (/* binding */ urlToUrlWithoutFlightMarker)
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5486);
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__(2428);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/app-router-context.shared-runtime.js
var app_router_context_shared_runtime = __webpack_require__(6099);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/router-reducer-types.js
var router_reducer_types = __webpack_require__(2642);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/create-href-from-url.js
function create_href_from_url_createHrefFromUrl(url, includeHash) {
    if (includeHash === void 0) includeHash = true;
    return url.pathname + url.search + (includeHash ? url.hash : "");
} //# sourceMappingURL=create-href-from-url.js.map

// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/hooks-client-context.shared-runtime.js
var hooks_client_context_shared_runtime = __webpack_require__(498);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/fetch-server-response.js
var fetch_server_response = __webpack_require__(10);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/create-router-cache-key.js
var create_router_cache_key = __webpack_require__(2505);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js


function fill_lazy_items_till_leaf_with_head_fillLazyItemsTillLeafWithHead(newCache, existingCache, routerState, cacheNodeSeedData, head, prefetchEntry) {
    const isLastSegment = Object.keys(routerState[1]).length === 0;
    if (isLastSegment) {
        newCache.head = head;
        return;
    }
    // Remove segment that we got data for so that it is filled in during rendering of rsc.
    for(const key in routerState[1]){
        const parallelRouteState = routerState[1][key];
        const segmentForParallelRoute = parallelRouteState[0];
        const cacheKey = (0,create_router_cache_key/* createRouterCacheKey */.d)(segmentForParallelRoute);
        // TODO: We should traverse the cacheNodeSeedData tree instead of the router
        // state tree. Ideally, they would always be the same shape, but because of
        // the loading.js pattern, cacheNodeSeedData sometimes only represents a
        // partial tree. That's why this node is sometimes null. Once PPR lands,
        // loading.js will no longer have special behavior and we can traverse the
        // data tree instead.
        //
        // We should also consider merging the router state tree and the data tree
        // in the response format, so that we don't have to send the keys twice.
        // Then the client can convert them into separate representations.
        const parallelSeedData = cacheNodeSeedData !== null && cacheNodeSeedData[1][key] !== undefined ? cacheNodeSeedData[1][key] : null;
        if (existingCache) {
            const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);
            if (existingParallelRoutesCacheNode) {
                const hasReusablePrefetch = (prefetchEntry == null ? void 0 : prefetchEntry.kind) === "auto" && prefetchEntry.status === router_reducer_types/* PrefetchCacheEntryStatus */.T7.reusable;
                let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);
                const existingCacheNode = parallelRouteCacheNode.get(cacheKey);
                let newCacheNode;
                if (parallelSeedData !== null) {
                    // New data was sent from the server.
                    const seedNode = parallelSeedData[2];
                    const loading = parallelSeedData[3];
                    newCacheNode = {
                        lazyData: null,
                        rsc: seedNode,
                        // This is a PPR-only field. When PPR is enabled, we shouldn't hit
                        // this path during a navigation, but until PPR is fully implemented
                        // yet it's possible the existing node does have a non-null
                        // `prefetchRsc`. As an incremental step, we'll just de-opt to the
                        // old behavior â€” no PPR value.
                        prefetchRsc: null,
                        head: null,
                        prefetchHead: null,
                        loading,
                        parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes),
                        lazyDataResolved: false
                    };
                } else if (hasReusablePrefetch && existingCacheNode) {
                    // No new data was sent from the server, but the existing cache node
                    // was prefetched, so we should reuse that.
                    newCacheNode = {
                        lazyData: existingCacheNode.lazyData,
                        rsc: existingCacheNode.rsc,
                        // This is a PPR-only field. Unlike the previous branch, since we're
                        // just cloning the existing cache node, we might as well keep the
                        // PPR value, if it exists.
                        prefetchRsc: existingCacheNode.prefetchRsc,
                        head: existingCacheNode.head,
                        prefetchHead: existingCacheNode.prefetchHead,
                        parallelRoutes: new Map(existingCacheNode.parallelRoutes),
                        lazyDataResolved: existingCacheNode.lazyDataResolved,
                        loading: existingCacheNode.loading
                    };
                } else {
                    // No data available for this node. This will trigger a lazy fetch
                    // during render.
                    newCacheNode = {
                        lazyData: null,
                        rsc: null,
                        prefetchRsc: null,
                        head: null,
                        prefetchHead: null,
                        parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes),
                        lazyDataResolved: false,
                        loading: null
                    };
                }
                // Overrides the cache key with the new cache node.
                parallelRouteCacheNode.set(cacheKey, newCacheNode);
                // Traverse deeper to apply the head / fill lazy items till the head.
                fill_lazy_items_till_leaf_with_head_fillLazyItemsTillLeafWithHead(newCacheNode, existingCacheNode, parallelRouteState, parallelSeedData ? parallelSeedData : null, head, prefetchEntry);
                newCache.parallelRoutes.set(key, parallelRouteCacheNode);
                continue;
            }
        }
        let newCacheNode;
        if (parallelSeedData !== null) {
            // New data was sent from the server.
            const seedNode = parallelSeedData[2];
            const loading = parallelSeedData[3];
            newCacheNode = {
                lazyData: null,
                rsc: seedNode,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                lazyDataResolved: false,
                loading
            };
        } else {
            // No data available for this node. This will trigger a lazy fetch
            // during render.
            newCacheNode = {
                lazyData: null,
                rsc: null,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                lazyDataResolved: false,
                loading: null
            };
        }
        const existingParallelRoutes = newCache.parallelRoutes.get(key);
        if (existingParallelRoutes) {
            existingParallelRoutes.set(cacheKey, newCacheNode);
        } else {
            newCache.parallelRoutes.set(key, new Map([
                [
                    cacheKey,
                    newCacheNode
                ]
            ]));
        }
        fill_lazy_items_till_leaf_with_head_fillLazyItemsTillLeafWithHead(newCacheNode, undefined, parallelRouteState, parallelSeedData, head, prefetchEntry);
    }
} //# sourceMappingURL=fill-lazy-items-till-leaf-with-head.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/fill-cache-with-new-subtree-data.js



/**
 * Fill cache with rsc based on flightDataPath
 */ function fill_cache_with_new_subtree_data_fillCacheWithNewSubTreeData(newCache, existingCache, flightDataPath, prefetchEntry) {
    const isLastEntry = flightDataPath.length <= 5;
    const [parallelRouteKey, segment] = flightDataPath;
    const cacheKey = createRouterCacheKey(segment);
    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);
    if (!existingChildSegmentMap) {
        // Bailout because the existing cache does not have the path to the leaf node
        // Will trigger lazy fetch in layout-router because of missing segment
        return;
    }
    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);
    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {
        childSegmentMap = new Map(existingChildSegmentMap);
        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);
    }
    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);
    let childCacheNode = childSegmentMap.get(cacheKey);
    if (isLastEntry) {
        if (!childCacheNode || !childCacheNode.lazyData || childCacheNode === existingChildCacheNode) {
            const seedData = flightDataPath[3];
            const rsc = seedData[2];
            const loading = seedData[3];
            childCacheNode = {
                lazyData: null,
                rsc,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                loading,
                // Ensure segments other than the one we got data for are preserved.
                parallelRoutes: existingChildCacheNode ? new Map(existingChildCacheNode.parallelRoutes) : new Map(),
                lazyDataResolved: false
            };
            if (existingChildCacheNode) {
                invalidateCacheByRouterState(childCacheNode, existingChildCacheNode, flightDataPath[2]);
            }
            fillLazyItemsTillLeafWithHead(childCacheNode, existingChildCacheNode, flightDataPath[2], seedData, flightDataPath[4], prefetchEntry);
            childSegmentMap.set(cacheKey, childCacheNode);
        }
        return;
    }
    if (!childCacheNode || !existingChildCacheNode) {
        // Bailout because the existing cache does not have the path to the leaf node
        // Will trigger lazy fetch in layout-router because of missing segment
        return;
    }
    if (childCacheNode === existingChildCacheNode) {
        childCacheNode = {
            lazyData: childCacheNode.lazyData,
            rsc: childCacheNode.rsc,
            prefetchRsc: childCacheNode.prefetchRsc,
            head: childCacheNode.head,
            prefetchHead: childCacheNode.prefetchHead,
            parallelRoutes: new Map(childCacheNode.parallelRoutes),
            lazyDataResolved: false,
            loading: childCacheNode.loading
        };
        childSegmentMap.set(cacheKey, childCacheNode);
    }
    fill_cache_with_new_subtree_data_fillCacheWithNewSubTreeData(childCacheNode, existingChildCacheNode, flightDataPath.slice(2), prefetchEntry);
} //# sourceMappingURL=fill-cache-with-new-subtree-data.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/apply-flight-data.js


function apply_flight_data_applyFlightData(existingCache, cache, flightDataPath, prefetchEntry) {
    // The one before last item is the router state tree patch
    const [treePatch, cacheNodeSeedData, head] = flightDataPath.slice(-3);
    // Handles case where prefetch only returns the router tree patch without rendered components.
    if (cacheNodeSeedData === null) {
        return false;
    }
    if (flightDataPath.length === 3) {
        const rsc = cacheNodeSeedData[2];
        const loading = cacheNodeSeedData[3];
        cache.loading = loading;
        cache.rsc = rsc;
        // This is a PPR-only field. When PPR is enabled, we shouldn't hit
        // this path during a navigation, but until PPR is fully implemented
        // yet it's possible the existing node does have a non-null
        // `prefetchRsc`. As an incremental step, we'll just de-opt to the
        // old behavior â€” no PPR value.
        cache.prefetchRsc = null;
        fillLazyItemsTillLeafWithHead(cache, existingCache, treePatch, cacheNodeSeedData, head, prefetchEntry);
    } else {
        // Copy rsc for the root node of the cache.
        cache.rsc = existingCache.rsc;
        // This is a PPR-only field. Unlike the previous branch, since we're
        // just cloning the existing cache node, we might as well keep the
        // PPR value, if it exists.
        cache.prefetchRsc = existingCache.prefetchRsc;
        cache.parallelRoutes = new Map(existingCache.parallelRoutes);
        cache.loading = existingCache.loading;
        // Create a copy of the existing cache with the rsc applied.
        fillCacheWithNewSubTreeData(cache, existingCache, flightDataPath, prefetchEntry);
    }
    return true;
} //# sourceMappingURL=apply-flight-data.js.map

// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/segment.js
var lib_segment = __webpack_require__(8478);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/refetch-inactive-parallel-segments.js



/**
 * Refreshes inactive segments that are still in the current FlightRouterState.
 * A segment is considered "inactive" when the server response indicates it didn't match to a page component.
 * This happens during a soft-navigation, where the server will want to patch in the segment
 * with the "default" component, but we explicitly ignore the server in this case
 * and keep the existing state for that segment. New data for inactive segments are inherently
 * not part of the server response when we patch the tree, because they were associated with a response
 * from an earlier navigation/request. For each segment, once it becomes "active", we encode the URL that provided
 * the data for it. This function traverses parallel routes looking for these markers so that it can re-fetch
 * and patch the new data into the tree.
 */ async function refetch_inactive_parallel_segments_refreshInactiveParallelSegments(options) {
    const fetchedSegments = new Set();
    await refreshInactiveParallelSegmentsImpl({
        ...options,
        rootTree: options.updatedTree,
        fetchedSegments
    });
}
async function refreshInactiveParallelSegmentsImpl(param) {
    let { state, updatedTree, updatedCache, includeNextUrl, fetchedSegments, rootTree = updatedTree, canonicalUrl } = param;
    const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree;
    const fetchPromises = [];
    if (refetchPath && refetchPath !== canonicalUrl && refetchMarker === "refresh" && // it's possible for the tree to contain multiple segments that contain data at the same URL
    // we keep track of them so we can dedupe the requests
    !fetchedSegments.has(refetchPath)) {
        fetchedSegments.add(refetchPath) // Mark this URL as fetched
        ;
        // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate
        // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.
        const fetchPromise = fetchServerResponse(new URL(refetchPath, location.origin), // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)
        [
            rootTree[0],
            rootTree[1],
            rootTree[2],
            "refetch"
        ], includeNextUrl ? state.nextUrl : null, state.buildId).then((fetchResponse)=>{
            const flightData = fetchResponse[0];
            if (typeof flightData !== "string") {
                for (const flightDataPath of flightData){
                    // we only pass the new cache as this function is called after clearing the router cache
                    // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's
                    // just been created & has been written to, but hasn't been "committed" yet.
                    applyFlightData(updatedCache, updatedCache, flightDataPath);
                }
            } else {
            // When flightData is a string, it suggests that the server response should have triggered an MPA navigation
            // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect
            // when refreshing on-screen data, so handling this has been ommitted.
            }
        });
        fetchPromises.push(fetchPromise);
    }
    for(const key in parallelRoutes){
        const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({
            state,
            updatedTree: parallelRoutes[key],
            updatedCache,
            includeNextUrl,
            fetchedSegments,
            rootTree,
            canonicalUrl
        });
        fetchPromises.push(parallelFetchPromise);
    }
    await Promise.all(fetchPromises);
}
/**
 * Walks the current parallel segments to determine if they are "active".
 * An active parallel route will have a `__PAGE__` segment in the FlightRouterState.
 * As opposed to a `__DEFAULT__` segment, which means there was no match for that parallel route.
 * We add a special marker here so that we know how to refresh its data when the router is revalidated.
 */ function refetch_inactive_parallel_segments_addRefreshMarkerToActiveParallelSegments(tree, path) {
    const [segment, parallelRoutes, , refetchMarker] = tree;
    // a page segment might also contain concatenated search params, so we do a partial match on the key
    if (segment.includes(lib_segment/* PAGE_SEGMENT_KEY */.GC) && refetchMarker !== "refresh") {
        tree[2] = path;
        tree[3] = "refresh";
    }
    for(const key in parallelRoutes){
        refetch_inactive_parallel_segments_addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path);
    }
} //# sourceMappingURL=refetch-inactive-parallel-segments.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/apply-router-state-patch-to-tree.js



/**
 * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.
 */ function applyPatch(initialTree, patchTree, flightSegmentPath) {
    const [initialSegment, initialParallelRoutes] = initialTree;
    const [patchSegment, patchParallelRoutes] = patchTree;
    // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree
    // this is because the __DEFAULT__ segment is used as a placeholder on navigation
    if (patchSegment === DEFAULT_SEGMENT_KEY && initialSegment !== DEFAULT_SEGMENT_KEY) {
        return initialTree;
    }
    if (matchSegment(initialSegment, patchSegment)) {
        const newParallelRoutes = {};
        for(const key in initialParallelRoutes){
            const isInPatchTreeParallelRoutes = typeof patchParallelRoutes[key] !== "undefined";
            if (isInPatchTreeParallelRoutes) {
                newParallelRoutes[key] = applyPatch(initialParallelRoutes[key], patchParallelRoutes[key], flightSegmentPath);
            } else {
                newParallelRoutes[key] = initialParallelRoutes[key];
            }
        }
        for(const key in patchParallelRoutes){
            if (newParallelRoutes[key]) {
                continue;
            }
            newParallelRoutes[key] = patchParallelRoutes[key];
        }
        const tree = [
            initialSegment,
            newParallelRoutes
        ];
        // Copy over the existing tree
        if (initialTree[2]) {
            tree[2] = initialTree[2];
        }
        if (initialTree[3]) {
            tree[3] = initialTree[3];
        }
        if (initialTree[4]) {
            tree[4] = initialTree[4];
        }
        return tree;
    }
    return patchTree;
}
/**
 * Apply the router state from the Flight response, but skip patching default segments.
 * Useful for patching the router cache when navigating, where we persist the existing default segment if there isn't a new one.
 * Creates a new router state tree.
 */ function apply_router_state_patch_to_tree_applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch, path) {
    const [segment, parallelRoutes, url, refetch, isRootLayout] = flightRouterState;
    // Root refresh
    if (flightSegmentPath.length === 1) {
        const tree = applyPatch(flightRouterState, treePatch, flightSegmentPath);
        addRefreshMarkerToActiveParallelSegments(tree, path);
        return tree;
    }
    const [currentSegment, parallelRouteKey] = flightSegmentPath;
    // Tree path returned from the server should always match up with the current tree in the browser
    if (!matchSegment(currentSegment, segment)) {
        return null;
    }
    const lastSegment = flightSegmentPath.length === 2;
    let parallelRoutePatch;
    if (lastSegment) {
        parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch, flightSegmentPath);
    } else {
        parallelRoutePatch = apply_router_state_patch_to_tree_applyRouterStatePatchToTree(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch, path);
        if (parallelRoutePatch === null) {
            return null;
        }
    }
    const tree = [
        flightSegmentPath[0],
        {
            ...parallelRoutes,
            [parallelRouteKey]: parallelRoutePatch
        },
        url,
        refetch
    ];
    // Current segment is the root layout
    if (isRootLayout) {
        tree[4] = true;
    }
    addRefreshMarkerToActiveParallelSegments(tree, path);
    return tree;
} //# sourceMappingURL=apply-router-state-patch-to-tree.js.map

// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/app-router-headers.js
var app_router_headers = __webpack_require__(3185);
;// CONCATENATED MODULE: ./node_modules/@swc/helpers/esm/_class_private_field_loose_base.js
function _class_private_field_loose_base(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
    }

    return receiver;
}


;// CONCATENATED MODULE: ./node_modules/@swc/helpers/esm/_class_private_field_loose_key.js
var id = 0;

function _class_private_field_loose_key(name) {
    return "__private_" + id++ + "_" + name;
}


;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/promise-queue.js
/*
    This is a simple promise queue that allows you to limit the number of concurrent promises
    that are running at any given time. It's used to limit the number of concurrent
    prefetch requests that are being made to the server but could be used for other
    things as well.
*/ 

var _maxConcurrency = /*#__PURE__*/ _class_private_field_loose_key("_maxConcurrency"), _runningCount = /*#__PURE__*/ _class_private_field_loose_key("_runningCount"), _queue = /*#__PURE__*/ _class_private_field_loose_key("_queue"), _processNext = /*#__PURE__*/ _class_private_field_loose_key("_processNext");
class PromiseQueue {
    enqueue(promiseFn) {
        let taskResolve;
        let taskReject;
        const taskPromise = new Promise((resolve, reject)=>{
            taskResolve = resolve;
            taskReject = reject;
        });
        const task = async ()=>{
            try {
                _class_private_field_loose_base(this, _runningCount)[_runningCount]++;
                const result = await promiseFn();
                taskResolve(result);
            } catch (error) {
                taskReject(error);
            } finally{
                _class_private_field_loose_base(this, _runningCount)[_runningCount]--;
                _class_private_field_loose_base(this, _processNext)[_processNext]();
            }
        };
        const enqueueResult = {
            promiseFn: taskPromise,
            task
        };
        // wonder if we should take a LIFO approach here
        _class_private_field_loose_base(this, _queue)[_queue].push(enqueueResult);
        _class_private_field_loose_base(this, _processNext)[_processNext]();
        return taskPromise;
    }
    bump(promiseFn) {
        const index = _class_private_field_loose_base(this, _queue)[_queue].findIndex((item)=>item.promiseFn === promiseFn);
        if (index > -1) {
            const bumpedItem = _class_private_field_loose_base(this, _queue)[_queue].splice(index, 1)[0];
            _class_private_field_loose_base(this, _queue)[_queue].unshift(bumpedItem);
            _class_private_field_loose_base(this, _processNext)[_processNext](true);
        }
    }
    constructor(maxConcurrency = 5){
        Object.defineProperty(this, _processNext, {
            value: processNext
        });
        Object.defineProperty(this, _maxConcurrency, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _runningCount, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _queue, {
            writable: true,
            value: void 0
        });
        _class_private_field_loose_base(this, _maxConcurrency)[_maxConcurrency] = maxConcurrency;
        _class_private_field_loose_base(this, _runningCount)[_runningCount] = 0;
        _class_private_field_loose_base(this, _queue)[_queue] = [];
    }
}
function processNext(forced) {
    if (forced === void 0) forced = false;
    if ((_class_private_field_loose_base(this, _runningCount)[_runningCount] < _class_private_field_loose_base(this, _maxConcurrency)[_maxConcurrency] || forced) && _class_private_field_loose_base(this, _queue)[_queue].length > 0) {
        var _class_private_field_loose_base__queue_shift;
        (_class_private_field_loose_base__queue_shift = _class_private_field_loose_base(this, _queue)[_queue].shift()) == null ? void 0 : _class_private_field_loose_base__queue_shift.task();
    }
} //# sourceMappingURL=promise-queue.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/prefetch-cache-utils.js




/**
 * Creates a cache key for the router prefetch cache
 *
 * @param url - The URL being navigated to
 * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.
 * @return The generated prefetch cache key.
 */ function createPrefetchCacheKey(url, nextUrl) {
    const pathnameFromUrl = create_href_from_url_createHrefFromUrl(url, false);
    // nextUrl is used as a cache key delimiter since entries can vary based on the Next-URL header
    if (nextUrl) {
        return nextUrl + "%" + pathnameFromUrl;
    }
    return pathnameFromUrl;
}
/**
 * Returns a prefetch cache entry if one exists. Otherwise creates a new one and enqueues a fetch request
 * to retrieve the prefetch data from the server.
 */ function prefetch_cache_utils_getOrCreatePrefetchCacheEntry(param) {
    let { url, nextUrl, tree, buildId, prefetchCache, kind } = param;
    let existingCacheEntry = undefined;
    // We first check if there's a more specific interception route prefetch entry
    // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)
    // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.
    const interceptionCacheKey = createPrefetchCacheKey(url, nextUrl);
    const interceptionData = prefetchCache.get(interceptionCacheKey);
    if (interceptionData) {
        existingCacheEntry = interceptionData;
    } else {
        // If we dont find a more specific interception route prefetch entry, we check for a regular prefetch entry
        const prefetchCacheKey = createPrefetchCacheKey(url);
        const prefetchData = prefetchCache.get(prefetchCacheKey);
        if (prefetchData) {
            existingCacheEntry = prefetchData;
        }
    }
    if (existingCacheEntry) {
        // Grab the latest status of the cache entry and update it
        existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);
        // when `kind` is provided, an explicit prefetch was requested.
        // if the requested prefetch is "full" and the current cache entry wasn't, we want to re-prefetch with the new intent
        const switchedToFullPrefetch = existingCacheEntry.kind !== PrefetchKind.FULL && kind === PrefetchKind.FULL;
        if (switchedToFullPrefetch) {
            return createLazyPrefetchEntry({
                tree,
                url,
                buildId,
                nextUrl,
                prefetchCache,
                // If we didn't get an explicit prefetch kind, we want to set a temporary kind
                // rather than assuming the same intent as the previous entry, to be consistent with how we
                // lazily create prefetch entries when intent is left unspecified.
                kind: kind != null ? kind : PrefetchKind.TEMPORARY
            });
        }
        // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,
        // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.
        if (kind && existingCacheEntry.kind === PrefetchKind.TEMPORARY) {
            existingCacheEntry.kind = kind;
        }
        // We've determined that the existing entry we found is still valid, so we return it.
        return existingCacheEntry;
    }
    // If we didn't return an entry, create a new one.
    return createLazyPrefetchEntry({
        tree,
        url,
        buildId,
        nextUrl,
        prefetchCache,
        kind: kind || // in dev, there's never gonna be a prefetch entry so we want to prefetch here
        ( false ? 0 : PrefetchKind.TEMPORARY)
    });
}
/*
 * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.
 * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).
 */ function prefixExistingPrefetchCacheEntry(param) {
    let { url, nextUrl, prefetchCache } = param;
    const existingCacheKey = createPrefetchCacheKey(url);
    const existingCacheEntry = prefetchCache.get(existingCacheKey);
    if (!existingCacheEntry) {
        // no-op -- there wasn't an entry to move
        return;
    }
    const newCacheKey = createPrefetchCacheKey(url, nextUrl);
    prefetchCache.set(newCacheKey, existingCacheEntry);
    prefetchCache.delete(existingCacheKey);
}
/**
 * Use to seed the prefetch cache with data that has already been fetched.
 */ function createPrefetchCacheEntryForInitialLoad(param) {
    let { nextUrl, tree, prefetchCache, url, kind, data } = param;
    const [, , , intercept] = data;
    // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key
    const prefetchCacheKey = intercept ? createPrefetchCacheKey(url, nextUrl) : createPrefetchCacheKey(url);
    const prefetchEntry = {
        treeAtTimeOfPrefetch: tree,
        data: Promise.resolve(data),
        kind,
        prefetchTime: Date.now(),
        lastUsedTime: Date.now(),
        key: prefetchCacheKey,
        status: router_reducer_types/* PrefetchCacheEntryStatus */.T7.fresh
    };
    prefetchCache.set(prefetchCacheKey, prefetchEntry);
    return prefetchEntry;
}
/**
 * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.
 */ function createLazyPrefetchEntry(param) {
    let { url, kind, tree, nextUrl, buildId, prefetchCache } = param;
    const prefetchCacheKey = createPrefetchCacheKey(url);
    // initiates the fetch request for the prefetch and attaches a listener
    // to the promise to update the prefetch cache entry when the promise resolves (if necessary)
    const data = prefetchQueue.enqueue(()=>fetchServerResponse(url, tree, nextUrl, buildId, kind).then((prefetchResponse)=>{
            // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations
            // to avoid drift between this cache key prefixing logic
            // (which is currently directly influenced by the server response)
            const [, , , intercepted] = prefetchResponse;
            if (intercepted) {
                prefixExistingPrefetchCacheEntry({
                    url,
                    nextUrl,
                    prefetchCache
                });
            }
            return prefetchResponse;
        }));
    const prefetchEntry = {
        treeAtTimeOfPrefetch: tree,
        data,
        kind,
        prefetchTime: Date.now(),
        lastUsedTime: null,
        key: prefetchCacheKey,
        status: PrefetchCacheEntryStatus.fresh
    };
    prefetchCache.set(prefetchCacheKey, prefetchEntry);
    return prefetchEntry;
}
function prefetch_cache_utils_prunePrefetchCache(prefetchCache) {
    for (const [href, prefetchCacheEntry] of prefetchCache){
        if (getPrefetchEntryCacheStatus(prefetchCacheEntry) === PrefetchCacheEntryStatus.expired) {
            prefetchCache.delete(href);
        }
    }
}
// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)
// and default to 5 minutes (static) / 30 seconds (dynamic)
const DYNAMIC_STALETIME_MS = Number("30") * 1000;
const STATIC_STALETIME_MS = Number("300") * 1000;
function getPrefetchEntryCacheStatus(param) {
    let { kind, prefetchTime, lastUsedTime } = param;
    // We will re-use the cache entry data for up to the `dynamic` staletime window.
    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {
        return lastUsedTime ? PrefetchCacheEntryStatus.reusable : PrefetchCacheEntryStatus.fresh;
    }
    // For "auto" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.
    // A stale entry will only re-use the `loading` boundary, not the full data.
    // This will trigger a "lazy fetch" for the full data.
    if (kind === "auto") {
        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {
            return PrefetchCacheEntryStatus.stale;
        }
    }
    // for "full" prefetching, we'll re-use the cache entry data for up to `static` staletime window.
    if (kind === "full") {
        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {
            return PrefetchCacheEntryStatus.reusable;
        }
    }
    return PrefetchCacheEntryStatus.expired;
} //# sourceMappingURL=prefetch-cache-utils.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/prefetch-reducer.js



const prefetch_reducer_prefetchQueue = new PromiseQueue(5);
function prefetch_reducer_prefetchReducer(state, action) {
    // let's prune the prefetch cache before we do anything else
    prunePrefetchCache(state.prefetchCache);
    const { url } = action;
    url.searchParams.delete(NEXT_RSC_UNION_QUERY);
    getOrCreatePrefetchCacheEntry({
        url,
        nextUrl: state.nextUrl,
        prefetchCache: state.prefetchCache,
        kind: action.kind,
        tree: state.tree,
        buildId: state.buildId
    });
    return state;
} //# sourceMappingURL=prefetch-reducer.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/ppr-navigations.js



// Creates a new Cache Node tree (i.e. copy-on-write) that represents the
// optimistic result of a navigation, using both the current Cache Node tree and
// data that was prefetched prior to navigation.
//
// At the moment we call this function, we haven't yet received the navigation
// response from the server. It could send back something completely different
// from the tree that was prefetched â€” due to rewrites, default routes, parallel
// routes, etc.
//
// But in most cases, it will return the same tree that we prefetched, just with
// the dynamic holes filled in. So we optimistically assume this will happen,
// and accept that the real result could be arbitrarily different.
//
// We'll reuse anything that was already in the previous tree, since that's what
// the server does.
//
// New segments (ones that don't appear in the old tree) are assigned an
// unresolved promise. The data for these promises will be fulfilled later, when
// the navigation response is received.
//
// The tree can be rendered immediately after it is created (that's why this is
// a synchronous function). Any new trees that do not have prefetch data will
// suspend during rendering, until the dynamic data streams in.
//
// Returns a Task object, which contains both the updated Cache Node and a path
// to the pending subtrees that need to be resolved by the navigation response.
//
// A return value of `null` means there were no changes, and the previous tree
// can be reused without initiating a server request.
function ppr_navigations_updateCacheNodeOnNavigation(oldCacheNode, oldRouterState, newRouterState, prefetchData, prefetchHead) {
    // Diff the old and new trees to reuse the shared layouts.
    const oldRouterStateChildren = oldRouterState[1];
    const newRouterStateChildren = newRouterState[1];
    const prefetchDataChildren = prefetchData[1];
    const oldParallelRoutes = oldCacheNode.parallelRoutes;
    // Clone the current set of segment children, even if they aren't active in
    // the new tree.
    // TODO: We currently retain all the inactive segments indefinitely, until
    // there's an explicit refresh, or a parent layout is lazily refreshed. We
    // rely on this for popstate navigations, which update the Router State Tree
    // but do not eagerly perform a data fetch, because they expect the segment
    // data to already be in the Cache Node tree. For highly static sites that
    // are mostly read-only, this may happen only rarely, causing memory to
    // leak. We should figure out a better model for the lifetime of inactive
    // segments, so we can maintain instant back/forward navigations without
    // leaking memory indefinitely.
    const prefetchParallelRoutes = new Map(oldParallelRoutes);
    // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)
    // the Route Tree that was returned by the server â€” for example, in the case
    // of default parallel routes, we preserve the currently active segment. To
    // avoid mutating the original tree, we clone the router state children along
    // the return path.
    let patchedRouterStateChildren = {};
    let taskChildren = null;
    for(let parallelRouteKey in newRouterStateChildren){
        const newRouterStateChild = newRouterStateChildren[parallelRouteKey];
        const oldRouterStateChild = oldRouterStateChildren[parallelRouteKey];
        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);
        const prefetchDataChild = prefetchDataChildren[parallelRouteKey];
        const newSegmentChild = newRouterStateChild[0];
        const newSegmentKeyChild = createRouterCacheKey(newSegmentChild);
        const oldSegmentChild = oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined;
        const oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;
        let taskChild;
        if (newSegmentChild === PAGE_SEGMENT_KEY) {
            // This is a leaf segment â€” a page, not a shared layout. We always apply
            // its data.
            taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);
        } else if (newSegmentChild === DEFAULT_SEGMENT_KEY) {
            // This is another kind of leaf segment â€” a default route.
            //
            // Default routes have special behavior. When there's no matching segment
            // for a parallel route, Next.js preserves the currently active segment
            // during a client navigation â€” but not for initial render. The server
            // leaves it to the client to account for this. So we need to handle
            // it here.
            if (oldRouterStateChild !== undefined) {
                // Reuse the existing Router State for this segment. We spawn a "task"
                // just to keep track of the updated router state; unlike most, it's
                // already fulfilled and won't be affected by the dynamic response.
                taskChild = spawnReusedTask(oldRouterStateChild);
            } else {
                // There's no currently active segment. Switch to the "create" path.
                taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);
            }
        } else if (oldSegmentChild !== undefined && matchSegment(newSegmentChild, oldSegmentChild)) {
            if (oldCacheNodeChild !== undefined && oldRouterStateChild !== undefined) {
                // This segment exists in both the old and new trees.
                if (prefetchDataChild !== undefined && prefetchDataChild !== null) {
                    // Recursively update the children.
                    taskChild = ppr_navigations_updateCacheNodeOnNavigation(oldCacheNodeChild, oldRouterStateChild, newRouterStateChild, prefetchDataChild, prefetchHead);
                } else {
                    // The server didn't send any prefetch data for this segment. This
                    // shouldn't happen because the Route Tree and the Seed Data tree
                    // should always be the same shape, but until we unify those types
                    // it's still possible. For now we're going to deopt and trigger a
                    // lazy fetch during render.
                    taskChild = spawnTaskForMissingData(newRouterStateChild);
                }
            } else {
                // Either there's no existing Cache Node for this segment, or this
                // segment doesn't exist in the old Router State tree. Switch to the
                // "create" path.
                taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);
            }
        } else {
            // This is a new tree. Switch to the "create" path.
            taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);
        }
        if (taskChild !== null) {
            // Something changed in the child tree. Keep track of the child task.
            if (taskChildren === null) {
                taskChildren = new Map();
            }
            taskChildren.set(parallelRouteKey, taskChild);
            const newCacheNodeChild = taskChild.node;
            if (newCacheNodeChild !== null) {
                const newSegmentMapChild = new Map(oldSegmentMapChild);
                newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);
                prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild);
            }
            // The child tree's route state may be different from the prefetched
            // route sent by the server. We need to clone it as we traverse back up
            // the tree.
            patchedRouterStateChildren[parallelRouteKey] = taskChild.route;
        } else {
            // The child didn't change. We can use the prefetched router state.
            patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild;
        }
    }
    if (taskChildren === null) {
        // No new tasks were spawned.
        return null;
    }
    const newCacheNode = {
        lazyData: null,
        rsc: oldCacheNode.rsc,
        // We intentionally aren't updating the prefetchRsc field, since this node
        // is already part of the current tree, because it would be weird for
        // prefetch data to be newer than the final data. It probably won't ever be
        // observable anyway, but it could happen if the segment is unmounted then
        // mounted again, because LayoutRouter will momentarily switch to rendering
        // prefetchRsc, via useDeferredValue.
        prefetchRsc: oldCacheNode.prefetchRsc,
        head: oldCacheNode.head,
        prefetchHead: oldCacheNode.prefetchHead,
        loading: oldCacheNode.loading,
        // Everything is cloned except for the children, which we computed above.
        parallelRoutes: prefetchParallelRoutes,
        lazyDataResolved: false
    };
    return {
        // Return a cloned copy of the router state with updated children.
        route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),
        node: newCacheNode,
        children: taskChildren
    };
}
function patchRouterStateWithNewChildren(baseRouterState, newChildren) {
    const clone = [
        baseRouterState[0],
        newChildren
    ];
    // Based on equivalent logic in apply-router-state-patch-to-tree, but should
    // confirm whether we need to copy all of these fields. Not sure the server
    // ever sends, e.g. the refetch marker.
    if (2 in baseRouterState) {
        clone[2] = baseRouterState[2];
    }
    if (3 in baseRouterState) {
        clone[3] = baseRouterState[3];
    }
    if (4 in baseRouterState) {
        clone[4] = baseRouterState[4];
    }
    return clone;
}
function spawnPendingTask(routerState, prefetchData, prefetchHead) {
    // Create a task that will later be fulfilled by data from the server.
    const pendingCacheNode = createPendingCacheNode(routerState, prefetchData, prefetchHead);
    return {
        route: routerState,
        node: pendingCacheNode,
        children: null
    };
}
function spawnReusedTask(reusedRouterState) {
    // Create a task that reuses an existing segment, e.g. when reusing
    // the current active segment in place of a default route.
    return {
        route: reusedRouterState,
        node: null,
        children: null
    };
}
function spawnTaskForMissingData(routerState) {
    // Create a task for a new subtree that wasn't prefetched by the server.
    // This shouldn't really ever happen but it's here just in case the Seed Data
    // Tree and the Router State Tree disagree unexpectedly.
    const pendingCacheNode = createPendingCacheNode(routerState, null, null);
    return {
        route: routerState,
        node: pendingCacheNode,
        children: null
    };
}
// Writes a dynamic server response into the tree created by
// updateCacheNodeOnNavigation. All pending promises that were spawned by the
// navigation will be resolved, either with dynamic data from the server, or
// `null` to indicate that the data is missing.
//
// A `null` value will trigger a lazy fetch during render, which will then patch
// up the tree using the same mechanism as the non-PPR implementation
// (serverPatchReducer).
//
// Usually, the server will respond with exactly the subset of data that we're
// waiting for â€” everything below the nearest shared layout. But technically,
// the server can return anything it wants.
//
// This does _not_ create a new tree; it modifies the existing one in place.
// Which means it must follow the Suspense rules of cache safety.
function ppr_navigations_listenForDynamicRequest(task, responsePromise) {
    responsePromise.then((response)=>{
        const flightData = response[0];
        for (const flightDataPath of flightData){
            const segmentPath = flightDataPath.slice(0, -3);
            const serverRouterState = flightDataPath[flightDataPath.length - 3];
            const dynamicData = flightDataPath[flightDataPath.length - 2];
            const dynamicHead = flightDataPath[flightDataPath.length - 1];
            if (typeof segmentPath === "string") {
                continue;
            }
            writeDynamicDataIntoPendingTask(task, segmentPath, serverRouterState, dynamicData, dynamicHead);
        }
        // Now that we've exhausted all the data we received from the server, if
        // there are any remaining pending tasks in the tree, abort them now.
        // If there's any missing data, it will trigger a lazy fetch.
        abortTask(task, null);
    }, (error)=>{
        // This will trigger an error during render
        abortTask(task, error);
    });
}
function writeDynamicDataIntoPendingTask(rootTask, segmentPath, serverRouterState, dynamicData, dynamicHead) {
    // The data sent by the server represents only a subtree of the app. We need
    // to find the part of the task tree that matches the server response, and
    // fulfill it using the dynamic data.
    //
    // segmentPath represents the parent path of subtree. It's a repeating pattern
    // of parallel route key and segment:
    //
    //   [string, Segment, string, Segment, string, Segment, ...]
    //
    // Iterate through the path and finish any tasks that match this payload.
    let task = rootTask;
    for(let i = 0; i < segmentPath.length; i += 2){
        const parallelRouteKey = segmentPath[i];
        const segment = segmentPath[i + 1];
        const taskChildren = task.children;
        if (taskChildren !== null) {
            const taskChild = taskChildren.get(parallelRouteKey);
            if (taskChild !== undefined) {
                const taskSegment = taskChild.route[0];
                if (matchSegment(segment, taskSegment)) {
                    // Found a match for this task. Keep traversing down the task tree.
                    task = taskChild;
                    continue;
                }
            }
        }
        // We didn't find a child task that matches the server data. Exit. We won't
        // abort the task, though, because a different FlightDataPath may be able to
        // fulfill it (see loop in listenForDynamicRequest). We only abort tasks
        // once we've run out of data.
        return;
    }
    finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead);
}
function finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead) {
    // dynamicData may represent a larger subtree than the task. Before we can
    // finish the task, we need to line them up.
    const taskChildren = task.children;
    const taskNode = task.node;
    if (taskChildren === null) {
        // We've reached the leaf node of the pending task. The server data tree
        // lines up the pending Cache Node tree. We can now switch to the
        // normal algorithm.
        if (taskNode !== null) {
            finishPendingCacheNode(taskNode, task.route, serverRouterState, dynamicData, dynamicHead);
            // Null this out to indicate that the task is complete.
            task.node = null;
        }
        return;
    }
    // The server returned more data than we need to finish the task. Skip over
    // the extra segments until we reach the leaf task node.
    const serverChildren = serverRouterState[1];
    const dynamicDataChildren = dynamicData[1];
    for(const parallelRouteKey in serverRouterState){
        const serverRouterStateChild = serverChildren[parallelRouteKey];
        const dynamicDataChild = dynamicDataChildren[parallelRouteKey];
        const taskChild = taskChildren.get(parallelRouteKey);
        if (taskChild !== undefined) {
            const taskSegment = taskChild.route[0];
            if (matchSegment(serverRouterStateChild[0], taskSegment) && dynamicDataChild !== null && dynamicDataChild !== undefined) {
                // Found a match for this task. Keep traversing down the task tree.
                return finishTaskUsingDynamicDataPayload(taskChild, serverRouterStateChild, dynamicDataChild, dynamicHead);
            }
        }
    // We didn't find a child task that matches the server data. We won't abort
    // the task, though, because a different FlightDataPath may be able to
    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks
    // once we've run out of data.
    }
}
function createPendingCacheNode(routerState, prefetchData, prefetchHead) {
    const routerStateChildren = routerState[1];
    const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null;
    const parallelRoutes = new Map();
    for(let parallelRouteKey in routerStateChildren){
        const routerStateChild = routerStateChildren[parallelRouteKey];
        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;
        const segmentChild = routerStateChild[0];
        const segmentKeyChild = createRouterCacheKey(segmentChild);
        const newCacheNodeChild = createPendingCacheNode(routerStateChild, prefetchDataChild === undefined ? null : prefetchDataChild, prefetchHead);
        const newSegmentMapChild = new Map();
        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);
        parallelRoutes.set(parallelRouteKey, newSegmentMapChild);
    }
    // The head is assigned to every leaf segment delivered by the server. Based
    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts
    const isLeafSegment = parallelRoutes.size === 0;
    const maybePrefetchRsc = prefetchData !== null ? prefetchData[2] : null;
    const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null;
    return {
        lazyData: null,
        parallelRoutes: parallelRoutes,
        prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,
        prefetchHead: isLeafSegment ? prefetchHead : null,
        loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,
        // Create a deferred promise. This will be fulfilled once the dynamic
        // response is received from the server.
        rsc: createDeferredRsc(),
        head: isLeafSegment ? createDeferredRsc() : null,
        lazyDataResolved: false
    };
}
function finishPendingCacheNode(cacheNode, taskState, serverState, dynamicData, dynamicHead) {
    // Writes a dynamic response into an existing Cache Node tree. This does _not_
    // create a new tree, it updates the existing tree in-place. So it must follow
    // the Suspense rules of cache safety â€” it can resolve pending promises, but
    // it cannot overwrite existing data. It can add segments to the tree (because
    // a missing segment will cause the layout router to suspend).
    // but it cannot delete them.
    //
    // We must resolve every promise in the tree, or else it will suspend
    // indefinitely. If we did not receive data for a segment, we will resolve its
    // data promise to `null` to trigger a lazy fetch during render.
    const taskStateChildren = taskState[1];
    const serverStateChildren = serverState[1];
    const dataChildren = dynamicData[1];
    // The router state that we traverse the tree with (taskState) is the same one
    // that we used to construct the pending Cache Node tree. That way we're sure
    // to resolve all the pending promises.
    const parallelRoutes = cacheNode.parallelRoutes;
    for(let parallelRouteKey in taskStateChildren){
        const taskStateChild = taskStateChildren[parallelRouteKey];
        const serverStateChild = serverStateChildren[parallelRouteKey];
        const dataChild = dataChildren[parallelRouteKey];
        const segmentMapChild = parallelRoutes.get(parallelRouteKey);
        const taskSegmentChild = taskStateChild[0];
        const taskSegmentKeyChild = createRouterCacheKey(taskSegmentChild);
        const cacheNodeChild = segmentMapChild !== undefined ? segmentMapChild.get(taskSegmentKeyChild) : undefined;
        if (cacheNodeChild !== undefined) {
            if (serverStateChild !== undefined && matchSegment(taskSegmentChild, serverStateChild[0])) {
                if (dataChild !== undefined && dataChild !== null) {
                    // This is the happy path. Recursively update all the children.
                    finishPendingCacheNode(cacheNodeChild, taskStateChild, serverStateChild, dataChild, dynamicHead);
                } else {
                    // The server never returned data for this segment. Trigger a lazy
                    // fetch during render. This shouldn't happen because the Route Tree
                    // and the Seed Data tree sent by the server should always be the same
                    // shape when part of the same server response.
                    abortPendingCacheNode(taskStateChild, cacheNodeChild, null);
                }
            } else {
                // The server never returned data for this segment. Trigger a lazy
                // fetch during render.
                abortPendingCacheNode(taskStateChild, cacheNodeChild, null);
            }
        } else {
        // The server response matches what was expected to receive, but there's
        // no matching Cache Node in the task tree. This is a bug in the
        // implementation because we should have created a node for every
        // segment in the tree that's associated with this task.
        }
    }
    // Use the dynamic data from the server to fulfill the deferred RSC promise
    // on the Cache Node.
    const rsc = cacheNode.rsc;
    const dynamicSegmentData = dynamicData[2];
    if (rsc === null) {
        // This is a lazy cache node. We can overwrite it. This is only safe
        // because we know that the LayoutRouter suspends if `rsc` is `null`.
        cacheNode.rsc = dynamicSegmentData;
    } else if (isDeferredRsc(rsc)) {
        // This is a deferred RSC promise. We can fulfill it with the data we just
        // received from the server. If it was already resolved by a different
        // navigation, then this does nothing because we can't overwrite data.
        rsc.resolve(dynamicSegmentData);
    } else {
    // This is not a deferred RSC promise, nor is it empty, so it must have
    // been populated by a different navigation. We must not overwrite it.
    }
    // Check if this is a leaf segment. If so, it will have a `head` property with
    // a pending promise that needs to be resolved with the dynamic head from
    // the server.
    const head = cacheNode.head;
    if (isDeferredRsc(head)) {
        head.resolve(dynamicHead);
    }
}
function abortTask(task, error) {
    const cacheNode = task.node;
    if (cacheNode === null) {
        // This indicates the task is already complete.
        return;
    }
    const taskChildren = task.children;
    if (taskChildren === null) {
        // Reached the leaf task node. This is the root of a pending cache
        // node tree.
        abortPendingCacheNode(task.route, cacheNode, error);
    } else {
        // This is an intermediate task node. Keep traversing until we reach a
        // task node with no children. That will be the root of the cache node tree
        // that needs to be resolved.
        for (const taskChild of taskChildren.values()){
            abortTask(taskChild, error);
        }
    }
    // Null this out to indicate that the task is complete.
    task.node = null;
}
function abortPendingCacheNode(routerState, cacheNode, error) {
    // For every pending segment in the tree, resolve its `rsc` promise to `null`
    // to trigger a lazy fetch during render.
    //
    // Or, if an error object is provided, it will error instead.
    const routerStateChildren = routerState[1];
    const parallelRoutes = cacheNode.parallelRoutes;
    for(let parallelRouteKey in routerStateChildren){
        const routerStateChild = routerStateChildren[parallelRouteKey];
        const segmentMapChild = parallelRoutes.get(parallelRouteKey);
        if (segmentMapChild === undefined) {
            continue;
        }
        const segmentChild = routerStateChild[0];
        const segmentKeyChild = createRouterCacheKey(segmentChild);
        const cacheNodeChild = segmentMapChild.get(segmentKeyChild);
        if (cacheNodeChild !== undefined) {
            abortPendingCacheNode(routerStateChild, cacheNodeChild, error);
        } else {
        // This shouldn't happen because we're traversing the same tree that was
        // used to construct the cache nodes in the first place.
        }
    }
    const rsc = cacheNode.rsc;
    if (isDeferredRsc(rsc)) {
        if (error === null) {
            // This will trigger a lazy fetch during render.
            rsc.resolve(null);
        } else {
            // This will trigger an error during rendering.
            rsc.reject(error);
        }
    }
    // Check if this is a leaf segment. If so, it will have a `head` property with
    // a pending promise that needs to be resolved. If an error was provided, we
    // will not resolve it with an error, since this is rendered at the root of
    // the app. We want the segment to error, not the entire app.
    const head = cacheNode.head;
    if (isDeferredRsc(head)) {
        head.resolve(null);
    }
}
function updateCacheNodeOnPopstateRestoration(oldCacheNode, routerState) {
    // A popstate navigation reads data from the local cache. It does not issue
    // new network requests (unless the cache entries have been evicted). So, we
    // update the cache to drop the prefetch  data for any segment whose dynamic
    // data was already received. This prevents an unnecessary flash back to PPR
    // state during a back/forward navigation.
    //
    // This function clones the entire cache node tree and sets the `prefetchRsc`
    // field to `null` to prevent it from being rendered. We can't mutate the node
    // in place because this is a concurrent data structure.
    const routerStateChildren = routerState[1];
    const oldParallelRoutes = oldCacheNode.parallelRoutes;
    const newParallelRoutes = new Map(oldParallelRoutes);
    for(let parallelRouteKey in routerStateChildren){
        const routerStateChild = routerStateChildren[parallelRouteKey];
        const segmentChild = routerStateChild[0];
        const segmentKeyChild = createRouterCacheKey(segmentChild);
        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);
        if (oldSegmentMapChild !== undefined) {
            const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild);
            if (oldCacheNodeChild !== undefined) {
                const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(oldCacheNodeChild, routerStateChild);
                const newSegmentMapChild = new Map(oldSegmentMapChild);
                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);
                newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);
            }
        }
    }
    // Only show prefetched data if the dynamic data is still pending.
    //
    // Tehnically, what we're actually checking is whether the dynamic network
    // response was received. But since it's a streaming response, this does not
    // mean that all the dynamic data has fully streamed in. It just means that
    // _some_ of the dynamic data was received. But as a heuristic, we assume that
    // the rest dynamic data will stream in quickly, so it's still better to skip
    // the prefetch state.
    const rsc = oldCacheNode.rsc;
    const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === "pending";
    return {
        lazyData: null,
        rsc,
        head: oldCacheNode.head,
        prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : null,
        prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,
        loading: shouldUsePrefetch ? oldCacheNode.loading : null,
        // These are the cloned children we computed above
        parallelRoutes: newParallelRoutes,
        lazyDataResolved: false
    };
}
const DEFERRED = Symbol();
// This type exists to distinguish a DeferredRsc from a Flight promise. It's a
// compromise to avoid adding an extra field on every Cache Node, which would be
// awkward because the pre-PPR parts of codebase would need to account for it,
// too. We can remove it once type Cache Node type is more settled.
function isDeferredRsc(value) {
    return value && value.tag === DEFERRED;
}
function createDeferredRsc() {
    let resolve;
    let reject;
    const pendingRsc = new Promise((res, rej)=>{
        resolve = res;
        reject = rej;
    });
    pendingRsc.status = "pending";
    pendingRsc.resolve = (value)=>{
        if (pendingRsc.status === "pending") {
            const fulfilledRsc = pendingRsc;
            fulfilledRsc.status = "fulfilled";
            fulfilledRsc.value = value;
            resolve(value);
        }
    };
    pendingRsc.reject = (error)=>{
        if (pendingRsc.status === "pending") {
            const rejectedRsc = pendingRsc;
            rejectedRsc.status = "rejected";
            rejectedRsc.reason = error;
            reject(error);
        }
    };
    pendingRsc.tag = DEFERRED;
    return pendingRsc;
} //# sourceMappingURL=ppr-navigations.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/navigate-reducer.js















function navigate_reducer_handleExternalUrl(state, mutable, url, pendingPush) {
    mutable.mpaNavigation = true;
    mutable.canonicalUrl = url;
    mutable.pendingPush = pendingPush;
    mutable.scrollableSegments = undefined;
    return handleMutable(state, mutable);
}
function generateSegmentsFromPatch(flightRouterPatch) {
    const segments = [];
    const [segment, parallelRoutes] = flightRouterPatch;
    if (Object.keys(parallelRoutes).length === 0) {
        return [
            [
                segment
            ]
        ];
    }
    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){
        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){
            // If the segment is empty, it means we are at the root of the tree
            if (segment === "") {
                segments.push([
                    parallelRouteKey,
                    ...childSegment
                ]);
            } else {
                segments.push([
                    segment,
                    parallelRouteKey,
                    ...childSegment
                ]);
            }
        }
    }
    return segments;
}
function triggerLazyFetchForLeafSegments(newCache, currentCache, flightSegmentPath, treePatch) {
    let appliedPatch = false;
    newCache.rsc = currentCache.rsc;
    newCache.prefetchRsc = currentCache.prefetchRsc;
    newCache.loading = currentCache.loading;
    newCache.parallelRoutes = new Map(currentCache.parallelRoutes);
    const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map((segment)=>[
            ...flightSegmentPath,
            ...segment
        ]);
    for (const segmentPaths of segmentPathsToFill){
        clearCacheNodeDataForSegmentPath(newCache, currentCache, segmentPaths);
        appliedPatch = true;
    }
    return appliedPatch;
}
// These implementations are expected to diverge significantly, so I've forked
// the entire function. The one that's disabled should be dead code eliminated
// because the check here is statically inlined at build time.
const navigate_reducer_navigateReducer = (/* unused pure expression or super */ null && ( false ? 0 : navigateReducer_noPPR));
// This is the implementation when PPR is disabled. We can assume its behavior
// is relatively stable because it's been running in production for a while.
function navigateReducer_noPPR(state, action) {
    const { url, isExternalUrl, navigateType, shouldScroll } = action;
    const mutable = {};
    const { hash } = url;
    const href = createHrefFromUrl(url);
    const pendingPush = navigateType === "push";
    // we want to prune the prefetch cache on every navigation to avoid it growing too large
    prunePrefetchCache(state.prefetchCache);
    mutable.preserveCustomHistoryState = false;
    if (isExternalUrl) {
        return navigate_reducer_handleExternalUrl(state, mutable, url.toString(), pendingPush);
    }
    const prefetchValues = getOrCreatePrefetchCacheEntry({
        url,
        nextUrl: state.nextUrl,
        tree: state.tree,
        buildId: state.buildId,
        prefetchCache: state.prefetchCache
    });
    const { treeAtTimeOfPrefetch, data } = prefetchValues;
    prefetchQueue.bump(data);
    return data.then((param)=>{
        let [flightData, canonicalUrlOverride] = param;
        let isFirstRead = false;
        // we only want to mark this once
        if (!prefetchValues.lastUsedTime) {
            // important: we should only mark the cache node as dirty after we unsuspend from the call above
            prefetchValues.lastUsedTime = Date.now();
            isFirstRead = true;
        }
        // Handle case when navigating to page in `pages` from `app`
        if (typeof flightData === "string") {
            return navigate_reducer_handleExternalUrl(state, mutable, flightData, pendingPush);
        }
        // Handles case where `<meta http-equiv="refresh">` tag is present,
        // which will trigger an MPA navigation.
        if (document.getElementById("__next-page-redirect")) {
            return navigate_reducer_handleExternalUrl(state, mutable, href, pendingPush);
        }
        let currentTree = state.tree;
        let currentCache = state.cache;
        let scrollableSegments = [];
        for (const flightDataPath of flightData){
            const flightSegmentPath = flightDataPath.slice(0, -4);
            // The one before last item is the router state tree patch
            const treePatch = flightDataPath.slice(-3)[0];
            // TODO-APP: remove ''
            const flightSegmentPathWithLeadingEmpty = [
                "",
                ...flightSegmentPath
            ];
            // Create new tree based on the flightSegmentPath and router state patch
            let newTree = applyRouterStatePatchToTree(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);
            // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch
            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.
            if (newTree === null) {
                newTree = applyRouterStatePatchToTree(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);
            }
            if (newTree !== null) {
                if (isNavigatingToNewRootLayout(currentTree, newTree)) {
                    return navigate_reducer_handleExternalUrl(state, mutable, href, pendingPush);
                }
                const cache = createEmptyCacheNode();
                let applied = false;
                if (prefetchValues.status === PrefetchCacheEntryStatus.stale && !isFirstRead) {
                    // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations
                    // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,
                    // while copying over the `loading` for the segment that contains the page data.
                    // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.
                    applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);
                    // since we re-used the stale cache's loading state & refreshed the data,
                    // update the `lastUsedTime` so that it can continue to be re-used for the next 30s
                    prefetchValues.lastUsedTime = Date.now();
                } else {
                    applied = applyFlightData(currentCache, cache, flightDataPath, prefetchValues);
                }
                const hardNavigate = shouldHardNavigate(flightSegmentPathWithLeadingEmpty, currentTree);
                if (hardNavigate) {
                    // Copy rsc for the root node of the cache.
                    cache.rsc = currentCache.rsc;
                    cache.prefetchRsc = currentCache.prefetchRsc;
                    invalidateCacheBelowFlightSegmentPath(cache, currentCache, flightSegmentPath);
                    // Ensure the existing cache value is used when the cache was not invalidated.
                    mutable.cache = cache;
                } else if (applied) {
                    mutable.cache = cache;
                    // If we applied the cache, we update the "current cache" value so any other
                    // segments in the FlightDataPath will be able to reference the updated cache.
                    currentCache = cache;
                }
                currentTree = newTree;
                for (const subSegment of generateSegmentsFromPatch(treePatch)){
                    const scrollableSegmentPath = [
                        ...flightSegmentPath,
                        ...subSegment
                    ];
                    // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.
                    if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== DEFAULT_SEGMENT_KEY) {
                        scrollableSegments.push(scrollableSegmentPath);
                    }
                }
            }
        }
        mutable.patchedTree = currentTree;
        mutable.canonicalUrl = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : href;
        mutable.pendingPush = pendingPush;
        mutable.scrollableSegments = scrollableSegments;
        mutable.hashFragment = hash;
        mutable.shouldScroll = shouldScroll;
        return handleMutable(state, mutable);
    }, ()=>state);
}
// This is the experimental PPR implementation. It's closer to the behavior we
// want, but is likelier to include accidental regressions because it rewrites
// existing functionality.
function navigateReducer_PPR(state, action) {
    const { url, isExternalUrl, navigateType, shouldScroll } = action;
    const mutable = {};
    const { hash } = url;
    const href = createHrefFromUrl(url);
    const pendingPush = navigateType === "push";
    // we want to prune the prefetch cache on every navigation to avoid it growing too large
    prunePrefetchCache(state.prefetchCache);
    mutable.preserveCustomHistoryState = false;
    if (isExternalUrl) {
        return navigate_reducer_handleExternalUrl(state, mutable, url.toString(), pendingPush);
    }
    const prefetchValues = getOrCreatePrefetchCacheEntry({
        url,
        nextUrl: state.nextUrl,
        tree: state.tree,
        buildId: state.buildId,
        prefetchCache: state.prefetchCache
    });
    const { treeAtTimeOfPrefetch, data } = prefetchValues;
    prefetchQueue.bump(data);
    return data.then((param)=>{
        let [flightData, canonicalUrlOverride, _postponed] = param;
        let isFirstRead = false;
        // we only want to mark this once
        if (!prefetchValues.lastUsedTime) {
            // important: we should only mark the cache node as dirty after we unsuspend from the call above
            prefetchValues.lastUsedTime = Date.now();
            isFirstRead = true;
        }
        // Handle case when navigating to page in `pages` from `app`
        if (typeof flightData === "string") {
            return navigate_reducer_handleExternalUrl(state, mutable, flightData, pendingPush);
        }
        // Handles case where `<meta http-equiv="refresh">` tag is present,
        // which will trigger an MPA navigation.
        if (document.getElementById("__next-page-redirect")) {
            return navigate_reducer_handleExternalUrl(state, mutable, href, pendingPush);
        }
        let currentTree = state.tree;
        let currentCache = state.cache;
        let scrollableSegments = [];
        // TODO: In practice, this is always a single item array. We probably
        // aren't going to every send multiple segments, at least not in this
        // format. So we could remove the extra wrapper for now until
        // that settles.
        for (const flightDataPath of flightData){
            const flightSegmentPath = flightDataPath.slice(0, -4);
            // The one before last item is the router state tree patch
            const treePatch = flightDataPath.slice(-3)[0];
            // TODO-APP: remove ''
            const flightSegmentPathWithLeadingEmpty = [
                "",
                ...flightSegmentPath
            ];
            // Create new tree based on the flightSegmentPath and router state patch
            let newTree = applyRouterStatePatchToTree(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);
            // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch
            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.
            if (newTree === null) {
                newTree = applyRouterStatePatchToTree(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);
            }
            if (newTree !== null) {
                if (isNavigatingToNewRootLayout(currentTree, newTree)) {
                    return navigate_reducer_handleExternalUrl(state, mutable, href, pendingPush);
                }
                if (// will always send back a static response that's rendered from
                // the root. If for some reason it doesn't, we fall back to the
                // non-PPR implementation.
                // TODO: We should get rid of the else branch and do all navigations
                // via updateCacheNodeOnNavigation. The current structure is just
                // an incremental step.
                flightDataPath.length === 3) {
                    const prefetchedTree = flightDataPath[0];
                    const seedData = flightDataPath[1];
                    const head = flightDataPath[2];
                    const task = updateCacheNodeOnNavigation(currentCache, currentTree, prefetchedTree, seedData, head);
                    if (task !== null && task.node !== null) {
                        // We've created a new Cache Node tree that contains a prefetched
                        // version of the next page. This can be rendered instantly.
                        // Use the tree computed by updateCacheNodeOnNavigation instead
                        // of the one computed by applyRouterStatePatchToTree.
                        // TODO: We should remove applyRouterStatePatchToTree
                        // from the PPR path entirely.
                        const patchedRouterState = task.route;
                        newTree = patchedRouterState;
                        const newCache = task.node;
                        // The prefetched tree has dynamic holes in it. We initiate a
                        // dynamic request to fill them in.
                        //
                        // Do not block on the result. We'll immediately render the Cache
                        // Node tree and suspend on the dynamic parts. When the request
                        // comes in, we'll fill in missing data and ping React to
                        // re-render. Unlike the lazy fetching model in the non-PPR
                        // implementation, this is modeled as a single React update +
                        // streaming, rather than multiple top-level updates. (However,
                        // even in the new model, we'll still need to sometimes update the
                        // root multiple times per navigation, like if the server sends us
                        // a different response than we expected. For now, we revert back
                        // to the lazy fetching mechanism in that case.)
                        listenForDynamicRequest(task, fetchServerResponse(url, currentTree, state.nextUrl, state.buildId));
                        mutable.cache = newCache;
                    } else {
                        // Nothing changed, so reuse the old cache.
                        // TODO: What if the head changed but not any of the segment data?
                        // Is that possible? If so, we should clone the whole tree and
                        // update the head.
                        newTree = prefetchedTree;
                    }
                } else {
                    // The static response does not include any dynamic holes, so
                    // there's no need to do a second request.
                    // TODO: As an incremental step this just reverts back to the
                    // non-PPR implementation. We can simplify this branch further,
                    // given that PPR prefetches are always static and return the whole
                    // tree. Or in the meantime we could factor it out into a
                    // separate function.
                    const cache = createEmptyCacheNode();
                    let applied = false;
                    if (prefetchValues.status === PrefetchCacheEntryStatus.stale && !isFirstRead) {
                        // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations
                        // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,
                        // while copying over the `loading` for the segment that contains the page data.
                        // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.
                        applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);
                        // since we re-used the stale cache's loading state & refreshed the data,
                        // update the `lastUsedTime` so that it can continue to be re-used for the next 30s
                        prefetchValues.lastUsedTime = Date.now();
                    } else {
                        applied = applyFlightData(currentCache, cache, flightDataPath, prefetchValues);
                    }
                    const hardNavigate = shouldHardNavigate(flightSegmentPathWithLeadingEmpty, currentTree);
                    if (hardNavigate) {
                        // Copy rsc for the root node of the cache.
                        cache.rsc = currentCache.rsc;
                        cache.prefetchRsc = currentCache.prefetchRsc;
                        invalidateCacheBelowFlightSegmentPath(cache, currentCache, flightSegmentPath);
                        // Ensure the existing cache value is used when the cache was not invalidated.
                        mutable.cache = cache;
                    } else if (applied) {
                        mutable.cache = cache;
                        // If we applied the cache, we update the "current cache" value so any other
                        // segments in the FlightDataPath will be able to reference the updated cache.
                        currentCache = cache;
                    }
                }
                currentTree = newTree;
                for (const subSegment of generateSegmentsFromPatch(treePatch)){
                    const scrollableSegmentPath = [
                        ...flightSegmentPath,
                        ...subSegment
                    ];
                    // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.
                    if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== DEFAULT_SEGMENT_KEY) {
                        scrollableSegments.push(scrollableSegmentPath);
                    }
                }
            }
        }
        mutable.patchedTree = currentTree;
        mutable.canonicalUrl = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : href;
        mutable.pendingPush = pendingPush;
        mutable.scrollableSegments = scrollableSegments;
        mutable.hashFragment = hash;
        mutable.shouldScroll = shouldScroll;
        return handleMutable(state, mutable);
    }, ()=>state);
} //# sourceMappingURL=navigate-reducer.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/handle-segment-mismatch.js

/**
 * Handles the case where the client router attempted to patch the tree but, due to a mismatch, the patch failed.
 * This will perform an MPA navigation to return the router to a valid state.
 */ function handle_segment_mismatch_handleSegmentMismatch(state, action, treePatch) {
    if (false) {}
    return handleExternalUrl(state, {}, state.canonicalUrl, true);
} //# sourceMappingURL=handle-segment-mismatch.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/server-patch-reducer.js








function server_patch_reducer_serverPatchReducer(state, action) {
    const { serverResponse } = action;
    const [flightData, overrideCanonicalUrl] = serverResponse;
    const mutable = {};
    mutable.preserveCustomHistoryState = false;
    // Handle case when navigating to page in `pages` from `app`
    if (typeof flightData === "string") {
        return handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);
    }
    let currentTree = state.tree;
    let currentCache = state.cache;
    for (const flightDataPath of flightData){
        // Slices off the last segment (which is at -4) as it doesn't exist in the tree yet
        const flightSegmentPath = flightDataPath.slice(0, -4);
        const [treePatch] = flightDataPath.slice(-3, -2);
        const newTree = applyRouterStatePatchToTree([
            "",
            ...flightSegmentPath
        ], currentTree, treePatch, state.canonicalUrl);
        if (newTree === null) {
            return handleSegmentMismatch(state, action, treePatch);
        }
        if (isNavigatingToNewRootLayout(currentTree, newTree)) {
            return handleExternalUrl(state, mutable, state.canonicalUrl, state.pushRef.pendingPush);
        }
        const canonicalUrlOverrideHref = overrideCanonicalUrl ? createHrefFromUrl(overrideCanonicalUrl) : undefined;
        if (canonicalUrlOverrideHref) {
            mutable.canonicalUrl = canonicalUrlOverrideHref;
        }
        const cache = createEmptyCacheNode();
        applyFlightData(currentCache, cache, flightDataPath);
        mutable.patchedTree = newTree;
        mutable.cache = cache;
        currentCache = cache;
        currentTree = newTree;
    }
    return handleMutable(state, mutable);
} //# sourceMappingURL=server-patch-reducer.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/restore-reducer.js



function restore_reducer_restoreReducer(state, action) {
    const { url, tree } = action;
    const href = createHrefFromUrl(url);
    // This action is used to restore the router state from the history state.
    // However, it's possible that the history state no longer contains the `FlightRouterState`.
    // We will copy over the internal state on pushState/replaceState events, but if a history entry
    // occurred before hydration, or if the user navigated to a hash using a regular anchor link,
    // the history state will not contain the `FlightRouterState`.
    // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.
    const treeToRestore = tree || state.tree;
    const oldCache = state.cache;
    const newCache =  false ? // prevents an unnecessary flash back to PPR state during a
    // back/forward navigation.
    0 : oldCache;
    var _extractPathFromFlightRouterState;
    return {
        buildId: state.buildId,
        // Set canonical url
        canonicalUrl: href,
        pushRef: {
            pendingPush: false,
            mpaNavigation: false,
            // Ensures that the custom history state that was set is preserved when applying this update.
            preserveCustomHistoryState: true
        },
        focusAndScrollRef: state.focusAndScrollRef,
        cache: newCache,
        prefetchCache: state.prefetchCache,
        // Restore provided tree
        tree: treeToRestore,
        nextUrl: (_extractPathFromFlightRouterState = extractPathFromFlightRouterState(treeToRestore)) != null ? _extractPathFromFlightRouterState : url.pathname
    };
} //# sourceMappingURL=restore-reducer.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/refresh-reducer.js











function refresh_reducer_refreshReducer(state, action) {
    const { origin } = action;
    const mutable = {};
    const href = state.canonicalUrl;
    let currentTree = state.tree;
    mutable.preserveCustomHistoryState = false;
    const cache = createEmptyCacheNode();
    // If the current tree was intercepted, the nextUrl should be included in the request.
    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.
    const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree);
    // TODO-APP: verify that `href` is not an external url.
    // Fetch data from the root of the tree.
    cache.lazyData = fetchServerResponse(new URL(href, origin), [
        currentTree[0],
        currentTree[1],
        currentTree[2],
        "refetch"
    ], includeNextUrl ? state.nextUrl : null, state.buildId);
    return cache.lazyData.then(async (param)=>{
        let [flightData, canonicalUrlOverride] = param;
        // Handle case when navigating to page in `pages` from `app`
        if (typeof flightData === "string") {
            return handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);
        }
        // Remove cache.lazyData as it has been resolved at this point.
        cache.lazyData = null;
        for (const flightDataPath of flightData){
            // FlightDataPath with more than two items means unexpected Flight data was returned
            if (flightDataPath.length !== 3) {
                // TODO-APP: handle this case better
                console.log("REFRESH FAILED");
                return state;
            }
            // Given the path can only have two items the items are only the router state and rsc for the root.
            const [treePatch] = flightDataPath;
            const newTree = applyRouterStatePatchToTree([
                ""
            ], currentTree, treePatch, state.canonicalUrl);
            if (newTree === null) {
                return handleSegmentMismatch(state, action, treePatch);
            }
            if (isNavigatingToNewRootLayout(currentTree, newTree)) {
                return handleExternalUrl(state, mutable, href, state.pushRef.pendingPush);
            }
            const canonicalUrlOverrideHref = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : undefined;
            if (canonicalUrlOverride) {
                mutable.canonicalUrl = canonicalUrlOverrideHref;
            }
            // The one before last item is the router state tree patch
            const [cacheNodeSeedData, head] = flightDataPath.slice(-2);
            // Handles case where prefetch only returns the router tree patch without rendered components.
            if (cacheNodeSeedData !== null) {
                const rsc = cacheNodeSeedData[2];
                cache.rsc = rsc;
                cache.prefetchRsc = null;
                fillLazyItemsTillLeafWithHead(cache, undefined, treePatch, cacheNodeSeedData, head);
                mutable.prefetchCache = new Map();
            }
            await refreshInactiveParallelSegments({
                state,
                updatedTree: newTree,
                updatedCache: cache,
                includeNextUrl,
                canonicalUrl: mutable.canonicalUrl || state.canonicalUrl
            });
            mutable.cache = cache;
            mutable.patchedTree = newTree;
            mutable.canonicalUrl = href;
            currentTree = newTree;
        }
        return handleMutable(state, mutable);
    }, ()=>state);
} //# sourceMappingURL=refresh-reducer.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/fast-refresh-reducer.js










// A version of refresh reducer that keeps the cache around instead of wiping all of it.
function fastRefreshReducerImpl(state, action) {
    const { origin } = action;
    const mutable = {};
    const href = state.canonicalUrl;
    mutable.preserveCustomHistoryState = false;
    const cache = createEmptyCacheNode();
    // If the current tree was intercepted, the nextUrl should be included in the request.
    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.
    const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree);
    // TODO-APP: verify that `href` is not an external url.
    // Fetch data from the root of the tree.
    cache.lazyData = fetchServerResponse(new URL(href, origin), [
        state.tree[0],
        state.tree[1],
        state.tree[2],
        "refetch"
    ], includeNextUrl ? state.nextUrl : null, state.buildId);
    return cache.lazyData.then((param)=>{
        let [flightData, canonicalUrlOverride] = param;
        // Handle case when navigating to page in `pages` from `app`
        if (typeof flightData === "string") {
            return handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);
        }
        // Remove cache.lazyData as it has been resolved at this point.
        cache.lazyData = null;
        let currentTree = state.tree;
        let currentCache = state.cache;
        for (const flightDataPath of flightData){
            // FlightDataPath with more than two items means unexpected Flight data was returned
            if (flightDataPath.length !== 3) {
                // TODO-APP: handle this case better
                console.log("REFRESH FAILED");
                return state;
            }
            // Given the path can only have two items the items are only the router state and rsc for the root.
            const [treePatch] = flightDataPath;
            const newTree = applyRouterStatePatchToTree([
                ""
            ], currentTree, treePatch, state.canonicalUrl);
            if (newTree === null) {
                return handleSegmentMismatch(state, action, treePatch);
            }
            if (isNavigatingToNewRootLayout(currentTree, newTree)) {
                return handleExternalUrl(state, mutable, href, state.pushRef.pendingPush);
            }
            const canonicalUrlOverrideHref = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : undefined;
            if (canonicalUrlOverride) {
                mutable.canonicalUrl = canonicalUrlOverrideHref;
            }
            const applied = applyFlightData(currentCache, cache, flightDataPath);
            if (applied) {
                mutable.cache = cache;
                currentCache = cache;
            }
            mutable.patchedTree = newTree;
            mutable.canonicalUrl = href;
            currentTree = newTree;
        }
        return handleMutable(state, mutable);
    }, ()=>state);
}
function fastRefreshReducerNoop(state, _action) {
    return state;
}
const fast_refresh_reducer_fastRefreshReducer = (/* unused pure expression or super */ null && ( true ? fastRefreshReducerNoop : 0)); //# sourceMappingURL=fast-refresh-reducer.js.map

// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/app-call-server.js
var app_call_server = __webpack_require__(8283);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/server-action-reducer.js


// // eslint-disable-next-line import/no-extraneous-dependencies
// import { createFromFetch } from 'react-server-dom-webpack/client'
// // eslint-disable-next-line import/no-extraneous-dependencies
// import { encodeReply } from 'react-server-dom-webpack/client'
const { createFromFetch, encodeReply } =  true ? __webpack_require__(1502) : 0;











async function fetchServerAction(state, nextUrl, param) {
    let { actionId, actionArgs } = param;
    const body = await encodeReply(actionArgs);
    const res = await fetch("", {
        method: "POST",
        headers: {
            Accept: RSC_CONTENT_TYPE_HEADER,
            [ACTION]: actionId,
            [NEXT_ROUTER_STATE_TREE]: encodeURIComponent(JSON.stringify(state.tree)),
            ... false ? 0 : {},
            ...nextUrl ? {
                [NEXT_URL]: nextUrl
            } : {}
        },
        body
    });
    const location = res.headers.get("x-action-redirect");
    let revalidatedParts;
    try {
        const revalidatedHeader = JSON.parse(res.headers.get("x-action-revalidated") || "[[],0,0]");
        revalidatedParts = {
            paths: revalidatedHeader[0] || [],
            tag: !!revalidatedHeader[1],
            cookie: revalidatedHeader[2]
        };
    } catch (e) {
        revalidatedParts = {
            paths: [],
            tag: false,
            cookie: false
        };
    }
    const redirectLocation = location ? new URL(addBasePath(location), new URL(state.canonicalUrl, window.location.href)) : undefined;
    let isFlightResponse = res.headers.get("content-type") === RSC_CONTENT_TYPE_HEADER;
    if (isFlightResponse) {
        const response = await createFromFetch(Promise.resolve(res), {
            callServer
        });
        if (location) {
            // if it was a redirection, then result is just a regular RSC payload
            const [, actionFlightData] = response != null ? response : [];
            return {
                actionFlightData: actionFlightData,
                redirectLocation,
                revalidatedParts
            };
        }
        // otherwise it's a tuple of [actionResult, actionFlightData]
        const [actionResult, [, actionFlightData]] = response != null ? response : [];
        return {
            actionResult,
            actionFlightData,
            redirectLocation,
            revalidatedParts
        };
    }
    return {
        redirectLocation,
        revalidatedParts
    };
}
/*
 * This reducer is responsible for calling the server action and processing any side-effects from the server action.
 * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.
 */ function server_action_reducer_serverActionReducer(state, action) {
    const { resolve, reject } = action;
    const mutable = {};
    const href = state.canonicalUrl;
    let currentTree = state.tree;
    mutable.preserveCustomHistoryState = false;
    // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.
    // If the route has been intercepted, the action should be as well.
    // Otherwise the server action might be intercepted with the wrong action id
    // (ie, one that corresponds with the intercepted route)
    const nextUrl = state.nextUrl && hasInterceptionRouteInCurrentTree(state.tree) ? state.nextUrl : null;
    mutable.inFlightServerAction = fetchServerAction(state, nextUrl, action);
    return mutable.inFlightServerAction.then(async (param)=>{
        let { actionResult, actionFlightData: flightData, redirectLocation } = param;
        // Make sure the redirection is a push instead of a replace.
        // Issue: https://github.com/vercel/next.js/issues/53911
        if (redirectLocation) {
            state.pushRef.pendingPush = true;
            mutable.pendingPush = true;
        }
        if (!flightData) {
            resolve(actionResult);
            // If there is a redirect but no flight data we need to do a mpaNavigation.
            if (redirectLocation) {
                return handleExternalUrl(state, mutable, redirectLocation.href, state.pushRef.pendingPush);
            }
            return state;
        }
        if (typeof flightData === "string") {
            // Handle case when navigating to page in `pages` from `app`
            return handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);
        }
        // Remove cache.data as it has been resolved at this point.
        mutable.inFlightServerAction = null;
        if (redirectLocation) {
            const newHref = createHrefFromUrl(redirectLocation, false);
            mutable.canonicalUrl = newHref;
        }
        for (const flightDataPath of flightData){
            // FlightDataPath with more than two items means unexpected Flight data was returned
            if (flightDataPath.length !== 3) {
                // TODO-APP: handle this case better
                console.log("SERVER ACTION APPLY FAILED");
                return state;
            }
            // Given the path can only have two items the items are only the router state and rsc for the root.
            const [treePatch] = flightDataPath;
            const newTree = applyRouterStatePatchToTree([
                ""
            ], currentTree, treePatch, redirectLocation ? createHrefFromUrl(redirectLocation) : state.canonicalUrl);
            if (newTree === null) {
                return handleSegmentMismatch(state, action, treePatch);
            }
            if (isNavigatingToNewRootLayout(currentTree, newTree)) {
                return handleExternalUrl(state, mutable, href, state.pushRef.pendingPush);
            }
            // The one before last item is the router state tree patch
            const [cacheNodeSeedData, head] = flightDataPath.slice(-2);
            const rsc = cacheNodeSeedData !== null ? cacheNodeSeedData[2] : null;
            // Handles case where prefetch only returns the router tree patch without rendered components.
            if (rsc !== null) {
                const cache = createEmptyCacheNode();
                cache.rsc = rsc;
                cache.prefetchRsc = null;
                fillLazyItemsTillLeafWithHead(cache, undefined, treePatch, cacheNodeSeedData, head);
                await refreshInactiveParallelSegments({
                    state,
                    updatedTree: newTree,
                    updatedCache: cache,
                    includeNextUrl: Boolean(nextUrl),
                    canonicalUrl: mutable.canonicalUrl || state.canonicalUrl
                });
                mutable.cache = cache;
                mutable.prefetchCache = new Map();
            }
            mutable.patchedTree = newTree;
            currentTree = newTree;
        }
        resolve(actionResult);
        return handleMutable(state, mutable);
    }, (e)=>{
        // When the server action is rejected we don't update the state and instead call the reject handler of the promise.
        reject(e);
        return state;
    });
} //# sourceMappingURL=server-action-reducer.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/router-reducer.js








/**
 * Reducer that handles the app-router state updates.
 */ function clientReducer(state, action) {
    switch(action.type){
        case ACTION_NAVIGATE:
            {
                return navigateReducer(state, action);
            }
        case ACTION_SERVER_PATCH:
            {
                return serverPatchReducer(state, action);
            }
        case ACTION_RESTORE:
            {
                return restoreReducer(state, action);
            }
        case ACTION_REFRESH:
            {
                return refreshReducer(state, action);
            }
        case ACTION_FAST_REFRESH:
            {
                return fastRefreshReducer(state, action);
            }
        case ACTION_PREFETCH:
            {
                return prefetchReducer(state, action);
            }
        case ACTION_SERVER_ACTION:
            {
                return serverActionReducer(state, action);
            }
        // This case should never be hit as dispatch is strongly typed.
        default:
            throw new Error("Unknown action");
    }
}
function serverReducer(state, _action) {
    return state;
}
// we don't run the client reducer on the server, so we use a noop function for better tree shaking
const router_reducer_reducer = (/* unused pure expression or super */ null && ( true ? serverReducer : 0)); //# sourceMappingURL=router-reducer.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/shared/lib/router/action-queue.js



const action_queue_ActionQueueContext = /*#__PURE__*/ (/* unused pure expression or super */ null && (React.createContext(null)));
function runRemainingActions(actionQueue, setState) {
    if (actionQueue.pending !== null) {
        actionQueue.pending = actionQueue.pending.next;
        if (actionQueue.pending !== null) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            runAction({
                actionQueue,
                action: actionQueue.pending,
                setState
            });
        } else {
            // No more actions are pending, check if a refresh is needed
            if (actionQueue.needsRefresh) {
                actionQueue.needsRefresh = false;
                actionQueue.dispatch({
                    type: ACTION_REFRESH,
                    origin: window.location.origin
                }, setState);
            }
        }
    }
}
async function runAction(param) {
    let { actionQueue, action, setState } = param;
    const prevState = actionQueue.state;
    if (!prevState) {
        // This shouldn't happen as the state is initialized in the dispatcher if it's not set
        throw new Error("Invariant: Router state not initialized");
    }
    actionQueue.pending = action;
    const payload = action.payload;
    const actionResult = actionQueue.action(prevState, payload);
    function handleResult(nextState) {
        // if we discarded this action, the state should also be discarded
        if (action.discarded) {
            return;
        }
        actionQueue.state = nextState;
        if (actionQueue.devToolsInstance) {
            actionQueue.devToolsInstance.send(payload, nextState);
        }
        runRemainingActions(actionQueue, setState);
        action.resolve(nextState);
    }
    // if the action is a promise, set up a callback to resolve it
    if (isThenable(actionResult)) {
        actionResult.then(handleResult, (err)=>{
            runRemainingActions(actionQueue, setState);
            action.reject(err);
        });
    } else {
        handleResult(actionResult);
    }
}
function dispatchAction(actionQueue, payload, setState) {
    let resolvers = {
        resolve: setState,
        reject: ()=>{}
    };
    // most of the action types are async with the exception of restore
    // it's important that restore is handled quickly since it's fired on the popstate event
    // and we don't want to add any delay on a back/forward nav
    // this only creates a promise for the async actions
    if (payload.type !== ACTION_RESTORE) {
        // Create the promise and assign the resolvers to the object.
        const deferredPromise = new Promise((resolve, reject)=>{
            resolvers = {
                resolve,
                reject
            };
        });
        startTransition(()=>{
            // we immediately notify React of the pending promise -- the resolver is attached to the action node
            // and will be called when the associated action promise resolves
            setState(deferredPromise);
        });
    }
    const newAction = {
        payload,
        next: null,
        resolve: resolvers.resolve,
        reject: resolvers.reject
    };
    // Check if the queue is empty
    if (actionQueue.pending === null) {
        // The queue is empty, so add the action and start it immediately
        // Mark this action as the last in the queue
        actionQueue.last = newAction;
        runAction({
            actionQueue,
            action: newAction,
            setState
        });
    } else if (payload.type === ACTION_NAVIGATE || payload.type === ACTION_RESTORE) {
        // Navigations (including back/forward) take priority over any pending actions.
        // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.
        actionQueue.pending.discarded = true;
        // Mark this action as the last in the queue
        actionQueue.last = newAction;
        // if the pending action was a server action, mark the queue as needing a refresh once events are processed
        if (actionQueue.pending.payload.type === ACTION_SERVER_ACTION) {
            actionQueue.needsRefresh = true;
        }
        runAction({
            actionQueue,
            action: newAction,
            setState
        });
    } else {
        // The queue is not empty, so add the action to the end of the queue
        // It will be started by runRemainingActions after the previous action finishes
        if (actionQueue.last !== null) {
            actionQueue.last.next = newAction;
        }
        actionQueue.last = newAction;
    }
}
function createMutableActionQueue() {
    const actionQueue = {
        state: null,
        dispatch: (payload, setState)=>dispatchAction(actionQueue, payload, setState),
        action: async (state, action)=>{
            if (state === null) {
                throw new Error("Invariant: Router state not initialized");
            }
            const result = reducer(state, action);
            return result;
        },
        pending: null,
        last: null
    };
    return actionQueue;
} //# sourceMappingURL=action-queue.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/use-reducer-with-devtools.js




function normalizeRouterState(val) {
    if (val instanceof Map) {
        const obj = {};
        for (const [key, value] of val.entries()){
            if (typeof value === "function") {
                obj[key] = "fn()";
                continue;
            }
            if (typeof value === "object" && value !== null) {
                if (value.$$typeof) {
                    obj[key] = value.$$typeof.toString();
                    continue;
                }
                if (value._bundlerConfig) {
                    obj[key] = "FlightData";
                    continue;
                }
            }
            obj[key] = normalizeRouterState(value);
        }
        return obj;
    }
    if (typeof val === "object" && val !== null) {
        const obj = {};
        for(const key in val){
            const value = val[key];
            if (typeof value === "function") {
                obj[key] = "fn()";
                continue;
            }
            if (typeof value === "object" && value !== null) {
                if (value.$$typeof) {
                    obj[key] = value.$$typeof.toString();
                    continue;
                }
                if (value.hasOwnProperty("_bundlerConfig")) {
                    obj[key] = "FlightData";
                    continue;
                }
            }
            obj[key] = normalizeRouterState(value);
        }
        return obj;
    }
    if (Array.isArray(val)) {
        return val.map(normalizeRouterState);
    }
    return val;
}
function useUnwrapState(state) {
    // reducer actions can be async, so sometimes we need to suspend until the state is resolved
    if ((0,router_reducer_types/* isThenable */.J8)(state)) {
        const result = (0,react.use)(state);
        return result;
    }
    return state;
}
function useReducerWithReduxDevtoolsNoop(initialState) {
    return [
        initialState,
        ()=>{},
        ()=>{}
    ];
}
function useReducerWithReduxDevtoolsImpl(initialState) {
    const [state, setState] = React.useState(initialState);
    const actionQueue = useContext(ActionQueueContext);
    if (!actionQueue) {
        throw new Error("Invariant: Missing ActionQueueContext");
    }
    const devtoolsConnectionRef = useRef();
    const enabledRef = useRef();
    null;
    const dispatch = useCallback((action)=>{
        if (!actionQueue.state) {
            // we lazy initialize the mutable action queue state since the data needed
            // to generate the state is not available when the actionQueue context is created
            actionQueue.state = initialState;
        }
        actionQueue.dispatch(action, setState);
    }, [
        actionQueue,
        initialState
    ]);
    // Sync is called after a state update in the HistoryUpdater,
    // for debugging purposes. Since the reducer state may be a Promise,
    // we let the app router use() it and sync on the resolved value if
    // something changed.
    // Using the `state` here would be referentially unstable and cause
    // undesirable re-renders and history updates.
    const sync = useCallback((resolvedState)=>{
        if (devtoolsConnectionRef.current) {
            devtoolsConnectionRef.current.send({
                type: "RENDER_SYNC"
            }, normalizeRouterState(resolvedState));
        }
    }, []);
    return [
        state,
        dispatch,
        sync
    ];
}
const useReducerWithReduxDevtools =  false ? 0 : useReducerWithReduxDevtoolsNoop; //# sourceMappingURL=use-reducer-with-devtools.js.map

// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/error-boundary.js + 1 modules
var error_boundary = __webpack_require__(6120);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/future/helpers/interception-routes.js
var interception_routes = __webpack_require__(117);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/compute-changed-path.js



const removeLeadingSlash = (segment)=>{
    return segment[0] === "/" ? segment.slice(1) : segment;
};
const segmentToPathname = (segment)=>{
    if (typeof segment === "string") {
        // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page
        // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.
        if (segment === "children") return "";
        return segment;
    }
    return segment[1];
};
function normalizeSegments(segments) {
    return segments.reduce((acc, segment)=>{
        segment = removeLeadingSlash(segment);
        if (segment === "" || (0,lib_segment/* isGroupSegment */.lv)(segment)) {
            return acc;
        }
        return acc + "/" + segment;
    }, "") || "/";
}
function compute_changed_path_extractPathFromFlightRouterState(flightRouterState) {
    const segment = Array.isArray(flightRouterState[0]) ? flightRouterState[0][1] : flightRouterState[0];
    if (segment === lib_segment/* DEFAULT_SEGMENT_KEY */.av || interception_routes/* INTERCEPTION_ROUTE_MARKERS */.Wz.some((m)=>segment.startsWith(m))) return undefined;
    if (segment.startsWith(lib_segment/* PAGE_SEGMENT_KEY */.GC)) return "";
    const segments = [
        segmentToPathname(segment)
    ];
    var _flightRouterState_;
    const parallelRoutes = (_flightRouterState_ = flightRouterState[1]) != null ? _flightRouterState_ : {};
    const childrenPath = parallelRoutes.children ? compute_changed_path_extractPathFromFlightRouterState(parallelRoutes.children) : undefined;
    if (childrenPath !== undefined) {
        segments.push(childrenPath);
    } else {
        for (const [key, value] of Object.entries(parallelRoutes)){
            if (key === "children") continue;
            const childPath = compute_changed_path_extractPathFromFlightRouterState(value);
            if (childPath !== undefined) {
                segments.push(childPath);
            }
        }
    }
    return normalizeSegments(segments);
}
function computeChangedPathImpl(treeA, treeB) {
    const [segmentA, parallelRoutesA] = treeA;
    const [segmentB, parallelRoutesB] = treeB;
    const normalizedSegmentA = segmentToPathname(segmentA);
    const normalizedSegmentB = segmentToPathname(segmentB);
    if (INTERCEPTION_ROUTE_MARKERS.some((m)=>normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m))) {
        return "";
    }
    if (!matchSegment(segmentA, segmentB)) {
        var _extractPathFromFlightRouterState;
        // once we find where the tree changed, we compute the rest of the path by traversing the tree
        return (_extractPathFromFlightRouterState = compute_changed_path_extractPathFromFlightRouterState(treeB)) != null ? _extractPathFromFlightRouterState : "";
    }
    for(const parallelRouterKey in parallelRoutesA){
        if (parallelRoutesB[parallelRouterKey]) {
            const changedPath = computeChangedPathImpl(parallelRoutesA[parallelRouterKey], parallelRoutesB[parallelRouterKey]);
            if (changedPath !== null) {
                return segmentToPathname(segmentB) + "/" + changedPath;
            }
        }
    }
    return null;
}
function computeChangedPath(treeA, treeB) {
    const changedPath = computeChangedPathImpl(treeA, treeB);
    if (changedPath == null || changedPath === "/") {
        return changedPath;
    }
    // lightweight normalization to remove route groups
    return normalizeSegments(changedPath.split("/"));
} //# sourceMappingURL=compute-changed-path.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/create-initial-router-state.js






function createInitialRouterState(param) {
    let { buildId, initialTree, initialSeedData, initialCanonicalUrl, initialParallelRoutes, location, initialHead, couldBeIntercepted } = param;
    const isServer = !location;
    const rsc = initialSeedData[2];
    const cache = {
        lazyData: null,
        rsc: rsc,
        prefetchRsc: null,
        head: null,
        prefetchHead: null,
        // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.
        parallelRoutes: isServer ? new Map() : initialParallelRoutes,
        lazyDataResolved: false,
        loading: initialSeedData[3]
    };
    const canonicalUrl = // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.
    location ? create_href_from_url_createHrefFromUrl(location) : initialCanonicalUrl;
    refetch_inactive_parallel_segments_addRefreshMarkerToActiveParallelSegments(initialTree, canonicalUrl);
    const prefetchCache = new Map();
    // When the cache hasn't been seeded yet we fill the cache with the head.
    if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {
        fill_lazy_items_till_leaf_with_head_fillLazyItemsTillLeafWithHead(cache, undefined, initialTree, initialSeedData, initialHead);
    }
    var _ref;
    const initialState = {
        buildId,
        tree: initialTree,
        cache,
        prefetchCache,
        pushRef: {
            pendingPush: false,
            mpaNavigation: false,
            // First render needs to preserve the previous window.history.state
            // to avoid it being overwritten on navigation back/forward with MPA Navigation.
            preserveCustomHistoryState: true
        },
        focusAndScrollRef: {
            apply: false,
            onlyHashChange: false,
            hashFragment: null,
            segmentPaths: []
        },
        canonicalUrl,
        nextUrl: (_ref = compute_changed_path_extractPathFromFlightRouterState(initialTree) || (location == null ? void 0 : location.pathname)) != null ? _ref : null
    };
    if (location) {
        // Seed the prefetch cache with this page's data.
        // This is to prevent needlessly re-prefetching a page that is already reusable,
        // and will avoid triggering a loading state/data fetch stall when navigating back to the page.
        const url = new URL("" + location.pathname + location.search, location.origin);
        const initialFlightData = [
            [
                "",
                initialTree,
                null,
                null
            ]
        ];
        createPrefetchCacheEntryForInitialLoad({
            url,
            kind: router_reducer_types/* PrefetchKind */.Ke.AUTO,
            data: [
                initialFlightData,
                undefined,
                false,
                couldBeIntercepted
            ],
            tree: initialState.tree,
            prefetchCache: initialState.prefetchCache,
            nextUrl: initialState.nextUrl
        });
    }
    return initialState;
} //# sourceMappingURL=create-initial-router-state.js.map

// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/is-bot.js
var is_bot = __webpack_require__(5524);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/add-path-prefix.js
var add_path_prefix = __webpack_require__(7253);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/remove-trailing-slash.js
var remove_trailing_slash = __webpack_require__(1496);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/parse-path.js
var parse_path = __webpack_require__(6540);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/normalize-trailing-slash.js


/**
 * Normalizes the trailing slash of a path according to the `trailingSlash` option
 * in `next.config.js`.
 */ const normalizePathTrailingSlash = (path)=>{
    if (!path.startsWith("/") || undefined) {
        return path;
    }
    const { pathname, query, hash } = (0,parse_path/* parsePath */.c)(path);
    if (false) {}
    return "" + (0,remove_trailing_slash/* removeTrailingSlash */.Q)(pathname) + query + hash;
}; //# sourceMappingURL=normalize-trailing-slash.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/add-base-path.js


const basePath =  false || "";
function add_base_path_addBasePath(path, required) {
    return normalizePathTrailingSlash( false ? 0 : (0,add_path_prefix/* addPathPrefix */.V)(path, basePath));
} //# sourceMappingURL=add-base-path.js.map

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react-dom/server-rendering-stub.js
var server_rendering_stub = __webpack_require__(8754);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/app-router-announcer.js


const ANNOUNCER_TYPE = "next-route-announcer";
const ANNOUNCER_ID = "__next-route-announcer__";
function getAnnouncerNode() {
    var _existingAnnouncer_shadowRoot;
    const existingAnnouncer = document.getElementsByName(ANNOUNCER_TYPE)[0];
    if (existingAnnouncer == null ? void 0 : (_existingAnnouncer_shadowRoot = existingAnnouncer.shadowRoot) == null ? void 0 : _existingAnnouncer_shadowRoot.childNodes[0]) {
        return existingAnnouncer.shadowRoot.childNodes[0];
    } else {
        const container = document.createElement(ANNOUNCER_TYPE);
        container.style.cssText = "position:absolute";
        const announcer = document.createElement("div");
        announcer.ariaLive = "assertive";
        announcer.id = ANNOUNCER_ID;
        announcer.role = "alert";
        announcer.style.cssText = "position:absolute;border:0;height:1px;margin:-1px;padding:0;width:1px;clip:rect(0 0 0 0);overflow:hidden;white-space:nowrap;word-wrap:normal";
        // Use shadow DOM here to avoid any potential CSS bleed
        const shadow = container.attachShadow({
            mode: "open"
        });
        shadow.appendChild(announcer);
        document.body.appendChild(container);
        return announcer;
    }
}
function AppRouterAnnouncer(param) {
    let { tree } = param;
    const [portalNode, setPortalNode] = (0,react.useState)(null);
    null;
    const [routeAnnouncement, setRouteAnnouncement] = (0,react.useState)("");
    const previousTitle = (0,react.useRef)();
    null;
    return portalNode ? /*#__PURE__*/ (0,server_rendering_stub.createPortal)(routeAnnouncement, portalNode) : null;
} //# sourceMappingURL=app-router-announcer.js.map

// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/redirect-boundary.js
var redirect_boundary = __webpack_require__(7017);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/find-head-in-cache.js

function findHeadInCache(cache, parallelRoutes) {
    return findHeadInCacheImpl(cache, parallelRoutes, "");
}
function findHeadInCacheImpl(cache, parallelRoutes, keyPrefix) {
    const isLastItem = Object.keys(parallelRoutes).length === 0;
    if (isLastItem) {
        // Returns the entire Cache Node of the segment whose head we will render.
        return [
            cache,
            keyPrefix
        ];
    }
    for(const key in parallelRoutes){
        const [segment, childParallelRoutes] = parallelRoutes[key];
        const childSegmentMap = cache.parallelRoutes.get(key);
        if (!childSegmentMap) {
            continue;
        }
        const cacheKey = (0,create_router_cache_key/* createRouterCacheKey */.d)(segment);
        const cacheNode = childSegmentMap.get(cacheKey);
        if (!cacheNode) {
            continue;
        }
        const item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + "/" + cacheKey);
        if (item) {
            return item;
        }
    }
    return null;
} //# sourceMappingURL=find-head-in-cache.js.map

// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/unresolved-thenable.js
var unresolved_thenable = __webpack_require__(3654);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/remove-base-path.js

const remove_base_path_basePath =  false || "";
function removeBasePath(path) {
    if (false) {}
    // Can't trim the basePath if it has zero length!
    if (remove_base_path_basePath.length === 0) return path;
    path = path.slice(remove_base_path_basePath.length);
    if (!path.startsWith("/")) path = "/" + path;
    return path;
} //# sourceMappingURL=remove-base-path.js.map

// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/path-has-prefix.js
var path_has_prefix = __webpack_require__(8506);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/has-base-path.js

const has_base_path_basePath =  false || "";
function hasBasePath(path) {
    return (0,path_has_prefix/* pathHasPrefix */.Y)(path, has_base_path_basePath);
} //# sourceMappingURL=has-base-path.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/app-router.js
/* __next_internal_client_entry_do_not_use__ getServerActionDispatcher,urlToUrlWithoutFlightMarker,createEmptyCacheNode,default auto */ 


















const isServer = "undefined" === "undefined";
// Ensure the initialParallelRoutes are not combined because of double-rendering in the browser with Strict Mode.
let initialParallelRoutes = isServer ? null : new Map();
let globalServerActionDispatcher = null;
function getServerActionDispatcher() {
    return globalServerActionDispatcher;
}
const globalMutable = {};
function urlToUrlWithoutFlightMarker(url) {
    const urlWithoutFlightParameters = new URL(url, location.origin);
    urlWithoutFlightParameters.searchParams.delete(app_router_headers/* NEXT_RSC_UNION_QUERY */.H4);
    if (true) {
        if (false) {}
    }
    return urlWithoutFlightParameters;
}
// this function performs a depth-first search of the tree to find the selected
// params
function getSelectedParams(currentTree, params) {
    if (params === void 0) params = {};
    const parallelRoutes = currentTree[1];
    for (const parallelRoute of Object.values(parallelRoutes)){
        const segment = parallelRoute[0];
        const isDynamicParameter = Array.isArray(segment);
        const segmentValue = isDynamicParameter ? segment[1] : segment;
        if (!segmentValue || segmentValue.startsWith(lib_segment/* PAGE_SEGMENT_KEY */.GC)) continue;
        // Ensure catchAll and optional catchall are turned into an array
        const isCatchAll = isDynamicParameter && (segment[2] === "c" || segment[2] === "oc");
        if (isCatchAll) {
            params[segment[0]] = segment[1].split("/");
        } else if (isDynamicParameter) {
            params[segment[0]] = segment[1];
        }
        params = getSelectedParams(parallelRoute, params);
    }
    return params;
}
function isExternalURL(url) {
    return url.origin !== window.location.origin;
}
function HistoryUpdater(param) {
    let { appRouterState, sync } = param;
    (0,react.useInsertionEffect)(()=>{
        const { tree, pushRef, canonicalUrl } = appRouterState;
        const historyState = {
            ...pushRef.preserveCustomHistoryState ? window.history.state : {},
            // Identifier is shortened intentionally.
            // __NA is used to identify if the history entry can be handled by the app-router.
            // __N is used to identify if the history entry can be handled by the old router.
            __NA: true,
            __PRIVATE_NEXTJS_INTERNALS_TREE: tree
        };
        if (pushRef.pendingPush && // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.
        // This mirrors the browser behavior for normal navigation.
        create_href_from_url_createHrefFromUrl(new URL(window.location.href)) !== canonicalUrl) {
            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.
            pushRef.pendingPush = false;
            window.history.pushState(historyState, "", canonicalUrl);
        } else {
            window.history.replaceState(historyState, "", canonicalUrl);
        }
        sync(appRouterState);
    }, [
        appRouterState,
        sync
    ]);
    return null;
}
function app_router_createEmptyCacheNode() {
    return {
        lazyData: null,
        rsc: null,
        prefetchRsc: null,
        head: null,
        prefetchHead: null,
        parallelRoutes: new Map(),
        lazyDataResolved: false,
        loading: null
    };
}
function useServerActionDispatcher(dispatch) {
    const serverActionDispatcher = (0,react.useCallback)((actionPayload)=>{
        (0,react.startTransition)(()=>{
            dispatch({
                ...actionPayload,
                type: router_reducer_types/* ACTION_SERVER_ACTION */.WA
            });
        });
    }, [
        dispatch
    ]);
    globalServerActionDispatcher = serverActionDispatcher;
}
/**
 * Server response that only patches the cache and tree.
 */ function useChangeByServerResponse(dispatch) {
    return (0,react.useCallback)((param)=>{
        let { previousTree, serverResponse } = param;
        (0,react.startTransition)(()=>{
            dispatch({
                type: router_reducer_types/* ACTION_SERVER_PATCH */.n0,
                previousTree,
                serverResponse
            });
        });
    }, [
        dispatch
    ]);
}
function useNavigate(dispatch) {
    return (0,react.useCallback)((href, navigateType, shouldScroll)=>{
        const url = new URL(add_base_path_addBasePath(href), location.href);
        return dispatch({
            type: router_reducer_types/* ACTION_NAVIGATE */.bO,
            url,
            isExternalUrl: isExternalURL(url),
            locationSearch: location.search,
            shouldScroll: shouldScroll != null ? shouldScroll : true,
            navigateType
        });
    }, [
        dispatch
    ]);
}
function copyNextJsInternalHistoryState(data) {
    if (data == null) data = {};
    const currentState = window.history.state;
    const __NA = currentState == null ? void 0 : currentState.__NA;
    if (__NA) {
        data.__NA = __NA;
    }
    const __PRIVATE_NEXTJS_INTERNALS_TREE = currentState == null ? void 0 : currentState.__PRIVATE_NEXTJS_INTERNALS_TREE;
    if (__PRIVATE_NEXTJS_INTERNALS_TREE) {
        data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE;
    }
    return data;
}
function Head(param) {
    let { headCacheNode } = param;
    // If this segment has a `prefetchHead`, it's the statically prefetched data.
    // We should use that on initial render instead of `head`. Then we'll switch
    // to `head` when the dynamic response streams in.
    const head = headCacheNode !== null ? headCacheNode.head : null;
    const prefetchHead = headCacheNode !== null ? headCacheNode.prefetchHead : null;
    // If no prefetch data is available, then we go straight to rendering `head`.
    const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head;
    // We use `useDeferredValue` to handle switching between the prefetched and
    // final values. The second argument is returned on initial render, then it
    // re-renders with the first argument.
    //
    // @ts-expect-error The second argument to `useDeferredValue` is only
    // available in the experimental builds. When its disabled, it will always
    // return `head`.
    return (0,react.useDeferredValue)(head, resolvedPrefetchRsc);
}
/**
 * The global router that wraps the application components.
 */ function Router(param) {
    let { buildId, initialHead, initialTree, initialCanonicalUrl, initialSeedData, couldBeIntercepted, assetPrefix, missingSlots } = param;
    const initialState = (0,react.useMemo)(()=>createInitialRouterState({
            buildId,
            initialSeedData,
            initialCanonicalUrl,
            initialTree,
            initialParallelRoutes,
            location: !isServer ? window.location : null,
            initialHead,
            couldBeIntercepted
        }), [
        buildId,
        initialSeedData,
        initialCanonicalUrl,
        initialTree,
        initialHead,
        couldBeIntercepted
    ]);
    const [reducerState, dispatch, sync] = useReducerWithReduxDevtools(initialState);
    null;
    const { canonicalUrl } = useUnwrapState(reducerState);
    // Add memoized pathname/query for useSearchParams and usePathname.
    const { searchParams, pathname } = (0,react.useMemo)(()=>{
        const url = new URL(canonicalUrl,  true ? "http://n" : 0);
        return {
            // This is turned into a readonly class in `useSearchParams`
            searchParams: url.searchParams,
            pathname: hasBasePath(url.pathname) ? removeBasePath(url.pathname) : url.pathname
        };
    }, [
        canonicalUrl
    ]);
    const changeByServerResponse = useChangeByServerResponse(dispatch);
    const navigate = useNavigate(dispatch);
    useServerActionDispatcher(dispatch);
    /**
   * The app router that is exposed through `useRouter`. It's only concerned with dispatching actions to the reducer, does not hold state.
   */ const appRouter = (0,react.useMemo)(()=>{
        const routerInstance = {
            back: ()=>window.history.back(),
            forward: ()=>window.history.forward(),
            prefetch: (href, options)=>{
                // Don't prefetch for bots as they don't navigate.
                if ((0,is_bot/* isBot */.Q)(window.navigator.userAgent)) {
                    return;
                }
                let url;
                try {
                    url = new URL(add_base_path_addBasePath(href), window.location.href);
                } catch (_) {
                    throw new Error("Cannot prefetch '" + href + "' because it cannot be converted to a URL.");
                }
                // Don't prefetch during development (improves compilation performance)
                if (false) {}
                // External urls can't be prefetched in the same way.
                if (isExternalURL(url)) {
                    return;
                }
                (0,react.startTransition)(()=>{
                    var _options_kind;
                    dispatch({
                        type: router_reducer_types/* ACTION_PREFETCH */.Pm,
                        url,
                        kind: (_options_kind = options == null ? void 0 : options.kind) != null ? _options_kind : router_reducer_types/* PrefetchKind */.Ke.FULL
                    });
                });
            },
            replace: (href, options)=>{
                if (options === void 0) options = {};
                (0,react.startTransition)(()=>{
                    var _options_scroll;
                    navigate(href, "replace", (_options_scroll = options.scroll) != null ? _options_scroll : true);
                });
            },
            push: (href, options)=>{
                if (options === void 0) options = {};
                (0,react.startTransition)(()=>{
                    var _options_scroll;
                    navigate(href, "push", (_options_scroll = options.scroll) != null ? _options_scroll : true);
                });
            },
            refresh: ()=>{
                (0,react.startTransition)(()=>{
                    dispatch({
                        type: router_reducer_types/* ACTION_REFRESH */.HD,
                        origin: window.location.origin
                    });
                });
            },
            fastRefresh: ()=>{
                if (true) {
                    throw new Error("fastRefresh can only be used in development mode. Please use refresh instead.");
                } else {}
            }
        };
        return routerInstance;
    }, [
        dispatch,
        navigate
    ]);
    null;
    if (false) {}
    null;
    // When mpaNavigation flag is set do a hard navigation to the new url.
    // Infinitely suspend because we don't actually want to rerender any child
    // components with the new URL and any entangled state updates shouldn't
    // commit either (eg: useTransition isPending should stay true until the page
    // unloads).
    //
    // This is a side effect in render. Don't try this at home, kids. It's
    // probably safe because we know this is a singleton component and it's never
    // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,
    // but that's... fine?)
    const { pushRef } = useUnwrapState(reducerState);
    if (pushRef.mpaNavigation) {
        // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL
        if (globalMutable.pendingMpaPath !== canonicalUrl) {
            const location1 = window.location;
            if (pushRef.pendingPush) {
                location1.assign(canonicalUrl);
            } else {
                location1.replace(canonicalUrl);
            }
            globalMutable.pendingMpaPath = canonicalUrl;
        }
        // TODO-APP: Should we listen to navigateerror here to catch failed
        // navigations somehow? And should we call window.stop() if a SPA navigation
        // should interrupt an MPA one?
        (0,react.use)(unresolved_thenable/* unresolvedThenable */.c);
    }
    null;
    const { cache, tree, nextUrl, focusAndScrollRef } = useUnwrapState(reducerState);
    const matchingHead = (0,react.useMemo)(()=>{
        return findHeadInCache(cache, tree[1]);
    }, [
        cache,
        tree
    ]);
    // Add memoized pathParams for useParams.
    const pathParams = (0,react.useMemo)(()=>{
        return getSelectedParams(tree);
    }, [
        tree
    ]);
    let head;
    if (matchingHead !== null) {
        // The head is wrapped in an extra component so we can use
        // `useDeferredValue` to swap between the prefetched and final versions of
        // the head. (This is what LayoutRouter does for segment data, too.)
        //
        // The `key` is used to remount the component whenever the head moves to
        // a different segment.
        const [headCacheNode, headKey] = matchingHead;
        head = /*#__PURE__*/ (0,jsx_runtime.jsx)(Head, {
            headCacheNode: headCacheNode
        }, headKey);
    } else {
        head = null;
    }
    let content = /*#__PURE__*/ (0,jsx_runtime.jsxs)(redirect_boundary/* RedirectBoundary */.I, {
        children: [
            head,
            cache.rsc,
            /*#__PURE__*/ (0,jsx_runtime.jsx)(AppRouterAnnouncer, {
                tree: tree
            })
        ]
    });
    if (false) {}
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)(HistoryUpdater, {
                appRouterState: useUnwrapState(reducerState),
                sync: sync
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(hooks_client_context_shared_runtime.PathParamsContext.Provider, {
                value: pathParams,
                children: /*#__PURE__*/ (0,jsx_runtime.jsx)(hooks_client_context_shared_runtime.PathnameContext.Provider, {
                    value: pathname,
                    children: /*#__PURE__*/ (0,jsx_runtime.jsx)(hooks_client_context_shared_runtime.SearchParamsContext.Provider, {
                        value: searchParams,
                        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(app_router_context_shared_runtime.GlobalLayoutRouterContext.Provider, {
                            value: {
                                buildId,
                                changeByServerResponse,
                                tree,
                                focusAndScrollRef,
                                nextUrl
                            },
                            children: /*#__PURE__*/ (0,jsx_runtime.jsx)(app_router_context_shared_runtime.AppRouterContext.Provider, {
                                value: appRouter,
                                children: /*#__PURE__*/ (0,jsx_runtime.jsx)(app_router_context_shared_runtime.LayoutRouterContext.Provider, {
                                    value: {
                                        childNodes: cache.parallelRoutes,
                                        tree,
                                        // Root node always has `url`
                                        // Provided in AppTreeContext to ensure it can be overwritten in layout-router
                                        url: canonicalUrl,
                                        loading: cache.loading
                                    },
                                    children: content
                                })
                            })
                        })
                    })
                })
            })
        ]
    });
}
function AppRouter(props) {
    const { globalErrorComponent, ...rest } = props;
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(error_boundary.ErrorBoundary, {
        errorComponent: globalErrorComponent,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(Router, {
            ...rest
        })
    });
} //# sourceMappingURL=app-router.js.map


/***/ })áùÿÿäùÿÿëùÿÿx±í  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`Òwebpack://../../../../src/client/components/router-reducer/create-href-from-url.tsáwebpack://../../../../src/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.tsÞwebpack://../../../../src/client/components/router-reducer/fill-cache-with-new-subtree-data.tsÏwebpack://../../../../src/client/components/router-reducer/apply-flight-data.tsàwebpack://../../../../src/client/components/router-reducer/refetch-inactive-parallel-segments.tsÞwebpack://../../../../src/client/components/router-reducer/apply-router-state-patch-to-tree.ts  webpack://javascript/esm|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/@swc/helpers/esm/_class_private_field_loose_base.js|ssr  webpack://javascript/esm|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/@swc/helpers/esm/_class_private_field_loose_key.js|ssr¹webpack://../../../src/client/components/promise-queue.tsÒwebpack://../../../../src/client/components/router-reducer/prefetch-cache-utils.tsÚwebpack://../../../../../src/client/components/router-reducer/reducers/prefetch-reducer.tsÍwebpack://../../../../src/client/components/router-reducer/ppr-navigations.tsÚwebpack://../../../../../src/client/components/router-reducer/reducers/navigate-reducer.tsÕwebpack://../../../../src/client/components/router-reducer/handle-segment-mismatch.tsÞwebpack://../../../../../src/client/components/router-reducer/reducers/server-patch-reducer.tsÙwebpack://../../../../../src/client/components/router-reducer/reducers/restore-reducer.tsÙwebpack://../../../../../src/client/components/router-reducer/reducers/refresh-reducer.tsÞwebpack://../../../../../src/client/components/router-reducer/reducers/fast-refresh-reducer.tsßwebpack://../../../../../src/client/components/router-reducer/reducers/server-action-reducer.tsÌwebpack://../../../../src/client/components/router-reducer/router-reducer.ts»webpack://../../../../src/shared/lib/router/action-queue.tsÅwebpack://../../../src/client/components/use-reducer-with-devtools.tsÒwebpack://../../../../src/client/components/router-reducer/compute-changed-path.tsÙwebpack://../../../../src/client/components/router-reducer/create-initial-router-state.ts¶webpack://../../src/client/normalize-trailing-slash.ts«webpack://../../src/client/add-base-path.tsÁwebpack://../../../src/client/components/app-router-announcer.tsxÜwebpack://../../../../../src/client/components/router-reducer/reducers/find-head-in-cache.ts®webpack://../../src/client/remove-base-path.ts«webpack://../../src/client/has-base-path.tslúÿÿ-  export function _class_private_field_loose_base(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
        throw new TypeError("attempted to use private field on non-instance");
    }

    return receiver;
}
export { _class_private_field_loose_base as _ };
£   var id = 0;

export function _class_private_field_loose_key(name) {
    return "__private_" + id++ + "_" + name;
}
export { _class_private_field_loose_key as _ };
@j  ‘createHrefFromUrlÞúÿÿ‹includeHashFûÿÿ¥ûÿÿ¹ùÿÿ”createRouterCacheKey˜PrefetchCacheEntryStatusfillLazyItemsTillLeafWithHeadˆnewCacheexistingCache‹routerState‘cacheNodeSeedData„headprefetchEntryisLastSegmentûÿÿûÿÿîúÿÿ@ûÿÿ’parallelRouteState—segmentForParallelRouteˆcacheKeyparallelSeedDatalûÿÿŸexistingParallelRoutesCacheNodeŽparallelRoutesÞûÿÿ“hasReusablePrefetch„kind¤þÿÿˆreusable–parallelRouteCacheNodeéûÿÿ‘existingCacheNodeŒnewCacheNodeˆseedNode‡loadingˆlazyDataƒrsc‹prefetchRscŒprefetchHeadlazyDataResolved|ûÿÿ–existingParallelRoutesœinvalidateCacheByRouterState›fillCacheWithNewSubTreeDataŽflightDataPath‹isLastEntryparallelRouteKeyûÿÿ—existingChildSegmentMapchildSegmentMap–existingChildCacheNodeŽchildCacheNodeˆseedDataÝúÿÿapplyFlightData…cache‰treePatch“fetchServerResponsePAGE_SEGMENT_KEYŸrefreshInactiveParallelSegmentsûÿÿfetchedSegments¢þÿÿ£refreshInactiveParallelSegmentsImplˆrootTree‹updatedTree"ûÿÿ…stateŒupdatedCacheŽincludeNextUrlŒcanonicalUrl‹refetchPathrefetchMarkerfetchPromises|ûÿÿƒaddŒfetchPromise¥úÿÿ¹úÿÿ§úÿÿ‡nextUrl‡buildIdxþÿÿfetchResponseŠflightDataRûÿÿ”parallelFetchPromise{þÿÿ|þÿÿ¨addRefreshMarkerToActiveParallelSegments„treeïúÿÿûÿÿ“DEFAULT_SEGMENT_KEYŒmatchSegmentŠapplyPatch‹initialTree‰patchTree‘flightSegmentPathŽinitialSegment•initialParallelRoutesŒpatchSegment“patchParallelRoutes‘newParallelRoutes›isInPatchTreeParallelRoutes›applyRouterStatePatchToTree‘flightRouterState‡refetchŒisRootLayoutŽcurrentSegment‹lastSegment’parallelRoutePatch_Ÿ_class_private_field_loose_base_maxConcurrencyž_class_private_field_loose_key_runningCount†_queueŒ_processNextŒPromiseQueue‡enqueue‰promiseFn‹taskResolveŠtaskReject‹taskPromiseyþÿÿRÿÿÿ„taskŒrunningCountˆúÿÿÀúÿÿ‹processNextenqueueResult…queue„bump…index‰findIndex.ûÿÿŠbumpedItem€ûÿÿ‰ûÿÿ³úÿÿŽmaxConcurrencyŽdefineProperty†forced¬_class_private_field_loose_base__queue_shift…shiftŒPrefetchKindprefetchQueue–createPrefetchCacheKeypathnameFromUrlgetOrCreatePrefetchCacheEntryprefetchCache’existingCacheEntry”interceptionCacheKeyinterceptionDataprefetchCacheKeyŒprefetchData›getPrefetchEntryCacheStatus–switchedToFullPrefetch„FULL—createLazyPrefetchEntry‰TEMPORARY‹úÿÿ„AUTO prefixExistingPrefetchCacheEntryexistingCacheKey‹newCacheKeyûÿÿ¦createPrefetchCacheEntryForInitialLoadSþÿÿ‰intercept”treeAtTimeOfPrefetchŒprefetchTimeKþÿÿƒnowŒlastUsedTime…freshprefetchResponse‹intercepted’prunePrefetchCacheiúÿÿ’prefetchCacheEntry‡expired”DYNAMIC_STALETIME_MS=þÿÿuûÿÿ¦__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME“STATIC_STALETIME_MS¥__NEXT_CLIENT_ROUTER_STATIC_STALETIME…staleûÿÿprefetchReducer†actionöúÿÿ›updateCacheNodeOnNavigationŒoldCacheNodeŽoldRouterStateŽnewRouterState–oldRouterStateChildren–newRouterStateChildren”prefetchDataChildren‘oldParallelRoutes–prefetchParallelRoutesšpatchedRouterStateChildrenŒtaskChildren“newRouterStateChild“oldRouterStateChild’oldSegmentMapChild‘prefetchDataChildnewSegmentChild’newSegmentKeyChildoldSegmentChild‘oldCacheNodeChild‰taskChildspawnPendingTaskspawnReusedTask—spawnTaskForMissingData‘newCacheNodeChild„node’newSegmentMapChild{úÿÿŸpatchRouterStateWithNewChildren7ûÿÿbaseRouterState‹newChildren…clonependingCacheNode–createPendingCacheNode‘reusedRouterState—listenForDynamicRequestresponsePromiseˆresponse‹segmentPath‘serverRouterState‹dynamicData‹dynamicHeadŸwriteDynamicDataIntoPendingTask‰abortTaskˆrootTaski‹taskSegment¡finishTaskUsingDynamicDataPayloadˆtaskNode–finishPendingCacheNodeŽserverChildren“dynamicDataChildren–serverRouterStateChilddynamicDataChild“routerStateChildrenrouterStateChildŒsegmentChildsegmentKeyChildisLeafSegmentéøÿÿmaybePrefetchRsc”maybePrefetchLoading‘createDeferredRsc‰cacheNode‰taskState‹serverState‘taskStateChildren“serverStateChildrenŒdataChildrenŽtaskStateChildserverStateChild‰dataChildsegmentMapChildtaskSegmentChild“taskSegmentKeyChildŽcacheNodeChild•abortPendingCacheNode’dynamicSegmentDataisDeferredRsc†values¤updateCacheNodeOnPopstateRestoration‘shouldUsePrefetchˆDEFERREDßýÿÿ©úÿÿƒtagŠpendingRscúÿÿƒrejŒfulfilledRsc‹rejectedRscÍýÿÿ¥invalidateCacheBelowFlightSegmentPath’shouldHardNavigate›isNavigatingToNewRootLayouthandleMutable”createEmptyCacheNode clearCacheNodeDataForSegmentPath‘handleExternalUrl‡mutable‹pendingPushmpaNavigation’scrollableSegments™generateSegmentsFromPatch‘flightRouterPatchbúÿÿparallelRoutežúÿÿŒchildSegmentŸtriggerLazyFetchForLeafSegmentsŒcurrentCacheŒappliedPatch’segmentPathsToFillÀøÿÿŒsegmentPathsnavigateReducerŠ__NEXT_PPR“navigateReducer_PPR•navigateReducer_noPPRisExternalUrlŒnavigateTypeŒshouldScrollšpreserveCustomHistoryStateßùÿÿŽprefetchValues”canonicalUrlOverride‹isFirstReadˆdocumentŽgetElementById‹currentTree¡flightSegmentPathWithLeadingEmpty‡newTree‡appliedŒhardNavigateŠsubSegment•scrollableSegmentPath‹patchedTreeŒhashFragmentŠ_postponedŽprefetchedTree’patchedRouterState•handleSegmentMismatchûùÿÿüùÿÿ¡úÿÿúÿÿúÿÿ’serverPatchReducerŽserverResponse”overrideCanonicalUrl‡pushRef˜canonicalUrlOverrideHref extractPathFromFlightRouterStateŽrestoreReducertreeToRestoreˆoldCache‘focusAndScrollRef¡hasInterceptionRouteInCurrentTreeŽrefreshReducerƒlog–fastRefreshReducerImpl–fastRefreshReducerNoop‡_action’fastRefreshReducer†þÿÿþÿÿžþÿÿ þÿÿ¡þÿÿîýÿÿòýÿÿÝúÿÿßúÿÿ‹addBasePath‘fetchServerAction…þÿÿ†þÿÿíýÿÿ…fetchíùÿÿúÿÿ†Acceptúÿÿ’NEXT_DEPLOYMENT_IDrevalidatedParts‘revalidatedHeaderµýÿÿ…paths†cookieeredirectLocationÀùÿÿisFlightResponseactionFlightDataŒactionResult“serverActionReducer”inFlightServerAction‡newHrefªúÿÿACTION_NAVIGATE“ACTION_SERVER_PATCHŽACTION_RESTOREŽACTION_REFRESHACTION_PREFETCH“ACTION_FAST_REFRESH”ACTION_SERVER_ACTIONclientReducerÍùÿÿserverReducer‡reducerŠisThenable…ReactstartTransition’ActionQueueContextcreateContext“runRemainingActions‹actionQueueˆsetState‡pending„next‰runActionŒneedsRefreshˆdispatch‰prevState‡payloadŒhandleResult‰nextState‰discardeddevToolsInstance„send‚úÿÿŽdispatchAction‰resolversdeferredPromise‰newAction„last˜createMutableActionQueueƒuseŠuseContext†useRef‰useEffect‹useCallback”normalizeRouterStateƒvalƒobjŒýÿÿ“ýÿÿyúÿÿ*úÿÿ+úÿÿŽuseUnwrapStateŸuseReducerWithReduxDevtoolsNoopŒinitialStateŸuseReducerWithReduxDevtoolsImplˆuseState•devtoolsConnectionRefŠenabledRef„syncresolvedStatePýÿÿ›useReducerWithReduxDevtoolsàùÿÿŽisGroupSegment’removeLeadingSlash‘segmentToPathname‘normalizeSegments|úÿÿƒaccúÿÿmÀùÿÿŒchildrenPath‰childPath–computeChangedPathImpl…treeA…treeBˆsegmentAparallelRoutesAˆsegmentBparallelRoutesB’normalizedSegmentA’normalizedSegmentB‘parallelRouterKey‹changedPath’computeChangedPathùÿÿ˜createInitialRouterStateinitialSeedData“initialCanonicalUrl‹initialHead’couldBeInterceptedˆisServerWýÿÿŽonlyHashChange‘initialFlightDataÆùÿÿ‰parsePathšnormalizePathTrailingSlashœ__NEXT_MANUAL_TRAILING_SLASH úÿÿ•__NEXT_TRAILING_SLASHaùÿÿÈùÿÿaddPathPrefixˆbasePath–__NEXT_ROUTER_BASEPATHˆrequiredž__NEXT_MANUAL_CLIENT_BASE_PATHŒcreatePortalŽANNOUNCER_TYPEŒANNOUNCER_IDgetAnnouncerNode‘existingAnnouncer‘getElementsByNameŠshadowRootŠchildNodes‰containercreateElement…style‡cssText‰announcerˆariaLiveýÿÿ„role†shadowŒattachShadow„mode‹appendChild’AppRouterAnnouncerŠportalNodesetPortalNode‘routeAnnouncement”setRouteAnnouncementpreviousTitlefindHeadInCache“findHeadInCacheImplÀùÿÿŠisLastItem“childParallelRoutes‹hasBasePathŽremoveBasePathpathHasPrefix…_jsxs‡useMemo’useInsertionEffectAppRouterContext“LayoutRouterContext™GlobalLayoutRouterContext’MissingSlotContext“SearchParamsContextPathnameContextErrorBoundary…isBotRedirectBoundary’unresolvedThenableœglobalServerActionDispatcheríýÿÿglobalMutable›urlToUrlWithoutFlightMarkeršurlWithoutFlightParameters”__NEXT_CONFIG_OUTPUT‘getSelectedParamsùÿÿ’isDynamicParameterŒsegmentValue.úÿÿisExternalURLŽHistoryUpdaterŒhistoryStateŽappRouterState‡history„__NAŸ__PRIVATE_NEXTJS_INTERNALS_TREE‰pushStateŒreplaceState™useServerActionDispatcheractionPayload–serverActionDispatcherŒpreviousTree‹useNavigateŽlocationSearchŒcurrentState„HeadheadCacheNode“resolvedPrefetchRscuseDeferredValue‹assetPrefixŒmissingSlotsŒreducerStateˆnavigate‰appRouterŽrouterInstance„back‡forwardˆprefetch‰navigator‰userAgent_options_kindþøÿÿ_options_scroll†scroll‡refresh‹fastRefresh‰location1­ùÿÿŽpendingMpaPathŒmatchingHeadŠpathParams‡headKey—DevRootNotFoundBoundary‡content„_jsxˆProvider‹HotReloader–changeByServerResponse”globalErrorComponentùÿÿ„restŽerrorComponent†Router@Ü   Ñ÷ÿÿ2úÿÿÑ÷ÿÿ0  // ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  createEmptyCacheNode: () => (/* binding */ app_router_createEmptyCacheNode),
  "default": () => (/* binding */ AppRouter),
  getServerActionDispatcher: () => (/* binding */ getServerActionDispatcher),
  urlToUrlWithoutFlightMarker: () => (/* binding */ urlToUrlWithoutFlightMarker)
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5486);
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__(2428);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/app-router-context.shared-runtime.js
var app_router_context_shared_runtime = __webpack_require__(6099);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/router-reducer-types.js
var router_reducer_types = __webpack_require__(2642);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/create-href-from-url.js
3úÿÿ<úÿÿã   export function createHrefFromUrl(url, includeHash) {
    if (includeHash === void 0) includeHash = true;
    return url.pathname + url.search + (includeHash ? url.hash : "");
} //# sourceMappingURL=create-href-from-url.js.map
x  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/create-href-from-url.ts"],"names":["createHrefFromUrl","url","includeHash","pathname","search","hash"],"mappings":"AAAA,OAAO,SAASA,kBACdC,GAA8C,EAC9CC,WAA2B;IAA3BA,IAAAA,gBAAAA,KAAAA,GAAAA,cAAuB;IAEvB,OAAOD,IAAIE,QAAQ,GAAGF,IAAIG,MAAM,GAAIF,CAAAA,cAAcD,IAAII,IAAI,GAAG,EAAA;AAC/D","file":"x"}   false06undefined;   925create_href_from_url_createHrefFromUrlundefinedRawSourcel  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/hooks-client-context.shared-runtime.js
var hooks_client_context_shared_runtime = __webpack_require__(498);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/fetch-server-response.js
var fetch_server_response = __webpack_require__(10);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/create-router-cache-key.js
var create_router_cache_key = __webpack_require__(2505);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js
.úÿÿ7úÿÿ   import { createRouterCacheKey } from "./create-router-cache-key";
import { PrefetchCacheEntryStatus } from "./router-reducer-types";
export function fillLazyItemsTillLeafWithHead(newCache, existingCache, routerState, cacheNodeSeedData, head, prefetchEntry) {
    const isLastSegment = Object.keys(routerState[1]).length === 0;
    if (isLastSegment) {
        newCache.head = head;
        return;
    }
    // Remove segment that we got data for so that it is filled in during rendering of rsc.
    for(const key in routerState[1]){
        const parallelRouteState = routerState[1][key];
        const segmentForParallelRoute = parallelRouteState[0];
        const cacheKey = createRouterCacheKey(segmentForParallelRoute);
        // TODO: We should traverse the cacheNodeSeedData tree instead of the router
        // state tree. Ideally, they would always be the same shape, but because of
        // the loading.js pattern, cacheNodeSeedData sometimes only represents a
        // partial tree. That's why this node is sometimes null. Once PPR lands,
        // loading.js will no longer have special behavior and we can traverse the
        // data tree instead.
        //
        // We should also consider merging the router state tree and the data tree
        // in the response format, so that we don't have to send the keys twice.
        // Then the client can convert them into separate representations.
        const parallelSeedData = cacheNodeSeedData !== null && cacheNodeSeedData[1][key] !== undefined ? cacheNodeSeedData[1][key] : null;
        if (existingCache) {
            const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);
            if (existingParallelRoutesCacheNode) {
                const hasReusablePrefetch = (prefetchEntry == null ? void 0 : prefetchEntry.kind) === "auto" && prefetchEntry.status === PrefetchCacheEntryStatus.reusable;
                let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);
                const existingCacheNode = parallelRouteCacheNode.get(cacheKey);
                let newCacheNode;
                if (parallelSeedData !== null) {
                    // New data was sent from the server.
                    const seedNode = parallelSeedData[2];
                    const loading = parallelSeedData[3];
                    newCacheNode = {
                        lazyData: null,
                        rsc: seedNode,
                        // This is a PPR-only field. When PPR is enabled, we shouldn't hit
                        // this path during a navigation, but until PPR is fully implemented
                        // yet it's possible the existing node does have a non-null
                        // `prefetchRsc`. As an incremental step, we'll just de-opt to the
                        // old behavior â€” no PPR value.
                        prefetchRsc: null,
                        head: null,
                        prefetchHead: null,
                        loading,
                        parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes),
                        lazyDataResolved: false
                    };
                } else if (hasReusablePrefetch && existingCacheNode) {
                    // No new data was sent from the server, but the existing cache node
                    // was prefetched, so we should reuse that.
                    newCacheNode = {
                        lazyData: existingCacheNode.lazyData,
                        rsc: existingCacheNode.rsc,
                        // This is a PPR-only field. Unlike the previous branch, since we're
                        // just cloning the existing cache node, we might as well keep the
                        // PPR value, if it exists.
                        prefetchRsc: existingCacheNode.prefetchRsc,
                        head: existingCacheNode.head,
                        prefetchHead: existingCacheNode.prefetchHead,
                        parallelRoutes: new Map(existingCacheNode.parallelRoutes),
                        lazyDataResolved: existingCacheNode.lazyDataResolved,
                        loading: existingCacheNode.loading
                    };
                } else {
                    // No data available for this node. This will trigger a lazy fetch
                    // during render.
                    newCacheNode = {
                        lazyData: null,
                        rsc: null,
                        prefetchRsc: null,
                        head: null,
                        prefetchHead: null,
                        parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes),
                        lazyDataResolved: false,
                        loading: null
                    };
                }
                // Overrides the cache key with the new cache node.
                parallelRouteCacheNode.set(cacheKey, newCacheNode);
                // Traverse deeper to apply the head / fill lazy items till the head.
                fillLazyItemsTillLeafWithHead(newCacheNode, existingCacheNode, parallelRouteState, parallelSeedData ? parallelSeedData : null, head, prefetchEntry);
                newCache.parallelRoutes.set(key, parallelRouteCacheNode);
                continue;
            }
        }
        let newCacheNode;
        if (parallelSeedData !== null) {
            // New data was sent from the server.
            const seedNode = parallelSeedData[2];
            const loading = parallelSeedData[3];
            newCacheNode = {
                lazyData: null,
                rsc: seedNode,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                lazyDataResolved: false,
                loading
            };
        } else {
            // No data available for this node. This will trigger a lazy fetch
            // during render.
            newCacheNode = {
                lazyData: null,
                rsc: null,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                parallelRoutes: new Map(),
                lazyDataResolved: false,
                loading: null
            };
        }
        const existingParallelRoutes = newCache.parallelRoutes.get(key);
        if (existingParallelRoutes) {
            existingParallelRoutes.set(cacheKey, newCacheNode);
        } else {
            newCache.parallelRoutes.set(key, new Map([
                [
                    cacheKey,
                    newCacheNode
                ]
            ]));
        }
        fillLazyItemsTillLeafWithHead(newCacheNode, undefined, parallelRouteState, parallelSeedData, head, prefetchEntry);
    }
} //# sourceMappingURL=fill-lazy-items-till-leaf-with-head.js.map
¢  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.ts"],"names":["createRouterCacheKey","PrefetchCacheEntryStatus","fillLazyItemsTillLeafWithHead","newCache","existingCache","routerState","cacheNodeSeedData","head","prefetchEntry","isLastSegment","Object","keys","length","key","parallelRouteState","segmentForParallelRoute","cacheKey","parallelSeedData","undefined","existingParallelRoutesCacheNode","parallelRoutes","get","hasReusablePrefetch","kind","status","reusable","parallelRouteCacheNode","Map","existingCacheNode","newCacheNode","seedNode","loading","lazyData","rsc","prefetchRsc","prefetchHead","lazyDataResolved","set","existingParallelRoutes"],"mappings":"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","file":"x"}  false064undefined66131undefined133139undefined678697__WEBPACK_MODULE_REFERENCE__7_5b22637265617465526f7574657243616368654b6579225d_call_directImport_asiSafe1__._undefined18661889__WEBPACK_MODULE_REFERENCE__3_5b2250726566657463684361636865456e747279537461747573225d_asiSafe1__._undefined‡  1139fill_lazy_items_till_leaf_with_head_fillLazyItemsTillLeafWithHeadundefined540648(0,create_router_cache_key/* createRouterCacheKey */.d)undefined18171915router_reducer_types/* PrefetchCacheEntryStatus */.T7undefined51455173fill_lazy_items_till_leaf_with_head_fillLazyItemsTillLeafWithHeadundefined67816809fill_lazy_items_till_leaf_with_head_fillLazyItemsTillLeafWithHeadundefinedRawSource|   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/fill-cache-with-new-subtree-data.js
)úÿÿ2úÿÿ  import { invalidateCacheByRouterState } from "./invalidate-cache-by-router-state";
import { fillLazyItemsTillLeafWithHead } from "./fill-lazy-items-till-leaf-with-head";
import { createRouterCacheKey } from "./create-router-cache-key";
/**
 * Fill cache with rsc based on flightDataPath
 */ export function fillCacheWithNewSubTreeData(newCache, existingCache, flightDataPath, prefetchEntry) {
    const isLastEntry = flightDataPath.length <= 5;
    const [parallelRouteKey, segment] = flightDataPath;
    const cacheKey = createRouterCacheKey(segment);
    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);
    if (!existingChildSegmentMap) {
        // Bailout because the existing cache does not have the path to the leaf node
        // Will trigger lazy fetch in layout-router because of missing segment
        return;
    }
    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);
    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {
        childSegmentMap = new Map(existingChildSegmentMap);
        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);
    }
    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey);
    let childCacheNode = childSegmentMap.get(cacheKey);
    if (isLastEntry) {
        if (!childCacheNode || !childCacheNode.lazyData || childCacheNode === existingChildCacheNode) {
            const seedData = flightDataPath[3];
            const rsc = seedData[2];
            const loading = seedData[3];
            childCacheNode = {
                lazyData: null,
                rsc,
                prefetchRsc: null,
                head: null,
                prefetchHead: null,
                loading,
                // Ensure segments other than the one we got data for are preserved.
                parallelRoutes: existingChildCacheNode ? new Map(existingChildCacheNode.parallelRoutes) : new Map(),
                lazyDataResolved: false
            };
            if (existingChildCacheNode) {
                invalidateCacheByRouterState(childCacheNode, existingChildCacheNode, flightDataPath[2]);
            }
            fillLazyItemsTillLeafWithHead(childCacheNode, existingChildCacheNode, flightDataPath[2], seedData, flightDataPath[4], prefetchEntry);
            childSegmentMap.set(cacheKey, childCacheNode);
        }
        return;
    }
    if (!childCacheNode || !existingChildCacheNode) {
        // Bailout because the existing cache does not have the path to the leaf node
        // Will trigger lazy fetch in layout-router because of missing segment
        return;
    }
    if (childCacheNode === existingChildCacheNode) {
        childCacheNode = {
            lazyData: childCacheNode.lazyData,
            rsc: childCacheNode.rsc,
            prefetchRsc: childCacheNode.prefetchRsc,
            head: childCacheNode.head,
            prefetchHead: childCacheNode.prefetchHead,
            parallelRoutes: new Map(childCacheNode.parallelRoutes),
            lazyDataResolved: false,
            loading: childCacheNode.loading
        };
        childSegmentMap.set(cacheKey, childCacheNode);
    }
    fillCacheWithNewSubTreeData(childCacheNode, existingChildCacheNode, flightDataPath.slice(2), prefetchEntry);
} //# sourceMappingURL=fill-cache-with-new-subtree-data.js.map
‰  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/fill-cache-with-new-subtree-data.ts"],"names":["invalidateCacheByRouterState","fillLazyItemsTillLeafWithHead","createRouterCacheKey","fillCacheWithNewSubTreeData","newCache","existingCache","flightDataPath","prefetchEntry","isLastEntry","length","parallelRouteKey","segment","cacheKey","existingChildSegmentMap","parallelRoutes","get","childSegmentMap","Map","set","existingChildCacheNode","childCacheNode","lazyData","seedData","rsc","loading","prefetchRsc","head","prefetchHead","lazyDataResolved","slice"],"mappings":"AAKA,SAASA,4BAA4B,QAAQ,qCAAoC;AACjF,SAASC,6BAA6B,QAAQ,wCAAuC;AACrF,SAASC,oBAAoB,QAAQ,4BAA2B;AAGhE;;CAEC,GACD,OAAO,SAASC,4BACdC,QAAmB,EACnBC,aAAwB,EACxBC,cAA8B,EAC9BC,aAAkC;IAElC,MAAMC,cAAcF,eAAeG,MAAM,IAAI;IAC7C,MAAM,CAACC,kBAAkBC,QAAQ,GAAGL;IAEpC,MAAMM,WAAWV,qBAAqBS;IAEtC,MAAME,0BACJR,cAAcS,cAAc,CAACC,GAAG,CAACL;IAEnC,IAAI,CAACG,yBAAyB;QAC5B,6EAA6E;QAC7E,sEAAsE;QACtE;IACF;IAEA,IAAIG,kBAAkBZ,SAASU,cAAc,CAACC,GAAG,CAACL;IAClD,IAAI,CAACM,mBAAmBA,oBAAoBH,yBAAyB;QACnEG,kBAAkB,IAAIC,IAAIJ;QAC1BT,SAASU,cAAc,CAACI,GAAG,CAACR,kBAAkBM;IAChD;IAEA,MAAMG,yBAAyBN,wBAAwBE,GAAG,CAACH;IAC3D,IAAIQ,iBAAiBJ,gBAAgBD,GAAG,CAACH;IAEzC,IAAIJ,aAAa;QACf,IACE,CAACY,kBACD,CAACA,eAAeC,QAAQ,IACxBD,mBAAmBD,wBACnB;YACA,MAAMG,WAA8BhB,cAAc,CAAC,EAAE;YACrD,MAAMiB,MAAMD,QAAQ,CAAC,EAAE;YACvB,MAAME,UAAUF,QAAQ,CAAC,EAAE;YAC3BF,iBAAiB;gBACfC,UAAU;gBACVE;gBACAE,aAAa;gBACbC,MAAM;gBACNC,cAAc;gBACdH;gBACA,oEAAoE;gBACpEV,gBAAgBK,yBACZ,IAAIF,IAAIE,uBAAuBL,cAAc,IAC7C,IAAIG;gBACRW,kBAAkB;YACpB;YAEA,IAAIT,wBAAwB;gBAC1BnB,6BACEoB,gBACAD,wBACAb,cAAc,CAAC,EAAE;YAErB;YAEAL,8BACEmB,gBACAD,wBACAb,cAAc,CAAC,EAAE,EACjBgB,UACAhB,cAAc,CAAC,EAAE,EACjBC;YAGFS,gBAAgBE,GAAG,CAACN,UAAUQ;QAChC;QACA;IACF;IAEA,IAAI,CAACA,kBAAkB,CAACD,wBAAwB;QAC9C,6EAA6E;QAC7E,sEAAsE;QACtE;IACF;IAEA,IAAIC,mBAAmBD,wBAAwB;QAC7CC,iBAAiB;YACfC,UAAUD,eAAeC,QAAQ;YACjCE,KAAKH,eAAeG,GAAG;YACvBE,aAAaL,eAAeK,WAAW;YACvCC,MAAMN,eAAeM,IAAI;YACzBC,cAAcP,eAAeO,YAAY;YACzCb,gBAAgB,IAAIG,IAAIG,eAAeN,cAAc;YACrDc,kBAAkB;YAClBJ,SAASJ,eAAeI,OAAO;QACjC;QACAR,gBAAgBE,GAAG,CAACN,UAAUQ;IAChC;IAEAjB,4BACEiB,gBACAD,wBACAb,eAAeuB,KAAK,CAAC,IACrBtB;AAEJ","file":"x"}=   false081undefined83168undefined170234undefined291297undefinedŸ   6793fill_cache_with_new_subtree_data_fillCacheWithNewSubTreeDataundefined29332959fill_cache_with_new_subtree_data_fillCacheWithNewSubTreeDataundefinedRawSourcem   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/apply-flight-data.js
$úÿÿ-úÿÿ  import { fillLazyItemsTillLeafWithHead } from "./fill-lazy-items-till-leaf-with-head";
import { fillCacheWithNewSubTreeData } from "./fill-cache-with-new-subtree-data";
export function applyFlightData(existingCache, cache, flightDataPath, prefetchEntry) {
    // The one before last item is the router state tree patch
    const [treePatch, cacheNodeSeedData, head] = flightDataPath.slice(-3);
    // Handles case where prefetch only returns the router tree patch without rendered components.
    if (cacheNodeSeedData === null) {
        return false;
    }
    if (flightDataPath.length === 3) {
        const rsc = cacheNodeSeedData[2];
        const loading = cacheNodeSeedData[3];
        cache.loading = loading;
        cache.rsc = rsc;
        // This is a PPR-only field. When PPR is enabled, we shouldn't hit
        // this path during a navigation, but until PPR is fully implemented
        // yet it's possible the existing node does have a non-null
        // `prefetchRsc`. As an incremental step, we'll just de-opt to the
        // old behavior â€” no PPR value.
        cache.prefetchRsc = null;
        fillLazyItemsTillLeafWithHead(cache, existingCache, treePatch, cacheNodeSeedData, head, prefetchEntry);
    } else {
        // Copy rsc for the root node of the cache.
        cache.rsc = existingCache.rsc;
        // This is a PPR-only field. Unlike the previous branch, since we're
        // just cloning the existing cache node, we might as well keep the
        // PPR value, if it exists.
        cache.prefetchRsc = existingCache.prefetchRsc;
        cache.parallelRoutes = new Map(existingCache.parallelRoutes);
        cache.loading = existingCache.loading;
        // Create a copy of the existing cache with the rsc applied.
        fillCacheWithNewSubTreeData(cache, existingCache, flightDataPath, prefetchEntry);
    }
    return true;
} //# sourceMappingURL=apply-flight-data.js.map
¶  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/apply-flight-data.ts"],"names":["fillLazyItemsTillLeafWithHead","fillCacheWithNewSubTreeData","applyFlightData","existingCache","cache","flightDataPath","prefetchEntry","treePatch","cacheNodeSeedData","head","slice","length","rsc","loading","prefetchRsc","parallelRoutes","Map"],"mappings":"AAEA,SAASA,6BAA6B,QAAQ,wCAAuC;AACrF,SAASC,2BAA2B,QAAQ,qCAAoC;AAGhF,OAAO,SAASC,gBACdC,aAAwB,EACxBC,KAAgB,EAChBC,cAA8B,EAC9BC,aAAkC;IAElC,0DAA0D;IAC1D,MAAM,CAACC,WAAWC,mBAAmBC,KAAK,GAAGJ,eAAeK,KAAK,CAAC,CAAC;IAEnE,8FAA8F;IAC9F,IAAIF,sBAAsB,MAAM;QAC9B,OAAO;IACT;IAEA,IAAIH,eAAeM,MAAM,KAAK,GAAG;QAC/B,MAAMC,MAAMJ,iBAAiB,CAAC,EAAE;QAChC,MAAMK,UAAUL,iBAAiB,CAAC,EAAE;QACpCJ,MAAMS,OAAO,GAAGA;QAChBT,MAAMQ,GAAG,GAAGA;QACZ,kEAAkE;QAClE,oEAAoE;QACpE,2DAA2D;QAC3D,kEAAkE;QAClE,+BAA+B;QAC/BR,MAAMU,WAAW,GAAG;QACpBd,8BACEI,OACAD,eACAI,WACAC,mBACAC,MACAH;IAEJ,OAAO;QACL,2CAA2C;QAC3CF,MAAMQ,GAAG,GAAGT,cAAcS,GAAG;QAC7B,oEAAoE;QACpE,kEAAkE;QAClE,2BAA2B;QAC3BR,MAAMU,WAAW,GAAGX,cAAcW,WAAW;QAC7CV,MAAMW,cAAc,GAAG,IAAIC,IAAIb,cAAcY,cAAc;QAC3DX,MAAMS,OAAO,GAAGV,cAAcU,OAAO;QACrC,4DAA4D;QAC5DZ,4BACEG,OACAD,eACAE,gBACAC;IAEJ;IAEA,OAAO;AACT","file":"x"}.   false085undefined87167undefined169175undefined7   1125apply_flight_data_applyFlightDataundefinedRawSourceò   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/segment.js
var lib_segment = __webpack_require__(8478);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/refetch-inactive-parallel-segments.js
úÿÿ(úÿÿS  import { applyFlightData } from "./apply-flight-data";
import { fetchServerResponse } from "./fetch-server-response";
import { PAGE_SEGMENT_KEY } from "../../../shared/lib/segment";
/**
 * Refreshes inactive segments that are still in the current FlightRouterState.
 * A segment is considered "inactive" when the server response indicates it didn't match to a page component.
 * This happens during a soft-navigation, where the server will want to patch in the segment
 * with the "default" component, but we explicitly ignore the server in this case
 * and keep the existing state for that segment. New data for inactive segments are inherently
 * not part of the server response when we patch the tree, because they were associated with a response
 * from an earlier navigation/request. For each segment, once it becomes "active", we encode the URL that provided
 * the data for it. This function traverses parallel routes looking for these markers so that it can re-fetch
 * and patch the new data into the tree.
 */ export async function refreshInactiveParallelSegments(options) {
    const fetchedSegments = new Set();
    await refreshInactiveParallelSegmentsImpl({
        ...options,
        rootTree: options.updatedTree,
        fetchedSegments
    });
}
async function refreshInactiveParallelSegmentsImpl(param) {
    let { state, updatedTree, updatedCache, includeNextUrl, fetchedSegments, rootTree = updatedTree, canonicalUrl } = param;
    const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree;
    const fetchPromises = [];
    if (refetchPath && refetchPath !== canonicalUrl && refetchMarker === "refresh" && // it's possible for the tree to contain multiple segments that contain data at the same URL
    // we keep track of them so we can dedupe the requests
    !fetchedSegments.has(refetchPath)) {
        fetchedSegments.add(refetchPath) // Mark this URL as fetched
        ;
        // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate
        // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.
        const fetchPromise = fetchServerResponse(new URL(refetchPath, location.origin), // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)
        [
            rootTree[0],
            rootTree[1],
            rootTree[2],
            "refetch"
        ], includeNextUrl ? state.nextUrl : null, state.buildId).then((fetchResponse)=>{
            const flightData = fetchResponse[0];
            if (typeof flightData !== "string") {
                for (const flightDataPath of flightData){
                    // we only pass the new cache as this function is called after clearing the router cache
                    // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's
                    // just been created & has been written to, but hasn't been "committed" yet.
                    applyFlightData(updatedCache, updatedCache, flightDataPath);
                }
            } else {
            // When flightData is a string, it suggests that the server response should have triggered an MPA navigation
            // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect
            // when refreshing on-screen data, so handling this has been ommitted.
            }
        });
        fetchPromises.push(fetchPromise);
    }
    for(const key in parallelRoutes){
        const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({
            state,
            updatedTree: parallelRoutes[key],
            updatedCache,
            includeNextUrl,
            fetchedSegments,
            rootTree,
            canonicalUrl
        });
        fetchPromises.push(parallelFetchPromise);
    }
    await Promise.all(fetchPromises);
}
/**
 * Walks the current parallel segments to determine if they are "active".
 * An active parallel route will have a `__PAGE__` segment in the FlightRouterState.
 * As opposed to a `__DEFAULT__` segment, which means there was no match for that parallel route.
 * We add a special marker here so that we know how to refresh its data when the router is revalidated.
 */ export function addRefreshMarkerToActiveParallelSegments(tree, path) {
    const [segment, parallelRoutes, , refetchMarker] = tree;
    // a page segment might also contain concatenated search params, so we do a partial match on the key
    if (segment.includes(PAGE_SEGMENT_KEY) && refetchMarker !== "refresh") {
        tree[2] = path;
        tree[3] = "refresh";
    }
    for(const key in parallelRoutes){
        addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path);
    }
} //# sourceMappingURL=refetch-inactive-parallel-segments.js.map
	  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/refetch-inactive-parallel-segments.ts"],"names":["applyFlightData","fetchServerResponse","PAGE_SEGMENT_KEY","refreshInactiveParallelSegments","options","fetchedSegments","Set","refreshInactiveParallelSegmentsImpl","rootTree","updatedTree","param","state","updatedCache","includeNextUrl","canonicalUrl","parallelRoutes","refetchPath","refetchMarker","fetchPromises","has","add","fetchPromise","URL","location","origin","nextUrl","buildId","then","fetchResponse","flightData","flightDataPath","push","key","parallelFetchPromise","Promise","all","addRefreshMarkerToActiveParallelSegments","tree","path","segment","includes"],"mappings":"AAGA,SAASA,eAAe,QAAQ,sBAAqB;AACrD,SAASC,mBAAmB,QAAQ,0BAAyB;AAC7D,SAASC,gBAAgB,QAAQ,8BAA6B;AAU9D;;;;;;;;;;CAUC,GACD,OAAO,eAAeC,gCACpBC,OAAwC;IAExC,MAAMC,kBAAkB,IAAIC;IAC5B,MAAMC,oCAAoC;QACxC,GAAGH,OAAO;QACVI,UAAUJ,QAAQK,WAAW;QAC7BJ;IACF;AACF;AAEA,eAAeE,oCAAoCG,KAWlD;IAXkD,IAAA,EACjDC,KAAK,EACLF,WAAW,EACXG,YAAY,EACZC,cAAc,EACdR,eAAe,EACfG,WAAWC,WAAW,EACtBK,YAAY,EAIb,GAXkDJ;IAYjD,MAAM,GAAGK,gBAAgBC,aAAaC,cAAc,GAAGR;IACvD,MAAMS,gBAAgB,EAAE;IAExB,IACEF,eACAA,gBAAgBF,gBAChBG,kBAAkB,aAClB,4FAA4F;IAC5F,sDAAsD;IACtD,CAACZ,gBAAgBc,GAAG,CAACH,cACrB;QACAX,gBAAgBe,GAAG,CAACJ,aAAa,2BAA2B;;QAE5D,wHAAwH;QACxH,kIAAkI;QAClI,MAAMK,eAAepB,oBACnB,IAAIqB,IAAIN,aAAaO,SAASC,MAAM,GAEpC,8HAA8H;QAC9H;YAAChB,QAAQ,CAAC,EAAE;YAAEA,QAAQ,CAAC,EAAE;YAAEA,QAAQ,CAAC,EAAE;YAAE;SAAU,EAClDK,iBAAiBF,MAAMc,OAAO,GAAG,MACjCd,MAAMe,OAAO,EACbC,IAAI,CAAC,CAACC;YACN,MAAMC,aAAaD,aAAa,CAAC,EAAE;YACnC,IAAI,OAAOC,eAAe,UAAU;gBAClC,KAAK,MAAMC,kBAAkBD,WAAY;oBACvC,wFAAwF;oBACxF,4GAA4G;oBAC5G,4EAA4E;oBAC5E7B,gBAAgBY,cAAcA,cAAckB;gBAC9C;YACF,OAAO;YACL,4GAA4G;YAC5G,+GAA+G;YAC/G,sEAAsE;YACxE;QACF;QAEAZ,cAAca,IAAI,CAACV;IACrB;IAEA,IAAK,MAAMW,OAAOjB,eAAgB;QAChC,MAAMkB,uBAAuB1B,oCAAoC;YAC/DI;YACAF,aAAaM,cAAc,CAACiB,IAAI;YAChCpB;YACAC;YACAR;YACAG;YACAM;QACF;QAEAI,cAAca,IAAI,CAACE;IACrB;IAEA,MAAMC,QAAQC,GAAG,CAACjB;AACpB;AAEA;;;;;CAKC,GACD,OAAO,SAASkB,yCACdC,IAAuB,EACvBC,IAAY;IAEZ,MAAM,CAACC,SAASxB,kBAAkBE,cAAc,GAAGoB;IACnD,oGAAoG;IACpG,IAAIE,QAAQC,QAAQ,CAACtC,qBAAqBe,kBAAkB,WAAW;QACrEoB,IAAI,CAAC,EAAE,GAAGC;QACVD,IAAI,CAAC,EAAE,GAAG;IACZ;IAEA,IAAK,MAAML,OAAOjB,eAAgB;QAChCqB,yCAAyCrB,cAAc,CAACiB,IAAI,EAAEM;IAChE;AACF","file":"x"}Â   false053undefined55116undefined118180undefined10201026undefined43884394undefined46504665__WEBPACK_MODULE_REFERENCE__11_5b22504147455f5345474d454e545f4b4559225d_directImport_asiSafe1__._undefinedG  856886refetch_inactive_parallel_segments_refreshInactiveParallelSegmentsundefined42114250refetch_inactive_parallel_segments_addRefreshMarkerToActiveParallelSegmentsundefined44574553lib_segment/* PAGE_SEGMENT_KEY */.GCundefined46954734refetch_inactive_parallel_segments_addRefreshMarkerToActiveParallelSegmentsundefinedRawSource|   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/apply-router-state-patch-to-tree.js
úÿÿ#úÿÿ¶  import { DEFAULT_SEGMENT_KEY } from "../../../shared/lib/segment";
import { matchSegment } from "../match-segments";
import { addRefreshMarkerToActiveParallelSegments } from "./refetch-inactive-parallel-segments";
/**
 * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.
 */ function applyPatch(initialTree, patchTree, flightSegmentPath) {
    const [initialSegment, initialParallelRoutes] = initialTree;
    const [patchSegment, patchParallelRoutes] = patchTree;
    // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree
    // this is because the __DEFAULT__ segment is used as a placeholder on navigation
    if (patchSegment === DEFAULT_SEGMENT_KEY && initialSegment !== DEFAULT_SEGMENT_KEY) {
        return initialTree;
    }
    if (matchSegment(initialSegment, patchSegment)) {
        const newParallelRoutes = {};
        for(const key in initialParallelRoutes){
            const isInPatchTreeParallelRoutes = typeof patchParallelRoutes[key] !== "undefined";
            if (isInPatchTreeParallelRoutes) {
                newParallelRoutes[key] = applyPatch(initialParallelRoutes[key], patchParallelRoutes[key], flightSegmentPath);
            } else {
                newParallelRoutes[key] = initialParallelRoutes[key];
            }
        }
        for(const key in patchParallelRoutes){
            if (newParallelRoutes[key]) {
                continue;
            }
            newParallelRoutes[key] = patchParallelRoutes[key];
        }
        const tree = [
            initialSegment,
            newParallelRoutes
        ];
        // Copy over the existing tree
        if (initialTree[2]) {
            tree[2] = initialTree[2];
        }
        if (initialTree[3]) {
            tree[3] = initialTree[3];
        }
        if (initialTree[4]) {
            tree[4] = initialTree[4];
        }
        return tree;
    }
    return patchTree;
}
/**
 * Apply the router state from the Flight response, but skip patching default segments.
 * Useful for patching the router cache when navigating, where we persist the existing default segment if there isn't a new one.
 * Creates a new router state tree.
 */ export function applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch, path) {
    const [segment, parallelRoutes, url, refetch, isRootLayout] = flightRouterState;
    // Root refresh
    if (flightSegmentPath.length === 1) {
        const tree = applyPatch(flightRouterState, treePatch, flightSegmentPath);
        addRefreshMarkerToActiveParallelSegments(tree, path);
        return tree;
    }
    const [currentSegment, parallelRouteKey] = flightSegmentPath;
    // Tree path returned from the server should always match up with the current tree in the browser
    if (!matchSegment(currentSegment, segment)) {
        return null;
    }
    const lastSegment = flightSegmentPath.length === 2;
    let parallelRoutePatch;
    if (lastSegment) {
        parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch, flightSegmentPath);
    } else {
        parallelRoutePatch = applyRouterStatePatchToTree(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch, path);
        if (parallelRoutePatch === null) {
            return null;
        }
    }
    const tree = [
        flightSegmentPath[0],
        {
            ...parallelRoutes,
            [parallelRouteKey]: parallelRoutePatch
        },
        url,
        refetch
    ];
    // Current segment is the root layout
    if (isRootLayout) {
        tree[4] = true;
    }
    addRefreshMarkerToActiveParallelSegments(tree, path);
    return tree;
} //# sourceMappingURL=apply-router-state-patch-to-tree.js.map
ò	  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/apply-router-state-patch-to-tree.ts"],"names":["DEFAULT_SEGMENT_KEY","matchSegment","addRefreshMarkerToActiveParallelSegments","applyPatch","initialTree","patchTree","flightSegmentPath","initialSegment","initialParallelRoutes","patchSegment","patchParallelRoutes","newParallelRoutes","key","isInPatchTreeParallelRoutes","tree","applyRouterStatePatchToTree","flightRouterState","treePatch","path","segment","parallelRoutes","url","refetch","isRootLayout","length","currentSegment","parallelRouteKey","lastSegment","parallelRoutePatch","slice"],"mappings":"AAIA,SAASA,mBAAmB,QAAQ,8BAA6B;AACjE,SAASC,YAAY,QAAQ,oBAAmB;AAChD,SAASC,wCAAwC,QAAQ,uCAAsC;AAE/F;;CAEC,GACD,SAASC,WACPC,WAA8B,EAC9BC,SAA4B,EAC5BC,iBAAoC;IAEpC,MAAM,CAACC,gBAAgBC,sBAAsB,GAAGJ;IAChD,MAAM,CAACK,cAAcC,oBAAoB,GAAGL;IAE5C,kGAAkG;IAClG,iFAAiF;IACjF,IACEI,iBAAiBT,uBACjBO,mBAAmBP,qBACnB;QACA,OAAOI;IACT;IAEA,IAAIH,aAAaM,gBAAgBE,eAAe;QAC9C,MAAME,oBAA0C,CAAC;QACjD,IAAK,MAAMC,OAAOJ,sBAAuB;YACvC,MAAMK,8BACJ,OAAOH,mBAAmB,CAACE,IAAI,KAAK;YACtC,IAAIC,6BAA6B;gBAC/BF,iBAAiB,CAACC,IAAI,GAAGT,WACvBK,qBAAqB,CAACI,IAAI,EAC1BF,mBAAmB,CAACE,IAAI,EACxBN;YAEJ,OAAO;gBACLK,iBAAiB,CAACC,IAAI,GAAGJ,qBAAqB,CAACI,IAAI;YACrD;QACF;QAEA,IAAK,MAAMA,OAAOF,oBAAqB;YACrC,IAAIC,iBAAiB,CAACC,IAAI,EAAE;gBAC1B;YACF;YAEAD,iBAAiB,CAACC,IAAI,GAAGF,mBAAmB,CAACE,IAAI;QACnD;QAEA,MAAME,OAA0B;YAACP;YAAgBI;SAAkB;QAEnE,8BAA8B;QAC9B,IAAIP,WAAW,CAAC,EAAE,EAAE;YAClBU,IAAI,CAAC,EAAE,GAAGV,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBU,IAAI,CAAC,EAAE,GAAGV,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBU,IAAI,CAAC,EAAE,GAAGV,WAAW,CAAC,EAAE;QAC1B;QAEA,OAAOU;IACT;IAEA,OAAOT;AACT;AAEA;;;;CAIC,GACD,OAAO,SAASU,4BACdT,iBAAoC,EACpCU,iBAAoC,EACpCC,SAA4B,EAC5BC,IAAY;IAEZ,MAAM,CAACC,SAASC,gBAAgBC,KAAKC,SAASC,aAAa,GACzDP;IAEF,eAAe;IACf,IAAIV,kBAAkBkB,MAAM,KAAK,GAAG;QAClC,MAAMV,OAA0BX,WAC9Ba,mBACAC,WACAX;QAGFJ,yCAAyCY,MAAMI;QAE/C,OAAOJ;IACT;IAEA,MAAM,CAACW,gBAAgBC,iBAAiB,GAAGpB;IAE3C,iGAAiG;IACjG,IAAI,CAACL,aAAawB,gBAAgBN,UAAU;QAC1C,OAAO;IACT;IAEA,MAAMQ,cAAcrB,kBAAkBkB,MAAM,KAAK;IAEjD,IAAII;IACJ,IAAID,aAAa;QACfC,qBAAqBzB,WACnBiB,cAAc,CAACM,iBAAiB,EAChCT,WACAX;IAEJ,OAAO;QACLsB,qBAAqBb,4BACnBT,kBAAkBuB,KAAK,CAAC,IACxBT,cAAc,CAACM,iBAAiB,EAChCT,WACAC;QAGF,IAAIU,uBAAuB,MAAM;YAC/B,OAAO;QACT;IACF;IAEA,MAAMd,OAA0B;QAC9BR,iBAAiB,CAAC,EAAE;QACpB;YACE,GAAGc,cAAc;YACjB,CAACM,iBAAiB,EAAEE;QACtB;QACAP;QACAC;KACD;IAED,qCAAqC;IACrC,IAAIC,cAAc;QAChBT,IAAI,CAAC,EAAE,GAAG;IACZ;IAEAZ,yCAAyCY,MAAMI;IAE/C,OAAOJ;AACT","file":"x"}?   false065undefined67115undefined117212undefined22342240undefined£   20322058apply_router_state_patch_to_tree_applyRouterStatePatchToTreeundefined29342960apply_router_state_patch_to_tree_applyRouterStatePatchToTreeundefinedRawSourceê   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/app-router-headers.js
var app_router_headers = __webpack_require__(3185);
;// CONCATENATED MODULE: ./node_modules/@swc/helpers/esm/_class_private_field_loose_base.js
úÿÿ×÷ÿÿÝýÿÿ4  webpack://javascript/esm|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/@swc/helpers/esm/_class_private_field_loose_base.js|ssr06undefined252299undefinedØ÷ÿÿ\   
;// CONCATENATED MODULE: ./node_modules/@swc/helpers/esm/_class_private_field_loose_key.js
úÿÿÕ÷ÿÿÜýÿÿ5  webpack://javascript/esm|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/@swc/helpers/esm/_class_private_field_loose_key.js|ssr1319undefined115161undefinedÖ÷ÿÿZ   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/promise-queue.js
úÿÿúÿÿ€  /*
    This is a simple promise queue that allows you to limit the number of concurrent promises
    that are running at any given time. It's used to limit the number of concurrent
    prefetch requests that are being made to the server but could be used for other
    things as well.
*/ import { _ as _class_private_field_loose_base } from "@swc/helpers/_/_class_private_field_loose_base";
import { _ as _class_private_field_loose_key } from "@swc/helpers/_/_class_private_field_loose_key";
var _maxConcurrency = /*#__PURE__*/ _class_private_field_loose_key("_maxConcurrency"), _runningCount = /*#__PURE__*/ _class_private_field_loose_key("_runningCount"), _queue = /*#__PURE__*/ _class_private_field_loose_key("_queue"), _processNext = /*#__PURE__*/ _class_private_field_loose_key("_processNext");
export class PromiseQueue {
    enqueue(promiseFn) {
        let taskResolve;
        let taskReject;
        const taskPromise = new Promise((resolve, reject)=>{
            taskResolve = resolve;
            taskReject = reject;
        });
        const task = async ()=>{
            try {
                _class_private_field_loose_base(this, _runningCount)[_runningCount]++;
                const result = await promiseFn();
                taskResolve(result);
            } catch (error) {
                taskReject(error);
            } finally{
                _class_private_field_loose_base(this, _runningCount)[_runningCount]--;
                _class_private_field_loose_base(this, _processNext)[_processNext]();
            }
        };
        const enqueueResult = {
            promiseFn: taskPromise,
            task
        };
        // wonder if we should take a LIFO approach here
        _class_private_field_loose_base(this, _queue)[_queue].push(enqueueResult);
        _class_private_field_loose_base(this, _processNext)[_processNext]();
        return taskPromise;
    }
    bump(promiseFn) {
        const index = _class_private_field_loose_base(this, _queue)[_queue].findIndex((item)=>item.promiseFn === promiseFn);
        if (index > -1) {
            const bumpedItem = _class_private_field_loose_base(this, _queue)[_queue].splice(index, 1)[0];
            _class_private_field_loose_base(this, _queue)[_queue].unshift(bumpedItem);
            _class_private_field_loose_base(this, _processNext)[_processNext](true);
        }
    }
    constructor(maxConcurrency = 5){
        Object.defineProperty(this, _processNext, {
            value: processNext
        });
        Object.defineProperty(this, _maxConcurrency, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _runningCount, {
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _queue, {
            writable: true,
            value: void 0
        });
        _class_private_field_loose_base(this, _maxConcurrency)[_maxConcurrency] = maxConcurrency;
        _class_private_field_loose_base(this, _runningCount)[_runningCount] = 0;
        _class_private_field_loose_base(this, _queue)[_queue] = [];
    }
}
function processNext(forced) {
    if (forced === void 0) forced = false;
    if ((_class_private_field_loose_base(this, _runningCount)[_runningCount] < _class_private_field_loose_base(this, _maxConcurrency)[_maxConcurrency] || forced) && _class_private_field_loose_base(this, _queue)[_queue].length > 0) {
        var _class_private_field_loose_base__queue_shift;
        (_class_private_field_loose_base__queue_shift = _class_private_field_loose_base(this, _queue)[_queue].shift()) == null ? void 0 : _class_private_field_loose_base__queue_shift.task();
    }
} //# sourceMappingURL=promise-queue.js.map
¼	  {"version":3,"sources":["webpack://../../../src/client/components/promise-queue.ts"],"names":["_","_class_private_field_loose_base","_maxConcurrency","_class_private_field_loose_key","_runningCount","_queue","_processNext","PromiseQueue","enqueue","promiseFn","taskResolve","taskReject","taskPromise","Promise","resolve","reject","task","runningCount","result","error","processNext","enqueueResult","queue","push","bump","index","findIndex","item","bumpedItem","splice","unshift","constructor","maxConcurrency","Object","defineProperty","forced","length","_class_private_field_loose_base__queue_shift","shift"],"mappings":"AAAA;;;;;AAKA,GAAA,SAAAA,KAAAC,+BAAA,QAAA,iDAAA;;IAEEC,kBAAA,WAAA,GAAAC,+BAAA,oBACAC,gBAAA,WAAA,GAAAD,+BAAA,kBACAE,SAAA,WAAA,GAAAF,+BAAA,WAmDAG,eAAA,WAAA,GAAAH,+BAAA;AAtDF,OAAO,MAAMI;IAcXC,QAAWC,SAA2B,EAAc;QAClD,IAAIC;QACJ,IAAIC;QAEJ,MAAMC,cAAc,IAAIC,QAAQ,CAACC,SAASC;YACxCL,cAAcI;YACdH,aAAaI;QACf;QAEA,MAAMC,OAAO;YACX,IAAI;gBACFf,gCAAA,IAAI,EAAEgB,cAAAA,CAAAA,cAAAA;gBACN,MAAMC,SAAS,MAAMT;gBACrBC,YAAYQ;YACd,EAAE,OAAOC,OAAO;gBACdR,WAAWQ;YACb,SAAU;gBACRlB,gCAAA,IAAI,EAAEgB,cAAAA,CAAAA,cAAAA;gBACNhB,gCAAA,IAAI,EAAEmB,aAAAA,CAAAA,aAAAA;YACR;QACF;QAEA,MAAMC,gBAAgB;YAAEZ,WAAWG;YAAaI;QAAK;QACrD,gDAAgD;QAChDf,gCAAA,IAAI,EAAEqB,OAAAA,CAAAA,OAAAA,CAAMC,IAAI,CAACF;QACjBpB,gCAAA,IAAI,EAAEmB,aAAAA,CAAAA,aAAAA;QAEN,OAAOR;IACT;IAEAY,KAAKf,SAAuB,EAAE;QAC5B,MAAMgB,QAAQxB,gCAAA,IAAI,EAAEqB,OAAAA,CAAAA,OAAAA,CAAMI,SAAS,CAAC,CAACC,OAASA,KAAKlB,SAAS,KAAKA;QAEjE,IAAIgB,QAAQ,CAAC,GAAG;YACd,MAAMG,aAAa3B,gCAAA,IAAI,EAAEqB,OAAAA,CAAAA,OAAAA,CAAMO,MAAM,CAACJ,OAAO,EAAE,CAAC,EAAE;YAClDxB,gCAAA,IAAI,EAAEqB,OAAAA,CAAAA,OAAAA,CAAMQ,OAAO,CAACF;YACpB3B,gCAAA,IAAI,EAAEmB,aAAAA,CAAAA,aAAAA,CAAY;QACpB;IACF;IA5CAW,YAAYC,iBAAiB,CAAC,CAAE;QA8ChCC,OAAAC,cAAA,CAAA,IAAA,EAAA5B,cAAA;mBAAAc;;QArDAa,OAAAC,cAAA,CAAA,IAAA,EAAAhC,iBAAA;;mBAAA,KAAA;;QACA+B,OAAAC,cAAA,CAAA,IAAA,EAAA9B,eAAA;;mBAAA,KAAA;;QACA6B,OAAAC,cAAA,CAAA,IAAA,EAAA7B,QAAA;;mBAAA,KAAA;;QAMEJ,gCAAA,IAAI,EAAE+B,gBAAAA,CAAAA,gBAAAA,GAAiBA;QACvB/B,gCAAA,IAAI,EAAEgB,cAAAA,CAAAA,cAAAA,GAAe;QACrBhB,gCAAA,IAAI,EAAEqB,OAAAA,CAAAA,OAAAA,GAAQ,EAAE;IAClB;AAkDF;AARE,SAAAF,YAAae,MAAc;IAAdA,IAAAA,WAAAA,KAAAA,GAAAA,SAAS;IACpB,IACE,AAAClC,CAAAA,gCAAA,IAAI,EAAEgB,cAAAA,CAAAA,cAAAA,GAAehB,gCAAA,IAAI,EAAE+B,gBAAAA,CAAAA,gBAAAA,IAAkBG,MAAAA,KAC9ClC,gCAAA,IAAI,EAAEqB,OAAAA,CAAAA,OAAAA,CAAMc,MAAM,GAAG,GACrB;YACAC;QAAAA,CAAAA,+CAAApC,gCAAA,IAAI,EAAEqB,OAAAA,CAAAA,OAAAA,CAAMgB,KAAK,EAAA,KAAA,OAAA,KAAA,IAAjBD,6CAAqBrB,IAAI;IAC3B;AACF","file":"x"}  false288389undefined391490undefined528557__WEBPACK_MODULE_REFERENCE__16_5b225f225d_call_directImport_asiSafe1__._undefined609638__WEBPACK_MODULE_REFERENCE__16_5b225f225d_call_directImport_asiSafe1__._undefined681710__WEBPACK_MODULE_REFERENCE__16_5b225f225d_call_directImport_asiSafe1__._undefined752781__WEBPACK_MODULE_REFERENCE__16_5b225f225d_call_directImport_asiSafe1__._undefined800806undefined11101140__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined13721402__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined14591489__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined17141744__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined17971827__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined19441974__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined21042134__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined21912221__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined22782308__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined28592889__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined29572987__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined30383068__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined31893219__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined32593289__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined33453375__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined35273557__WEBPACK_MODULE_REFERENCE__15_5b225f225d_call_directImport_asiSafe1__._undefined½  326397_class_private_field_loose_keyundefined449520_class_private_field_loose_keyundefined563634_class_private_field_loose_keyundefined676747_class_private_field_loose_keyundefined10691140_class_private_field_loose_baseundefined13721443_class_private_field_loose_baseundefined15001571_class_private_field_loose_baseundefined17961867_class_private_field_loose_baseundefined19201991_class_private_field_loose_baseundefined21082179_class_private_field_loose_baseundefined23092380_class_private_field_loose_baseundefined24372508_class_private_field_loose_baseundefined25652636_class_private_field_loose_baseundefined31873258_class_private_field_loose_baseundefined33263397_class_private_field_loose_baseundefined34483519_class_private_field_loose_baseundefined36403711_class_private_field_loose_baseundefined37513822_class_private_field_loose_baseundefined38783949_class_private_field_loose_baseundefined41014172_class_private_field_loose_baseundefinedRawSourcep   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/prefetch-cache-utils.js
úÿÿúÿÿr"  import { createHrefFromUrl } from "./create-href-from-url";
import { fetchServerResponse } from "./fetch-server-response";
import { PrefetchCacheEntryStatus, PrefetchKind } from "./router-reducer-types";
import { prefetchQueue } from "./reducers/prefetch-reducer";
/**
 * Creates a cache key for the router prefetch cache
 *
 * @param url - The URL being navigated to
 * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.
 * @return The generated prefetch cache key.
 */ function createPrefetchCacheKey(url, nextUrl) {
    const pathnameFromUrl = createHrefFromUrl(url, false);
    // nextUrl is used as a cache key delimiter since entries can vary based on the Next-URL header
    if (nextUrl) {
        return nextUrl + "%" + pathnameFromUrl;
    }
    return pathnameFromUrl;
}
/**
 * Returns a prefetch cache entry if one exists. Otherwise creates a new one and enqueues a fetch request
 * to retrieve the prefetch data from the server.
 */ export function getOrCreatePrefetchCacheEntry(param) {
    let { url, nextUrl, tree, buildId, prefetchCache, kind } = param;
    let existingCacheEntry = undefined;
    // We first check if there's a more specific interception route prefetch entry
    // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)
    // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.
    const interceptionCacheKey = createPrefetchCacheKey(url, nextUrl);
    const interceptionData = prefetchCache.get(interceptionCacheKey);
    if (interceptionData) {
        existingCacheEntry = interceptionData;
    } else {
        // If we dont find a more specific interception route prefetch entry, we check for a regular prefetch entry
        const prefetchCacheKey = createPrefetchCacheKey(url);
        const prefetchData = prefetchCache.get(prefetchCacheKey);
        if (prefetchData) {
            existingCacheEntry = prefetchData;
        }
    }
    if (existingCacheEntry) {
        // Grab the latest status of the cache entry and update it
        existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);
        // when `kind` is provided, an explicit prefetch was requested.
        // if the requested prefetch is "full" and the current cache entry wasn't, we want to re-prefetch with the new intent
        const switchedToFullPrefetch = existingCacheEntry.kind !== PrefetchKind.FULL && kind === PrefetchKind.FULL;
        if (switchedToFullPrefetch) {
            return createLazyPrefetchEntry({
                tree,
                url,
                buildId,
                nextUrl,
                prefetchCache,
                // If we didn't get an explicit prefetch kind, we want to set a temporary kind
                // rather than assuming the same intent as the previous entry, to be consistent with how we
                // lazily create prefetch entries when intent is left unspecified.
                kind: kind != null ? kind : PrefetchKind.TEMPORARY
            });
        }
        // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,
        // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.
        if (kind && existingCacheEntry.kind === PrefetchKind.TEMPORARY) {
            existingCacheEntry.kind = kind;
        }
        // We've determined that the existing entry we found is still valid, so we return it.
        return existingCacheEntry;
    }
    // If we didn't return an entry, create a new one.
    return createLazyPrefetchEntry({
        tree,
        url,
        buildId,
        nextUrl,
        prefetchCache,
        kind: kind || // in dev, there's never gonna be a prefetch entry so we want to prefetch here
        ("production" === "development" ? PrefetchKind.AUTO : PrefetchKind.TEMPORARY)
    });
}
/*
 * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.
 * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).
 */ function prefixExistingPrefetchCacheEntry(param) {
    let { url, nextUrl, prefetchCache } = param;
    const existingCacheKey = createPrefetchCacheKey(url);
    const existingCacheEntry = prefetchCache.get(existingCacheKey);
    if (!existingCacheEntry) {
        // no-op -- there wasn't an entry to move
        return;
    }
    const newCacheKey = createPrefetchCacheKey(url, nextUrl);
    prefetchCache.set(newCacheKey, existingCacheEntry);
    prefetchCache.delete(existingCacheKey);
}
/**
 * Use to seed the prefetch cache with data that has already been fetched.
 */ export function createPrefetchCacheEntryForInitialLoad(param) {
    let { nextUrl, tree, prefetchCache, url, kind, data } = param;
    const [, , , intercept] = data;
    // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key
    const prefetchCacheKey = intercept ? createPrefetchCacheKey(url, nextUrl) : createPrefetchCacheKey(url);
    const prefetchEntry = {
        treeAtTimeOfPrefetch: tree,
        data: Promise.resolve(data),
        kind,
        prefetchTime: Date.now(),
        lastUsedTime: Date.now(),
        key: prefetchCacheKey,
        status: PrefetchCacheEntryStatus.fresh
    };
    prefetchCache.set(prefetchCacheKey, prefetchEntry);
    return prefetchEntry;
}
/**
 * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.
 */ function createLazyPrefetchEntry(param) {
    let { url, kind, tree, nextUrl, buildId, prefetchCache } = param;
    const prefetchCacheKey = createPrefetchCacheKey(url);
    // initiates the fetch request for the prefetch and attaches a listener
    // to the promise to update the prefetch cache entry when the promise resolves (if necessary)
    const data = prefetchQueue.enqueue(()=>fetchServerResponse(url, tree, nextUrl, buildId, kind).then((prefetchResponse)=>{
            // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations
            // to avoid drift between this cache key prefixing logic
            // (which is currently directly influenced by the server response)
            const [, , , intercepted] = prefetchResponse;
            if (intercepted) {
                prefixExistingPrefetchCacheEntry({
                    url,
                    nextUrl,
                    prefetchCache
                });
            }
            return prefetchResponse;
        }));
    const prefetchEntry = {
        treeAtTimeOfPrefetch: tree,
        data,
        kind,
        prefetchTime: Date.now(),
        lastUsedTime: null,
        key: prefetchCacheKey,
        status: PrefetchCacheEntryStatus.fresh
    };
    prefetchCache.set(prefetchCacheKey, prefetchEntry);
    return prefetchEntry;
}
export function prunePrefetchCache(prefetchCache) {
    for (const [href, prefetchCacheEntry] of prefetchCache){
        if (getPrefetchEntryCacheStatus(prefetchCacheEntry) === PrefetchCacheEntryStatus.expired) {
            prefetchCache.delete(href);
        }
    }
}
// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)
// and default to 5 minutes (static) / 30 seconds (dynamic)
const DYNAMIC_STALETIME_MS = Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000;
const STATIC_STALETIME_MS = Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME) * 1000;
function getPrefetchEntryCacheStatus(param) {
    let { kind, prefetchTime, lastUsedTime } = param;
    // We will re-use the cache entry data for up to the `dynamic` staletime window.
    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {
        return lastUsedTime ? PrefetchCacheEntryStatus.reusable : PrefetchCacheEntryStatus.fresh;
    }
    // For "auto" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.
    // A stale entry will only re-use the `loading` boundary, not the full data.
    // This will trigger a "lazy fetch" for the full data.
    if (kind === "auto") {
        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {
            return PrefetchCacheEntryStatus.stale;
        }
    }
    // for "full" prefetching, we'll re-use the cache entry data for up to `static` staletime window.
    if (kind === "full") {
        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {
            return PrefetchCacheEntryStatus.reusable;
        }
    }
    return PrefetchCacheEntryStatus.expired;
} //# sourceMappingURL=prefetch-cache-utils.js.map
{  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/prefetch-cache-utils.ts"],"names":["createHrefFromUrl","fetchServerResponse","PrefetchCacheEntryStatus","PrefetchKind","prefetchQueue","createPrefetchCacheKey","url","nextUrl","pathnameFromUrl","getOrCreatePrefetchCacheEntry","param","tree","buildId","prefetchCache","kind","existingCacheEntry","undefined","interceptionCacheKey","interceptionData","get","prefetchCacheKey","prefetchData","status","getPrefetchEntryCacheStatus","switchedToFullPrefetch","FULL","createLazyPrefetchEntry","TEMPORARY","process","AUTO","prefixExistingPrefetchCacheEntry","existingCacheKey","newCacheKey","set","delete","createPrefetchCacheEntryForInitialLoad","data","intercept","prefetchEntry","treeAtTimeOfPrefetch","Promise","resolve","prefetchTime","Date","now","lastUsedTime","key","fresh","enqueue","then","prefetchResponse","intercepted","prunePrefetchCache","href","prefetchCacheEntry","expired","DYNAMIC_STALETIME_MS","Number","env","__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME","STATIC_STALETIME_MS","__NEXT_CLIENT_ROUTER_STATIC_STALETIME","reusable","stale"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,yBAAwB;AAC1D,SACEC,mBAAmB,QAEd,0BAAyB;AAChC,SACEC,wBAAwB,EAExBC,YAAY,QAEP,yBAAwB;AAC/B,SAASC,aAAa,QAAQ,8BAA6B;AAE3D;;;;;;CAMC,GACD,SAASC,uBAAuBC,GAAQ,EAAEC,OAAuB;IAC/D,MAAMC,kBAAkBR,kBACtBM,KAEA;IAGF,+FAA+F;IAC/F,IAAIC,SAAS;QACX,OAAOA,UAAW,MAAGC;IACvB;IAEA,OAAOA;AACT;AAEA;;;CAGC,GACD,OAAO,SAASC,8BAA8BC,KAa7C;IAb6C,IAAA,EAC5CJ,GAAG,EACHC,OAAO,EACPI,IAAI,EACJC,OAAO,EACPC,aAAa,EACbC,IAAI,EAOL,GAb6CJ;IAc5C,IAAIK,qBAAqDC;IACzD,8EAA8E;IAC9E,kJAAkJ;IAClJ,iIAAiI;IACjI,MAAMC,uBAAuBZ,uBAAuBC,KAAKC;IACzD,MAAMW,mBAAmBL,cAAcM,GAAG,CAACF;IAE3C,IAAIC,kBAAkB;QACpBH,qBAAqBG;IACvB,OAAO;QACL,2GAA2G;QAC3G,MAAME,mBAAmBf,uBAAuBC;QAChD,MAAMe,eAAeR,cAAcM,GAAG,CAACC;QACvC,IAAIC,cAAc;YAChBN,qBAAqBM;QACvB;IACF;IAEA,IAAIN,oBAAoB;QACtB,0DAA0D;QAC1DA,mBAAmBO,MAAM,GAAGC,4BAA4BR;QAExD,+DAA+D;QAC/D,qHAAqH;QACrH,MAAMS,yBACJT,mBAAmBD,IAAI,KAAKX,aAAasB,IAAI,IAC7CX,SAASX,aAAasB,IAAI;QAE5B,IAAID,wBAAwB;YAC1B,OAAOE,wBAAwB;gBAC7Bf;gBACAL;gBACAM;gBACAL;gBACAM;gBACA,8EAA8E;gBAC9E,2FAA2F;gBAC3F,kEAAkE;gBAClEC,MAAMA,QAAAA,OAAAA,OAAQX,aAAawB,SAAS;YACtC;QACF;QAEA,uHAAuH;QACvH,4IAA4I;QAC5I,IAAIb,QAAQC,mBAAmBD,IAAI,KAAKX,aAAawB,SAAS,EAAE;YAC9DZ,mBAAmBD,IAAI,GAAGA;QAC5B;QAEA,qFAAqF;QACrF,OAAOC;IACT;IAEA,kDAAkD;IAClD,OAAOW,wBAAwB;QAC7Bf;QACAL;QACAM;QACAL;QACAM;QACAC,MACEA,QACA,8EAA8E;QAC7Ec,CAAAA,AAnHP,iBAmHgC,gBACtBzB,aAAa0B,IAAI,GACjB1B,aAAawB,SAAS,AAATA;IACrB;AACF;AAEA;;;CAGC,GACD,SAASG,iCAAiCpB,KAMzC;IANyC,IAAA,EACxCJ,GAAG,EACHC,OAAO,EACPM,aAAa,EAGd,GANyCH;IAOxC,MAAMqB,mBAAmB1B,uBAAuBC;IAChD,MAAMS,qBAAqBF,cAAcM,GAAG,CAACY;IAC7C,IAAI,CAAChB,oBAAoB;QACvB,yCAAyC;QACzC;IACF;IAEA,MAAMiB,cAAc3B,uBAAuBC,KAAKC;IAChDM,cAAcoB,GAAG,CAACD,aAAajB;IAC/BF,cAAcqB,MAAM,CAACH;AACvB;AAEA;;CAEC,GACD,OAAO,SAASI,uCAAuCzB,KAWtD;IAXsD,IAAA,EACrDH,OAAO,EACPI,IAAI,EACJE,aAAa,EACbP,GAAG,EACHQ,IAAI,EACJsB,IAAI,EAKL,GAXsD1B;IAYrD,MAAM,OAAO2B,UAAU,GAAGD;IAC1B,qGAAqG;IACrG,MAAMhB,mBAAmBiB,YACrBhC,uBAAuBC,KAAKC,WAC5BF,uBAAuBC;IAE3B,MAAMgC,gBAAgB;QACpBC,sBAAsB5B;QACtByB,MAAMI,QAAQC,OAAO,CAACL;QACtBtB;QACA4B,cAAcC,KAAKC,GAAG;QACtBC,cAAcF,KAAKC,GAAG;QACtBE,KAAK1B;QACLE,QAAQpB,yBAAyB6C,KAAK;IACxC;IAEAlC,cAAcoB,GAAG,CAACb,kBAAkBkB;IAEpC,OAAOA;AACT;AAEA;;CAEC,GACD,SAASZ,wBAAwBhB,KAahC;IAbgC,IAAA,EAC/BJ,GAAG,EACHQ,IAAI,EACJH,IAAI,EACJJ,OAAO,EACPK,OAAO,EACPC,aAAa,EAOd,GAbgCH;IAc/B,MAAMU,mBAAmBf,uBAAuBC;IAEhD,uEAAuE;IACvE,6FAA6F;IAC7F,MAAM8B,OAAOhC,cAAc4C,OAAO,CAAC,IACjC/C,oBAAoBK,KAAKK,MAAMJ,SAASK,SAASE,MAAMmC,IAAI,CACzD,CAACC;YACC,+FAA+F;YAC/F,wDAAwD;YACxD,kEAAkE;YAClE,MAAM,OAAOC,YAAY,GAAGD;YAC5B,IAAIC,aAAa;gBACfrB,iCAAiC;oBAAExB;oBAAKC;oBAASM;gBAAc;YACjE;YAEA,OAAOqC;QACT;IAIJ,MAAMZ,gBAAgB;QACpBC,sBAAsB5B;QACtByB;QACAtB;QACA4B,cAAcC,KAAKC,GAAG;QACtBC,cAAc;QACdC,KAAK1B;QACLE,QAAQpB,yBAAyB6C,KAAK;IACxC;IAEAlC,cAAcoB,GAAG,CAACb,kBAAkBkB;IAEpC,OAAOA;AACT;AAEA,OAAO,SAASc,mBACdvC,aAAoD;IAEpD,KAAK,MAAM,CAACwC,MAAMC,mBAAmB,IAAIzC,cAAe;QACtD,IACEU,4BAA4B+B,wBAC5BpD,yBAAyBqD,OAAO,EAChC;YACA1C,cAAcqB,MAAM,CAACmB;QACvB;IACF;AACF;AAEA,8FAA8F;AAC9F,2DAA2D;AAC3D,MAAMG,uBACJC,OAAO7B,QAAQ8B,GAAG,CAACC,sCAAsC,IAAI;AAE/D,MAAMC,sBACJH,OAAO7B,QAAQ8B,GAAG,CAACG,qCAAqC,IAAI;AAE9D,SAAStC,4BAA4Bb,KAIhB;IAJgB,IAAA,EACnCI,IAAI,EACJ4B,YAAY,EACZG,YAAY,EACO,GAJgBnC;IAKnC,gFAAgF;IAChF,IAAIiC,KAAKC,GAAG,KAAK,AAACC,CAAAA,gBAAAA,OAAAA,eAAgBH,YAAAA,IAAgBc,sBAAsB;QACtE,OAAOX,eACH3C,yBAAyB4D,QAAQ,GACjC5D,yBAAyB6C,KAAK;IACpC;IAEA,sGAAsG;IACtG,4EAA4E;IAC5E,sDAAsD;IACtD,IAAIjC,SAAS,QAAQ;QACnB,IAAI6B,KAAKC,GAAG,KAAKF,eAAekB,qBAAqB;YACnD,OAAO1D,yBAAyB6D,KAAK;QACvC;IACF;IAEA,iGAAiG;IACjG,IAAIjD,SAAS,QAAQ;QACnB,IAAI6B,KAAKC,GAAG,KAAKF,eAAekB,qBAAqB;YACnD,OAAO1D,yBAAyB4D,QAAQ;QAC1C;IACF;IAEA,OAAO5D,yBAAyBqD,OAAO;AACzC","file":"x"}¬  false058undefined60121undefined123202undefined204263undefined585601__WEBPACK_MODULE_REFERENCE__4_5b226372656174654872656646726f6d55726c225d_call_directImport_asiSafe1__._undefined983989undefined39884017 falseundefined402140370undefined48644870undefined54765499__WEBPACK_MODULE_REFERENCE__3_5b2250726566657463684361636865456e747279537461747573225d_asiSafe1__._undefined70517057undefined75137562"30"undefined76087656"300"undefinedý   324426create_href_from_url_createHrefFromUrlundefined817845prefetch_cache_utils_getOrCreatePrefetchCacheEntryundefined52475345router_reducer_types/* PrefetchCacheEntryStatus */.T7undefined69066923prefetch_cache_utils_prunePrefetchCacheundefinedRawSourceu   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/prefetch-reducer.js
úÿÿúÿÿ  import { NEXT_RSC_UNION_QUERY } from "../../app-router-headers";
import { PromiseQueue } from "../../promise-queue";
import { getOrCreatePrefetchCacheEntry, prunePrefetchCache } from "../prefetch-cache-utils";
export const prefetchQueue = new PromiseQueue(5);
export function prefetchReducer(state, action) {
    // let's prune the prefetch cache before we do anything else
    prunePrefetchCache(state.prefetchCache);
    const { url } = action;
    url.searchParams.delete(NEXT_RSC_UNION_QUERY);
    getOrCreatePrefetchCacheEntry({
        url,
        nextUrl: state.nextUrl,
        prefetchCache: state.prefetchCache,
        kind: action.kind,
        tree: state.tree,
        buildId: state.buildId
    });
    return state;
} //# sourceMappingURL=prefetch-reducer.js.map
>  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/prefetch-reducer.ts"],"names":["NEXT_RSC_UNION_QUERY","PromiseQueue","getOrCreatePrefetchCacheEntry","prunePrefetchCache","prefetchQueue","prefetchReducer","state","action","prefetchCache","url","searchParams","delete","nextUrl","kind","tree","buildId"],"mappings":"AAKA,SAASA,oBAAoB,QAAQ,2BAA0B;AAC/D,SAASC,YAAY,QAAQ,sBAAqB;AAClD,SACEC,6BAA6B,EAC7BC,kBAAkB,QACb,0BAAyB;AAEhC,OAAO,MAAMC,gBAAgB,IAAIH,aAAa,GAAE;AAEhD,OAAO,SAASI,gBACdC,KAA2B,EAC3BC,MAAsB;IAEtB,4DAA4D;IAC5DJ,mBAAmBG,MAAME,aAAa;IAEtC,MAAM,EAAEC,GAAG,EAAE,GAAGF;IAChBE,IAAIC,YAAY,CAACC,MAAM,CAACX;IAExBE,8BAA8B;QAC5BO;QACAG,SAASN,MAAMM,OAAO;QACtBJ,eAAeF,MAAME,aAAa;QAClCK,MAAMN,OAAOM,IAAI;QACjBC,MAAMR,MAAMQ,IAAI;QAChBC,SAAST,MAAMS,OAAO;IACxB;IAEA,OAAOT;AACT","file":"x"}´   false063undefined65115undefined117208undefined210216undefined243254__WEBPACK_MODULE_REFERENCE__17_5b2250726f6d6973655175657565225d_directImport_asiSafe1__._undefined260266undefined|   921prefetch_reducer_prefetchQueueundefined29117PromiseQueueundefined132146prefetch_reducer_prefetchReducerundefinedRawSourcek   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/ppr-navigations.js
úÿÿúÿÿÑs  import { DEFAULT_SEGMENT_KEY, PAGE_SEGMENT_KEY } from "../../../shared/lib/segment";
import { matchSegment } from "../match-segments";
import { createRouterCacheKey } from "./create-router-cache-key";
// Creates a new Cache Node tree (i.e. copy-on-write) that represents the
// optimistic result of a navigation, using both the current Cache Node tree and
// data that was prefetched prior to navigation.
//
// At the moment we call this function, we haven't yet received the navigation
// response from the server. It could send back something completely different
// from the tree that was prefetched â€” due to rewrites, default routes, parallel
// routes, etc.
//
// But in most cases, it will return the same tree that we prefetched, just with
// the dynamic holes filled in. So we optimistically assume this will happen,
// and accept that the real result could be arbitrarily different.
//
// We'll reuse anything that was already in the previous tree, since that's what
// the server does.
//
// New segments (ones that don't appear in the old tree) are assigned an
// unresolved promise. The data for these promises will be fulfilled later, when
// the navigation response is received.
//
// The tree can be rendered immediately after it is created (that's why this is
// a synchronous function). Any new trees that do not have prefetch data will
// suspend during rendering, until the dynamic data streams in.
//
// Returns a Task object, which contains both the updated Cache Node and a path
// to the pending subtrees that need to be resolved by the navigation response.
//
// A return value of `null` means there were no changes, and the previous tree
// can be reused without initiating a server request.
export function updateCacheNodeOnNavigation(oldCacheNode, oldRouterState, newRouterState, prefetchData, prefetchHead) {
    // Diff the old and new trees to reuse the shared layouts.
    const oldRouterStateChildren = oldRouterState[1];
    const newRouterStateChildren = newRouterState[1];
    const prefetchDataChildren = prefetchData[1];
    const oldParallelRoutes = oldCacheNode.parallelRoutes;
    // Clone the current set of segment children, even if they aren't active in
    // the new tree.
    // TODO: We currently retain all the inactive segments indefinitely, until
    // there's an explicit refresh, or a parent layout is lazily refreshed. We
    // rely on this for popstate navigations, which update the Router State Tree
    // but do not eagerly perform a data fetch, because they expect the segment
    // data to already be in the Cache Node tree. For highly static sites that
    // are mostly read-only, this may happen only rarely, causing memory to
    // leak. We should figure out a better model for the lifetime of inactive
    // segments, so we can maintain instant back/forward navigations without
    // leaking memory indefinitely.
    const prefetchParallelRoutes = new Map(oldParallelRoutes);
    // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)
    // the Route Tree that was returned by the server â€” for example, in the case
    // of default parallel routes, we preserve the currently active segment. To
    // avoid mutating the original tree, we clone the router state children along
    // the return path.
    let patchedRouterStateChildren = {};
    let taskChildren = null;
    for(let parallelRouteKey in newRouterStateChildren){
        const newRouterStateChild = newRouterStateChildren[parallelRouteKey];
        const oldRouterStateChild = oldRouterStateChildren[parallelRouteKey];
        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);
        const prefetchDataChild = prefetchDataChildren[parallelRouteKey];
        const newSegmentChild = newRouterStateChild[0];
        const newSegmentKeyChild = createRouterCacheKey(newSegmentChild);
        const oldSegmentChild = oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined;
        const oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;
        let taskChild;
        if (newSegmentChild === PAGE_SEGMENT_KEY) {
            // This is a leaf segment â€” a page, not a shared layout. We always apply
            // its data.
            taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);
        } else if (newSegmentChild === DEFAULT_SEGMENT_KEY) {
            // This is another kind of leaf segment â€” a default route.
            //
            // Default routes have special behavior. When there's no matching segment
            // for a parallel route, Next.js preserves the currently active segment
            // during a client navigation â€” but not for initial render. The server
            // leaves it to the client to account for this. So we need to handle
            // it here.
            if (oldRouterStateChild !== undefined) {
                // Reuse the existing Router State for this segment. We spawn a "task"
                // just to keep track of the updated router state; unlike most, it's
                // already fulfilled and won't be affected by the dynamic response.
                taskChild = spawnReusedTask(oldRouterStateChild);
            } else {
                // There's no currently active segment. Switch to the "create" path.
                taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);
            }
        } else if (oldSegmentChild !== undefined && matchSegment(newSegmentChild, oldSegmentChild)) {
            if (oldCacheNodeChild !== undefined && oldRouterStateChild !== undefined) {
                // This segment exists in both the old and new trees.
                if (prefetchDataChild !== undefined && prefetchDataChild !== null) {
                    // Recursively update the children.
                    taskChild = updateCacheNodeOnNavigation(oldCacheNodeChild, oldRouterStateChild, newRouterStateChild, prefetchDataChild, prefetchHead);
                } else {
                    // The server didn't send any prefetch data for this segment. This
                    // shouldn't happen because the Route Tree and the Seed Data tree
                    // should always be the same shape, but until we unify those types
                    // it's still possible. For now we're going to deopt and trigger a
                    // lazy fetch during render.
                    taskChild = spawnTaskForMissingData(newRouterStateChild);
                }
            } else {
                // Either there's no existing Cache Node for this segment, or this
                // segment doesn't exist in the old Router State tree. Switch to the
                // "create" path.
                taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);
            }
        } else {
            // This is a new tree. Switch to the "create" path.
            taskChild = spawnPendingTask(newRouterStateChild, prefetchDataChild !== undefined ? prefetchDataChild : null, prefetchHead);
        }
        if (taskChild !== null) {
            // Something changed in the child tree. Keep track of the child task.
            if (taskChildren === null) {
                taskChildren = new Map();
            }
            taskChildren.set(parallelRouteKey, taskChild);
            const newCacheNodeChild = taskChild.node;
            if (newCacheNodeChild !== null) {
                const newSegmentMapChild = new Map(oldSegmentMapChild);
                newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);
                prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild);
            }
            // The child tree's route state may be different from the prefetched
            // route sent by the server. We need to clone it as we traverse back up
            // the tree.
            patchedRouterStateChildren[parallelRouteKey] = taskChild.route;
        } else {
            // The child didn't change. We can use the prefetched router state.
            patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild;
        }
    }
    if (taskChildren === null) {
        // No new tasks were spawned.
        return null;
    }
    const newCacheNode = {
        lazyData: null,
        rsc: oldCacheNode.rsc,
        // We intentionally aren't updating the prefetchRsc field, since this node
        // is already part of the current tree, because it would be weird for
        // prefetch data to be newer than the final data. It probably won't ever be
        // observable anyway, but it could happen if the segment is unmounted then
        // mounted again, because LayoutRouter will momentarily switch to rendering
        // prefetchRsc, via useDeferredValue.
        prefetchRsc: oldCacheNode.prefetchRsc,
        head: oldCacheNode.head,
        prefetchHead: oldCacheNode.prefetchHead,
        loading: oldCacheNode.loading,
        // Everything is cloned except for the children, which we computed above.
        parallelRoutes: prefetchParallelRoutes,
        lazyDataResolved: false
    };
    return {
        // Return a cloned copy of the router state with updated children.
        route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),
        node: newCacheNode,
        children: taskChildren
    };
}
function patchRouterStateWithNewChildren(baseRouterState, newChildren) {
    const clone = [
        baseRouterState[0],
        newChildren
    ];
    // Based on equivalent logic in apply-router-state-patch-to-tree, but should
    // confirm whether we need to copy all of these fields. Not sure the server
    // ever sends, e.g. the refetch marker.
    if (2 in baseRouterState) {
        clone[2] = baseRouterState[2];
    }
    if (3 in baseRouterState) {
        clone[3] = baseRouterState[3];
    }
    if (4 in baseRouterState) {
        clone[4] = baseRouterState[4];
    }
    return clone;
}
function spawnPendingTask(routerState, prefetchData, prefetchHead) {
    // Create a task that will later be fulfilled by data from the server.
    const pendingCacheNode = createPendingCacheNode(routerState, prefetchData, prefetchHead);
    return {
        route: routerState,
        node: pendingCacheNode,
        children: null
    };
}
function spawnReusedTask(reusedRouterState) {
    // Create a task that reuses an existing segment, e.g. when reusing
    // the current active segment in place of a default route.
    return {
        route: reusedRouterState,
        node: null,
        children: null
    };
}
function spawnTaskForMissingData(routerState) {
    // Create a task for a new subtree that wasn't prefetched by the server.
    // This shouldn't really ever happen but it's here just in case the Seed Data
    // Tree and the Router State Tree disagree unexpectedly.
    const pendingCacheNode = createPendingCacheNode(routerState, null, null);
    return {
        route: routerState,
        node: pendingCacheNode,
        children: null
    };
}
// Writes a dynamic server response into the tree created by
// updateCacheNodeOnNavigation. All pending promises that were spawned by the
// navigation will be resolved, either with dynamic data from the server, or
// `null` to indicate that the data is missing.
//
// A `null` value will trigger a lazy fetch during render, which will then patch
// up the tree using the same mechanism as the non-PPR implementation
// (serverPatchReducer).
//
// Usually, the server will respond with exactly the subset of data that we're
// waiting for â€” everything below the nearest shared layout. But technically,
// the server can return anything it wants.
//
// This does _not_ create a new tree; it modifies the existing one in place.
// Which means it must follow the Suspense rules of cache safety.
export function listenForDynamicRequest(task, responsePromise) {
    responsePromise.then((response)=>{
        const flightData = response[0];
        for (const flightDataPath of flightData){
            const segmentPath = flightDataPath.slice(0, -3);
            const serverRouterState = flightDataPath[flightDataPath.length - 3];
            const dynamicData = flightDataPath[flightDataPath.length - 2];
            const dynamicHead = flightDataPath[flightDataPath.length - 1];
            if (typeof segmentPath === "string") {
                continue;
            }
            writeDynamicDataIntoPendingTask(task, segmentPath, serverRouterState, dynamicData, dynamicHead);
        }
        // Now that we've exhausted all the data we received from the server, if
        // there are any remaining pending tasks in the tree, abort them now.
        // If there's any missing data, it will trigger a lazy fetch.
        abortTask(task, null);
    }, (error)=>{
        // This will trigger an error during render
        abortTask(task, error);
    });
}
function writeDynamicDataIntoPendingTask(rootTask, segmentPath, serverRouterState, dynamicData, dynamicHead) {
    // The data sent by the server represents only a subtree of the app. We need
    // to find the part of the task tree that matches the server response, and
    // fulfill it using the dynamic data.
    //
    // segmentPath represents the parent path of subtree. It's a repeating pattern
    // of parallel route key and segment:
    //
    //   [string, Segment, string, Segment, string, Segment, ...]
    //
    // Iterate through the path and finish any tasks that match this payload.
    let task = rootTask;
    for(let i = 0; i < segmentPath.length; i += 2){
        const parallelRouteKey = segmentPath[i];
        const segment = segmentPath[i + 1];
        const taskChildren = task.children;
        if (taskChildren !== null) {
            const taskChild = taskChildren.get(parallelRouteKey);
            if (taskChild !== undefined) {
                const taskSegment = taskChild.route[0];
                if (matchSegment(segment, taskSegment)) {
                    // Found a match for this task. Keep traversing down the task tree.
                    task = taskChild;
                    continue;
                }
            }
        }
        // We didn't find a child task that matches the server data. Exit. We won't
        // abort the task, though, because a different FlightDataPath may be able to
        // fulfill it (see loop in listenForDynamicRequest). We only abort tasks
        // once we've run out of data.
        return;
    }
    finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead);
}
function finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead) {
    // dynamicData may represent a larger subtree than the task. Before we can
    // finish the task, we need to line them up.
    const taskChildren = task.children;
    const taskNode = task.node;
    if (taskChildren === null) {
        // We've reached the leaf node of the pending task. The server data tree
        // lines up the pending Cache Node tree. We can now switch to the
        // normal algorithm.
        if (taskNode !== null) {
            finishPendingCacheNode(taskNode, task.route, serverRouterState, dynamicData, dynamicHead);
            // Null this out to indicate that the task is complete.
            task.node = null;
        }
        return;
    }
    // The server returned more data than we need to finish the task. Skip over
    // the extra segments until we reach the leaf task node.
    const serverChildren = serverRouterState[1];
    const dynamicDataChildren = dynamicData[1];
    for(const parallelRouteKey in serverRouterState){
        const serverRouterStateChild = serverChildren[parallelRouteKey];
        const dynamicDataChild = dynamicDataChildren[parallelRouteKey];
        const taskChild = taskChildren.get(parallelRouteKey);
        if (taskChild !== undefined) {
            const taskSegment = taskChild.route[0];
            if (matchSegment(serverRouterStateChild[0], taskSegment) && dynamicDataChild !== null && dynamicDataChild !== undefined) {
                // Found a match for this task. Keep traversing down the task tree.
                return finishTaskUsingDynamicDataPayload(taskChild, serverRouterStateChild, dynamicDataChild, dynamicHead);
            }
        }
    // We didn't find a child task that matches the server data. We won't abort
    // the task, though, because a different FlightDataPath may be able to
    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks
    // once we've run out of data.
    }
}
function createPendingCacheNode(routerState, prefetchData, prefetchHead) {
    const routerStateChildren = routerState[1];
    const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null;
    const parallelRoutes = new Map();
    for(let parallelRouteKey in routerStateChildren){
        const routerStateChild = routerStateChildren[parallelRouteKey];
        const prefetchDataChild = prefetchDataChildren !== null ? prefetchDataChildren[parallelRouteKey] : null;
        const segmentChild = routerStateChild[0];
        const segmentKeyChild = createRouterCacheKey(segmentChild);
        const newCacheNodeChild = createPendingCacheNode(routerStateChild, prefetchDataChild === undefined ? null : prefetchDataChild, prefetchHead);
        const newSegmentMapChild = new Map();
        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);
        parallelRoutes.set(parallelRouteKey, newSegmentMapChild);
    }
    // The head is assigned to every leaf segment delivered by the server. Based
    // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts
    const isLeafSegment = parallelRoutes.size === 0;
    const maybePrefetchRsc = prefetchData !== null ? prefetchData[2] : null;
    const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null;
    return {
        lazyData: null,
        parallelRoutes: parallelRoutes,
        prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,
        prefetchHead: isLeafSegment ? prefetchHead : null,
        loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,
        // Create a deferred promise. This will be fulfilled once the dynamic
        // response is received from the server.
        rsc: createDeferredRsc(),
        head: isLeafSegment ? createDeferredRsc() : null,
        lazyDataResolved: false
    };
}
function finishPendingCacheNode(cacheNode, taskState, serverState, dynamicData, dynamicHead) {
    // Writes a dynamic response into an existing Cache Node tree. This does _not_
    // create a new tree, it updates the existing tree in-place. So it must follow
    // the Suspense rules of cache safety â€” it can resolve pending promises, but
    // it cannot overwrite existing data. It can add segments to the tree (because
    // a missing segment will cause the layout router to suspend).
    // but it cannot delete them.
    //
    // We must resolve every promise in the tree, or else it will suspend
    // indefinitely. If we did not receive data for a segment, we will resolve its
    // data promise to `null` to trigger a lazy fetch during render.
    const taskStateChildren = taskState[1];
    const serverStateChildren = serverState[1];
    const dataChildren = dynamicData[1];
    // The router state that we traverse the tree with (taskState) is the same one
    // that we used to construct the pending Cache Node tree. That way we're sure
    // to resolve all the pending promises.
    const parallelRoutes = cacheNode.parallelRoutes;
    for(let parallelRouteKey in taskStateChildren){
        const taskStateChild = taskStateChildren[parallelRouteKey];
        const serverStateChild = serverStateChildren[parallelRouteKey];
        const dataChild = dataChildren[parallelRouteKey];
        const segmentMapChild = parallelRoutes.get(parallelRouteKey);
        const taskSegmentChild = taskStateChild[0];
        const taskSegmentKeyChild = createRouterCacheKey(taskSegmentChild);
        const cacheNodeChild = segmentMapChild !== undefined ? segmentMapChild.get(taskSegmentKeyChild) : undefined;
        if (cacheNodeChild !== undefined) {
            if (serverStateChild !== undefined && matchSegment(taskSegmentChild, serverStateChild[0])) {
                if (dataChild !== undefined && dataChild !== null) {
                    // This is the happy path. Recursively update all the children.
                    finishPendingCacheNode(cacheNodeChild, taskStateChild, serverStateChild, dataChild, dynamicHead);
                } else {
                    // The server never returned data for this segment. Trigger a lazy
                    // fetch during render. This shouldn't happen because the Route Tree
                    // and the Seed Data tree sent by the server should always be the same
                    // shape when part of the same server response.
                    abortPendingCacheNode(taskStateChild, cacheNodeChild, null);
                }
            } else {
                // The server never returned data for this segment. Trigger a lazy
                // fetch during render.
                abortPendingCacheNode(taskStateChild, cacheNodeChild, null);
            }
        } else {
        // The server response matches what was expected to receive, but there's
        // no matching Cache Node in the task tree. This is a bug in the
        // implementation because we should have created a node for every
        // segment in the tree that's associated with this task.
        }
    }
    // Use the dynamic data from the server to fulfill the deferred RSC promise
    // on the Cache Node.
    const rsc = cacheNode.rsc;
    const dynamicSegmentData = dynamicData[2];
    if (rsc === null) {
        // This is a lazy cache node. We can overwrite it. This is only safe
        // because we know that the LayoutRouter suspends if `rsc` is `null`.
        cacheNode.rsc = dynamicSegmentData;
    } else if (isDeferredRsc(rsc)) {
        // This is a deferred RSC promise. We can fulfill it with the data we just
        // received from the server. If it was already resolved by a different
        // navigation, then this does nothing because we can't overwrite data.
        rsc.resolve(dynamicSegmentData);
    } else {
    // This is not a deferred RSC promise, nor is it empty, so it must have
    // been populated by a different navigation. We must not overwrite it.
    }
    // Check if this is a leaf segment. If so, it will have a `head` property with
    // a pending promise that needs to be resolved with the dynamic head from
    // the server.
    const head = cacheNode.head;
    if (isDeferredRsc(head)) {
        head.resolve(dynamicHead);
    }
}
export function abortTask(task, error) {
    const cacheNode = task.node;
    if (cacheNode === null) {
        // This indicates the task is already complete.
        return;
    }
    const taskChildren = task.children;
    if (taskChildren === null) {
        // Reached the leaf task node. This is the root of a pending cache
        // node tree.
        abortPendingCacheNode(task.route, cacheNode, error);
    } else {
        // This is an intermediate task node. Keep traversing until we reach a
        // task node with no children. That will be the root of the cache node tree
        // that needs to be resolved.
        for (const taskChild of taskChildren.values()){
            abortTask(taskChild, error);
        }
    }
    // Null this out to indicate that the task is complete.
    task.node = null;
}
function abortPendingCacheNode(routerState, cacheNode, error) {
    // For every pending segment in the tree, resolve its `rsc` promise to `null`
    // to trigger a lazy fetch during render.
    //
    // Or, if an error object is provided, it will error instead.
    const routerStateChildren = routerState[1];
    const parallelRoutes = cacheNode.parallelRoutes;
    for(let parallelRouteKey in routerStateChildren){
        const routerStateChild = routerStateChildren[parallelRouteKey];
        const segmentMapChild = parallelRoutes.get(parallelRouteKey);
        if (segmentMapChild === undefined) {
            continue;
        }
        const segmentChild = routerStateChild[0];
        const segmentKeyChild = createRouterCacheKey(segmentChild);
        const cacheNodeChild = segmentMapChild.get(segmentKeyChild);
        if (cacheNodeChild !== undefined) {
            abortPendingCacheNode(routerStateChild, cacheNodeChild, error);
        } else {
        // This shouldn't happen because we're traversing the same tree that was
        // used to construct the cache nodes in the first place.
        }
    }
    const rsc = cacheNode.rsc;
    if (isDeferredRsc(rsc)) {
        if (error === null) {
            // This will trigger a lazy fetch during render.
            rsc.resolve(null);
        } else {
            // This will trigger an error during rendering.
            rsc.reject(error);
        }
    }
    // Check if this is a leaf segment. If so, it will have a `head` property with
    // a pending promise that needs to be resolved. If an error was provided, we
    // will not resolve it with an error, since this is rendered at the root of
    // the app. We want the segment to error, not the entire app.
    const head = cacheNode.head;
    if (isDeferredRsc(head)) {
        head.resolve(null);
    }
}
export function updateCacheNodeOnPopstateRestoration(oldCacheNode, routerState) {
    // A popstate navigation reads data from the local cache. It does not issue
    // new network requests (unless the cache entries have been evicted). So, we
    // update the cache to drop the prefetch  data for any segment whose dynamic
    // data was already received. This prevents an unnecessary flash back to PPR
    // state during a back/forward navigation.
    //
    // This function clones the entire cache node tree and sets the `prefetchRsc`
    // field to `null` to prevent it from being rendered. We can't mutate the node
    // in place because this is a concurrent data structure.
    const routerStateChildren = routerState[1];
    const oldParallelRoutes = oldCacheNode.parallelRoutes;
    const newParallelRoutes = new Map(oldParallelRoutes);
    for(let parallelRouteKey in routerStateChildren){
        const routerStateChild = routerStateChildren[parallelRouteKey];
        const segmentChild = routerStateChild[0];
        const segmentKeyChild = createRouterCacheKey(segmentChild);
        const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);
        if (oldSegmentMapChild !== undefined) {
            const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild);
            if (oldCacheNodeChild !== undefined) {
                const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(oldCacheNodeChild, routerStateChild);
                const newSegmentMapChild = new Map(oldSegmentMapChild);
                newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);
                newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);
            }
        }
    }
    // Only show prefetched data if the dynamic data is still pending.
    //
    // Tehnically, what we're actually checking is whether the dynamic network
    // response was received. But since it's a streaming response, this does not
    // mean that all the dynamic data has fully streamed in. It just means that
    // _some_ of the dynamic data was received. But as a heuristic, we assume that
    // the rest dynamic data will stream in quickly, so it's still better to skip
    // the prefetch state.
    const rsc = oldCacheNode.rsc;
    const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === "pending";
    return {
        lazyData: null,
        rsc,
        head: oldCacheNode.head,
        prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : null,
        prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,
        loading: shouldUsePrefetch ? oldCacheNode.loading : null,
        // These are the cloned children we computed above
        parallelRoutes: newParallelRoutes,
        lazyDataResolved: false
    };
}
const DEFERRED = Symbol();
// This type exists to distinguish a DeferredRsc from a Flight promise. It's a
// compromise to avoid adding an extra field on every Cache Node, which would be
// awkward because the pre-PPR parts of codebase would need to account for it,
// too. We can remove it once type Cache Node type is more settled.
function isDeferredRsc(value) {
    return value && value.tag === DEFERRED;
}
function createDeferredRsc() {
    let resolve;
    let reject;
    const pendingRsc = new Promise((res, rej)=>{
        resolve = res;
        reject = rej;
    });
    pendingRsc.status = "pending";
    pendingRsc.resolve = (value)=>{
        if (pendingRsc.status === "pending") {
            const fulfilledRsc = pendingRsc;
            fulfilledRsc.status = "fulfilled";
            fulfilledRsc.value = value;
            resolve(value);
        }
    };
    pendingRsc.reject = (error)=>{
        if (pendingRsc.status === "pending") {
            const rejectedRsc = pendingRsc;
            rejectedRsc.status = "rejected";
            rejectedRsc.reason = error;
            reject(error);
        }
    };
    pendingRsc.tag = DEFERRED;
    return pendingRsc;
} //# sourceMappingURL=ppr-navigations.js.map
)6  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/ppr-navigations.ts"],"names":["DEFAULT_SEGMENT_KEY","PAGE_SEGMENT_KEY","matchSegment","createRouterCacheKey","updateCacheNodeOnNavigation","oldCacheNode","oldRouterState","newRouterState","prefetchData","prefetchHead","oldRouterStateChildren","newRouterStateChildren","prefetchDataChildren","oldParallelRoutes","parallelRoutes","prefetchParallelRoutes","Map","patchedRouterStateChildren","taskChildren","parallelRouteKey","newRouterStateChild","oldRouterStateChild","oldSegmentMapChild","get","prefetchDataChild","newSegmentChild","newSegmentKeyChild","oldSegmentChild","undefined","oldCacheNodeChild","taskChild","spawnPendingTask","spawnReusedTask","spawnTaskForMissingData","set","newCacheNodeChild","node","newSegmentMapChild","route","newCacheNode","lazyData","rsc","prefetchRsc","head","loading","lazyDataResolved","patchRouterStateWithNewChildren","children","baseRouterState","newChildren","clone","routerState","pendingCacheNode","createPendingCacheNode","reusedRouterState","listenForDynamicRequest","task","responsePromise","then","response","flightData","flightDataPath","segmentPath","slice","serverRouterState","length","dynamicData","dynamicHead","writeDynamicDataIntoPendingTask","abortTask","error","rootTask","i","segment","taskSegment","finishTaskUsingDynamicDataPayload","taskNode","finishPendingCacheNode","serverChildren","dynamicDataChildren","serverRouterStateChild","dynamicDataChild","routerStateChildren","routerStateChild","segmentChild","segmentKeyChild","isLeafSegment","size","maybePrefetchRsc","maybePrefetchLoading","createDeferredRsc","cacheNode","taskState","serverState","taskStateChildren","serverStateChildren","dataChildren","taskStateChild","serverStateChild","dataChild","segmentMapChild","taskSegmentChild","taskSegmentKeyChild","cacheNodeChild","abortPendingCacheNode","dynamicSegmentData","isDeferredRsc","resolve","values","reject","updateCacheNodeOnPopstateRestoration","newParallelRoutes","shouldUsePrefetch","status","DEFERRED","Symbol","value","tag","pendingRsc","Promise","res","rej","fulfilledRsc","rejectedRsc","reason"],"mappings":"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","file":"x"}x   false083undefined85133undefined135199undefined17171723undefined1200112007undefined2295722963undefined2562325629undefined»   15281554ppr_navigations_updateCacheNodeOnNavigationundefined57785804ppr_navigations_updateCacheNodeOnNavigationundefined1180511827ppr_navigations_listenForDynamicRequestundefinedRawSourceu   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/navigate-reducer.js
ýùÿÿúÿÿÙN  import { fetchServerResponse } from "../fetch-server-response";
import { createHrefFromUrl } from "../create-href-from-url";
import { invalidateCacheBelowFlightSegmentPath } from "../invalidate-cache-below-flight-segmentpath";
import { applyRouterStatePatchToTree } from "../apply-router-state-patch-to-tree";
import { shouldHardNavigate } from "../should-hard-navigate";
import { isNavigatingToNewRootLayout } from "../is-navigating-to-new-root-layout";
import { PrefetchCacheEntryStatus } from "../router-reducer-types";
import { handleMutable } from "../handle-mutable";
import { applyFlightData } from "../apply-flight-data";
import { prefetchQueue } from "./prefetch-reducer";
import { createEmptyCacheNode } from "../../app-router";
import { DEFAULT_SEGMENT_KEY } from "../../../../shared/lib/segment";
import { listenForDynamicRequest, updateCacheNodeOnNavigation } from "../ppr-navigations";
import { getOrCreatePrefetchCacheEntry, prunePrefetchCache } from "../prefetch-cache-utils";
import { clearCacheNodeDataForSegmentPath } from "../clear-cache-node-data-for-segment-path";
export function handleExternalUrl(state, mutable, url, pendingPush) {
    mutable.mpaNavigation = true;
    mutable.canonicalUrl = url;
    mutable.pendingPush = pendingPush;
    mutable.scrollableSegments = undefined;
    return handleMutable(state, mutable);
}
function generateSegmentsFromPatch(flightRouterPatch) {
    const segments = [];
    const [segment, parallelRoutes] = flightRouterPatch;
    if (Object.keys(parallelRoutes).length === 0) {
        return [
            [
                segment
            ]
        ];
    }
    for (const [parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){
        for (const childSegment of generateSegmentsFromPatch(parallelRoute)){
            // If the segment is empty, it means we are at the root of the tree
            if (segment === "") {
                segments.push([
                    parallelRouteKey,
                    ...childSegment
                ]);
            } else {
                segments.push([
                    segment,
                    parallelRouteKey,
                    ...childSegment
                ]);
            }
        }
    }
    return segments;
}
function triggerLazyFetchForLeafSegments(newCache, currentCache, flightSegmentPath, treePatch) {
    let appliedPatch = false;
    newCache.rsc = currentCache.rsc;
    newCache.prefetchRsc = currentCache.prefetchRsc;
    newCache.loading = currentCache.loading;
    newCache.parallelRoutes = new Map(currentCache.parallelRoutes);
    const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map((segment)=>[
            ...flightSegmentPath,
            ...segment
        ]);
    for (const segmentPaths of segmentPathsToFill){
        clearCacheNodeDataForSegmentPath(newCache, currentCache, segmentPaths);
        appliedPatch = true;
    }
    return appliedPatch;
}
// These implementations are expected to diverge significantly, so I've forked
// the entire function. The one that's disabled should be dead code eliminated
// because the check here is statically inlined at build time.
export const navigateReducer = process.env.__NEXT_PPR ? navigateReducer_PPR : navigateReducer_noPPR;
// This is the implementation when PPR is disabled. We can assume its behavior
// is relatively stable because it's been running in production for a while.
function navigateReducer_noPPR(state, action) {
    const { url, isExternalUrl, navigateType, shouldScroll } = action;
    const mutable = {};
    const { hash } = url;
    const href = createHrefFromUrl(url);
    const pendingPush = navigateType === "push";
    // we want to prune the prefetch cache on every navigation to avoid it growing too large
    prunePrefetchCache(state.prefetchCache);
    mutable.preserveCustomHistoryState = false;
    if (isExternalUrl) {
        return handleExternalUrl(state, mutable, url.toString(), pendingPush);
    }
    const prefetchValues = getOrCreatePrefetchCacheEntry({
        url,
        nextUrl: state.nextUrl,
        tree: state.tree,
        buildId: state.buildId,
        prefetchCache: state.prefetchCache
    });
    const { treeAtTimeOfPrefetch, data } = prefetchValues;
    prefetchQueue.bump(data);
    return data.then((param)=>{
        let [flightData, canonicalUrlOverride] = param;
        let isFirstRead = false;
        // we only want to mark this once
        if (!prefetchValues.lastUsedTime) {
            // important: we should only mark the cache node as dirty after we unsuspend from the call above
            prefetchValues.lastUsedTime = Date.now();
            isFirstRead = true;
        }
        // Handle case when navigating to page in `pages` from `app`
        if (typeof flightData === "string") {
            return handleExternalUrl(state, mutable, flightData, pendingPush);
        }
        // Handles case where `<meta http-equiv="refresh">` tag is present,
        // which will trigger an MPA navigation.
        if (document.getElementById("__next-page-redirect")) {
            return handleExternalUrl(state, mutable, href, pendingPush);
        }
        let currentTree = state.tree;
        let currentCache = state.cache;
        let scrollableSegments = [];
        for (const flightDataPath of flightData){
            const flightSegmentPath = flightDataPath.slice(0, -4);
            // The one before last item is the router state tree patch
            const treePatch = flightDataPath.slice(-3)[0];
            // TODO-APP: remove ''
            const flightSegmentPathWithLeadingEmpty = [
                "",
                ...flightSegmentPath
            ];
            // Create new tree based on the flightSegmentPath and router state patch
            let newTree = applyRouterStatePatchToTree(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);
            // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch
            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.
            if (newTree === null) {
                newTree = applyRouterStatePatchToTree(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);
            }
            if (newTree !== null) {
                if (isNavigatingToNewRootLayout(currentTree, newTree)) {
                    return handleExternalUrl(state, mutable, href, pendingPush);
                }
                const cache = createEmptyCacheNode();
                let applied = false;
                if (prefetchValues.status === PrefetchCacheEntryStatus.stale && !isFirstRead) {
                    // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations
                    // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,
                    // while copying over the `loading` for the segment that contains the page data.
                    // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.
                    applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);
                    // since we re-used the stale cache's loading state & refreshed the data,
                    // update the `lastUsedTime` so that it can continue to be re-used for the next 30s
                    prefetchValues.lastUsedTime = Date.now();
                } else {
                    applied = applyFlightData(currentCache, cache, flightDataPath, prefetchValues);
                }
                const hardNavigate = shouldHardNavigate(flightSegmentPathWithLeadingEmpty, currentTree);
                if (hardNavigate) {
                    // Copy rsc for the root node of the cache.
                    cache.rsc = currentCache.rsc;
                    cache.prefetchRsc = currentCache.prefetchRsc;
                    invalidateCacheBelowFlightSegmentPath(cache, currentCache, flightSegmentPath);
                    // Ensure the existing cache value is used when the cache was not invalidated.
                    mutable.cache = cache;
                } else if (applied) {
                    mutable.cache = cache;
                    // If we applied the cache, we update the "current cache" value so any other
                    // segments in the FlightDataPath will be able to reference the updated cache.
                    currentCache = cache;
                }
                currentTree = newTree;
                for (const subSegment of generateSegmentsFromPatch(treePatch)){
                    const scrollableSegmentPath = [
                        ...flightSegmentPath,
                        ...subSegment
                    ];
                    // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.
                    if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== DEFAULT_SEGMENT_KEY) {
                        scrollableSegments.push(scrollableSegmentPath);
                    }
                }
            }
        }
        mutable.patchedTree = currentTree;
        mutable.canonicalUrl = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : href;
        mutable.pendingPush = pendingPush;
        mutable.scrollableSegments = scrollableSegments;
        mutable.hashFragment = hash;
        mutable.shouldScroll = shouldScroll;
        return handleMutable(state, mutable);
    }, ()=>state);
}
// This is the experimental PPR implementation. It's closer to the behavior we
// want, but is likelier to include accidental regressions because it rewrites
// existing functionality.
function navigateReducer_PPR(state, action) {
    const { url, isExternalUrl, navigateType, shouldScroll } = action;
    const mutable = {};
    const { hash } = url;
    const href = createHrefFromUrl(url);
    const pendingPush = navigateType === "push";
    // we want to prune the prefetch cache on every navigation to avoid it growing too large
    prunePrefetchCache(state.prefetchCache);
    mutable.preserveCustomHistoryState = false;
    if (isExternalUrl) {
        return handleExternalUrl(state, mutable, url.toString(), pendingPush);
    }
    const prefetchValues = getOrCreatePrefetchCacheEntry({
        url,
        nextUrl: state.nextUrl,
        tree: state.tree,
        buildId: state.buildId,
        prefetchCache: state.prefetchCache
    });
    const { treeAtTimeOfPrefetch, data } = prefetchValues;
    prefetchQueue.bump(data);
    return data.then((param)=>{
        let [flightData, canonicalUrlOverride, _postponed] = param;
        let isFirstRead = false;
        // we only want to mark this once
        if (!prefetchValues.lastUsedTime) {
            // important: we should only mark the cache node as dirty after we unsuspend from the call above
            prefetchValues.lastUsedTime = Date.now();
            isFirstRead = true;
        }
        // Handle case when navigating to page in `pages` from `app`
        if (typeof flightData === "string") {
            return handleExternalUrl(state, mutable, flightData, pendingPush);
        }
        // Handles case where `<meta http-equiv="refresh">` tag is present,
        // which will trigger an MPA navigation.
        if (document.getElementById("__next-page-redirect")) {
            return handleExternalUrl(state, mutable, href, pendingPush);
        }
        let currentTree = state.tree;
        let currentCache = state.cache;
        let scrollableSegments = [];
        // TODO: In practice, this is always a single item array. We probably
        // aren't going to every send multiple segments, at least not in this
        // format. So we could remove the extra wrapper for now until
        // that settles.
        for (const flightDataPath of flightData){
            const flightSegmentPath = flightDataPath.slice(0, -4);
            // The one before last item is the router state tree patch
            const treePatch = flightDataPath.slice(-3)[0];
            // TODO-APP: remove ''
            const flightSegmentPathWithLeadingEmpty = [
                "",
                ...flightSegmentPath
            ];
            // Create new tree based on the flightSegmentPath and router state patch
            let newTree = applyRouterStatePatchToTree(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);
            // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch
            // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.
            if (newTree === null) {
                newTree = applyRouterStatePatchToTree(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);
            }
            if (newTree !== null) {
                if (isNavigatingToNewRootLayout(currentTree, newTree)) {
                    return handleExternalUrl(state, mutable, href, pendingPush);
                }
                if (// will always send back a static response that's rendered from
                // the root. If for some reason it doesn't, we fall back to the
                // non-PPR implementation.
                // TODO: We should get rid of the else branch and do all navigations
                // via updateCacheNodeOnNavigation. The current structure is just
                // an incremental step.
                flightDataPath.length === 3) {
                    const prefetchedTree = flightDataPath[0];
                    const seedData = flightDataPath[1];
                    const head = flightDataPath[2];
                    const task = updateCacheNodeOnNavigation(currentCache, currentTree, prefetchedTree, seedData, head);
                    if (task !== null && task.node !== null) {
                        // We've created a new Cache Node tree that contains a prefetched
                        // version of the next page. This can be rendered instantly.
                        // Use the tree computed by updateCacheNodeOnNavigation instead
                        // of the one computed by applyRouterStatePatchToTree.
                        // TODO: We should remove applyRouterStatePatchToTree
                        // from the PPR path entirely.
                        const patchedRouterState = task.route;
                        newTree = patchedRouterState;
                        const newCache = task.node;
                        // The prefetched tree has dynamic holes in it. We initiate a
                        // dynamic request to fill them in.
                        //
                        // Do not block on the result. We'll immediately render the Cache
                        // Node tree and suspend on the dynamic parts. When the request
                        // comes in, we'll fill in missing data and ping React to
                        // re-render. Unlike the lazy fetching model in the non-PPR
                        // implementation, this is modeled as a single React update +
                        // streaming, rather than multiple top-level updates. (However,
                        // even in the new model, we'll still need to sometimes update the
                        // root multiple times per navigation, like if the server sends us
                        // a different response than we expected. For now, we revert back
                        // to the lazy fetching mechanism in that case.)
                        listenForDynamicRequest(task, fetchServerResponse(url, currentTree, state.nextUrl, state.buildId));
                        mutable.cache = newCache;
                    } else {
                        // Nothing changed, so reuse the old cache.
                        // TODO: What if the head changed but not any of the segment data?
                        // Is that possible? If so, we should clone the whole tree and
                        // update the head.
                        newTree = prefetchedTree;
                    }
                } else {
                    // The static response does not include any dynamic holes, so
                    // there's no need to do a second request.
                    // TODO: As an incremental step this just reverts back to the
                    // non-PPR implementation. We can simplify this branch further,
                    // given that PPR prefetches are always static and return the whole
                    // tree. Or in the meantime we could factor it out into a
                    // separate function.
                    const cache = createEmptyCacheNode();
                    let applied = false;
                    if (prefetchValues.status === PrefetchCacheEntryStatus.stale && !isFirstRead) {
                        // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations
                        // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,
                        // while copying over the `loading` for the segment that contains the page data.
                        // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.
                        applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);
                        // since we re-used the stale cache's loading state & refreshed the data,
                        // update the `lastUsedTime` so that it can continue to be re-used for the next 30s
                        prefetchValues.lastUsedTime = Date.now();
                    } else {
                        applied = applyFlightData(currentCache, cache, flightDataPath, prefetchValues);
                    }
                    const hardNavigate = shouldHardNavigate(flightSegmentPathWithLeadingEmpty, currentTree);
                    if (hardNavigate) {
                        // Copy rsc for the root node of the cache.
                        cache.rsc = currentCache.rsc;
                        cache.prefetchRsc = currentCache.prefetchRsc;
                        invalidateCacheBelowFlightSegmentPath(cache, currentCache, flightSegmentPath);
                        // Ensure the existing cache value is used when the cache was not invalidated.
                        mutable.cache = cache;
                    } else if (applied) {
                        mutable.cache = cache;
                        // If we applied the cache, we update the "current cache" value so any other
                        // segments in the FlightDataPath will be able to reference the updated cache.
                        currentCache = cache;
                    }
                }
                currentTree = newTree;
                for (const subSegment of generateSegmentsFromPatch(treePatch)){
                    const scrollableSegmentPath = [
                        ...flightSegmentPath,
                        ...subSegment
                    ];
                    // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.
                    if (scrollableSegmentPath[scrollableSegmentPath.length - 1] !== DEFAULT_SEGMENT_KEY) {
                        scrollableSegments.push(scrollableSegmentPath);
                    }
                }
            }
        }
        mutable.patchedTree = currentTree;
        mutable.canonicalUrl = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : href;
        mutable.pendingPush = pendingPush;
        mutable.scrollableSegments = scrollableSegments;
        mutable.hashFragment = hash;
        mutable.shouldScroll = shouldScroll;
        return handleMutable(state, mutable);
    }, ()=>state);
} //# sourceMappingURL=navigate-reducer.js.map
&  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/navigate-reducer.ts"],"names":["fetchServerResponse","createHrefFromUrl","invalidateCacheBelowFlightSegmentPath","applyRouterStatePatchToTree","shouldHardNavigate","isNavigatingToNewRootLayout","PrefetchCacheEntryStatus","handleMutable","applyFlightData","prefetchQueue","createEmptyCacheNode","DEFAULT_SEGMENT_KEY","listenForDynamicRequest","updateCacheNodeOnNavigation","getOrCreatePrefetchCacheEntry","prunePrefetchCache","clearCacheNodeDataForSegmentPath","handleExternalUrl","state","mutable","url","pendingPush","mpaNavigation","canonicalUrl","scrollableSegments","undefined","generateSegmentsFromPatch","flightRouterPatch","segments","segment","parallelRoutes","Object","keys","length","parallelRouteKey","parallelRoute","entries","childSegment","push","triggerLazyFetchForLeafSegments","newCache","currentCache","flightSegmentPath","treePatch","appliedPatch","rsc","prefetchRsc","loading","Map","segmentPathsToFill","map","segmentPaths","navigateReducer","process","env","__NEXT_PPR","navigateReducer_PPR","navigateReducer_noPPR","action","isExternalUrl","navigateType","shouldScroll","hash","href","prefetchCache","preserveCustomHistoryState","toString","prefetchValues","nextUrl","tree","buildId","treeAtTimeOfPrefetch","data","bump","then","param","flightData","canonicalUrlOverride","isFirstRead","lastUsedTime","Date","now","document","getElementById","currentTree","cache","flightDataPath","slice","flightSegmentPathWithLeadingEmpty","newTree","applied","status","stale","hardNavigate","subSegment","scrollableSegmentPath","patchedTree","hashFragment","_postponed","prefetchedTree","seedData","head","task","node","patchedRouterState","route"],"mappings":"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","file":"x"}‚  false062undefined64123undefined125225undefined227308undefined310370undefined372453undefined455521undefined523572undefined574628undefined630680undefined682737undefined739807undefined809898undefined900991undefined9931085undefined10871093undefined31573163undefined31883187(/* unused pure expression or super */ null && (undefined31883209 falseundefined321332310undefined32563255))undefined  2440navigate_reducer_handleExternalUrlundefined20842098navigate_reducer_navigateReducerundefined28292845navigate_reducer_handleExternalUrlundefined37473763navigate_reducer_handleExternalUrlundefined40244040navigate_reducer_handleExternalUrlundefined53985414navigate_reducer_handleExternalUrlundefined92859301navigate_reducer_handleExternalUrlundefined1021510231navigate_reducer_handleExternalUrlundefined1049210508navigate_reducer_handleExternalUrlundefined1211712133navigate_reducer_handleExternalUrlundefinedRawSources   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/handle-segment-mismatch.js
øùÿÿúÿÿ[  import { handleExternalUrl } from "./reducers/navigate-reducer";
/**
 * Handles the case where the client router attempted to patch the tree but, due to a mismatch, the patch failed.
 * This will perform an MPA navigation to return the router to a valid state.
 */ export function handleSegmentMismatch(state, action, treePatch) {
    if ("production" === "development") {
        console.warn("Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.\n\n" + "Reason: Segment mismatch\n" + ("Last Action: " + action.type + "\n\n") + ("Current Tree: " + JSON.stringify(state.tree) + "\n\n") + ("Tree Patch Payload: " + JSON.stringify(treePatch)));
    }
    return handleExternalUrl(state, {}, state.canonicalUrl, true);
} //# sourceMappingURL=handle-segment-mismatch.js.map
  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/handle-segment-mismatch.ts"],"names":["handleExternalUrl","handleSegmentMismatch","state","action","treePatch","process","console","warn","type","JSON","stringify","tree","canonicalUrl"],"mappings":"AACA,SAASA,iBAAiB,QAAQ,8BAA6B;AAM/D;;;CAGC,GACD,OAAO,SAASC,sBACdC,KAA2B,EAC3BC,MAAsB,EACtBC,SAA4B;IAE5B,IAAIC,AAfN,iBAe+B,eAAe;QAC1CC,QAAQC,IAAI,CACV,sJACE,+BACA,CAAA,kBAAgBJ,OAAOK,IAAI,GAAC,MAAA,IAC5B,CAAA,mBAAiBC,KAAKC,SAAS,CAACR,MAAMS,IAAI,IAAE,MAAA,IAC5C,CAAA,yBAAuBF,KAAKC,SAAS,CAACN,UAAAA;IAE5C;IAEA,OAAOJ,kBAAkBE,OAAO,CAAC,GAAGA,MAAMU,YAAY,EAAE;AAC1D","file":"x"}E   false063undefined265271undefined339368falseundefined371736{}undefinedE   210230handle_segment_mismatch_handleSegmentMismatchundefinedRawSourcey   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/server-patch-reducer.js
óùÿÿüùÿÿë  import { createHrefFromUrl } from "../create-href-from-url";
import { applyRouterStatePatchToTree } from "../apply-router-state-patch-to-tree";
import { isNavigatingToNewRootLayout } from "../is-navigating-to-new-root-layout";
import { handleExternalUrl } from "./navigate-reducer";
import { applyFlightData } from "../apply-flight-data";
import { handleMutable } from "../handle-mutable";
import { createEmptyCacheNode } from "../../app-router";
import { handleSegmentMismatch } from "../handle-segment-mismatch";
export function serverPatchReducer(state, action) {
    const { serverResponse } = action;
    const [flightData, overrideCanonicalUrl] = serverResponse;
    const mutable = {};
    mutable.preserveCustomHistoryState = false;
    // Handle case when navigating to page in `pages` from `app`
    if (typeof flightData === "string") {
        return handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);
    }
    let currentTree = state.tree;
    let currentCache = state.cache;
    for (const flightDataPath of flightData){
        // Slices off the last segment (which is at -4) as it doesn't exist in the tree yet
        const flightSegmentPath = flightDataPath.slice(0, -4);
        const [treePatch] = flightDataPath.slice(-3, -2);
        const newTree = applyRouterStatePatchToTree([
            "",
            ...flightSegmentPath
        ], currentTree, treePatch, state.canonicalUrl);
        if (newTree === null) {
            return handleSegmentMismatch(state, action, treePatch);
        }
        if (isNavigatingToNewRootLayout(currentTree, newTree)) {
            return handleExternalUrl(state, mutable, state.canonicalUrl, state.pushRef.pendingPush);
        }
        const canonicalUrlOverrideHref = overrideCanonicalUrl ? createHrefFromUrl(overrideCanonicalUrl) : undefined;
        if (canonicalUrlOverrideHref) {
            mutable.canonicalUrl = canonicalUrlOverrideHref;
        }
        const cache = createEmptyCacheNode();
        applyFlightData(currentCache, cache, flightDataPath);
        mutable.patchedTree = newTree;
        mutable.cache = cache;
        currentCache = cache;
        currentTree = newTree;
    }
    return handleMutable(state, mutable);
} //# sourceMappingURL=server-patch-reducer.js.map
W  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/server-patch-reducer.ts"],"names":["createHrefFromUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleExternalUrl","applyFlightData","handleMutable","createEmptyCacheNode","handleSegmentMismatch","serverPatchReducer","state","action","serverResponse","flightData","overrideCanonicalUrl","mutable","preserveCustomHistoryState","pushRef","pendingPush","currentTree","tree","currentCache","cache","flightDataPath","flightSegmentPath","slice","treePatch","newTree","canonicalUrl","canonicalUrlOverrideHref","undefined","patchedTree"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,0BAAyB;AAC3D,SAASC,2BAA2B,QAAQ,sCAAqC;AACjF,SAASC,2BAA2B,QAAQ,sCAAqC;AAOjF,SAASC,iBAAiB,QAAQ,qBAAoB;AACtD,SAASC,eAAe,QAAQ,uBAAsB;AACtD,SAASC,aAAa,QAAQ,oBAAmB;AAEjD,SAASC,oBAAoB,QAAQ,mBAAkB;AACvD,SAASC,qBAAqB,QAAQ,6BAA4B;AAElE,OAAO,SAASC,mBACdC,KAA2B,EAC3BC,MAAyB;IAEzB,MAAM,EAAEC,cAAc,EAAE,GAAGD;IAC3B,MAAM,CAACE,YAAYC,qBAAqB,GAAGF;IAE3C,MAAMG,UAAmB,CAAC;IAE1BA,QAAQC,0BAA0B,GAAG;IAErC,4DAA4D;IAC5D,IAAI,OAAOH,eAAe,UAAU;QAClC,OAAOT,kBACLM,OACAK,SACAF,YACAH,MAAMO,OAAO,CAACC,WAAW;IAE7B;IAEA,IAAIC,cAAcT,MAAMU,IAAI;IAC5B,IAAIC,eAAeX,MAAMY,KAAK;IAE9B,KAAK,MAAMC,kBAAkBV,WAAY;QACvC,mFAAmF;QACnF,MAAMW,oBAAoBD,eAAeE,KAAK,CAAC,GAAG,CAAC;QAEnD,MAAM,CAACC,UAAU,GAAGH,eAAeE,KAAK,CAAC,CAAC,GAAG,CAAC;QAC9C,MAAME,UAAUzB,4BAEd;YAAC;eAAOsB;SAAkB,EAC1BL,aACAO,WACAhB,MAAMkB,YAAY;QAGpB,IAAID,YAAY,MAAM;YACpB,OAAOnB,sBAAsBE,OAAOC,QAAQe;QAC9C;QAEA,IAAIvB,4BAA4BgB,aAAaQ,UAAU;YACrD,OAAOvB,kBACLM,OACAK,SACAL,MAAMkB,YAAY,EAClBlB,MAAMO,OAAO,CAACC,WAAW;QAE7B;QAEA,MAAMW,2BAA2Bf,uBAC7Bb,kBAAkBa,wBAClBgB;QAEJ,IAAID,0BAA0B;YAC5Bd,QAAQa,YAAY,GAAGC;QACzB;QAEA,MAAMP,QAAmBf;QACzBF,gBAAgBgB,cAAcC,OAAOC;QAErCR,QAAQgB,WAAW,GAAGJ;QACtBZ,QAAQO,KAAK,GAAGA;QAEhBD,eAAeC;QACfH,cAAcQ;IAChB;IAEA,OAAOrB,cAAcI,OAAOK;AAC9B","file":"x"}ˆ   false059undefined61142undefined144225undefined227281undefined283337undefined339388undefined390445undefined447513undefined515521undefined=   1734server_patch_reducer_serverPatchReducerundefinedRawSourcet   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/restore-reducer.js
îùÿÿ÷ùÿÿµ  import { createHrefFromUrl } from "../create-href-from-url";
import { extractPathFromFlightRouterState } from "../compute-changed-path";
import { updateCacheNodeOnPopstateRestoration } from "../ppr-navigations";
export function restoreReducer(state, action) {
    const { url, tree } = action;
    const href = createHrefFromUrl(url);
    // This action is used to restore the router state from the history state.
    // However, it's possible that the history state no longer contains the `FlightRouterState`.
    // We will copy over the internal state on pushState/replaceState events, but if a history entry
    // occurred before hydration, or if the user navigated to a hash using a regular anchor link,
    // the history state will not contain the `FlightRouterState`.
    // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.
    const treeToRestore = tree || state.tree;
    const oldCache = state.cache;
    const newCache = process.env.__NEXT_PPR ? // prevents an unnecessary flash back to PPR state during a
    // back/forward navigation.
    updateCacheNodeOnPopstateRestoration(oldCache, treeToRestore) : oldCache;
    var _extractPathFromFlightRouterState;
    return {
        buildId: state.buildId,
        // Set canonical url
        canonicalUrl: href,
        pushRef: {
            pendingPush: false,
            mpaNavigation: false,
            // Ensures that the custom history state that was set is preserved when applying this update.
            preserveCustomHistoryState: true
        },
        focusAndScrollRef: state.focusAndScrollRef,
        cache: newCache,
        prefetchCache: state.prefetchCache,
        // Restore provided tree
        tree: treeToRestore,
        nextUrl: (_extractPathFromFlightRouterState = extractPathFromFlightRouterState(treeToRestore)) != null ? _extractPathFromFlightRouterState : url.pathname
    };
} //# sourceMappingURL=restore-reducer.js.map
ý  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/restore-reducer.ts"],"names":["createHrefFromUrl","extractPathFromFlightRouterState","updateCacheNodeOnPopstateRestoration","restoreReducer","state","action","url","tree","href","treeToRestore","oldCache","cache","newCache","process","env","__NEXT_PPR","buildId","canonicalUrl","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","prefetchCache","nextUrl","pathname"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,0BAAyB;AAM3D,SAASC,gCAAgC,QAAQ,0BAAyB;AAC1E,SAASC,oCAAoC,QAAQ,qBAAoB;AAEzE,OAAO,SAASC,eACdC,KAA2B,EAC3BC,MAAqB;IAErB,MAAM,EAAEC,GAAG,EAAEC,IAAI,EAAE,GAAGF;IACtB,MAAMG,OAAOR,kBAAkBM;IAC/B,0EAA0E;IAC1E,4FAA4F;IAC5F,gGAAgG;IAChG,6FAA6F;IAC7F,8DAA8D;IAC9D,yGAAyG;IACzG,MAAMG,gBAAgBF,QAAQH,MAAMG,IAAI;IAExC,MAAMG,WAAWN,MAAMO,KAAK;IAC5B,MAAMC,WAAWC,QAAQC,GAAG,CAACC,UAAU,GAGnC,2DAA2D;IAC3D,2BAA2B;IAC3Bb,qCAAqCQ,UAAUD,iBAC/CC;QAiBOT;IAfX,OAAO;QACLe,SAASZ,MAAMY,OAAO;QACtB,oBAAoB;QACpBC,cAAcT;QACdU,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,6FAA6F;YAC7FC,4BAA4B;QAC9B;QACAC,mBAAmBlB,MAAMkB,iBAAiB;QAC1CX,OAAOC;QACPW,eAAenB,MAAMmB,aAAa;QAClC,wBAAwB;QACxBhB,MAAME;QACNe,SAASvB,CAAAA,oCAAAA,iCAAiCQ,cAAAA,KAAAA,OAAjCR,oCAAmDK,IAAImB,QAAQ;IAC1E;AACF","file":"x"}e   false059undefined61135undefined137210undefined212218undefined9881009 falseundefined110911690undefined4   1225restore_reducer_restoreReducerundefinedRawSourcet   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/refresh-reducer.js
éùÿÿòùÿÿ.  import { fetchServerResponse } from "../fetch-server-response";
import { createHrefFromUrl } from "../create-href-from-url";
import { applyRouterStatePatchToTree } from "../apply-router-state-patch-to-tree";
import { isNavigatingToNewRootLayout } from "../is-navigating-to-new-root-layout";
import { handleExternalUrl } from "./navigate-reducer";
import { handleMutable } from "../handle-mutable";
import { fillLazyItemsTillLeafWithHead } from "../fill-lazy-items-till-leaf-with-head";
import { createEmptyCacheNode } from "../../app-router";
import { handleSegmentMismatch } from "../handle-segment-mismatch";
import { hasInterceptionRouteInCurrentTree } from "./has-interception-route-in-current-tree";
import { refreshInactiveParallelSegments } from "../refetch-inactive-parallel-segments";
export function refreshReducer(state, action) {
    const { origin } = action;
    const mutable = {};
    const href = state.canonicalUrl;
    let currentTree = state.tree;
    mutable.preserveCustomHistoryState = false;
    const cache = createEmptyCacheNode();
    // If the current tree was intercepted, the nextUrl should be included in the request.
    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.
    const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree);
    // TODO-APP: verify that `href` is not an external url.
    // Fetch data from the root of the tree.
    cache.lazyData = fetchServerResponse(new URL(href, origin), [
        currentTree[0],
        currentTree[1],
        currentTree[2],
        "refetch"
    ], includeNextUrl ? state.nextUrl : null, state.buildId);
    return cache.lazyData.then(async (param)=>{
        let [flightData, canonicalUrlOverride] = param;
        // Handle case when navigating to page in `pages` from `app`
        if (typeof flightData === "string") {
            return handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);
        }
        // Remove cache.lazyData as it has been resolved at this point.
        cache.lazyData = null;
        for (const flightDataPath of flightData){
            // FlightDataPath with more than two items means unexpected Flight data was returned
            if (flightDataPath.length !== 3) {
                // TODO-APP: handle this case better
                console.log("REFRESH FAILED");
                return state;
            }
            // Given the path can only have two items the items are only the router state and rsc for the root.
            const [treePatch] = flightDataPath;
            const newTree = applyRouterStatePatchToTree([
                ""
            ], currentTree, treePatch, state.canonicalUrl);
            if (newTree === null) {
                return handleSegmentMismatch(state, action, treePatch);
            }
            if (isNavigatingToNewRootLayout(currentTree, newTree)) {
                return handleExternalUrl(state, mutable, href, state.pushRef.pendingPush);
            }
            const canonicalUrlOverrideHref = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : undefined;
            if (canonicalUrlOverride) {
                mutable.canonicalUrl = canonicalUrlOverrideHref;
            }
            // The one before last item is the router state tree patch
            const [cacheNodeSeedData, head] = flightDataPath.slice(-2);
            // Handles case where prefetch only returns the router tree patch without rendered components.
            if (cacheNodeSeedData !== null) {
                const rsc = cacheNodeSeedData[2];
                cache.rsc = rsc;
                cache.prefetchRsc = null;
                fillLazyItemsTillLeafWithHead(cache, undefined, treePatch, cacheNodeSeedData, head);
                mutable.prefetchCache = new Map();
            }
            await refreshInactiveParallelSegments({
                state,
                updatedTree: newTree,
                updatedCache: cache,
                includeNextUrl,
                canonicalUrl: mutable.canonicalUrl || state.canonicalUrl
            });
            mutable.cache = cache;
            mutable.patchedTree = newTree;
            mutable.canonicalUrl = href;
            currentTree = newTree;
        }
        return handleMutable(state, mutable);
    }, ()=>state);
} //# sourceMappingURL=refresh-reducer.js.map
˜  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/refresh-reducer.ts"],"names":["fetchServerResponse","createHrefFromUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleExternalUrl","handleMutable","fillLazyItemsTillLeafWithHead","createEmptyCacheNode","handleSegmentMismatch","hasInterceptionRouteInCurrentTree","refreshInactiveParallelSegments","refreshReducer","state","action","origin","mutable","href","canonicalUrl","currentTree","tree","preserveCustomHistoryState","cache","includeNextUrl","lazyData","URL","nextUrl","buildId","then","param","flightData","canonicalUrlOverride","pushRef","pendingPush","flightDataPath","length","console","log","treePatch","newTree","canonicalUrlOverrideHref","undefined","cacheNodeSeedData","head","slice","rsc","prefetchRsc","prefetchCache","Map","updatedTree","updatedCache","patchedTree"],"mappings":"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","file":"x"}µ   false062undefined64123undefined125206undefined208289undefined291345undefined347396undefined398484undefined486541undefined543609undefined611703undefined705792undefined794800undefined4   2033refresh_reducer_refreshReducerundefinedRawSourcey   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/fast-refresh-reducer.js
äùÿÿíùÿÿ;  import { fetchServerResponse } from "../fetch-server-response";
import { createHrefFromUrl } from "../create-href-from-url";
import { applyRouterStatePatchToTree } from "../apply-router-state-patch-to-tree";
import { isNavigatingToNewRootLayout } from "../is-navigating-to-new-root-layout";
import { handleExternalUrl } from "./navigate-reducer";
import { handleMutable } from "../handle-mutable";
import { applyFlightData } from "../apply-flight-data";
import { createEmptyCacheNode } from "../../app-router";
import { handleSegmentMismatch } from "../handle-segment-mismatch";
import { hasInterceptionRouteInCurrentTree } from "./has-interception-route-in-current-tree";
// A version of refresh reducer that keeps the cache around instead of wiping all of it.
function fastRefreshReducerImpl(state, action) {
    const { origin } = action;
    const mutable = {};
    const href = state.canonicalUrl;
    mutable.preserveCustomHistoryState = false;
    const cache = createEmptyCacheNode();
    // If the current tree was intercepted, the nextUrl should be included in the request.
    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.
    const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree);
    // TODO-APP: verify that `href` is not an external url.
    // Fetch data from the root of the tree.
    cache.lazyData = fetchServerResponse(new URL(href, origin), [
        state.tree[0],
        state.tree[1],
        state.tree[2],
        "refetch"
    ], includeNextUrl ? state.nextUrl : null, state.buildId);
    return cache.lazyData.then((param)=>{
        let [flightData, canonicalUrlOverride] = param;
        // Handle case when navigating to page in `pages` from `app`
        if (typeof flightData === "string") {
            return handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);
        }
        // Remove cache.lazyData as it has been resolved at this point.
        cache.lazyData = null;
        let currentTree = state.tree;
        let currentCache = state.cache;
        for (const flightDataPath of flightData){
            // FlightDataPath with more than two items means unexpected Flight data was returned
            if (flightDataPath.length !== 3) {
                // TODO-APP: handle this case better
                console.log("REFRESH FAILED");
                return state;
            }
            // Given the path can only have two items the items are only the router state and rsc for the root.
            const [treePatch] = flightDataPath;
            const newTree = applyRouterStatePatchToTree([
                ""
            ], currentTree, treePatch, state.canonicalUrl);
            if (newTree === null) {
                return handleSegmentMismatch(state, action, treePatch);
            }
            if (isNavigatingToNewRootLayout(currentTree, newTree)) {
                return handleExternalUrl(state, mutable, href, state.pushRef.pendingPush);
            }
            const canonicalUrlOverrideHref = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : undefined;
            if (canonicalUrlOverride) {
                mutable.canonicalUrl = canonicalUrlOverrideHref;
            }
            const applied = applyFlightData(currentCache, cache, flightDataPath);
            if (applied) {
                mutable.cache = cache;
                currentCache = cache;
            }
            mutable.patchedTree = newTree;
            mutable.canonicalUrl = href;
            currentTree = newTree;
        }
        return handleMutable(state, mutable);
    }, ()=>state);
}
function fastRefreshReducerNoop(state, _action) {
    return state;
}
export const fastRefreshReducer = "production" === "production" ? fastRefreshReducerNoop : fastRefreshReducerImpl; //# sourceMappingURL=fast-refresh-reducer.js.map
Ã
  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/fast-refresh-reducer.ts"],"names":["fetchServerResponse","createHrefFromUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleExternalUrl","handleMutable","applyFlightData","createEmptyCacheNode","handleSegmentMismatch","hasInterceptionRouteInCurrentTree","fastRefreshReducerImpl","state","action","origin","mutable","href","canonicalUrl","preserveCustomHistoryState","cache","includeNextUrl","tree","lazyData","URL","nextUrl","buildId","then","param","flightData","canonicalUrlOverride","pushRef","pendingPush","currentTree","currentCache","flightDataPath","length","console","log","treePatch","newTree","canonicalUrlOverrideHref","undefined","applied","patchedTree","fastRefreshReducerNoop","_action","fastRefreshReducer","process"],"mappings":"AAAA,SAASA,mBAAmB,QAAQ,2BAA0B;AAC9D,SAASC,iBAAiB,QAAQ,0BAAyB;AAC3D,SAASC,2BAA2B,QAAQ,sCAAqC;AACjF,SAASC,2BAA2B,QAAQ,sCAAqC;AAOjF,SAASC,iBAAiB,QAAQ,qBAAoB;AACtD,SAASC,aAAa,QAAQ,oBAAmB;AACjD,SAASC,eAAe,QAAQ,uBAAsB;AAEtD,SAASC,oBAAoB,QAAQ,mBAAkB;AACvD,SAASC,qBAAqB,QAAQ,6BAA4B;AAClE,SAASC,iCAAiC,QAAQ,2CAA0C;AAE5F,wFAAwF;AACxF,SAASC,uBACPC,KAA2B,EAC3BC,MAAyB;IAEzB,MAAM,EAAEC,MAAM,EAAE,GAAGD;IACnB,MAAME,UAAmB,CAAC;IAC1B,MAAMC,OAAOJ,MAAMK,YAAY;IAE/BF,QAAQG,0BAA0B,GAAG;IAErC,MAAMC,QAAmBX;IACzB,sFAAsF;IACtF,sHAAsH;IACtH,MAAMY,iBAAiBV,kCAAkCE,MAAMS,IAAI;IAEnE,uDAAuD;IACvD,wCAAwC;IACxCF,MAAMG,QAAQ,GAAGrB,oBACf,IAAIsB,IAAIP,MAAMF,SACd;QAACF,MAAMS,IAAI,CAAC,EAAE;QAAET,MAAMS,IAAI,CAAC,EAAE;QAAET,MAAMS,IAAI,CAAC,EAAE;QAAE;KAAU,EACxDD,iBAAiBR,MAAMY,OAAO,GAAG,MACjCZ,MAAMa,OAAO;IAGf,OAAON,MAAMG,QAAQ,CAACI,IAAI,CACxB,CAAAC;YAAC,CAACC,YAAYC,qBAAqB,GAAAF;QACjC,4DAA4D;QAC5D,IAAI,OAAOC,eAAe,UAAU;YAClC,OAAOvB,kBACLO,OACAG,SACAa,YACAhB,MAAMkB,OAAO,CAACC,WAAW;QAE7B;QAEA,+DAA+D;QAC/DZ,MAAMG,QAAQ,GAAG;QAEjB,IAAIU,cAAcpB,MAAMS,IAAI;QAC5B,IAAIY,eAAerB,MAAMO,KAAK;QAE9B,KAAK,MAAMe,kBAAkBN,WAAY;YACvC,oFAAoF;YACpF,IAAIM,eAAeC,MAAM,KAAK,GAAG;gBAC/B,oCAAoC;gBACpCC,QAAQC,GAAG,CAAC;gBACZ,OAAOzB;YACT;YAEA,mGAAmG;YACnG,MAAM,CAAC0B,UAAU,GAAGJ;YACpB,MAAMK,UAAUpC,4BAEd;gBAAC;aAAG,EACJ6B,aACAM,WACA1B,MAAMK,YAAY;YAGpB,IAAIsB,YAAY,MAAM;gBACpB,OAAO9B,sBAAsBG,OAAOC,QAAQyB;YAC9C;YAEA,IAAIlC,4BAA4B4B,aAAaO,UAAU;gBACrD,OAAOlC,kBACLO,OACAG,SACAC,MACAJ,MAAMkB,OAAO,CAACC,WAAW;YAE7B;YAEA,MAAMS,2BAA2BX,uBAC7B3B,kBAAkB2B,wBAClBY;YAEJ,IAAIZ,sBAAsB;gBACxBd,QAAQE,YAAY,GAAGuB;YACzB;YACA,MAAME,UAAUnC,gBAAgB0B,cAAcd,OAAOe;YAErD,IAAIQ,SAAS;gBACX3B,QAAQI,KAAK,GAAGA;gBAChBc,eAAed;YACjB;YAEAJ,QAAQ4B,WAAW,GAAGJ;YACtBxB,QAAQE,YAAY,GAAGD;YAEvBgB,cAAcO;QAChB;QACA,OAAOjC,cAAcM,OAAOG;IAC9B,GACA,IAAMH;AAEV;AAEA,SAASgC,uBACPhC,KAA2B,EAC3BiC,OAA0B;IAE1B,OAAOjC;AACT;AAEA,OAAO,MAAMkC,qBACXC,AA7HF,iBA6H2B,eACrBH,yBACAjC,uBAAsB","file":"x"}$  false062undefined64123undefined125206undefined208289undefined291345undefined347396undefined398452undefined454509undefined511577undefined579671undefined37353741undefined37693768(/* unused pure expression or super */ null && (undefined37693797 trueundefined382638470undefined38483847))undefinedA   30783095fast_refresh_reducer_fastRefreshReducerundefinedRawSourceö   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/app-call-server.js
var app_call_server = __webpack_require__(8283);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/server-action-reducer.js
ßùÿÿèùÿÿ4   import { callServer } from "../../../app-call-server";
import { ACTION, NEXT_ROUTER_STATE_TREE, NEXT_URL, RSC_CONTENT_TYPE_HEADER } from "../../app-router-headers";
// // eslint-disable-next-line import/no-extraneous-dependencies
// import { createFromFetch } from 'react-server-dom-webpack/client'
// // eslint-disable-next-line import/no-extraneous-dependencies
// import { encodeReply } from 'react-server-dom-webpack/client'
const { createFromFetch, encodeReply } = !!process.env.NEXT_RUNTIME ? require("react-server-dom-webpack/client.edge") : require("react-server-dom-webpack/client");
import { addBasePath } from "../../../add-base-path";
import { createHrefFromUrl } from "../create-href-from-url";
import { handleExternalUrl } from "./navigate-reducer";
import { applyRouterStatePatchToTree } from "../apply-router-state-patch-to-tree";
import { isNavigatingToNewRootLayout } from "../is-navigating-to-new-root-layout";
import { handleMutable } from "../handle-mutable";
import { fillLazyItemsTillLeafWithHead } from "../fill-lazy-items-till-leaf-with-head";
import { createEmptyCacheNode } from "../../app-router";
import { hasInterceptionRouteInCurrentTree } from "./has-interception-route-in-current-tree";
import { handleSegmentMismatch } from "../handle-segment-mismatch";
import { refreshInactiveParallelSegments } from "../refetch-inactive-parallel-segments";
async function fetchServerAction(state, nextUrl, param) {
    let { actionId, actionArgs } = param;
    const body = await encodeReply(actionArgs);
    const res = await fetch("", {
        method: "POST",
        headers: {
            Accept: RSC_CONTENT_TYPE_HEADER,
            [ACTION]: actionId,
            [NEXT_ROUTER_STATE_TREE]: encodeURIComponent(JSON.stringify(state.tree)),
            ...process.env.NEXT_DEPLOYMENT_ID ? {
                "x-deployment-id": process.env.NEXT_DEPLOYMENT_ID
            } : {},
            ...nextUrl ? {
                [NEXT_URL]: nextUrl
            } : {}
        },
        body
    });
    const location = res.headers.get("x-action-redirect");
    let revalidatedParts;
    try {
        const revalidatedHeader = JSON.parse(res.headers.get("x-action-revalidated") || "[[],0,0]");
        revalidatedParts = {
            paths: revalidatedHeader[0] || [],
            tag: !!revalidatedHeader[1],
            cookie: revalidatedHeader[2]
        };
    } catch (e) {
        revalidatedParts = {
            paths: [],
            tag: false,
            cookie: false
        };
    }
    const redirectLocation = location ? new URL(addBasePath(location), new URL(state.canonicalUrl, window.location.href)) : undefined;
    let isFlightResponse = res.headers.get("content-type") === RSC_CONTENT_TYPE_HEADER;
    if (isFlightResponse) {
        const response = await createFromFetch(Promise.resolve(res), {
            callServer
        });
        if (location) {
            // if it was a redirection, then result is just a regular RSC payload
            const [, actionFlightData] = response != null ? response : [];
            return {
                actionFlightData: actionFlightData,
                redirectLocation,
                revalidatedParts
            };
        }
        // otherwise it's a tuple of [actionResult, actionFlightData]
        const [actionResult, [, actionFlightData]] = response != null ? response : [];
        return {
            actionResult,
            actionFlightData,
            redirectLocation,
            revalidatedParts
        };
    }
    return {
        redirectLocation,
        revalidatedParts
    };
}
/*
 * This reducer is responsible for calling the server action and processing any side-effects from the server action.
 * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.
 */ export function serverActionReducer(state, action) {
    const { resolve, reject } = action;
    const mutable = {};
    const href = state.canonicalUrl;
    let currentTree = state.tree;
    mutable.preserveCustomHistoryState = false;
    // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.
    // If the route has been intercepted, the action should be as well.
    // Otherwise the server action might be intercepted with the wrong action id
    // (ie, one that corresponds with the intercepted route)
    const nextUrl = state.nextUrl && hasInterceptionRouteInCurrentTree(state.tree) ? state.nextUrl : null;
    mutable.inFlightServerAction = fetchServerAction(state, nextUrl, action);
    return mutable.inFlightServerAction.then(async (param)=>{
        let { actionResult, actionFlightData: flightData, redirectLocation } = param;
        // Make sure the redirection is a push instead of a replace.
        // Issue: https://github.com/vercel/next.js/issues/53911
        if (redirectLocation) {
            state.pushRef.pendingPush = true;
            mutable.pendingPush = true;
        }
        if (!flightData) {
            resolve(actionResult);
            // If there is a redirect but no flight data we need to do a mpaNavigation.
            if (redirectLocation) {
                return handleExternalUrl(state, mutable, redirectLocation.href, state.pushRef.pendingPush);
            }
            return state;
        }
        if (typeof flightData === "string") {
            // Handle case when navigating to page in `pages` from `app`
            return handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);
        }
        // Remove cache.data as it has been resolved at this point.
        mutable.inFlightServerAction = null;
        if (redirectLocation) {
            const newHref = createHrefFromUrl(redirectLocation, false);
            mutable.canonicalUrl = newHref;
        }
        for (const flightDataPath of flightData){
            // FlightDataPath with more than two items means unexpected Flight data was returned
            if (flightDataPath.length !== 3) {
                // TODO-APP: handle this case better
                console.log("SERVER ACTION APPLY FAILED");
                return state;
            }
            // Given the path can only have two items the items are only the router state and rsc for the root.
            const [treePatch] = flightDataPath;
            const newTree = applyRouterStatePatchToTree([
                ""
            ], currentTree, treePatch, redirectLocation ? createHrefFromUrl(redirectLocation) : state.canonicalUrl);
            if (newTree === null) {
                return handleSegmentMismatch(state, action, treePatch);
            }
            if (isNavigatingToNewRootLayout(currentTree, newTree)) {
                return handleExternalUrl(state, mutable, href, state.pushRef.pendingPush);
            }
            // The one before last item is the router state tree patch
            const [cacheNodeSeedData, head] = flightDataPath.slice(-2);
            const rsc = cacheNodeSeedData !== null ? cacheNodeSeedData[2] : null;
            // Handles case where prefetch only returns the router tree patch without rendered components.
            if (rsc !== null) {
                const cache = createEmptyCacheNode();
                cache.rsc = rsc;
                cache.prefetchRsc = null;
                fillLazyItemsTillLeafWithHead(cache, undefined, treePatch, cacheNodeSeedData, head);
                await refreshInactiveParallelSegments({
                    state,
                    updatedTree: newTree,
                    updatedCache: cache,
                    includeNextUrl: Boolean(nextUrl),
                    canonicalUrl: mutable.canonicalUrl || state.canonicalUrl
                });
                mutable.cache = cache;
                mutable.prefetchCache = new Map();
            }
            mutable.patchedTree = newTree;
            currentTree = newTree;
        }
        resolve(actionResult);
        return handleMutable(state, mutable);
    }, (e)=>{
        // When the server action is rejected we don't update the state and instead call the reject handler of the promise.
        reject(e);
        return state;
    });
} //# sourceMappingURL=server-action-reducer.js.map
"  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/server-action-reducer.ts"],"names":["callServer","ACTION","NEXT_ROUTER_STATE_TREE","NEXT_URL","RSC_CONTENT_TYPE_HEADER","createFromFetch","encodeReply","process","env","NEXT_RUNTIME","require","addBasePath","createHrefFromUrl","handleExternalUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleMutable","fillLazyItemsTillLeafWithHead","createEmptyCacheNode","hasInterceptionRouteInCurrentTree","handleSegmentMismatch","refreshInactiveParallelSegments","fetchServerAction","state","nextUrl","param","actionId","actionArgs","body","res","fetch","method","headers","Accept","encodeURIComponent","JSON","stringify","tree","NEXT_DEPLOYMENT_ID","location","get","revalidatedParts","revalidatedHeader","parse","paths","tag","cookie","e","redirectLocation","URL","canonicalUrl","window","href","undefined","isFlightResponse","response","Promise","resolve","actionFlightData","actionResult","serverActionReducer","action","reject","mutable","currentTree","preserveCustomHistoryState","inFlightServerAction","then","flightData","pushRef","pendingPush","newHref","flightDataPath","length","console","log","treePatch","newTree","cacheNodeSeedData","head","slice","rsc","cache","prefetchRsc","updatedTree","updatedCache","includeNextUrl","Boolean","prefetchCache","Map","patchedTree"],"mappings":"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","file":"x"}`  false053undefined55163undefined470495 trueundefined499505__webpack_require__undefined5075441502undefined5495900undefined593645undefined647706undefined708762undefined764845undefined847928undefined930979undefined9811067undefined10691124undefined11261218undefined12201286undefined12881375undefined17801809 falseundefined181318930undefined38313837undefinedC   27162734server_action_reducer_serverActionReducerundefinedRawSourcej   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/router-reducer.js
ÚùÿÿãùÿÿÐ  import { ACTION_NAVIGATE, ACTION_SERVER_PATCH, ACTION_RESTORE, ACTION_REFRESH, ACTION_PREFETCH, ACTION_FAST_REFRESH, ACTION_SERVER_ACTION } from "./router-reducer-types";
import { navigateReducer } from "./reducers/navigate-reducer";
import { serverPatchReducer } from "./reducers/server-patch-reducer";
import { restoreReducer } from "./reducers/restore-reducer";
import { refreshReducer } from "./reducers/refresh-reducer";
import { prefetchReducer } from "./reducers/prefetch-reducer";
import { fastRefreshReducer } from "./reducers/fast-refresh-reducer";
import { serverActionReducer } from "./reducers/server-action-reducer";
/**
 * Reducer that handles the app-router state updates.
 */ function clientReducer(state, action) {
    switch(action.type){
        case ACTION_NAVIGATE:
            {
                return navigateReducer(state, action);
            }
        case ACTION_SERVER_PATCH:
            {
                return serverPatchReducer(state, action);
            }
        case ACTION_RESTORE:
            {
                return restoreReducer(state, action);
            }
        case ACTION_REFRESH:
            {
                return refreshReducer(state, action);
            }
        case ACTION_FAST_REFRESH:
            {
                return fastRefreshReducer(state, action);
            }
        case ACTION_PREFETCH:
            {
                return prefetchReducer(state, action);
            }
        case ACTION_SERVER_ACTION:
            {
                return serverActionReducer(state, action);
            }
        // This case should never be hit as dispatch is strongly typed.
        default:
            throw new Error("Unknown action");
    }
}
function serverReducer(state, _action) {
    return state;
}
// we don't run the client reducer on the server, so we use a noop function for better tree shaking
export const reducer = "undefined" === "undefined" ? serverReducer : clientReducer; //# sourceMappingURL=router-reducer.js.map
j  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/router-reducer.ts"],"names":["ACTION_NAVIGATE","ACTION_SERVER_PATCH","ACTION_RESTORE","ACTION_REFRESH","ACTION_PREFETCH","ACTION_FAST_REFRESH","ACTION_SERVER_ACTION","navigateReducer","serverPatchReducer","restoreReducer","refreshReducer","prefetchReducer","fastRefreshReducer","serverActionReducer","clientReducer","state","action","type","Error","serverReducer","_action","reducer"],"mappings":"AAAA,SACEA,eAAe,EACfC,mBAAmB,EACnBC,cAAc,EACdC,cAAc,EACdC,eAAe,EACfC,mBAAmB,EACnBC,oBAAoB,QACf,yBAAwB;AAM/B,SAASC,eAAe,QAAQ,8BAA6B;AAC7D,SAASC,kBAAkB,QAAQ,kCAAiC;AACpE,SAASC,cAAc,QAAQ,6BAA4B;AAC3D,SAASC,cAAc,QAAQ,6BAA4B;AAC3D,SAASC,eAAe,QAAQ,8BAA6B;AAC7D,SAASC,kBAAkB,QAAQ,kCAAiC;AACpE,SAASC,mBAAmB,QAAQ,mCAAkC;AAEtE;;CAEC,GACD,SAASC,cACPC,KAA2B,EAC3BC,MAAsB;IAEtB,OAAQA,OAAOC,IAAI;QACjB,KAAKjB;YAAiB;gBACpB,OAAOO,gBAAgBQ,OAAOC;YAChC;QACA,KAAKf;YAAqB;gBACxB,OAAOO,mBAAmBO,OAAOC;YACnC;QACA,KAAKd;YAAgB;gBACnB,OAAOO,eAAeM,OAAOC;YAC/B;QACA,KAAKb;YAAgB;gBACnB,OAAOO,eAAeK,OAAOC;YAC/B;QACA,KAAKX;YAAqB;gBACxB,OAAOO,mBAAmBG,OAAOC;YACnC;QACA,KAAKZ;YAAiB;gBACpB,OAAOO,gBAAgBI,OAAOC;YAChC;QACA,KAAKV;YAAsB;gBACzB,OAAOO,oBAAoBE,OAAOC;YACpC;QACA,+DAA+D;QAC/D;YACE,MAAM,IAAIE,MAAM;IACpB;AACF;AAEA,SAASC,cACPJ,KAA2B,EAC3BK,OAAuB;IAEvB,OAAOL;AACT;AAEA,mGAAmG;AACnG,OAAO,MAAMM,UACX,gBAAkB,cAAcF,gBAAgBL,cAAa","file":"x"}  false0169undefined171232undefined234302undefined304363undefined365424undefined426487undefined489557undefined559629undefined18731879undefined18961895(/* unused pure expression or super */ null && (undefined18961922 trueundefined194219540undefined19551954))undefined0   12561262router_reducer_reducerundefinedRawSourceY   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/shared/lib/router/action-queue.js
ÕùÿÿÞùÿÿf  import { isThenable, ACTION_REFRESH, ACTION_SERVER_ACTION, ACTION_NAVIGATE, ACTION_RESTORE } from "../../../client/components/router-reducer/router-reducer-types";
import { reducer } from "../../../client/components/router-reducer/router-reducer";
import React, { startTransition } from "react";
export const ActionQueueContext = /*#__PURE__*/ React.createContext(null);
function runRemainingActions(actionQueue, setState) {
    if (actionQueue.pending !== null) {
        actionQueue.pending = actionQueue.pending.next;
        if (actionQueue.pending !== null) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            runAction({
                actionQueue,
                action: actionQueue.pending,
                setState
            });
        } else {
            // No more actions are pending, check if a refresh is needed
            if (actionQueue.needsRefresh) {
                actionQueue.needsRefresh = false;
                actionQueue.dispatch({
                    type: ACTION_REFRESH,
                    origin: window.location.origin
                }, setState);
            }
        }
    }
}
async function runAction(param) {
    let { actionQueue, action, setState } = param;
    const prevState = actionQueue.state;
    if (!prevState) {
        // This shouldn't happen as the state is initialized in the dispatcher if it's not set
        throw new Error("Invariant: Router state not initialized");
    }
    actionQueue.pending = action;
    const payload = action.payload;
    const actionResult = actionQueue.action(prevState, payload);
    function handleResult(nextState) {
        // if we discarded this action, the state should also be discarded
        if (action.discarded) {
            return;
        }
        actionQueue.state = nextState;
        if (actionQueue.devToolsInstance) {
            actionQueue.devToolsInstance.send(payload, nextState);
        }
        runRemainingActions(actionQueue, setState);
        action.resolve(nextState);
    }
    // if the action is a promise, set up a callback to resolve it
    if (isThenable(actionResult)) {
        actionResult.then(handleResult, (err)=>{
            runRemainingActions(actionQueue, setState);
            action.reject(err);
        });
    } else {
        handleResult(actionResult);
    }
}
function dispatchAction(actionQueue, payload, setState) {
    let resolvers = {
        resolve: setState,
        reject: ()=>{}
    };
    // most of the action types are async with the exception of restore
    // it's important that restore is handled quickly since it's fired on the popstate event
    // and we don't want to add any delay on a back/forward nav
    // this only creates a promise for the async actions
    if (payload.type !== ACTION_RESTORE) {
        // Create the promise and assign the resolvers to the object.
        const deferredPromise = new Promise((resolve, reject)=>{
            resolvers = {
                resolve,
                reject
            };
        });
        startTransition(()=>{
            // we immediately notify React of the pending promise -- the resolver is attached to the action node
            // and will be called when the associated action promise resolves
            setState(deferredPromise);
        });
    }
    const newAction = {
        payload,
        next: null,
        resolve: resolvers.resolve,
        reject: resolvers.reject
    };
    // Check if the queue is empty
    if (actionQueue.pending === null) {
        // The queue is empty, so add the action and start it immediately
        // Mark this action as the last in the queue
        actionQueue.last = newAction;
        runAction({
            actionQueue,
            action: newAction,
            setState
        });
    } else if (payload.type === ACTION_NAVIGATE || payload.type === ACTION_RESTORE) {
        // Navigations (including back/forward) take priority over any pending actions.
        // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.
        actionQueue.pending.discarded = true;
        // Mark this action as the last in the queue
        actionQueue.last = newAction;
        // if the pending action was a server action, mark the queue as needing a refresh once events are processed
        if (actionQueue.pending.payload.type === ACTION_SERVER_ACTION) {
            actionQueue.needsRefresh = true;
        }
        runAction({
            actionQueue,
            action: newAction,
            setState
        });
    } else {
        // The queue is not empty, so add the action to the end of the queue
        // It will be started by runRemainingActions after the previous action finishes
        if (actionQueue.last !== null) {
            actionQueue.last.next = newAction;
        }
        actionQueue.last = newAction;
    }
}
export function createMutableActionQueue() {
    const actionQueue = {
        state: null,
        dispatch: (payload, setState)=>dispatchAction(actionQueue, payload, setState),
        action: async (state, action)=>{
            if (state === null) {
                throw new Error("Invariant: Router state not initialized");
            }
            const result = reducer(state, action);
            return result;
        },
        pending: null,
        last: null
    };
    return actionQueue;
} //# sourceMappingURL=action-queue.js.map
²  {"version":3,"sources":["webpack://../../../../src/shared/lib/router/action-queue.ts"],"names":["isThenable","ACTION_REFRESH","ACTION_SERVER_ACTION","ACTION_NAVIGATE","ACTION_RESTORE","reducer","React","startTransition","ActionQueueContext","createContext","runRemainingActions","actionQueue","setState","pending","next","runAction","action","needsRefresh","dispatch","type","origin","window","location","param","prevState","state","Error","payload","actionResult","handleResult","nextState","discarded","devToolsInstance","send","resolve","then","err","reject","dispatchAction","resolvers","deferredPromise","Promise","newAction","last","createMutableActionQueue","result"],"mappings":"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","file":"x"}    false0162undefined164246undefined248294undefined296302undefined344343(/* unused pure expression or super */ null && (undefined369368))undefined49294935undefined4   926action_queue_ActionQueueContextundefinedRawSourcef   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/use-reducer-with-devtools.js
ÐùÿÿÙùÿÿí  import React, { use, useContext } from "react";
import { useRef, useEffect, useCallback } from "react";
import { isThenable } from "./router-reducer/router-reducer-types";
import { ActionQueueContext } from "../../shared/lib/router/action-queue";
function normalizeRouterState(val) {
    if (val instanceof Map) {
        const obj = {};
        for (const [key, value] of val.entries()){
            if (typeof value === "function") {
                obj[key] = "fn()";
                continue;
            }
            if (typeof value === "object" && value !== null) {
                if (value.$$typeof) {
                    obj[key] = value.$$typeof.toString();
                    continue;
                }
                if (value._bundlerConfig) {
                    obj[key] = "FlightData";
                    continue;
                }
            }
            obj[key] = normalizeRouterState(value);
        }
        return obj;
    }
    if (typeof val === "object" && val !== null) {
        const obj = {};
        for(const key in val){
            const value = val[key];
            if (typeof value === "function") {
                obj[key] = "fn()";
                continue;
            }
            if (typeof value === "object" && value !== null) {
                if (value.$$typeof) {
                    obj[key] = value.$$typeof.toString();
                    continue;
                }
                if (value.hasOwnProperty("_bundlerConfig")) {
                    obj[key] = "FlightData";
                    continue;
                }
            }
            obj[key] = normalizeRouterState(value);
        }
        return obj;
    }
    if (Array.isArray(val)) {
        return val.map(normalizeRouterState);
    }
    return val;
}
export function useUnwrapState(state) {
    // reducer actions can be async, so sometimes we need to suspend until the state is resolved
    if (isThenable(state)) {
        const result = use(state);
        return result;
    }
    return state;
}
function useReducerWithReduxDevtoolsNoop(initialState) {
    return [
        initialState,
        ()=>{},
        ()=>{}
    ];
}
function useReducerWithReduxDevtoolsImpl(initialState) {
    const [state, setState] = React.useState(initialState);
    const actionQueue = useContext(ActionQueueContext);
    if (!actionQueue) {
        throw new Error("Invariant: Missing ActionQueueContext");
    }
    const devtoolsConnectionRef = useRef();
    const enabledRef = useRef();
    null;
    const dispatch = useCallback((action)=>{
        if (!actionQueue.state) {
            // we lazy initialize the mutable action queue state since the data needed
            // to generate the state is not available when the actionQueue context is created
            actionQueue.state = initialState;
        }
        actionQueue.dispatch(action, setState);
    }, [
        actionQueue,
        initialState
    ]);
    // Sync is called after a state update in the HistoryUpdater,
    // for debugging purposes. Since the reducer state may be a Promise,
    // we let the app router use() it and sync on the resolved value if
    // something changed.
    // Using the `state` here would be referentially unstable and cause
    // undesirable re-renders and history updates.
    const sync = useCallback((resolvedState)=>{
        if (devtoolsConnectionRef.current) {
            devtoolsConnectionRef.current.send({
                type: "RENDER_SYNC"
            }, normalizeRouterState(resolvedState));
        }
    }, []);
    return [
        state,
        dispatch,
        sync
    ];
}
export const useReducerWithReduxDevtools = "undefined" !== "undefined" ? useReducerWithReduxDevtoolsImpl : useReducerWithReduxDevtoolsNoop; //# sourceMappingURL=use-reducer-with-devtools.js.map
“
  {"version":3,"sources":["webpack://../../../src/client/components/use-reducer-with-devtools.ts"],"names":["React","use","useContext","useRef","useEffect","useCallback","isThenable","ActionQueueContext","normalizeRouterState","val","Map","obj","key","value","entries","$$typeof","toString","_bundlerConfig","hasOwnProperty","Array","isArray","map","useUnwrapState","state","result","useReducerWithReduxDevtoolsNoop","initialState","useReducerWithReduxDevtoolsImpl","setState","useState","actionQueue","Error","devtoolsConnectionRef","enabledRef","dispatch","action","sync","resolvedState","current","send","type","useReducerWithReduxDevtools"],"mappings":"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","file":"x"}N  false046undefined48102undefined104170undefined172245undefined17851791undefined19301939__WEBPACK_MODULE_REFERENCE__3_5b2269735468656e61626c65225d_call_directImport_asiSafe1__._undefined19741976__WEBPACK_MODULE_REFERENCE__1_5b22757365225d_call_directImport_asiSafe1__._undefined36273633undefined36703696 falseundefined370037300undefinedc   16801768(0,router_reducer_types/* isThenable */.J8)undefined18031877(0,react.use)undefinedRawSource“  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/error-boundary.js + 1 modules
var error_boundary = __webpack_require__(6120);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/future/helpers/interception-routes.js
var interception_routes = __webpack_require__(117);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/compute-changed-path.js
ËùÿÿÔùÿÿX  import { INTERCEPTION_ROUTE_MARKERS } from "../../../server/future/helpers/interception-routes";
import { isGroupSegment, DEFAULT_SEGMENT_KEY, PAGE_SEGMENT_KEY } from "../../../shared/lib/segment";
import { matchSegment } from "../match-segments";
const removeLeadingSlash = (segment)=>{
    return segment[0] === "/" ? segment.slice(1) : segment;
};
const segmentToPathname = (segment)=>{
    if (typeof segment === "string") {
        // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page
        // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.
        if (segment === "children") return "";
        return segment;
    }
    return segment[1];
};
function normalizeSegments(segments) {
    return segments.reduce((acc, segment)=>{
        segment = removeLeadingSlash(segment);
        if (segment === "" || isGroupSegment(segment)) {
            return acc;
        }
        return acc + "/" + segment;
    }, "") || "/";
}
export function extractPathFromFlightRouterState(flightRouterState) {
    const segment = Array.isArray(flightRouterState[0]) ? flightRouterState[0][1] : flightRouterState[0];
    if (segment === DEFAULT_SEGMENT_KEY || INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m))) return undefined;
    if (segment.startsWith(PAGE_SEGMENT_KEY)) return "";
    const segments = [
        segmentToPathname(segment)
    ];
    var _flightRouterState_;
    const parallelRoutes = (_flightRouterState_ = flightRouterState[1]) != null ? _flightRouterState_ : {};
    const childrenPath = parallelRoutes.children ? extractPathFromFlightRouterState(parallelRoutes.children) : undefined;
    if (childrenPath !== undefined) {
        segments.push(childrenPath);
    } else {
        for (const [key, value] of Object.entries(parallelRoutes)){
            if (key === "children") continue;
            const childPath = extractPathFromFlightRouterState(value);
            if (childPath !== undefined) {
                segments.push(childPath);
            }
        }
    }
    return normalizeSegments(segments);
}
function computeChangedPathImpl(treeA, treeB) {
    const [segmentA, parallelRoutesA] = treeA;
    const [segmentB, parallelRoutesB] = treeB;
    const normalizedSegmentA = segmentToPathname(segmentA);
    const normalizedSegmentB = segmentToPathname(segmentB);
    if (INTERCEPTION_ROUTE_MARKERS.some((m)=>normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m))) {
        return "";
    }
    if (!matchSegment(segmentA, segmentB)) {
        var _extractPathFromFlightRouterState;
        // once we find where the tree changed, we compute the rest of the path by traversing the tree
        return (_extractPathFromFlightRouterState = extractPathFromFlightRouterState(treeB)) != null ? _extractPathFromFlightRouterState : "";
    }
    for(const parallelRouterKey in parallelRoutesA){
        if (parallelRoutesB[parallelRouterKey]) {
            const changedPath = computeChangedPathImpl(parallelRoutesA[parallelRouterKey], parallelRoutesB[parallelRouterKey]);
            if (changedPath !== null) {
                return segmentToPathname(segmentB) + "/" + changedPath;
            }
        }
    }
    return null;
}
export function computeChangedPath(treeA, treeB) {
    const changedPath = computeChangedPathImpl(treeA, treeB);
    if (changedPath == null || changedPath === "/") {
        return changedPath;
    }
    // lightweight normalization to remove route groups
    return normalizeSegments(changedPath.split("/"));
} //# sourceMappingURL=compute-changed-path.js.map
  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/compute-changed-path.ts"],"names":["INTERCEPTION_ROUTE_MARKERS","isGroupSegment","DEFAULT_SEGMENT_KEY","PAGE_SEGMENT_KEY","matchSegment","removeLeadingSlash","segment","slice","segmentToPathname","normalizeSegments","segments","reduce","acc","extractPathFromFlightRouterState","flightRouterState","Array","isArray","some","m","startsWith","undefined","parallelRoutes","childrenPath","children","push","key","value","Object","entries","childPath","computeChangedPathImpl","treeA","treeB","segmentA","parallelRoutesA","segmentB","parallelRoutesB","normalizedSegmentA","normalizedSegmentB","parallelRouterKey","changedPath","computeChangedPath","split"],"mappings":"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","file":"x"})  false095undefined97196undefined198246undefined942955__WEBPACK_MODULE_REFERENCE__11_5b22697347726f75705365676d656e74225d_call_directImport_asiSafe1__._undefined10601066undefined12561274__WEBPACK_MODULE_REFERENCE__11_5b2244454641554c545f5345474d454e545f4b4559225d_directImport_asiSafe1__._undefined12791304__WEBPACK_MODULE_REFERENCE__33_5b22494e54455243455054494f4e5f524f5554455f4d41524b455253225d_call_asiSafe1__._undefined13851400__WEBPACK_MODULE_REFERENCE__11_5b22504147455f5345474d454e545f4b4559225d_directImport_asiSafe1__._undefined33103316undefined  697794(0,lib_segment/* isGroupSegment */.lv)undefined908939compute_changed_path_extractPathFromFlightRouterStateundefined10881190lib_segment/* DEFAULT_SEGMENT_KEY */.avundefined11951303interception_routes/* INTERCEPTION_ROUTE_MARKERS */.Wzundefined13841480lib_segment/* PAGE_SEGMENT_KEY */.GCundefined17481779compute_changed_path_extractPathFromFlightRouterStateundefined20512082compute_changed_path_extractPathFromFlightRouterStateundefined29012932compute_changed_path_extractPathFromFlightRouterStateundefinedRawSourcew   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/create-initial-router-state.js
ÆùÿÿÏùÿÿé  import { createHrefFromUrl } from "./create-href-from-url";
import { fillLazyItemsTillLeafWithHead } from "./fill-lazy-items-till-leaf-with-head";
import { extractPathFromFlightRouterState } from "./compute-changed-path";
import { createPrefetchCacheEntryForInitialLoad } from "./prefetch-cache-utils";
import { PrefetchKind } from "./router-reducer-types";
import { addRefreshMarkerToActiveParallelSegments } from "./refetch-inactive-parallel-segments";
export function createInitialRouterState(param) {
    let { buildId, initialTree, initialSeedData, initialCanonicalUrl, initialParallelRoutes, location, initialHead, couldBeIntercepted } = param;
    const isServer = !location;
    const rsc = initialSeedData[2];
    const cache = {
        lazyData: null,
        rsc: rsc,
        prefetchRsc: null,
        head: null,
        prefetchHead: null,
        // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.
        parallelRoutes: isServer ? new Map() : initialParallelRoutes,
        lazyDataResolved: false,
        loading: initialSeedData[3]
    };
    const canonicalUrl = // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.
    location ? createHrefFromUrl(location) : initialCanonicalUrl;
    addRefreshMarkerToActiveParallelSegments(initialTree, canonicalUrl);
    const prefetchCache = new Map();
    // When the cache hasn't been seeded yet we fill the cache with the head.
    if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {
        fillLazyItemsTillLeafWithHead(cache, undefined, initialTree, initialSeedData, initialHead);
    }
    var _ref;
    const initialState = {
        buildId,
        tree: initialTree,
        cache,
        prefetchCache,
        pushRef: {
            pendingPush: false,
            mpaNavigation: false,
            // First render needs to preserve the previous window.history.state
            // to avoid it being overwritten on navigation back/forward with MPA Navigation.
            preserveCustomHistoryState: true
        },
        focusAndScrollRef: {
            apply: false,
            onlyHashChange: false,
            hashFragment: null,
            segmentPaths: []
        },
        canonicalUrl,
        nextUrl: (_ref = extractPathFromFlightRouterState(initialTree) || (location == null ? void 0 : location.pathname)) != null ? _ref : null
    };
    if (location) {
        // Seed the prefetch cache with this page's data.
        // This is to prevent needlessly re-prefetching a page that is already reusable,
        // and will avoid triggering a loading state/data fetch stall when navigating back to the page.
        const url = new URL("" + location.pathname + location.search, location.origin);
        const initialFlightData = [
            [
                "",
                initialTree,
                null,
                null
            ]
        ];
        createPrefetchCacheEntryForInitialLoad({
            url,
            kind: PrefetchKind.AUTO,
            data: [
                initialFlightData,
                undefined,
                false,
                couldBeIntercepted
            ],
            tree: initialState.tree,
            prefetchCache: initialState.prefetchCache,
            nextUrl: initialState.nextUrl
        });
    }
    return initialState;
} //# sourceMappingURL=create-initial-router-state.js.map
	  {"version":3,"sources":["webpack://../../../../src/client/components/router-reducer/create-initial-router-state.ts"],"names":["createHrefFromUrl","fillLazyItemsTillLeafWithHead","extractPathFromFlightRouterState","createPrefetchCacheEntryForInitialLoad","PrefetchKind","addRefreshMarkerToActiveParallelSegments","createInitialRouterState","param","buildId","initialTree","initialSeedData","initialCanonicalUrl","initialParallelRoutes","location","initialHead","couldBeIntercepted","isServer","rsc","cache","lazyData","prefetchRsc","head","prefetchHead","parallelRoutes","Map","lazyDataResolved","loading","canonicalUrl","prefetchCache","size","undefined","initialState","tree","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","onlyHashChange","hashFragment","segmentPaths","nextUrl","pathname","url","URL","search","origin","initialFlightData","kind","AUTO","data"],"mappings":"AAQA,SAASA,iBAAiB,QAAQ,yBAAwB;AAC1D,SAASC,6BAA6B,QAAQ,wCAAuC;AACrF,SAASC,gCAAgC,QAAQ,yBAAwB;AACzE,SAASC,sCAAsC,QAAQ,yBAAwB;AAC/E,SAASC,YAAY,QAAiC,yBAAwB;AAC9E,SAASC,wCAAwC,QAAQ,uCAAsC;AAa/F,OAAO,SAASC,yBAAyBC,KASV;IATU,IAAA,EACvCC,OAAO,EACPC,WAAW,EACXC,eAAe,EACfC,mBAAmB,EACnBC,qBAAqB,EACrBC,QAAQ,EACRC,WAAW,EACXC,kBAAkB,EACW,GATUR;IAUvC,MAAMS,WAAW,CAACH;IAClB,MAAMI,MAAMP,eAAe,CAAC,EAAE;IAE9B,MAAMQ,QAAmB;QACvBC,UAAU;QACVF,KAAKA;QACLG,aAAa;QACbC,MAAM;QACNC,cAAc;QACd,oJAAoJ;QACpJC,gBAAgBP,WAAW,IAAIQ,QAAQZ;QACvCa,kBAAkB;QAClBC,SAAShB,eAAe,CAAC,EAAE;IAC7B;IAEA,MAAMiB,eAEJ,kJAAkJ;IAClJd,WAEIb,kBAAkBa,YAClBF;IAENN,yCAAyCI,aAAakB;IAEtD,MAAMC,gBAAgB,IAAIJ;IAE1B,yEAAyE;IACzE,IAAIZ,0BAA0B,QAAQA,sBAAsBiB,IAAI,KAAK,GAAG;QACtE5B,8BACEiB,OACAY,WACArB,aACAC,iBACAI;IAEJ;QAuBKZ;IArBL,MAAM6B,eAAe;QACnBvB;QACAwB,MAAMvB;QACNS;QACAU;QACAK,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,mEAAmE;YACnE,gFAAgF;YAChFC,4BAA4B;QAC9B;QACAC,mBAAmB;YACjBC,OAAO;YACPC,gBAAgB;YAChBC,cAAc;YACdC,cAAc,EAAE;QAClB;QACAd;QACAe,SAEE,AAACxC,CAAAA,OAAAA,iCAAiCO,gBAAgBI,CAAAA,YAAAA,OAAAA,KAAAA,IAAAA,SAAU8B,QAAQ,AAARA,CAAQ,KAAA,OAAnEzC,OACD;IACJ;IAEA,IAAIW,UAAU;QACZ,iDAAiD;QACjD,gFAAgF;QAChF,+FAA+F;QAC/F,MAAM+B,MAAM,IAAIC,IACd,KAAGhC,SAAS8B,QAAQ,GAAG9B,SAASiC,MAAM,EACtCjC,SAASkC,MAAM;QAGjB,MAAMC,oBAAgC;YAAC;gBAAC;gBAAIvC;gBAAa;gBAAM;aAAK;SAAC;QACrEN,uCAAuC;YACrCyC;YACAK,MAAM7C,aAAa8C,IAAI;YACvBC,MAAM;gBAACH;gBAAmBlB;gBAAW;gBAAOf;aAAmB;YAC/DiB,MAAMD,aAAaC,IAAI;YACvBJ,eAAeG,aAAaH,aAAa;YACzCc,SAASX,aAAaW,OAAO;QAC/B;IACF;IAEA,OAAOX;AACT","file":"x"}¯  false058undefined60145undefined147220undefined222301undefined303356undefined358453undefined455461undefined13461362__WEBPACK_MODULE_REFERENCE__4_5b226372656174654872656646726f6d55726c225d_call_directImport_asiSafe1__._undefined14011440__WEBPACK_MODULE_REFERENCE__12_5b22616464526566726573684d61726b6572546f416374697665506172616c6c656c5365676d656e7473225d_call_directImport_asiSafe1__._undefined16711699__WEBPACK_MODULE_REFERENCE__8_5b2266696c6c4c617a794974656d7354696c6c4c6561665769746848656164225d_call_directImport_asiSafe1__._undefined24152446__WEBPACK_MODULE_REFERENCE__34_5b22657874726163745061746846726f6d466c69676874526f757465725374617465225d_call_directImport_asiSafe1__._undefined30763113__WEBPACK_MODULE_REFERENCE__18_5b2263726561746550726566657463684361636865456e747279466f72496e697469616c4c6f6164225d_call_directImport_asiSafe1__._undefined31523163__WEBPACK_MODULE_REFERENCE__3_5b2250726566657463684b696e64225d_asiSafe1__._undefined£  890992create_href_from_url_createHrefFromUrlundefined10311180refetch_inactive_parallel_segments_addRefreshMarkerToActiveParallelSegmentsundefined14111537fill_lazy_items_till_leaf_with_head_fillLazyItemsTillLeafWithHeadundefined22532386compute_changed_path_extractPathFromFlightRouterStateundefined30163161createPrefetchCacheEntryForInitialLoadundefined32003274router_reducer_types/* PrefetchKind */.KeundefinedRawSource~  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/is-bot.js
var is_bot = __webpack_require__(5524);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/add-path-prefix.js
var add_path_prefix = __webpack_require__(7253);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/remove-trailing-slash.js
var remove_trailing_slash = __webpack_require__(1496);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/parse-path.js
var parse_path = __webpack_require__(6540);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/normalize-trailing-slash.js
ÁùÿÿÊùÿÿ§  import { removeTrailingSlash } from "../shared/lib/router/utils/remove-trailing-slash";
import { parsePath } from "../shared/lib/router/utils/parse-path";
/**
 * Normalizes the trailing slash of a path according to the `trailingSlash` option
 * in `next.config.js`.
 */ export const normalizePathTrailingSlash = (path)=>{
    if (!path.startsWith("/") || process.env.__NEXT_MANUAL_TRAILING_SLASH) {
        return path;
    }
    const { pathname, query, hash } = parsePath(path);
    if (process.env.__NEXT_TRAILING_SLASH) {
        if (/\.[^/]+\/?$/.test(pathname)) {
            return "" + removeTrailingSlash(pathname) + query + hash;
        } else if (pathname.endsWith("/")) {
            return "" + pathname + query + hash;
        } else {
            return pathname + "/" + query + hash;
        }
    }
    return "" + removeTrailingSlash(pathname) + query + hash;
}; //# sourceMappingURL=normalize-trailing-slash.js.map
C  {"version":3,"sources":["webpack://../../src/client/normalize-trailing-slash.ts"],"names":["removeTrailingSlash","parsePath","normalizePathTrailingSlash","path","startsWith","process","env","__NEXT_MANUAL_TRAILING_SLASH","pathname","query","hash","__NEXT_TRAILING_SLASH","test","endsWith"],"mappings":"AAAA,SAASA,mBAAmB,QAAQ,mDAAkD;AACtF,SAASC,SAAS,QAAQ,wCAAuC;AAEjE;;;CAGC,GACD,OAAO,MAAMC,6BAA6B,CAACC;IACzC,IAAI,CAACA,KAAKC,UAAU,CAAC,QAAQC,QAAQC,GAAG,CAACC,4BAA4B,EAAE;QACrE,OAAOJ;IACT;IAEA,MAAM,EAAEK,QAAQ,EAAEC,KAAK,EAAEC,IAAI,EAAE,GAAGT,UAAUE;IAC5C,IAAIE,QAAQC,GAAG,CAACK,qBAAqB,EAAE;QACrC,IAAI,cAAcC,IAAI,CAACJ,WAAW;YAChC,OAAO,KAAGR,oBAAoBQ,YAAYC,QAAQC;QACpD,OAAO,IAAIF,SAASK,QAAQ,CAAC,MAAM;YACjC,OAAO,KAAGL,WAAWC,QAAQC;QAC/B,OAAO;YACL,OAAOF,WAAY,MAAGC,QAAQC;QAChC;IACF;IAEA,OAAO,KAAGV,oBAAoBQ,YAAYC,QAAQC;AACpD,EAAC","file":"x"}M  false086undefined88153undefined270276undefined355394undefinedundefined464472__WEBPACK_MODULE_REFERENCE__39_5b22706172736550617468225d_call_directImport_asiSafe1__._undefined489521falseundefined524815{}undefined833851__WEBPACK_MODULE_REFERENCE__38_5b2272656d6f7665547261696c696e67536c617368225d_call_directImport_asiSafe1__._undefinedz   273360(0,parse_path/* parsePath */.c)undefined403510(0,remove_trailing_slash/* removeTrailingSlash */.Q)undefinedRawSourceO   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/add-base-path.js
¼ùÿÿÅùÿÿ±  import { addPathPrefix } from "../shared/lib/router/utils/add-path-prefix";
import { normalizePathTrailingSlash } from "./normalize-trailing-slash";
const basePath = process.env.__NEXT_ROUTER_BASEPATH || "";
export function addBasePath(path, required) {
    return normalizePathTrailingSlash(process.env.__NEXT_MANUAL_CLIENT_BASE_PATH && !required ? path : addPathPrefix(path, basePath));
} //# sourceMappingURL=add-base-path.js.map
ò  {"version":3,"sources":["webpack://../../src/client/add-base-path.ts"],"names":["addPathPrefix","normalizePathTrailingSlash","basePath","process","env","__NEXT_ROUTER_BASEPATH","addBasePath","path","required","__NEXT_MANUAL_CLIENT_BASE_PATH"],"mappings":"AAAA,SAASA,aAAa,QAAQ,6CAA4C;AAC1E,SAASC,0BAA0B,QAAQ,6BAA4B;AAEvE,MAAMC,WAAWC,QAASC,GAAG,CAACC,sBAAsB,IAAe;AAEnE,OAAO,SAASC,YAAYC,IAAY,EAAEC,QAAkB;IAC1D,OAAOP,2BACLE,QAAQC,GAAG,CAACK,8BAA8B,IAAI,CAACD,WAC3CD,OACAP,cAAcO,MAAML;AAE5B","file":"x"}`  false074undefined76147undefined166199 falseundefined208214undefined265290__WEBPACK_MODULE_REFERENCE__40_5b226e6f726d616c697a6550617468547261696c696e67536c617368225d_call_directImport_asiSafe1__._undefined292346 falseundefined3503530undefined357369__WEBPACK_MODULE_REFERENCE__37_5b2261646450617468507265666978225d_call_directImport_asiSafe1__._undefinedŽ   4252add_base_path_addBasePathundefined83204normalizePathTrailingSlashundefined219314(0,add_path_prefix/* addPathPrefix */.V)undefinedRawSourceñ   
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react-dom/server-rendering-stub.js
var server_rendering_stub = __webpack_require__(8754);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/app-router-announcer.js
·ùÿÿÀùÿÿ¯  import { useEffect, useRef, useState } from "react";
import { createPortal } from "react-dom";
const ANNOUNCER_TYPE = "next-route-announcer";
const ANNOUNCER_ID = "__next-route-announcer__";
function getAnnouncerNode() {
    var _existingAnnouncer_shadowRoot;
    const existingAnnouncer = document.getElementsByName(ANNOUNCER_TYPE)[0];
    if (existingAnnouncer == null ? void 0 : (_existingAnnouncer_shadowRoot = existingAnnouncer.shadowRoot) == null ? void 0 : _existingAnnouncer_shadowRoot.childNodes[0]) {
        return existingAnnouncer.shadowRoot.childNodes[0];
    } else {
        const container = document.createElement(ANNOUNCER_TYPE);
        container.style.cssText = "position:absolute";
        const announcer = document.createElement("div");
        announcer.ariaLive = "assertive";
        announcer.id = ANNOUNCER_ID;
        announcer.role = "alert";
        announcer.style.cssText = "position:absolute;border:0;height:1px;margin:-1px;padding:0;width:1px;clip:rect(0 0 0 0);overflow:hidden;white-space:nowrap;word-wrap:normal";
        // Use shadow DOM here to avoid any potential CSS bleed
        const shadow = container.attachShadow({
            mode: "open"
        });
        shadow.appendChild(announcer);
        document.body.appendChild(container);
        return announcer;
    }
}
export function AppRouterAnnouncer(param) {
    let { tree } = param;
    const [portalNode, setPortalNode] = useState(null);
    null;
    const [routeAnnouncement, setRouteAnnouncement] = useState("");
    const previousTitle = useRef();
    null;
    return portalNode ? /*#__PURE__*/ createPortal(routeAnnouncement, portalNode) : null;
} //# sourceMappingURL=app-router-announcer.js.map
Ý  {"version":3,"sources":["webpack://../../../src/client/components/app-router-announcer.tsx"],"names":["useEffect","useRef","useState","createPortal","ANNOUNCER_TYPE","ANNOUNCER_ID","getAnnouncerNode","existingAnnouncer","document","getElementsByName","shadowRoot","childNodes","container","createElement","style","cssText","announcer","ariaLive","id","role","shadow","attachShadow","mode","appendChild","body","AppRouterAnnouncer","param","tree","portalNode","setPortalNode","routeAnnouncement","setRouteAnnouncement","previousTitle"],"mappings":"AAAA,SAASA,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,QAAO;AACnD,SAASC,YAAY,QAAQ,YAAW;AAGxC,MAAMC,iBAAiB;AACvB,MAAMC,eAAe;AAErB,SAASC;QAEHC;IADJ,MAAMA,oBAAoBC,SAASC,iBAAiB,CAACL,eAAe,CAAC,EAAE;IACvE,IAAIG,qBAAAA,OAAAA,KAAAA,IAAAA,CAAAA,gCAAAA,kBAAmBG,UAAU,AAAVA,KAAU,OAAA,KAAA,IAA7BH,8BAA+BI,UAAU,CAAC,EAAE,EAAE;QAChD,OAAOJ,kBAAkBG,UAAU,CAACC,UAAU,CAAC,EAAE;IACnD,OAAO;QACL,MAAMC,YAAYJ,SAASK,aAAa,CAACT;QACzCQ,UAAUE,KAAK,CAACC,OAAO,GAAG;QAC1B,MAAMC,YAAYR,SAASK,aAAa,CAAC;QACzCG,UAAUC,QAAQ,GAAG;QACrBD,UAAUE,EAAE,GAAGb;QACfW,UAAUG,IAAI,GAAG;QACjBH,UAAUF,KAAK,CAACC,OAAO,GACrB;QAEF,uDAAuD;QACvD,MAAMK,SAASR,UAAUS,YAAY,CAAC;YAAEC,MAAM;QAAO;QACrDF,OAAOG,WAAW,CAACP;QACnBR,SAASgB,IAAI,CAACD,WAAW,CAACX;QAC1B,OAAOI;IACT;AACF;AAEA,OAAO,SAASS,mBAAmBC,KAAqC;IAArC,IAAA,EAAEC,IAAI,EAA+B,GAArCD;IACjC,MAAM,CAACE,YAAYC,cAAc,GAAG3B,SAA6B;;IAajE,MAAM,CAAC4B,mBAAmBC,qBAAqB,GAAG7B,SAAS;IAC3D,MAAM8B,gBAAgB/B;;IAwBtB,OAAO2B,aAAAA,WAAAA,GAAazB,aAAa2B,mBAAmBF,cAAc;AACpE","file":"x"}Ì  false051undefined5393undefined13201326undefined14301437__WEBPACK_MODULE_REFERENCE__1_5b227573655374617465225d_call_directImport_asiSafe1__._undefined15101517__WEBPACK_MODULE_REFERENCE__1_5b227573655374617465225d_call_directImport_asiSafe1__._undefined15501555__WEBPACK_MODULE_REFERENCE__1_5b22757365526566225d_call_directImport_asiSafe1__._undefined16081619__WEBPACK_MODULE_REFERENCE__42_5b22637265617465506f7274616c225d_call_directImport_asiSafe1__._undefined§   13301414(0,react.useState)undefined14871571(0,react.useState)undefined16041684(0,react.useRef)undefined17371830(0,server_rendering_stub.createPortal)undefinedRawSource  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/redirect-boundary.js
var redirect_boundary = __webpack_require__(7017);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/find-head-in-cache.js
²ùÿÿ»ùÿÿh  import { createRouterCacheKey } from "../create-router-cache-key";
export function findHeadInCache(cache, parallelRoutes) {
    return findHeadInCacheImpl(cache, parallelRoutes, "");
}
function findHeadInCacheImpl(cache, parallelRoutes, keyPrefix) {
    const isLastItem = Object.keys(parallelRoutes).length === 0;
    if (isLastItem) {
        // Returns the entire Cache Node of the segment whose head we will render.
        return [
            cache,
            keyPrefix
        ];
    }
    for(const key in parallelRoutes){
        const [segment, childParallelRoutes] = parallelRoutes[key];
        const childSegmentMap = cache.parallelRoutes.get(key);
        if (!childSegmentMap) {
            continue;
        }
        const cacheKey = createRouterCacheKey(segment);
        const cacheNode = childSegmentMap.get(cacheKey);
        if (!cacheNode) {
            continue;
        }
        const item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + "/" + cacheKey);
        if (item) {
            return item;
        }
    }
    return null;
} //# sourceMappingURL=find-head-in-cache.js.map
ü  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/find-head-in-cache.ts"],"names":["createRouterCacheKey","findHeadInCache","cache","parallelRoutes","findHeadInCacheImpl","keyPrefix","isLastItem","Object","keys","length","key","segment","childParallelRoutes","childSegmentMap","get","cacheKey","cacheNode","item"],"mappings":"AAEA,SAASA,oBAAoB,QAAQ,6BAA4B;AAEjE,OAAO,SAASC,gBACdC,KAAgB,EAChBC,cAAoC;IAEpC,OAAOC,oBAAoBF,OAAOC,gBAAgB;AACpD;AAEA,SAASC,oBACPF,KAAgB,EAChBC,cAAoC,EACpCE,SAAiB;IAEjB,MAAMC,aAAaC,OAAOC,IAAI,CAACL,gBAAgBM,MAAM,KAAK;IAC1D,IAAIH,YAAY;QACd,0EAA0E;QAC1E,OAAO;YAACJ;YAAOG;SAAU;IAC3B;IACA,IAAK,MAAMK,OAAOP,eAAgB;QAChC,MAAM,CAACQ,SAASC,oBAAoB,GAAGT,cAAc,CAACO,IAAI;QAC1D,MAAMG,kBAAkBX,MAAMC,cAAc,CAACW,GAAG,CAACJ;QACjD,IAAI,CAACG,iBAAiB;YACpB;QACF;QAEA,MAAME,WAAWf,qBAAqBW;QAEtC,MAAMK,YAAYH,gBAAgBC,GAAG,CAACC;QACtC,IAAI,CAACC,WAAW;YACd;QACF;QAEA,MAAMC,OAAOb,oBACXY,WACAJ,qBACAP,YAAY,MAAMU;QAEpB,IAAIE,MAAM;YACR,OAAOA;QACT;IACF;IAEA,OAAO;AACT","file":"x"}š   false065undefined6773undefined753772__WEBPACK_MODULE_REFERENCE__7_5b22637265617465526f7574657243616368654b6579225d_call_directImport_asiSafe1__._undefinedO   680788(0,create_router_cache_key/* createRouterCacheKey */.d)undefinedRawSourceá   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/unresolved-thenable.js
var unresolved_thenable = __webpack_require__(3654);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/remove-base-path.js
­ùÿÿ¶ùÿÿ  import { hasBasePath } from "./has-base-path";
const basePath = process.env.__NEXT_ROUTER_BASEPATH || "";
export function removeBasePath(path) {
    if (process.env.__NEXT_MANUAL_CLIENT_BASE_PATH) {
        if (!hasBasePath(path)) {
            return path;
        }
    }
    // Can't trim the basePath if it has zero length!
    if (basePath.length === 0) return path;
    path = path.slice(basePath.length);
    if (!path.startsWith("/")) path = "/" + path;
    return path;
} //# sourceMappingURL=remove-base-path.js.map
f  {"version":3,"sources":["webpack://../../src/client/remove-base-path.ts"],"names":["hasBasePath","basePath","process","env","__NEXT_ROUTER_BASEPATH","removeBasePath","path","__NEXT_MANUAL_CLIENT_BASE_PATH","length","slice","startsWith"],"mappings":"AAAA,SAASA,WAAW,QAAQ,kBAAiB;AAE7C,MAAMC,WAAWC,QAASC,GAAG,CAACC,sBAAsB,IAAe;AAEnE,OAAO,SAASC,eAAeC,IAAY;IACzC,IAAIJ,QAAQC,GAAG,CAACI,8BAA8B,EAAE;QAC9C,IAAI,CAACP,YAAYM,OAAO;YACtB,OAAOA;QACT;IACF;IAEA,iDAAiD;IACjD,IAAIL,SAASO,MAAM,KAAK,GAAG,OAAOF;IAElCA,OAAOA,KAAKG,KAAK,CAACR,SAASO,MAAM;IACjC,IAAI,CAACF,KAAKI,UAAU,CAAC,MAAMJ,OAAO,MAAIA;IACtC,OAAOA;AACT","file":"x"}X   false045undefined6497 falseundefined106112undefined153194falseundefined197272{}undefined~   714remove_base_path_basePathundefined144151remove_base_path_basePathundefined202209remove_base_path_basePathundefinedRawSourceÜ   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/path-has-prefix.js
var path_has_prefix = __webpack_require__(8506);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/has-base-path.js
¨ùÿÿ±ùÿÿ  import { pathHasPrefix } from "../shared/lib/router/utils/path-has-prefix";
const basePath = process.env.__NEXT_ROUTER_BASEPATH || "";
export function hasBasePath(path) {
    return pathHasPrefix(path, basePath);
} //# sourceMappingURL=has-base-path.js.map
G  {"version":3,"sources":["webpack://../../src/client/has-base-path.ts"],"names":["pathHasPrefix","basePath","process","env","__NEXT_ROUTER_BASEPATH","hasBasePath","path"],"mappings":"AAAA,SAASA,aAAa,QAAQ,6CAA4C;AAE1E,MAAMC,WAAWC,QAASC,GAAG,CAACC,sBAAsB,IAAe;AAEnE,OAAO,SAASC,YAAYC,IAAY;IACtC,OAAON,cAAcM,MAAML;AAC7B","file":"x"}£   false074undefined93126 falseundefined135141undefined182194__WEBPACK_MODULE_REFERENCE__48_5b2270617468486173507265666978225d_call_directImport_asiSafe1__._undefined†   714has_base_path_basePathundefined72167(0,path_has_prefix/* pathHasPrefix */.Y)undefined175182has_base_path_basePathundefinedRawSourceW   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/app-router.js
£ùÿÿ¬ùÿÿ<I  /* __next_internal_client_entry_do_not_use__ getServerActionDispatcher,urlToUrlWithoutFlightMarker,createEmptyCacheNode,default auto */ import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React, { use, useEffect, useMemo, useCallback, startTransition, useInsertionEffect, useDeferredValue } from "react";
import { AppRouterContext, LayoutRouterContext, GlobalLayoutRouterContext, MissingSlotContext } from "../../shared/lib/app-router-context.shared-runtime";
import { ACTION_FAST_REFRESH, ACTION_NAVIGATE, ACTION_PREFETCH, ACTION_REFRESH, ACTION_RESTORE, ACTION_SERVER_ACTION, ACTION_SERVER_PATCH, PrefetchKind } from "./router-reducer/router-reducer-types";
import { createHrefFromUrl } from "./router-reducer/create-href-from-url";
import { SearchParamsContext, PathnameContext, PathParamsContext } from "../../shared/lib/hooks-client-context.shared-runtime";
import { useReducerWithReduxDevtools, useUnwrapState } from "./use-reducer-with-devtools";
import { ErrorBoundary } from "./error-boundary";
import { createInitialRouterState } from "./router-reducer/create-initial-router-state";
import { isBot } from "../../shared/lib/router/utils/is-bot";
import { addBasePath } from "../add-base-path";
import { AppRouterAnnouncer } from "./app-router-announcer";
import { RedirectBoundary } from "./redirect-boundary";
import { findHeadInCache } from "./router-reducer/reducers/find-head-in-cache";
import { unresolvedThenable } from "./unresolved-thenable";
import { NEXT_RSC_UNION_QUERY } from "./app-router-headers";
import { removeBasePath } from "../remove-base-path";
import { hasBasePath } from "../has-base-path";
import { PAGE_SEGMENT_KEY } from "../../shared/lib/segment";
const isServer = "undefined" === "undefined";
// Ensure the initialParallelRoutes are not combined because of double-rendering in the browser with Strict Mode.
let initialParallelRoutes = isServer ? null : new Map();
let globalServerActionDispatcher = null;
export function getServerActionDispatcher() {
    return globalServerActionDispatcher;
}
const globalMutable = {};
export function urlToUrlWithoutFlightMarker(url) {
    const urlWithoutFlightParameters = new URL(url, location.origin);
    urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY);
    if ("production" === "production") {
        if (process.env.__NEXT_CONFIG_OUTPUT === "export" && urlWithoutFlightParameters.pathname.endsWith(".txt")) {
            const { pathname } = urlWithoutFlightParameters;
            const length = pathname.endsWith("/index.txt") ? 10 : 4;
            // Slice off `/index.txt` or `.txt` from the end of the pathname
            urlWithoutFlightParameters.pathname = pathname.slice(0, -length);
        }
    }
    return urlWithoutFlightParameters;
}
// this function performs a depth-first search of the tree to find the selected
// params
function getSelectedParams(currentTree, params) {
    if (params === void 0) params = {};
    const parallelRoutes = currentTree[1];
    for (const parallelRoute of Object.values(parallelRoutes)){
        const segment = parallelRoute[0];
        const isDynamicParameter = Array.isArray(segment);
        const segmentValue = isDynamicParameter ? segment[1] : segment;
        if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue;
        // Ensure catchAll and optional catchall are turned into an array
        const isCatchAll = isDynamicParameter && (segment[2] === "c" || segment[2] === "oc");
        if (isCatchAll) {
            params[segment[0]] = segment[1].split("/");
        } else if (isDynamicParameter) {
            params[segment[0]] = segment[1];
        }
        params = getSelectedParams(parallelRoute, params);
    }
    return params;
}
function isExternalURL(url) {
    return url.origin !== window.location.origin;
}
function HistoryUpdater(param) {
    let { appRouterState, sync } = param;
    useInsertionEffect(()=>{
        const { tree, pushRef, canonicalUrl } = appRouterState;
        const historyState = {
            ...pushRef.preserveCustomHistoryState ? window.history.state : {},
            // Identifier is shortened intentionally.
            // __NA is used to identify if the history entry can be handled by the app-router.
            // __N is used to identify if the history entry can be handled by the old router.
            __NA: true,
            __PRIVATE_NEXTJS_INTERNALS_TREE: tree
        };
        if (pushRef.pendingPush && // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.
        // This mirrors the browser behavior for normal navigation.
        createHrefFromUrl(new URL(window.location.href)) !== canonicalUrl) {
            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.
            pushRef.pendingPush = false;
            window.history.pushState(historyState, "", canonicalUrl);
        } else {
            window.history.replaceState(historyState, "", canonicalUrl);
        }
        sync(appRouterState);
    }, [
        appRouterState,
        sync
    ]);
    return null;
}
export function createEmptyCacheNode() {
    return {
        lazyData: null,
        rsc: null,
        prefetchRsc: null,
        head: null,
        prefetchHead: null,
        parallelRoutes: new Map(),
        lazyDataResolved: false,
        loading: null
    };
}
function useServerActionDispatcher(dispatch) {
    const serverActionDispatcher = useCallback((actionPayload)=>{
        startTransition(()=>{
            dispatch({
                ...actionPayload,
                type: ACTION_SERVER_ACTION
            });
        });
    }, [
        dispatch
    ]);
    globalServerActionDispatcher = serverActionDispatcher;
}
/**
 * Server response that only patches the cache and tree.
 */ function useChangeByServerResponse(dispatch) {
    return useCallback((param)=>{
        let { previousTree, serverResponse } = param;
        startTransition(()=>{
            dispatch({
                type: ACTION_SERVER_PATCH,
                previousTree,
                serverResponse
            });
        });
    }, [
        dispatch
    ]);
}
function useNavigate(dispatch) {
    return useCallback((href, navigateType, shouldScroll)=>{
        const url = new URL(addBasePath(href), location.href);
        return dispatch({
            type: ACTION_NAVIGATE,
            url,
            isExternalUrl: isExternalURL(url),
            locationSearch: location.search,
            shouldScroll: shouldScroll != null ? shouldScroll : true,
            navigateType
        });
    }, [
        dispatch
    ]);
}
function copyNextJsInternalHistoryState(data) {
    if (data == null) data = {};
    const currentState = window.history.state;
    const __NA = currentState == null ? void 0 : currentState.__NA;
    if (__NA) {
        data.__NA = __NA;
    }
    const __PRIVATE_NEXTJS_INTERNALS_TREE = currentState == null ? void 0 : currentState.__PRIVATE_NEXTJS_INTERNALS_TREE;
    if (__PRIVATE_NEXTJS_INTERNALS_TREE) {
        data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE;
    }
    return data;
}
function Head(param) {
    let { headCacheNode } = param;
    // If this segment has a `prefetchHead`, it's the statically prefetched data.
    // We should use that on initial render instead of `head`. Then we'll switch
    // to `head` when the dynamic response streams in.
    const head = headCacheNode !== null ? headCacheNode.head : null;
    const prefetchHead = headCacheNode !== null ? headCacheNode.prefetchHead : null;
    // If no prefetch data is available, then we go straight to rendering `head`.
    const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head;
    // We use `useDeferredValue` to handle switching between the prefetched and
    // final values. The second argument is returned on initial render, then it
    // re-renders with the first argument.
    //
    // @ts-expect-error The second argument to `useDeferredValue` is only
    // available in the experimental builds. When its disabled, it will always
    // return `head`.
    return useDeferredValue(head, resolvedPrefetchRsc);
}
/**
 * The global router that wraps the application components.
 */ function Router(param) {
    let { buildId, initialHead, initialTree, initialCanonicalUrl, initialSeedData, couldBeIntercepted, assetPrefix, missingSlots } = param;
    const initialState = useMemo(()=>createInitialRouterState({
            buildId,
            initialSeedData,
            initialCanonicalUrl,
            initialTree,
            initialParallelRoutes,
            location: !isServer ? window.location : null,
            initialHead,
            couldBeIntercepted
        }), [
        buildId,
        initialSeedData,
        initialCanonicalUrl,
        initialTree,
        initialHead,
        couldBeIntercepted
    ]);
    const [reducerState, dispatch, sync] = useReducerWithReduxDevtools(initialState);
    null;
    const { canonicalUrl } = useUnwrapState(reducerState);
    // Add memoized pathname/query for useSearchParams and usePathname.
    const { searchParams, pathname } = useMemo(()=>{
        const url = new URL(canonicalUrl, "undefined" === "undefined" ? "http://n" : window.location.href);
        return {
            // This is turned into a readonly class in `useSearchParams`
            searchParams: url.searchParams,
            pathname: hasBasePath(url.pathname) ? removeBasePath(url.pathname) : url.pathname
        };
    }, [
        canonicalUrl
    ]);
    const changeByServerResponse = useChangeByServerResponse(dispatch);
    const navigate = useNavigate(dispatch);
    useServerActionDispatcher(dispatch);
    /**
   * The app router that is exposed through `useRouter`. It's only concerned with dispatching actions to the reducer, does not hold state.
   */ const appRouter = useMemo(()=>{
        const routerInstance = {
            back: ()=>window.history.back(),
            forward: ()=>window.history.forward(),
            prefetch: (href, options)=>{
                // Don't prefetch for bots as they don't navigate.
                if (isBot(window.navigator.userAgent)) {
                    return;
                }
                let url;
                try {
                    url = new URL(addBasePath(href), window.location.href);
                } catch (_) {
                    throw new Error("Cannot prefetch '" + href + "' because it cannot be converted to a URL.");
                }
                // Don't prefetch during development (improves compilation performance)
                if ("production" === "development") {
                    return;
                }
                // External urls can't be prefetched in the same way.
                if (isExternalURL(url)) {
                    return;
                }
                startTransition(()=>{
                    var _options_kind;
                    dispatch({
                        type: ACTION_PREFETCH,
                        url,
                        kind: (_options_kind = options == null ? void 0 : options.kind) != null ? _options_kind : PrefetchKind.FULL
                    });
                });
            },
            replace: (href, options)=>{
                if (options === void 0) options = {};
                startTransition(()=>{
                    var _options_scroll;
                    navigate(href, "replace", (_options_scroll = options.scroll) != null ? _options_scroll : true);
                });
            },
            push: (href, options)=>{
                if (options === void 0) options = {};
                startTransition(()=>{
                    var _options_scroll;
                    navigate(href, "push", (_options_scroll = options.scroll) != null ? _options_scroll : true);
                });
            },
            refresh: ()=>{
                startTransition(()=>{
                    dispatch({
                        type: ACTION_REFRESH,
                        origin: window.location.origin
                    });
                });
            },
            fastRefresh: ()=>{
                if ("production" !== "development") {
                    throw new Error("fastRefresh can only be used in development mode. Please use refresh instead.");
                } else {
                    startTransition(()=>{
                        dispatch({
                            type: ACTION_FAST_REFRESH,
                            origin: window.location.origin
                        });
                    });
                }
            }
        };
        return routerInstance;
    }, [
        dispatch,
        navigate
    ]);
    null;
    if ("production" !== "production") {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        const { cache, prefetchCache, tree } = useUnwrapState(reducerState);
        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes
        // eslint-disable-next-line react-hooks/rules-of-hooks
        null;
    }
    null;
    // When mpaNavigation flag is set do a hard navigation to the new url.
    // Infinitely suspend because we don't actually want to rerender any child
    // components with the new URL and any entangled state updates shouldn't
    // commit either (eg: useTransition isPending should stay true until the page
    // unloads).
    //
    // This is a side effect in render. Don't try this at home, kids. It's
    // probably safe because we know this is a singleton component and it's never
    // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,
    // but that's... fine?)
    const { pushRef } = useUnwrapState(reducerState);
    if (pushRef.mpaNavigation) {
        // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL
        if (globalMutable.pendingMpaPath !== canonicalUrl) {
            const location1 = window.location;
            if (pushRef.pendingPush) {
                location1.assign(canonicalUrl);
            } else {
                location1.replace(canonicalUrl);
            }
            globalMutable.pendingMpaPath = canonicalUrl;
        }
        // TODO-APP: Should we listen to navigateerror here to catch failed
        // navigations somehow? And should we call window.stop() if a SPA navigation
        // should interrupt an MPA one?
        use(unresolvedThenable);
    }
    null;
    const { cache, tree, nextUrl, focusAndScrollRef } = useUnwrapState(reducerState);
    const matchingHead = useMemo(()=>{
        return findHeadInCache(cache, tree[1]);
    }, [
        cache,
        tree
    ]);
    // Add memoized pathParams for useParams.
    const pathParams = useMemo(()=>{
        return getSelectedParams(tree);
    }, [
        tree
    ]);
    let head;
    if (matchingHead !== null) {
        // The head is wrapped in an extra component so we can use
        // `useDeferredValue` to swap between the prefetched and final versions of
        // the head. (This is what LayoutRouter does for segment data, too.)
        //
        // The `key` is used to remount the component whenever the head moves to
        // a different segment.
        const [headCacheNode, headKey] = matchingHead;
        head = /*#__PURE__*/ _jsx(Head, {
            headCacheNode: headCacheNode
        }, headKey);
    } else {
        head = null;
    }
    let content = /*#__PURE__*/ _jsxs(RedirectBoundary, {
        children: [
            head,
            cache.rsc,
            /*#__PURE__*/ _jsx(AppRouterAnnouncer, {
                tree: tree
            })
        ]
    });
    if ("production" !== "production") {
        if ("undefined" !== "undefined") {
            const DevRootNotFoundBoundary = require("./dev-root-not-found-boundary").DevRootNotFoundBoundary;
            content = /*#__PURE__*/ _jsx(DevRootNotFoundBoundary, {
                children: /*#__PURE__*/ _jsx(MissingSlotContext.Provider, {
                    value: missingSlots,
                    children: content
                })
            });
        }
        const HotReloader = require("./react-dev-overlay/app/hot-reloader-client").default;
        content = /*#__PURE__*/ _jsx(HotReloader, {
            assetPrefix: assetPrefix,
            children: content
        });
    }
    return /*#__PURE__*/ _jsxs(_Fragment, {
        children: [
            /*#__PURE__*/ _jsx(HistoryUpdater, {
                appRouterState: useUnwrapState(reducerState),
                sync: sync
            }),
            /*#__PURE__*/ _jsx(PathParamsContext.Provider, {
                value: pathParams,
                children: /*#__PURE__*/ _jsx(PathnameContext.Provider, {
                    value: pathname,
                    children: /*#__PURE__*/ _jsx(SearchParamsContext.Provider, {
                        value: searchParams,
                        children: /*#__PURE__*/ _jsx(GlobalLayoutRouterContext.Provider, {
                            value: {
                                buildId,
                                changeByServerResponse,
                                tree,
                                focusAndScrollRef,
                                nextUrl
                            },
                            children: /*#__PURE__*/ _jsx(AppRouterContext.Provider, {
                                value: appRouter,
                                children: /*#__PURE__*/ _jsx(LayoutRouterContext.Provider, {
                                    value: {
                                        childNodes: cache.parallelRoutes,
                                        tree,
                                        // Root node always has `url`
                                        // Provided in AppTreeContext to ensure it can be overwritten in layout-router
                                        url: canonicalUrl,
                                        loading: cache.loading
                                    },
                                    children: content
                                })
                            })
                        })
                    })
                })
            })
        ]
    });
}
export default function AppRouter(props) {
    const { globalErrorComponent, ...rest } = props;
    return /*#__PURE__*/ _jsx(ErrorBoundary, {
        errorComponent: globalErrorComponent,
        children: /*#__PURE__*/ _jsx(Router, {
            ...rest
        })
    });
} //# sourceMappingURL=app-router.js.map
š)  {"version":3,"sources":["webpack://../../../src/client/components/app-router.tsx"],"names":["React","use","useEffect","_jsxs","useMemo","useCallback","startTransition","useInsertionEffect","AppRouterContext","LayoutRouterContext","GlobalLayoutRouterContext","MissingSlotContext","ACTION_FAST_REFRESH","ACTION_PREFETCH","ACTION_REFRESH","ACTION_RESTORE","ACTION_SERVER_ACTION","createHrefFromUrl","ACTION_NAVIGATE","ACTION_SERVER_PATCH","PrefetchKind","SearchParamsContext","PathnameContext","useReducerWithReduxDevtools","useUnwrapState","ErrorBoundary","createInitialRouterState","isBot","addBasePath","AppRouterAnnouncer","RedirectBoundary","findHeadInCache","unresolvedThenable","NEXT_RSC_UNION_QUERY","removeBasePath","hasBasePath","PAGE_SEGMENT_KEY","isServer","window","Map","globalServerActionDispatcher","getServerActionDispatcher","globalMutable","urlToUrlWithoutFlightMarker","urlWithoutFlightParameters","URL","url","searchParams","delete","process","__NEXT_CONFIG_OUTPUT","pathname","length","endsWith","slice","getSelectedParams","params","parallelRoutes","currentTree","parallelRoute","Object","values","segment","isDynamicParameter","Array","segmentValue","startsWith","isCatchAll","split","isExternalURL","origin","location","HistoryUpdater","param","sync","pushRef","historyState","canonicalUrl","appRouterState","preserveCustomHistoryState","history","state","__NA","__PRIVATE_NEXTJS_INTERNALS_TREE","tree","pendingPush","href","pushState","replaceState","createEmptyCacheNode","lazyData","rsc","prefetchRsc","head","prefetchHead","lazyDataResolved","loading","useServerActionDispatcher","actionPayload","type","dispatch","serverActionDispatcher","previousTree","serverResponse","useNavigate","isExternalUrl","locationSearch","search","shouldScroll","navigateType","data","currentState","Head","headCacheNode","resolvedPrefetchRsc","useDeferredValue","buildId","initialHead","initialState","initialSeedData","couldBeIntercepted","assetPrefix","missingSlots","initialCanonicalUrl","initialTree","initialParallelRoutes","reducerState","navigate","appRouter","routerInstance","back","forward","prefetch","options","navigator","userAgent","_","Error","kind","_options_kind","FULL","replace","_options_scroll","scroll","push","refresh","fastRefresh","cache","prefetchCache","mpaNavigation","location1","assign","pendingMpaPath","matchingHead","focusAndScrollRef","pathParams","headKey","DevRootNotFoundBoundary","content","_jsx","Provider","value","HotReloader","changeByServerResponse","nextUrl","childNodes","globalErrorComponent","props","rest","errorComponent","Router"],"mappings":"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","file":"x"}à  false136221undefined223345undefined347500undefined502700undefined702775undefined777903undefined905994undefined9961044undefined10461133undefined11351195undefined11971243undefined12451304undefined13061360undefined13621440undefined14421500undefined15021561undefined15631615undefined16171663undefined16651724undefined19841990undefined20992105undefined22712290__WEBPACK_MODULE_REFERENCE__14_5b224e4558545f5253435f554e494f4e5f5155455259225d_directImport_asiSafe1__._undefined23022330trueundefined23472447falseundefined24502745{}undefined33073322__WEBPACK_MODULE_REFERENCE__11_5b22504147455f5345474d454e545f4b4559225d_directImport_asiSafe1__._undefined39293946__WEBPACK_MODULE_REFERENCE__1_5b22757365496e73657274696f6e456666656374225d_call_directImport_asiSafe1__._undefined46634679__WEBPACK_MODULE_REFERENCE__4_5b226372656174654872656646726f6d55726c225d_call_directImport_asiSafe1__._undefined52085214undefined55615571__WEBPACK_MODULE_REFERENCE__1_5b2275736543616c6c6261636b225d_call_directImport_asiSafe1__._undefined56005614__WEBPACK_MODULE_REFERENCE__1_5b2273746172745472616e736974696f6e225d_call_directImport_asiSafe1__._undefined57015720__WEBPACK_MODULE_REFERENCE__3_5b22414354494f4e5f5345525645525f414354494f4e225d_directImport_asiSafe1__._undefined59685978__WEBPACK_MODULE_REFERENCE__1_5b2275736543616c6c6261636b225d_call_directImport_asiSafe1__._undefined60536067__WEBPACK_MODULE_REFERENCE__1_5b2273746172745472616e736974696f6e225d_call_directImport_asiSafe1__._undefined61206138__WEBPACK_MODULE_REFERENCE__3_5b22414354494f4e5f5345525645525f5041544348225d_directImport_asiSafe1__._undefined63106320__WEBPACK_MODULE_REFERENCE__1_5b2275736543616c6c6261636b225d_call_directImport_asiSafe1__._undefined63886398__WEBPACK_MODULE_REFERENCE__41_5b226164644261736550617468225d_call_directImport_asiSafe1__._undefined64676481__WEBPACK_MODULE_REFERENCE__3_5b22414354494f4e5f4e41564947415445225d_directImport_asiSafe1__._undefined82358250__WEBPACK_MODULE_REFERENCE__1_5b22757365446566657272656456616c7565225d_call_directImport_asiSafe1__._undefined85408546__WEBPACK_MODULE_REFERENCE__1_5b227573654d656d6f225d_call_directImport_asiSafe1__._undefined85528575__WEBPACK_MODULE_REFERENCE__35_5b22637265617465496e697469616c526f757465725374617465225d_call_directImport_asiSafe1__._undefined90419067__WEBPACK_MODULE_REFERENCE__31_5b2275736552656475636572576974685265647578446576746f6f6c73225d_call_directImport_asiSafe1__._undefined91239136__WEBPACK_MODULE_REFERENCE__31_5b22757365556e777261705374617465225d_call_directImport_asiSafe1__._undefined92649270__WEBPACK_MODULE_REFERENCE__1_5b227573654d656d6f225d_call_directImport_asiSafe1__._undefined93209346 trueundefined936393820undefined95429552__WEBPACK_MODULE_REFERENCE__49_5b226861734261736550617468225d_call_directImport_asiSafe1__._undefined95709583__WEBPACK_MODULE_REFERENCE__47_5b2272656d6f76654261736550617468225d_call_directImport_asiSafe1__._undefined99919997__WEBPACK_MODULE_REFERENCE__1_5b227573654d656d6f225d_call_directImport_asiSafe1__._undefined1026210266__WEBPACK_MODULE_REFERENCE__36_5b226973426f74225d_call_directImport_asiSafe1__._undefined1042610436__WEBPACK_MODULE_REFERENCE__41_5b226164644261736550617468225d_call_directImport_asiSafe1__._undefined1073610765falseundefined1076810814{}undefined1099011004__WEBPACK_MODULE_REFERENCE__1_5b2273746172745472616e736974696f6e225d_call_directImport_asiSafe1__._undefined1111211126__WEBPACK_MODULE_REFERENCE__3_5b22414354494f4e5f5052454645544348225d_directImport_asiSafe1__._undefined1127211283__WEBPACK_MODULE_REFERENCE__3_5b2250726566657463684b696e64225d_asiSafe1__._undefined1145911473__WEBPACK_MODULE_REFERENCE__1_5b2273746172745472616e736974696f6e225d_call_directImport_asiSafe1__._undefined1178011794__WEBPACK_MODULE_REFERENCE__1_5b2273746172745472616e736974696f6e225d_call_directImport_asiSafe1__._undefined1203412048__WEBPACK_MODULE_REFERENCE__1_5b2273746172745472616e736974696f6e225d_call_directImport_asiSafe1__._undefined1211712130__WEBPACK_MODULE_REFERENCE__3_5b22414354494f4e5f52454652455348225d_directImport_asiSafe1__._undefined1229812327trueundefined1247312734{}undefined1286212890falseundefined1289313217{}undefined1385713870__WEBPACK_MODULE_REFERENCE__31_5b22757365556e777261705374617465225d_call_directImport_asiSafe1__._undefined1459614598__WEBPACK_MODULE_REFERENCE__1_5b22757365225d_call_directImport_asiSafe1__._undefined1460014617__WEBPACK_MODULE_REFERENCE__46_5b22756e7265736f6c7665645468656e61626c65225d_directImport_asiSafe1__._undefined1469314706__WEBPACK_MODULE_REFERENCE__31_5b22757365556e777261705374617465225d_call_directImport_asiSafe1__._undefined1474814754__WEBPACK_MODULE_REFERENCE__1_5b227573654d656d6f225d_call_directImport_asiSafe1__._undefined1477714791__WEBPACK_MODULE_REFERENCE__45_5b2266696e6448656164496e4361636865225d_call_directImport_asiSafe1__._undefined1492414930__WEBPACK_MODULE_REFERENCE__1_5b227573654d656d6f225d_call_directImport_asiSafe1__._undefined1549015493__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1563715641__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined1564315658__WEBPACK_MODULE_REFERENCE__44_5b225265646972656374426f756e64617279225d_directImport_asiSafe1__._undefined1575015753__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1575515772__WEBPACK_MODULE_REFERENCE__43_5b22417070526f75746572416e6e6f756e636572225d_directImport_asiSafe1__._undefined1584515873falseundefined1587616527{}undefined1655416558__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined1656016568__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined1661916622__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1667416687__WEBPACK_MODULE_REFERENCE__31_5b22757365556e777261705374617465225d_call_directImport_asiSafe1__._undefined1677316776__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1677816794__WEBPACK_MODULE_REFERENCE__5_5b2250617468506172616d73436f6e74657874225d_asiSafe1__._undefined1688316886__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1688816902__WEBPACK_MODULE_REFERENCE__5_5b22506174686e616d65436f6e74657874225d_asiSafe1__._undefined1699717000__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1700217020__WEBPACK_MODULE_REFERENCE__5_5b22536561726368506172616d73436f6e74657874225d_asiSafe1__._undefined1712717130__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1713217156__WEBPACK_MODULE_REFERENCE__2_5b22476c6f62616c4c61796f7574526f75746572436f6e74657874225d_asiSafe1__._undefined1751617519__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1752117536__WEBPACK_MODULE_REFERENCE__2_5b22417070526f75746572436f6e74657874225d_asiSafe1__._undefined1765617659__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1766117679__WEBPACK_MODULE_REFERENCE__2_5b224c61796f7574526f75746572436f6e74657874225d_asiSafe1__._undefined1843218446undefined1855318556__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1855818570__WEBPACK_MODULE_REFERENCE__32_5b224572726f72426f756e64617279225d_directImport_asiSafe1__._undefined1865318656__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined=  686790app_router_headers/* NEXT_RSC_UNION_QUERY */.H4undefined13921488lib_segment/* PAGE_SEGMENT_KEY */.GCundefined20952199(0,react.useInsertionEffect)undefined29163018create_href_from_url_createHrefFromUrlundefined35563575app_router_createEmptyCacheNodeundefined38933983(0,react.useCallback)undefined40124110(0,react.startTransition)undefined41974300router_reducer_types/* ACTION_SERVER_ACTION */.WAundefined45484638(0,react.useCallback)undefined47134811(0,react.startTransition)undefined48644965router_reducer_types/* ACTION_SERVER_PATCH */.n0undefined51375227(0,react.useCallback)undefined52955386add_base_path_addBasePathundefined54555548router_reducer_types/* ACTION_NAVIGATE */.bOundefined73027402(0,react.useDeferredValue)undefined76927774(0,react.useMemo)undefined77807897createInitialRouterStateundefined83638486useReducerWithReduxDevtoolsundefined85428639useUnwrapStateundefined87678849(0,react.useMemo)undefined90809171hasBasePathundefined91899286removeBasePathundefined96949776(0,react.useMemo)undefined1004110120(0,is_bot/* isBot */.Q)undefined1028010371add_base_path_addBasePathundefined1085510953(0,react.startTransition)undefined1106111154router_reducer_types/* ACTION_PREFETCH */.Pmundefined1130011374router_reducer_types/* PrefetchKind */.Keundefined1155011648(0,react.startTransition)undefined1195512053(0,react.startTransition)undefined1229312391(0,react.startTransition)undefined1246012551router_reducer_types/* ACTION_REFRESH */.HDundefined1364513742useUnwrapStateundefined1446814542(0,react.use)undefined1454414644unresolved_thenable/* unresolvedThenable */.cundefined1472014817useUnwrapStateundefined1485914941(0,react.useMemo)undefined1496415063findHeadInCacheundefined1519615278(0,react.useMemo)undefined1583815912(0,jsx_runtime.jsx)undefined1605616132(0,jsx_runtime.jsxs)undefined1613416230redirect_boundary/* RedirectBoundary */.Iundefined1632216396(0,jsx_runtime.jsx)undefined1639816498AppRouterAnnouncerundefined1660616682(0,jsx_runtime.jsxs)undefined1668416763jsx_runtime.Fragmentundefined1681416888(0,jsx_runtime.jsx)undefined1694017037useUnwrapStateundefined1712317197(0,jsx_runtime.jsx)undefined1719917283hooks_client_context_shared_runtime.PathParamsContextundefined1737217446(0,jsx_runtime.jsx)undefined1744817528hooks_client_context_shared_runtime.PathnameContextundefined1762317697(0,jsx_runtime.jsx)undefined1769917787hooks_client_context_shared_runtime.SearchParamsContextundefined1789417968(0,jsx_runtime.jsx)undefined1797018070app_router_context_shared_runtime.GlobalLayoutRouterContextundefined1843018504(0,jsx_runtime.jsx)undefined1850618588app_router_context_shared_runtime.AppRouterContextundefined1870818782(0,jsx_runtime.jsx)undefined1878418872app_router_context_shared_runtime.LayoutRouterContextundefined1973119805(0,jsx_runtime.jsx)undefined1980719897error_boundary.ErrorBoundaryundefined1998020054(0,jsx_runtime.jsx)undefinedc÷ÿÿ@÷ÿÿ   ,

/***/ 9061:
   6  «webpack/lib/util/registerExternalSerializerœwebpack-sources/ConcatSource€«webpack/lib/util/registerExternalSerializer™webpack-sources/RawSource_   /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
«webpack/lib/util/registerExternalSerializerœwebpack-sources/CachedSource   µ	  «webpack/lib/util/registerExternalSerializerœwebpack-sources/ConcatSource€«webpack/lib/util/registerExternalSerializer™webpack-sources/RawSourceß  __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bailoutToClientRendering: () => (/* binding */ bailoutToClientRendering)
/* harmony export */ });
/* harmony import */ var _shared_lib_lazy_dynamic_bailout_to_csr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1192);
/* harmony import */ var _static_generation_async_storage_external__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1548);
«webpack/lib/util/registerExternalSerializerwebpack-sources/ReplaceSource«webpack/lib/util/registerExternalSerializerŸwebpack-sources/SourceMapSourceA  import { BailoutToCSRError } from "../../shared/lib/lazy-dynamic/bailout-to-csr";
import { staticGenerationAsyncStorage } from "./static-generation-async-storage.external";
export function bailoutToClientRendering(reason) {
    const staticGenerationStore = staticGenerationAsyncStorage.getStore();
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.forceStatic) return;
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.isStaticGeneration) throw new BailoutToCSRError(reason);
} //# sourceMappingURL=bailout-to-client-rendering.js.map
&  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/client/components/bailout-to-client-rendering.js|ssr(  {"version":3,"sources":["webpack://../../../src/client/components/bailout-to-client-rendering.ts"],"names":["BailoutToCSRError","staticGenerationAsyncStorage","bailoutToClientRendering","reason","staticGenerationStore","getStore","forceStatic","isStaticGeneration"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,+CAA8C;AAChF,SAASC,4BAA4B,QAAQ,6CAA4C;AAEzF,OAAO,SAASC,yBAAyBC,MAAc;IACrD,MAAMC,wBAAwBH,6BAA6BI,QAAQ;IAEnE,IAAID,yBAAAA,OAAAA,KAAAA,IAAAA,sBAAuBE,WAAW,EAAE;IAExC,IAAIF,yBAAAA,OAAAA,KAAAA,IAAAA,sBAAuBG,kBAAkB,EAC3C,MAAM,IAAIP,kBAAkBG;AAChC","file":"x"} aPRF«   ­   ³       ì  ü  €€€ì_static_generation_async_storage_external__WEBPACK_IMPORTED_MODULE_1__/* .staticGenerationAsyncStorage */ .Aß_shared_lib_lazy_dynamic_bailout_to_csr__WEBPACK_IMPORTED_MODULE_0__/* .BailoutToCSRError */ .Z€†buffer†source„size„maps„hash  __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bailoutToClientRendering: () => (/* binding */ bailoutToClientRendering)
/* harmony export */ });
/* harmony import */ var _shared_lib_lazy_dynamic_bailout_to_csr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1192);
/* harmony import */ var _static_generation_async_storage_external__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1548);


function bailoutToClientRendering(reason) {
    const staticGenerationStore = _static_generation_async_storage_external__WEBPACK_IMPORTED_MODULE_1__/* .staticGenerationAsyncStorage */ .A.getStore();
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.forceStatic) return;
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.isStaticGeneration) throw new _shared_lib_lazy_dynamic_bailout_to_csr__WEBPACK_IMPORTED_MODULE_0__/* .BailoutToCSRError */ .Z(reason);
} //# sourceMappingURL=bailout-to-client-rendering.js.map
€”{"finalSource":true}ƒmap‹bufferedMap‡version„fileˆmappings‡sourcesŽsourcesContent…namesxà   ;;;;;;AAAgF;AACS;AAElF,SAASE,yBAAyBC,MAAc;IACrD,MAAMC,wBAAwBH,4GAAAA,CAA6BI,QAAQ;IAEnE,IAAID,yBAAAA,OAAAA,KAAAA,IAAAA,sBAAuBE,WAAW,EAAE;IAExC,IAAIF,yBAAAA,OAAAA,KAAAA,IAAAA,sBAAuBG,kBAAkB,EAC3C,MAAM,IAAIP,+FAAAA,CAAkBG;AAChCÇwebpack://../../../src/client/components/bailout-to-client-rendering.ts‘BailoutToCSRErrorœstaticGenerationAsyncStorage˜bailoutToClientRendering†reason•staticGenerationStoreˆgetStore‹forceStatic’isStaticGeneration   ConcatSourceRawSourceß  __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bailoutToClientRendering: () => (/* binding */ bailoutToClientRendering)
/* harmony export */ });
/* harmony import */ var _shared_lib_lazy_dynamic_bailout_to_csr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1192);
/* harmony import */ var _static_generation_async_storage_external__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1548);
   ReplaceSourceSourceMapSourceA  import { BailoutToCSRError } from "../../shared/lib/lazy-dynamic/bailout-to-csr";
import { staticGenerationAsyncStorage } from "./static-generation-async-storage.external";
export function bailoutToClientRendering(reason) {
    const staticGenerationStore = staticGenerationAsyncStorage.getStore();
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.forceStatic) return;
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.isStaticGeneration) throw new BailoutToCSRError(reason);
} //# sourceMappingURL=bailout-to-client-rendering.js.map
(  {"version":3,"sources":["webpack://../../../src/client/components/bailout-to-client-rendering.ts"],"names":["BailoutToCSRError","staticGenerationAsyncStorage","bailoutToClientRendering","reason","staticGenerationStore","getStore","forceStatic","isStaticGeneration"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,+CAA8C;AAChF,SAASC,4BAA4B,QAAQ,6CAA4C;AAEzF,OAAO,SAASC,yBAAyBC,MAAc;IACrD,MAAMC,wBAAwBH,6BAA6BI,QAAQ;IAEnE,IAAID,yBAAAA,OAAAA,KAAAA,IAAAA,sBAAuBE,WAAW,EAAE;IAExC,IAAIF,yBAAAA,OAAAA,KAAAA,IAAAA,sBAAuBG,kBAAkB,EAC3C,MAAM,IAAIP,kBAAkBG;AAChC","file":"x"}  false080undefined82171undefined173179undefined258285_static_generation_async_storage_external__WEBPACK_IMPORTED_MODULE_1__/* .staticGenerationAsyncStorage */ .Aundefined492508_shared_lib_lazy_dynamic_bailout_to_csr__WEBPACK_IMPORTED_MODULE_0__/* .BailoutToCSRError */ .Zundefined
   

/***/ })!÷ÿÿu  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bailoutToClientRendering: () => (/* binding */ bailoutToClientRendering)
/* harmony export */ });
/* harmony import */ var _shared_lib_lazy_dynamic_bailout_to_csr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1192);
/* harmony import */ var _static_generation_async_storage_external__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1548);


function bailoutToClientRendering(reason) {
    const staticGenerationStore = _static_generation_async_storage_external__WEBPACK_IMPORTED_MODULE_1__/* .staticGenerationAsyncStorage */ .A.getStore();
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.forceStatic) return;
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.isStaticGeneration) throw new _shared_lib_lazy_dynamic_bailout_to_csr__WEBPACK_IMPORTED_MODULE_0__/* .BailoutToCSRError */ .Z(reason);
} //# sourceMappingURL=bailout-to-client-rendering.js.map


/***/ })"÷ÿÿ%÷ÿÿ,÷ÿÿxã   ;;;;;;;;;AAAgF;AACS;AAElF,SAASE,yBAAyBC,MAAc;IACrD,MAAMC,wBAAwBH,4GAAAA,CAA6BI,QAAQ;IAEnE,IAAID,yBAAAA,OAAAA,KAAAA,IAAAA,sBAAuBE,WAAW,EAAE;IAExC,IAAIF,yBAAAA,OAAAA,KAAAA,IAAAA,sBAAuBG,kBAAkB,EAC3C,MAAM,IAAIP,+FAAAA,CAAkBG;AAChCÇwebpack://../../../src/client/components/bailout-to-client-rendering.ts‘BailoutToCSRError€ùÿÿ˜bailoutToClientRenderingüÿÿ•staticGenerationStoreƒùÿÿ„ùÿÿ†ùÿÿ
,÷ÿÿùÿÿ,÷ÿÿß  __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bailoutToClientRendering: () => (/* binding */ bailoutToClientRendering)
/* harmony export */ });
/* harmony import */ var _shared_lib_lazy_dynamic_bailout_to_csr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1192);
/* harmony import */ var _static_generation_async_storage_external__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1548);
—ùÿÿA  import { BailoutToCSRError } from "../../shared/lib/lazy-dynamic/bailout-to-csr";
import { staticGenerationAsyncStorage } from "./static-generation-async-storage.external";
export function bailoutToClientRendering(reason) {
    const staticGenerationStore = staticGenerationAsyncStorage.getStore();
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.forceStatic) return;
    if (staticGenerationStore == null ? void 0 : staticGenerationStore.isStaticGeneration) throw new BailoutToCSRError(reason);
} //# sourceMappingURL=bailout-to-client-rendering.js.map
(  {"version":3,"sources":["webpack://../../../src/client/components/bailout-to-client-rendering.ts"],"names":["BailoutToCSRError","staticGenerationAsyncStorage","bailoutToClientRendering","reason","staticGenerationStore","getStore","forceStatic","isStaticGeneration"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,+CAA8C;AAChF,SAASC,4BAA4B,QAAQ,6CAA4C;AAEzF,OAAO,SAASC,yBAAyBC,MAAc;IACrD,MAAMC,wBAAwBH,6BAA6BI,QAAQ;IAEnE,IAAID,yBAAAA,OAAAA,KAAAA,IAAAA,sBAAuBE,WAAW,EAAE;IAExC,IAAIF,yBAAAA,OAAAA,KAAAA,IAAAA,sBAAuBG,kBAAkB,EAC3C,MAAM,IAAIP,kBAAkBG;AAChC","file":"x"}  false080undefined82171undefined173179undefined258285_static_generation_async_storage_external__WEBPACK_IMPORTED_MODULE_1__/* .staticGenerationAsyncStorage */ .Aundefined492508_shared_lib_lazy_dynamic_bailout_to_csr__WEBPACK_IMPORTED_MODULE_0__/* .BailoutToCSRError */ .ZundefinedO÷ÿÿ,÷ÿÿ   ,

/***/ 5441:
   •  «webpack/lib/util/registerExternalSerializerœwebpack-sources/ConcatSource€«webpack/lib/util/registerExternalSerializer™webpack-sources/RawSource_   /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
«webpack/lib/util/registerExternalSerializerœwebpack-sources/CachedSource   XX  «webpack/lib/util/registerExternalSerializerœwebpack-sources/ConcatSource€«webpack/lib/util/registerExternalSerializer™webpack-sources/RawSource]  // ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ClientPageRoot: () => (/* binding */ ClientPageRoot)
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5486);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/static-generation-async-storage.external.js + 1 modules
var static_generation_async_storage_external = __webpack_require__(1548);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/app-render/dynamic-rendering.js
var dynamic_rendering = __webpack_require__(8255);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/adapters/reflect.js
var reflect = __webpack_require__(8491);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/search-params.js
«webpack/lib/util/registerExternalSerializerwebpack-sources/ReplaceSource«webpack/lib/util/registerExternalSerializerœwebpack-sources/CachedSource   p  «webpack/lib/util/registerExternalSerializerwebpack-sources/ReplaceSource«webpack/lib/util/registerExternalSerializerŸwebpack-sources/SourceMapSource€j  import { staticGenerationAsyncStorage } from "./static-generation-async-storage.external";
import { trackDynamicDataAccessed } from "../../server/app-render/dynamic-rendering";
import { ReflectAdapter } from "../../server/web/spec-extension/adapters/reflect";
/**
 * Takes a ParsedUrlQuery object and either returns it unmodified or returns an empty object
 *
 * Even though we do not track read access on the returned searchParams we need to
 * return an empty object if we are doing a 'force-static' render. This is to ensure
 * we don't encode the searchParams into the flight data.
 */ export function createUntrackedSearchParams(searchParams) {
    const store = staticGenerationAsyncStorage.getStore();
    if (store && store.forceStatic) {
        return {};
    } else {
        return searchParams;
    }
}
/**
 * Takes a ParsedUrlQuery object and returns a Proxy that tracks read access to the object
 *
 * If running in the browser will always return the provided searchParams object.
 * When running during SSR will return empty during a 'force-static' render and
 * otherwise it returns a searchParams object which tracks reads to trigger dynamic rendering
 * behavior if appropriate
 */ export function createDynamicallyTrackedSearchParams(searchParams) {
    const store = staticGenerationAsyncStorage.getStore();
    if (!store) {
        // we assume we are in a route handler or page render. just return the searchParams
        return searchParams;
    } else if (store.forceStatic) {
        // If we forced static we omit searchParams entirely. This is true both during SSR
        // and browser render because we need there to be parity between these environments
        return {};
    } else if (!store.isStaticGeneration && !store.dynamicShouldError) {
        // during dynamic renders we don't actually have to track anything so we just return
        // the searchParams directly. However if dynamic data access should error then we
        // still want to track access. This covers the case in Dev where all renders are dynamic
        // but we still want to error if you use a dynamic data source because it will fail the build
        // or revalidate if you do.
        return searchParams;
    } else {
        // We need to track dynamic access with a Proxy. We implement get, has, and ownKeys because
        // these can all be used to exfiltrate information about searchParams.
        return new Proxy({}, {
            get (target, prop, receiver) {
                if (typeof prop === "string") {
                    trackDynamicDataAccessed(store, "searchParams." + prop);
                }
                return ReflectAdapter.get(target, prop, receiver);
            },
            has (target, prop) {
                if (typeof prop === "string") {
                    trackDynamicDataAccessed(store, "searchParams." + prop);
                }
                return Reflect.has(target, prop);
            },
            ownKeys (target) {
                trackDynamicDataAccessed(store, "searchParams");
                return Reflect.ownKeys(target);
            }
        });
    }
} //# sourceMappingURL=search-params.js.map
  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/client/components/search-params.js|ssr¢  {"version":3,"sources":["webpack://../../../src/client/components/search-params.ts"],"names":["staticGenerationAsyncStorage","trackDynamicDataAccessed","ReflectAdapter","createUntrackedSearchParams","searchParams","store","getStore","forceStatic","createDynamicallyTrackedSearchParams","isStaticGeneration","dynamicShouldError","Proxy","get","target","prop","receiver","has","Reflect","ownKeys"],"mappings":"AAEA,SAASA,4BAA4B,QAAQ,6CAA4C;AACzF,SAASC,wBAAwB,QAAQ,4CAA2C;AACpF,SAASC,cAAc,QAAQ,mDAAkD;AAEjF;;;;;;CAMC,GACD,OAAO,SAASC,4BACdC,YAA4B;IAE5B,MAAMC,QAAQL,6BAA6BM,QAAQ;IACnD,IAAID,SAASA,MAAME,WAAW,EAAE;QAC9B,OAAO,CAAC;IACV,OAAO;QACL,OAAOH;IACT;AACF;AAEA;;;;;;;CAOC,GACD,OAAO,SAASI,qCACdJ,YAA4B;IAE5B,MAAMC,QAAQL,6BAA6BM,QAAQ;IACnD,IAAI,CAACD,OAAO;QACV,mFAAmF;QACnF,OAAOD;IACT,OAAO,IAAIC,MAAME,WAAW,EAAE;QAC5B,kFAAkF;QAClF,mFAAmF;QACnF,OAAO,CAAC;IACV,OAAO,IAAI,CAACF,MAAMI,kBAAkB,IAAI,CAACJ,MAAMK,kBAAkB,EAAE;QACjE,oFAAoF;QACpF,iFAAiF;QACjF,wFAAwF;QACxF,6FAA6F;QAC7F,2BAA2B;QAC3B,OAAON;IACT,OAAO;QACL,2FAA2F;QAC3F,sEAAsE;QACtE,OAAO,IAAIO,MAAM,CAAC,GAAqB;YACrCC,KAAIC,MAAM,EAAEC,IAAI,EAAEC,QAAQ;gBACxB,IAAI,OAAOD,SAAS,UAAU;oBAC5Bb,yBAAyBI,OAAO,kBAAgBS;gBAClD;gBACA,OAAOZ,eAAeU,GAAG,CAACC,QAAQC,MAAMC;YAC1C;YACAC,KAAIH,MAAM,EAAEC,IAAI;gBACd,IAAI,OAAOA,SAAS,UAAU;oBAC5Bb,yBAAyBI,OAAO,kBAAgBS;gBAClD;gBACA,OAAOG,QAAQD,GAAG,CAACH,QAAQC;YAC7B;YACAI,SAAQL,MAAM;gBACZZ,yBAAyBI,OAAO;gBAChC,OAAOY,QAAQC,OAAO,CAACL;YACzB;QACF;IACF;AACF","file":"x"}
 aY[P¯   ±     N  T  ±  ·    #   
  
  b
  o
      ½  Ô  €€€€€ð__WEBPACK_MODULE_REFERENCE__1_5b2273746174696347656e65726174696f6e4173796e6353746f72616765225d_call_asiSafe1__._õ__WEBPACK_MODULE_REFERENCE__2_5b22747261636b44796e616d6963446174614163636573736564225d_call_directImport_asiSafe1__._Ô__WEBPACK_MODULE_REFERENCE__3_5b225265666c65637441646170746572225d_call_asiSafe1__._þþ€†buffer†source„size„maps„hash  


/**
 * Takes a ParsedUrlQuery object and either returns it unmodified or returns an empty object
 *
 * Even though we do not track read access on the returned searchParams we need to
 * return an empty object if we are doing a 'force-static' render. This is to ensure
 * we don't encode the searchParams into the flight data.
 */ function createUntrackedSearchParams(searchParams) {
    const store = staticGenerationAsyncStorage.getStore();
    if (store && store.forceStatic) {
        return {};
    } else {
        return searchParams;
    }
}
/**
 * Takes a ParsedUrlQuery object and returns a Proxy that tracks read access to the object
 *
 * If running in the browser will always return the provided searchParams object.
 * When running during SSR will return empty during a 'force-static' render and
 * otherwise it returns a searchParams object which tracks reads to trigger dynamic rendering
 * behavior if appropriate
 */ function createDynamicallyTrackedSearchParams(searchParams) {
    const store = __WEBPACK_MODULE_REFERENCE__1_5b2273746174696347656e65726174696f6e4173796e6353746f72616765225d_call_asiSafe1__._.getStore();
    if (!store) {
        // we assume we are in a route handler or page render. just return the searchParams
        return searchParams;
    } else if (store.forceStatic) {
        // If we forced static we omit searchParams entirely. This is true both during SSR
        // and browser render because we need there to be parity between these environments
        return {};
    } else if (!store.isStaticGeneration && !store.dynamicShouldError) {
        // during dynamic renders we don't actually have to track anything so we just return
        // the searchParams directly. However if dynamic data access should error then we
        // still want to track access. This covers the case in Dev where all renders are dynamic
        // but we still want to error if you use a dynamic data source because it will fail the build
        // or revalidate if you do.
        return searchParams;
    } else {
        // We need to track dynamic access with a Proxy. We implement get, has, and ownKeys because
        // these can all be used to exfiltrate information about searchParams.
        return new Proxy({}, {
            get (target, prop, receiver) {
                if (typeof prop === "string") {
                    __WEBPACK_MODULE_REFERENCE__2_5b22747261636b44796e616d6963446174614163636573736564225d_call_directImport_asiSafe1__._(store, "searchParams." + prop);
                }
                return __WEBPACK_MODULE_REFERENCE__3_5b225265666c65637441646170746572225d_call_asiSafe1__._.get(target, prop, receiver);
            },
            has (target, prop) {
                if (typeof prop === "string") {
                    __WEBPACK_MODULE_REFERENCE__2_5b22747261636b44796e616d6963446174614163636573736564225d_call_directImport_asiSafe1__._(store, "searchParams." + prop);
                }
                return Reflect.has(target, prop);
            },
            ownKeys (target) {
                __WEBPACK_MODULE_REFERENCE__2_5b22747261636b44796e616d6963446174614163636573736564225d_call_directImport_asiSafe1__._(store, "searchParams");
                return Reflect.ownKeys(target);
            }
        });
    }
} //# sourceMappingURL=search-params.js.map
€•{"finalSource":false}ƒmap‹bufferedMap‡version„fileˆmappings‡sourcesŽsourcesContent…namesxÈ  AAEyF;AACL;AACH;AAEjF;;;;;;CAMC,GACM,SAASG,4BACdC,YAA4B;IAE5B,MAAMC,QAAQL,6BAA6BM,QAAQ;IACnD,IAAID,SAASA,MAAME,WAAW,EAAE;QAC9B,OAAO,CAAC;IACV,OAAO;QACL,OAAOH;IACT;AACF;AAEA;;;;;;;CAOC,GACM,SAASI,qCACdJ,YAA4B;IAE5B,MAAMC,QAAQL,gHAAAA,CAA6BM,QAAQ;IACnD,IAAI,CAACD,OAAO;QACV,mFAAmF;QACnF,OAAOD;IACT,OAAO,IAAIC,MAAME,WAAW,EAAE;QAC5B,kFAAkF;QAClF,mFAAmF;QACnF,OAAO,CAAC;IACV,OAAO,IAAI,CAACF,MAAMI,kBAAkB,IAAI,CAACJ,MAAMK,kBAAkB,EAAE;QACjE,oFAAoF;QACpF,iFAAiF;QACjF,wFAAwF;QACxF,6FAA6F;QAC7F,2BAA2B;QAC3B,OAAON;IACT,OAAO;QACL,2FAA2F;QAC3F,sEAAsE;QACtE,OAAO,IAAIO,MAAM,CAAC,GAAqB;YACrCC,KAAIC,MAAM,EAAEC,IAAI,EAAEC,QAAQ;gBACxB,IAAI,OAAOD,SAAS,UAAU;oBAC5Bb,qHAAAA,CAAyBI,OAAO,kBAAgBS;gBAClD;gBACA,OAAOZ,oFAAAA,CAAeU,GAAG,CAACC,QAAQC,MAAMC;YAC1C;YACAC,KAAIH,MAAM,EAAEC,IAAI;gBACd,IAAI,OAAOA,SAAS,UAAU;oBAC5Bb,qHAAAA,CAAyBI,OAAO,kBAAgBS;gBAClD;gBACA,OAAOG,QAAQD,GAAG,CAACH,QAAQC;YAC7B;YACAI,SAAQL,MAAM;gBACZZ,qHAAAA,CAAyBI,OAAO;gBAChC,OAAOY,QAAQC,OAAO,CAACL;YACzB;QACF;IACF;AACF¹webpack://../../../src/client/components/search-params.ts`œstaticGenerationAsyncStorage˜trackDynamicDataAccessedŽReflectAdapter›createUntrackedSearchParamsŒsearchParams…storeˆgetStore‹forceStatic¤createDynamicallyTrackedSearchParams’isStaticGeneration’dynamicShouldError…Proxyƒget†target„propˆreceiverƒhas‡Reflect‡ownKeys   ReplaceSourceSourceMapSourcej  import { staticGenerationAsyncStorage } from "./static-generation-async-storage.external";
import { trackDynamicDataAccessed } from "../../server/app-render/dynamic-rendering";
import { ReflectAdapter } from "../../server/web/spec-extension/adapters/reflect";
/**
 * Takes a ParsedUrlQuery object and either returns it unmodified or returns an empty object
 *
 * Even though we do not track read access on the returned searchParams we need to
 * return an empty object if we are doing a 'force-static' render. This is to ensure
 * we don't encode the searchParams into the flight data.
 */ export function createUntrackedSearchParams(searchParams) {
    const store = staticGenerationAsyncStorage.getStore();
    if (store && store.forceStatic) {
        return {};
    } else {
        return searchParams;
    }
}
/**
 * Takes a ParsedUrlQuery object and returns a Proxy that tracks read access to the object
 *
 * If running in the browser will always return the provided searchParams object.
 * When running during SSR will return empty during a 'force-static' render and
 * otherwise it returns a searchParams object which tracks reads to trigger dynamic rendering
 * behavior if appropriate
 */ export function createDynamicallyTrackedSearchParams(searchParams) {
    const store = staticGenerationAsyncStorage.getStore();
    if (!store) {
        // we assume we are in a route handler or page render. just return the searchParams
        return searchParams;
    } else if (store.forceStatic) {
        // If we forced static we omit searchParams entirely. This is true both during SSR
        // and browser render because we need there to be parity between these environments
        return {};
    } else if (!store.isStaticGeneration && !store.dynamicShouldError) {
        // during dynamic renders we don't actually have to track anything so we just return
        // the searchParams directly. However if dynamic data access should error then we
        // still want to track access. This covers the case in Dev where all renders are dynamic
        // but we still want to error if you use a dynamic data source because it will fail the build
        // or revalidate if you do.
        return searchParams;
    } else {
        // We need to track dynamic access with a Proxy. We implement get, has, and ownKeys because
        // these can all be used to exfiltrate information about searchParams.
        return new Proxy({}, {
            get (target, prop, receiver) {
                if (typeof prop === "string") {
                    trackDynamicDataAccessed(store, "searchParams." + prop);
                }
                return ReflectAdapter.get(target, prop, receiver);
            },
            has (target, prop) {
                if (typeof prop === "string") {
                    trackDynamicDataAccessed(store, "searchParams." + prop);
                }
                return Reflect.has(target, prop);
            },
            ownKeys (target) {
                trackDynamicDataAccessed(store, "searchParams");
                return Reflect.ownKeys(target);
            }
        });
    }
} //# sourceMappingURL=search-params.js.map
¢  {"version":3,"sources":["webpack://../../../src/client/components/search-params.ts"],"names":["staticGenerationAsyncStorage","trackDynamicDataAccessed","ReflectAdapter","createUntrackedSearchParams","searchParams","store","getStore","forceStatic","createDynamicallyTrackedSearchParams","isStaticGeneration","dynamicShouldError","Proxy","get","target","prop","receiver","has","Reflect","ownKeys"],"mappings":"AAEA,SAASA,4BAA4B,QAAQ,6CAA4C;AACzF,SAASC,wBAAwB,QAAQ,4CAA2C;AACpF,SAASC,cAAc,QAAQ,mDAAkD;AAEjF;;;;;;CAMC,GACD,OAAO,SAASC,4BACdC,YAA4B;IAE5B,MAAMC,QAAQL,6BAA6BM,QAAQ;IACnD,IAAID,SAASA,MAAME,WAAW,EAAE;QAC9B,OAAO,CAAC;IACV,OAAO;QACL,OAAOH;IACT;AACF;AAEA;;;;;;;CAOC,GACD,OAAO,SAASI,qCACdJ,YAA4B;IAE5B,MAAMC,QAAQL,6BAA6BM,QAAQ;IACnD,IAAI,CAACD,OAAO;QACV,mFAAmF;QACnF,OAAOD;IACT,OAAO,IAAIC,MAAME,WAAW,EAAE;QAC5B,kFAAkF;QAClF,mFAAmF;QACnF,OAAO,CAAC;IACV,OAAO,IAAI,CAACF,MAAMI,kBAAkB,IAAI,CAACJ,MAAMK,kBAAkB,EAAE;QACjE,oFAAoF;QACpF,iFAAiF;QACjF,wFAAwF;QACxF,6FAA6F;QAC7F,2BAA2B;QAC3B,OAAON;IACT,OAAO;QACL,2FAA2F;QAC3F,sEAAsE;QACtE,OAAO,IAAIO,MAAM,CAAC,GAAqB;YACrCC,KAAIC,MAAM,EAAEC,IAAI,EAAEC,QAAQ;gBACxB,IAAI,OAAOD,SAAS,UAAU;oBAC5Bb,yBAAyBI,OAAO,kBAAgBS;gBAClD;gBACA,OAAOZ,eAAeU,GAAG,CAACC,QAAQC,MAAMC;YAC1C;YACAC,KAAIH,MAAM,EAAEC,IAAI;gBACd,IAAI,OAAOA,SAAS,UAAU;oBAC5Bb,yBAAyBI,OAAO,kBAAgBS;gBAClD;gBACA,OAAOG,QAAQD,GAAG,CAACH,QAAQC;YAC7B;YACAI,SAAQL,MAAM;gBACZZ,yBAAyBI,OAAO;gBAChC,OAAOY,QAAQC,OAAO,CAACL;YACzB;QACF;IACF;AACF","file":"x"}Æ  false089undefined91175undefined177258undefined590596undefined12011207undefined12881315__WEBPACK_MODULE_REFERENCE__1_5b2273746174696347656e65726174696f6e4173796e6353746f72616765225d_call_asiSafe1__._undefined25602583__WEBPACK_MODULE_REFERENCE__2_5b22747261636b44796e616d6963446174614163636573736564225d_call_directImport_asiSafe1__._undefined26582671__WEBPACK_MODULE_REFERENCE__3_5b225265666c65637441646170746572225d_call_asiSafe1__._undefined28182841__WEBPACK_MODULE_REFERENCE__2_5b22747261636b44796e616d6963446174614163636573736564225d_call_directImport_asiSafe1__._undefined30053028__WEBPACK_MODULE_REFERENCE__2_5b22747261636b44796e616d6963446174614163636573736564225d_call_directImport_asiSafe1__._undefinedIù  h  E	  ¹	  
  W
  ê
  ^    v  Ìstatic_generation_async_storage_external/* staticGenerationAsyncStorage */.A¶(0,dynamic_rendering/* trackDynamicDataAccessed */.TP)reflect/* ReflectAdapter */.gþþX   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/client-page.js
   ™  «webpack/lib/util/registerExternalSerializerwebpack-sources/ReplaceSource«webpack/lib/util/registerExternalSerializerŸwebpack-sources/SourceMapSource€Ë  /* __next_internal_client_entry_do_not_use__ ClientPageRoot auto */ import { jsx as _jsx } from "react/jsx-runtime";
import { createDynamicallyTrackedSearchParams } from "./search-params";
export function ClientPageRoot(param) {
    let { Component, props } = param;
    // We expect to be passed searchParams but even if we aren't we can construct one from
    // an empty object. We only do this if we are in a static generation as a performance
    // optimization. Ideally we'd unconditionally construct the tracked params but since
    // this creates a proxy which is slow and this would happen even for client navigations
    // that are done entirely dynamically and we know there the dynamic tracking is a noop
    // in this dynamic case we can safely elide it.
    props.searchParams = createDynamicallyTrackedSearchParams(props.searchParams || {});
    return /*#__PURE__*/ _jsx(Component, {
        ...props
    });
} //# sourceMappingURL=client-page.js.map
  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/client/components/client-page.js|ssrý  {"version":3,"sources":["webpack://../../../src/client/components/client-page.tsx"],"names":["createDynamicallyTrackedSearchParams","Component","param","props","searchParams","_jsx"],"mappings":"oEACA,SAASA,OAAAA,IAAAA,QAAAA,oBAAoC;AAE7C,SAAOA,oCAMN,QAAA,kBAAA;OAN8B,SAC7BC,eAD6BC,KAAA;IAO7B,IAAA,EAAAD,SAAA,EAAAE,KAAA,EAAA,GAAAD;IACA,sFAAqF;IACrF,qFAAoF;IACpF,oFAAA;IACA,uFAAsF;IACtF,sFAA+C;IAC/CC,+CAAqBH;IAGrBG,MAAAC,YAAA,GAAOJ,qCAACC,MAAAA,YAAAA,IAAAA,CAAAA;WAAcE,WAAK,GAAAE,KAAAJ,WAAA;;IAC7B","file":"x"}bDsuF»   ½   Ã     @  v  y  €€€   __WEBPACK_MODULE_REFERENCE__4_5b2263726561746544796e616d6963616c6c79547261636b6564536561726368506172616d73225d_call_directImport_asiSafe1__._Ë__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._Ìý  /* __next_internal_client_entry_do_not_use__ ClientPageRoot auto */ 

function ClientPageRoot(param) {
    let { Component, props } = param;
    // We expect to be passed searchParams but even if we aren't we can construct one from
    // an empty object. We only do this if we are in a static generation as a performance
    // optimization. Ideally we'd unconditionally construct the tracked params but since
    // this creates a proxy which is slow and this would happen even for client navigations
    // that are done entirely dynamically and we know there the dynamic tracking is a noop
    // in this dynamic case we can safely elide it.
    props.searchParams = __WEBPACK_MODULE_REFERENCE__4_5b2263726561746544796e616d6963616c6c79547261636b6564536561726368506172616d73225d_call_directImport_asiSafe1__._(props.searchParams || {});
    return /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._(Component, {
        ...props
    });
} //# sourceMappingURL=client-page.js.map
ÍÐ×xõ   oEAC6C;AAQ5C;AAN8B,SAC7BC,eAD6BC,KAAA;IAO7B,MAAAD,SAAA,EAAAE,KAAA,KAAAD;IACA,sFAAqF;IACrF,qFAAoF;IACpF;IACA,uFAAsF;IACtF,sFAA+C;IAC/CC,+CAAqBH;IAGrBG,MAAAC,YAAA,GAAOJ,6IAAAA,CAACC,MAAAA,YAAAA,IAAAA,CAAAA;WAAcE,WAAK,GAAAE,2EAAAA,CAAAJ,WAAA;;IAC7B¸webpack://../../../src/client/components/client-page.tsxà‰Component…param…propsÙ„_jsxçË  /* __next_internal_client_entry_do_not_use__ ClientPageRoot auto */ import { jsx as _jsx } from "react/jsx-runtime";
import { createDynamicallyTrackedSearchParams } from "./search-params";
export function ClientPageRoot(param) {
    let { Component, props } = param;
    // We expect to be passed searchParams but even if we aren't we can construct one from
    // an empty object. We only do this if we are in a static generation as a performance
    // optimization. Ideally we'd unconditionally construct the tracked params but since
    // this creates a proxy which is slow and this would happen even for client navigations
    // that are done entirely dynamically and we know there the dynamic tracking is a noop
    // in this dynamic case we can safely elide it.
    props.searchParams = createDynamicallyTrackedSearchParams(props.searchParams || {});
    return /*#__PURE__*/ _jsx(Component, {
        ...props
    });
} //# sourceMappingURL=client-page.js.map
ý  {"version":3,"sources":["webpack://../../../src/client/components/client-page.tsx"],"names":["createDynamicallyTrackedSearchParams","Component","param","props","searchParams","_jsx"],"mappings":"oEACA,SAASA,OAAAA,IAAAA,QAAAA,oBAAoC;AAE7C,SAAOA,oCAMN,QAAA,kBAAA;OAN8B,SAC7BC,eAD6BC,KAAA;IAO7B,IAAA,EAAAD,SAAA,EAAAE,KAAA,EAAA,GAAAD;IACA,sFAAqF;IACrF,qFAAoF;IACpF,oFAAA;IACA,uFAAsF;IACtF,sFAA+C;IAC/CC,+CAAqBH;IAGrBG,MAAAC,YAAA,GAAOJ,qCAACC,MAAAA,YAAAA,IAAAA,CAAAA;WAAcE,WAAK,GAAAE,KAAAJ,WAAA;;IAC7B","file":"x"}'  false68115undefined117187undefined189195undefined797832__WEBPACK_MODULE_REFERENCE__4_5b2263726561746544796e616d6963616c6c79547261636b6564536561726368506172616d73225d_call_directImport_asiSafe1__._undefined886889__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefinedCŸ  +  a  «  Ò“(0,jsx_runtime.jsx)€†buffer†source„size„maps„hash  // ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ClientPageRoot: () => (/* binding */ ClientPageRoot)
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5486);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/static-generation-async-storage.external.js + 1 modules
var static_generation_async_storage_external = __webpack_require__(1548);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/app-render/dynamic-rendering.js
var dynamic_rendering = __webpack_require__(8255);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/adapters/reflect.js
var reflect = __webpack_require__(8491);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/search-params.js



/**
 * Takes a ParsedUrlQuery object and either returns it unmodified or returns an empty object
 *
 * Even though we do not track read access on the returned searchParams we need to
 * return an empty object if we are doing a 'force-static' render. This is to ensure
 * we don't encode the searchParams into the flight data.
 */ function createUntrackedSearchParams(searchParams) {
    const store = staticGenerationAsyncStorage.getStore();
    if (store && store.forceStatic) {
        return {};
    } else {
        return searchParams;
    }
}
/**
 * Takes a ParsedUrlQuery object and returns a Proxy that tracks read access to the object
 *
 * If running in the browser will always return the provided searchParams object.
 * When running during SSR will return empty during a 'force-static' render and
 * otherwise it returns a searchParams object which tracks reads to trigger dynamic rendering
 * behavior if appropriate
 */ function createDynamicallyTrackedSearchParams(searchParams) {
    const store = static_generation_async_storage_external/* staticGenerationAsyncStorage */.A.getStore();
    if (!store) {
        // we assume we are in a route handler or page render. just return the searchParams
        return searchParams;
    } else if (store.forceStatic) {
        // If we forced static we omit searchParams entirely. This is true both during SSR
        // and browser render because we need there to be parity between these environments
        return {};
    } else if (!store.isStaticGeneration && !store.dynamicShouldError) {
        // during dynamic renders we don't actually have to track anything so we just return
        // the searchParams directly. However if dynamic data access should error then we
        // still want to track access. This covers the case in Dev where all renders are dynamic
        // but we still want to error if you use a dynamic data source because it will fail the build
        // or revalidate if you do.
        return searchParams;
    } else {
        // We need to track dynamic access with a Proxy. We implement get, has, and ownKeys because
        // these can all be used to exfiltrate information about searchParams.
        return new Proxy({}, {
            get (target, prop, receiver) {
                if (typeof prop === "string") {
                    (0,dynamic_rendering/* trackDynamicDataAccessed */.TP)(store, "searchParams." + prop);
                }
                return reflect/* ReflectAdapter */.g.get(target, prop, receiver);
            },
            has (target, prop) {
                if (typeof prop === "string") {
                    (0,dynamic_rendering/* trackDynamicDataAccessed */.TP)(store, "searchParams." + prop);
                }
                return Reflect.has(target, prop);
            },
            ownKeys (target) {
                (0,dynamic_rendering/* trackDynamicDataAccessed */.TP)(store, "searchParams");
                return Reflect.ownKeys(target);
            }
        });
    }
} //# sourceMappingURL=search-params.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/client-page.js
/* __next_internal_client_entry_do_not_use__ ClientPageRoot auto */ 

function ClientPageRoot(param) {
    let { Component, props } = param;
    // We expect to be passed searchParams but even if we aren't we can construct one from
    // an empty object. We only do this if we are in a static generation as a performance
    // optimization. Ideally we'd unconditionally construct the tracked params but since
    // this creates a proxy which is slow and this would happen even for client navigations
    // that are done entirely dynamically and we know there the dynamic tracking is a noop
    // in this dynamic case we can safely elide it.
    props.searchParams = createDynamicallyTrackedSearchParams(props.searchParams || {});
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Component, {
        ...props
    });
} //# sourceMappingURL=client-page.js.map
€”{"finalSource":true}ƒmap‹bufferedMap‡version„fileˆmappings‡sourcesŽsourcesContent…namesxÓ  ;;;;;;;;;;;;;;;;;AAEyF;AACL;AACH;AAEjF;;;;;;CAMC,GACM,SAASG,4BACdC,YAA4B;IAE5B,MAAMC,QAAQL,6BAA6BM,QAAQ;IACnD,IAAID,SAASA,MAAME,WAAW,EAAE;QAC9B,OAAO,CAAC;IACV,OAAO;QACL,OAAOH;IACT;AACF;AAEA;;;;;;;CAOC,GACM,SAASI,qCACdJ,YAA4B;IAE5B,MAAMC,QAAQL,4EAAAA,CAA6BM,QAAQ;IACnD,IAAI,CAACD,OAAO;QACV,mFAAmF;QACnF,OAAOD;IACT,OAAO,IAAIC,MAAME,WAAW,EAAE;QAC5B,kFAAkF;QAClF,mFAAmF;QACnF,OAAO,CAAC;IACV,OAAO,IAAI,CAACF,MAAMI,kBAAkB,IAAI,CAACJ,MAAMK,kBAAkB,EAAE;QACjE,oFAAoF;QACpF,iFAAiF;QACjF,wFAAwF;QACxF,6FAA6F;QAC7F,2BAA2B;QAC3B,OAAON;IACT,OAAO;QACL,2FAA2F;QAC3F,sEAAsE;QACtE,OAAO,IAAIO,MAAM,CAAC,GAAqB;YACrCC,KAAIC,MAAM,EAAEC,IAAI,EAAEC,QAAQ;gBACxB,IAAI,OAAOD,SAAS,UAAU;oBAC5Bb,sDAAAA,CAAyBI,OAAO,kBAAgBS;gBAClD;gBACA,OAAOZ,6BAAAA,CAAeU,GAAG,CAACC,QAAQC,MAAMC;YAC1C;YACAC,KAAIH,MAAM,EAAEC,IAAI;gBACd,IAAI,OAAOA,SAAS,UAAU;oBAC5Bb,sDAAAA,CAAyBI,OAAO,kBAAgBS;gBAClD;gBACA,OAAOG,QAAQD,GAAG,CAACH,QAAQC;YAC7B;YACAI,SAAQL,MAAM;gBACZZ,sDAAAA,CAAyBI,OAAO;gBAChC,OAAOY,QAAQC,OAAO,CAACL;YACzB;QACF;IACF;AACF;;;oECvE6C;AAQ5C;AAN8B,SAC7BM,eAD6BC,KAAA;IAO7B,MAAAD,SAAA,EAAAE,KAAA,KAAAD;IACA,sFAAqF;IACrF,qFAAoF;IACpF;IACA,uFAAsF;IACtF,sFAA+C;IAC/CC,+CAAqBb;IAGrBa,MAAAjB,YAAA,GAAOI,oCAAAA,CAACW,MAAAA,YAAAA,IAAAA,CAAAA;WAAcE,WAAK,GAAAC,mBAAAA,CAAAH,WAAA;;IAC7B¹webpack://../../../src/client/components/search-params.ts¸webpack://../../../src/client/components/client-page.tsx`œstaticGenerationAsyncStorage˜trackDynamicDataAccessedŽReflectAdapter›createUntrackedSearchParamsŒsearchParams…storeˆgetStore‹forceStatic¤createDynamicallyTrackedSearchParams’isStaticGeneration’dynamicShouldError…Proxyƒget†target„propˆreceiverƒhas‡Reflect‡ownKeys‰Component…param…props„_jsx`   ConcatSourceRawSource]  // ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ClientPageRoot: () => (/* binding */ ClientPageRoot)
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5486);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/static-generation-async-storage.external.js + 1 modules
var static_generation_async_storage_external = __webpack_require__(1548);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/app-render/dynamic-rendering.js
var dynamic_rendering = __webpack_require__(8255);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/adapters/reflect.js
var reflect = __webpack_require__(8491);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/search-params.js
   ReplaceSource   ReplaceSourceSourceMapSourcej  import { staticGenerationAsyncStorage } from "./static-generation-async-storage.external";
import { trackDynamicDataAccessed } from "../../server/app-render/dynamic-rendering";
import { ReflectAdapter } from "../../server/web/spec-extension/adapters/reflect";
/**
 * Takes a ParsedUrlQuery object and either returns it unmodified or returns an empty object
 *
 * Even though we do not track read access on the returned searchParams we need to
 * return an empty object if we are doing a 'force-static' render. This is to ensure
 * we don't encode the searchParams into the flight data.
 */ export function createUntrackedSearchParams(searchParams) {
    const store = staticGenerationAsyncStorage.getStore();
    if (store && store.forceStatic) {
        return {};
    } else {
        return searchParams;
    }
}
/**
 * Takes a ParsedUrlQuery object and returns a Proxy that tracks read access to the object
 *
 * If running in the browser will always return the provided searchParams object.
 * When running during SSR will return empty during a 'force-static' render and
 * otherwise it returns a searchParams object which tracks reads to trigger dynamic rendering
 * behavior if appropriate
 */ export function createDynamicallyTrackedSearchParams(searchParams) {
    const store = staticGenerationAsyncStorage.getStore();
    if (!store) {
        // we assume we are in a route handler or page render. just return the searchParams
        return searchParams;
    } else if (store.forceStatic) {
        // If we forced static we omit searchParams entirely. This is true both during SSR
        // and browser render because we need there to be parity between these environments
        return {};
    } else if (!store.isStaticGeneration && !store.dynamicShouldError) {
        // during dynamic renders we don't actually have to track anything so we just return
        // the searchParams directly. However if dynamic data access should error then we
        // still want to track access. This covers the case in Dev where all renders are dynamic
        // but we still want to error if you use a dynamic data source because it will fail the build
        // or revalidate if you do.
        return searchParams;
    } else {
        // We need to track dynamic access with a Proxy. We implement get, has, and ownKeys because
        // these can all be used to exfiltrate information about searchParams.
        return new Proxy({}, {
            get (target, prop, receiver) {
                if (typeof prop === "string") {
                    trackDynamicDataAccessed(store, "searchParams." + prop);
                }
                return ReflectAdapter.get(target, prop, receiver);
            },
            has (target, prop) {
                if (typeof prop === "string") {
                    trackDynamicDataAccessed(store, "searchParams." + prop);
                }
                return Reflect.has(target, prop);
            },
            ownKeys (target) {
                trackDynamicDataAccessed(store, "searchParams");
                return Reflect.ownKeys(target);
            }
        });
    }
} //# sourceMappingURL=search-params.js.map
¢  {"version":3,"sources":["webpack://../../../src/client/components/search-params.ts"],"names":["staticGenerationAsyncStorage","trackDynamicDataAccessed","ReflectAdapter","createUntrackedSearchParams","searchParams","store","getStore","forceStatic","createDynamicallyTrackedSearchParams","isStaticGeneration","dynamicShouldError","Proxy","get","target","prop","receiver","has","Reflect","ownKeys"],"mappings":"AAEA,SAASA,4BAA4B,QAAQ,6CAA4C;AACzF,SAASC,wBAAwB,QAAQ,4CAA2C;AACpF,SAASC,cAAc,QAAQ,mDAAkD;AAEjF;;;;;;CAMC,GACD,OAAO,SAASC,4BACdC,YAA4B;IAE5B,MAAMC,QAAQL,6BAA6BM,QAAQ;IACnD,IAAID,SAASA,MAAME,WAAW,EAAE;QAC9B,OAAO,CAAC;IACV,OAAO;QACL,OAAOH;IACT;AACF;AAEA;;;;;;;CAOC,GACD,OAAO,SAASI,qCACdJ,YAA4B;IAE5B,MAAMC,QAAQL,6BAA6BM,QAAQ;IACnD,IAAI,CAACD,OAAO;QACV,mFAAmF;QACnF,OAAOD;IACT,OAAO,IAAIC,MAAME,WAAW,EAAE;QAC5B,kFAAkF;QAClF,mFAAmF;QACnF,OAAO,CAAC;IACV,OAAO,IAAI,CAACF,MAAMI,kBAAkB,IAAI,CAACJ,MAAMK,kBAAkB,EAAE;QACjE,oFAAoF;QACpF,iFAAiF;QACjF,wFAAwF;QACxF,6FAA6F;QAC7F,2BAA2B;QAC3B,OAAON;IACT,OAAO;QACL,2FAA2F;QAC3F,sEAAsE;QACtE,OAAO,IAAIO,MAAM,CAAC,GAAqB;YACrCC,KAAIC,MAAM,EAAEC,IAAI,EAAEC,QAAQ;gBACxB,IAAI,OAAOD,SAAS,UAAU;oBAC5Bb,yBAAyBI,OAAO,kBAAgBS;gBAClD;gBACA,OAAOZ,eAAeU,GAAG,CAACC,QAAQC,MAAMC;YAC1C;YACAC,KAAIH,MAAM,EAAEC,IAAI;gBACd,IAAI,OAAOA,SAAS,UAAU;oBAC5Bb,yBAAyBI,OAAO,kBAAgBS;gBAClD;gBACA,OAAOG,QAAQD,GAAG,CAACH,QAAQC;YAC7B;YACAI,SAAQL,MAAM;gBACZZ,yBAAyBI,OAAO;gBAChC,OAAOY,QAAQC,OAAO,CAACL;YACzB;QACF;IACF;AACF","file":"x"}Æ  false089undefined91175undefined177258undefined590596undefined12011207undefined12881315__WEBPACK_MODULE_REFERENCE__1_5b2273746174696347656e65726174696f6e4173796e6353746f72616765225d_call_asiSafe1__._undefined25602583__WEBPACK_MODULE_REFERENCE__2_5b22747261636b44796e616d6963446174614163636573736564225d_call_directImport_asiSafe1__._undefined26582671__WEBPACK_MODULE_REFERENCE__3_5b225265666c65637441646170746572225d_call_asiSafe1__._undefined28182841__WEBPACK_MODULE_REFERENCE__2_5b22747261636b44796e616d6963446174614163636573736564225d_call_directImport_asiSafe1__._undefined30053028__WEBPACK_MODULE_REFERENCE__2_5b22747261636b44796e616d6963446174614163636573736564225d_call_directImport_asiSafe1__._undefinedi  10171128static_generation_async_storage_external/* staticGenerationAsyncStorage */.Aundefined23732489(0,dynamic_rendering/* trackDynamicDataAccessed */.TP)undefined25642647reflect/* ReflectAdapter */.gundefined27942910(0,dynamic_rendering/* trackDynamicDataAccessed */.TP)undefined30743190(0,dynamic_rendering/* trackDynamicDataAccessed */.TP)undefinedRawSourceX   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/client-page.js
ùúË  /* __next_internal_client_entry_do_not_use__ ClientPageRoot auto */ import { jsx as _jsx } from "react/jsx-runtime";
import { createDynamicallyTrackedSearchParams } from "./search-params";
export function ClientPageRoot(param) {
    let { Component, props } = param;
    // We expect to be passed searchParams but even if we aren't we can construct one from
    // an empty object. We only do this if we are in a static generation as a performance
    // optimization. Ideally we'd unconditionally construct the tracked params but since
    // this creates a proxy which is slow and this would happen even for client navigations
    // that are done entirely dynamically and we know there the dynamic tracking is a noop
    // in this dynamic case we can safely elide it.
    props.searchParams = createDynamicallyTrackedSearchParams(props.searchParams || {});
    return /*#__PURE__*/ _jsx(Component, {
        ...props
    });
} //# sourceMappingURL=client-page.js.map
ý  {"version":3,"sources":["webpack://../../../src/client/components/client-page.tsx"],"names":["createDynamicallyTrackedSearchParams","Component","param","props","searchParams","_jsx"],"mappings":"oEACA,SAASA,OAAAA,IAAAA,QAAAA,oBAAoC;AAE7C,SAAOA,oCAMN,QAAA,kBAAA;OAN8B,SAC7BC,eAD6BC,KAAA;IAO7B,IAAA,EAAAD,SAAA,EAAAE,KAAA,EAAA,GAAAD;IACA,sFAAqF;IACrF,qFAAoF;IACpF,oFAAA;IACA,uFAAsF;IACtF,sFAA+C;IAC/CC,+CAAqBH;IAGrBG,MAAAC,YAAA,GAAOJ,qCAACC,MAAAA,YAAAA,IAAAA,CAAAA;WAAcE,WAAK,GAAAE,KAAAJ,WAAA;;IAC7B","file":"x"}'  false68115undefined117187undefined189195undefined797832__WEBPACK_MODULE_REFERENCE__4_5b2263726561746544796e616d6963616c6c79547261636b6564536561726368506172616d73225d_call_directImport_asiSafe1__._undefined886889__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefinedU   671811createDynamicallyTrackedSearchParamsundefined865939(0,jsx_runtime.jsx)undefined
   

/***/ })÷ÿÿn  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ClientPageRoot: () => (/* binding */ ClientPageRoot)
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5486);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/static-generation-async-storage.external.js + 1 modules
var static_generation_async_storage_external = __webpack_require__(1548);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/app-render/dynamic-rendering.js
var dynamic_rendering = __webpack_require__(8255);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/adapters/reflect.js
var reflect = __webpack_require__(8491);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/search-params.js



/**
 * Takes a ParsedUrlQuery object and either returns it unmodified or returns an empty object
 *
 * Even though we do not track read access on the returned searchParams we need to
 * return an empty object if we are doing a 'force-static' render. This is to ensure
 * we don't encode the searchParams into the flight data.
 */ function createUntrackedSearchParams(searchParams) {
    const store = staticGenerationAsyncStorage.getStore();
    if (store && store.forceStatic) {
        return {};
    } else {
        return searchParams;
    }
}
/**
 * Takes a ParsedUrlQuery object and returns a Proxy that tracks read access to the object
 *
 * If running in the browser will always return the provided searchParams object.
 * When running during SSR will return empty during a 'force-static' render and
 * otherwise it returns a searchParams object which tracks reads to trigger dynamic rendering
 * behavior if appropriate
 */ function createDynamicallyTrackedSearchParams(searchParams) {
    const store = static_generation_async_storage_external/* staticGenerationAsyncStorage */.A.getStore();
    if (!store) {
        // we assume we are in a route handler or page render. just return the searchParams
        return searchParams;
    } else if (store.forceStatic) {
        // If we forced static we omit searchParams entirely. This is true both during SSR
        // and browser render because we need there to be parity between these environments
        return {};
    } else if (!store.isStaticGeneration && !store.dynamicShouldError) {
        // during dynamic renders we don't actually have to track anything so we just return
        // the searchParams directly. However if dynamic data access should error then we
        // still want to track access. This covers the case in Dev where all renders are dynamic
        // but we still want to error if you use a dynamic data source because it will fail the build
        // or revalidate if you do.
        return searchParams;
    } else {
        // We need to track dynamic access with a Proxy. We implement get, has, and ownKeys because
        // these can all be used to exfiltrate information about searchParams.
        return new Proxy({}, {
            get (target, prop, receiver) {
                if (typeof prop === "string") {
                    (0,dynamic_rendering/* trackDynamicDataAccessed */.TP)(store, "searchParams." + prop);
                }
                return reflect/* ReflectAdapter */.g.get(target, prop, receiver);
            },
            has (target, prop) {
                if (typeof prop === "string") {
                    (0,dynamic_rendering/* trackDynamicDataAccessed */.TP)(store, "searchParams." + prop);
                }
                return Reflect.has(target, prop);
            },
            ownKeys (target) {
                (0,dynamic_rendering/* trackDynamicDataAccessed */.TP)(store, "searchParams");
                return Reflect.ownKeys(target);
            }
        });
    }
} //# sourceMappingURL=search-params.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/client-page.js
/* __next_internal_client_entry_do_not_use__ ClientPageRoot auto */ 

function ClientPageRoot(param) {
    let { Component, props } = param;
    // We expect to be passed searchParams but even if we aren't we can construct one from
    // an empty object. We only do this if we are in a static generation as a performance
    // optimization. Ideally we'd unconditionally construct the tracked params but since
    // this creates a proxy which is slow and this would happen even for client navigations
    // that are done entirely dynamically and we know there the dynamic tracking is a noop
    // in this dynamic case we can safely elide it.
    props.searchParams = createDynamicallyTrackedSearchParams(props.searchParams || {});
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Component, {
        ...props
    });
} //# sourceMappingURL=client-page.js.map


/***/ })÷ÿÿ÷ÿÿ÷ÿÿxÖ  ;;;;;;;;;;;;;;;;;;;;AAEyF;AACL;AACH;AAEjF;;;;;;CAMC,GACM,SAASG,4BACdC,YAA4B;IAE5B,MAAMC,QAAQL,6BAA6BM,QAAQ;IACnD,IAAID,SAASA,MAAME,WAAW,EAAE;QAC9B,OAAO,CAAC;IACV,OAAO;QACL,OAAOH;IACT;AACF;AAEA;;;;;;;CAOC,GACM,SAASI,qCACdJ,YAA4B;IAE5B,MAAMC,QAAQL,4EAAAA,CAA6BM,QAAQ;IACnD,IAAI,CAACD,OAAO;QACV,mFAAmF;QACnF,OAAOD;IACT,OAAO,IAAIC,MAAME,WAAW,EAAE;QAC5B,kFAAkF;QAClF,mFAAmF;QACnF,OAAO,CAAC;IACV,OAAO,IAAI,CAACF,MAAMI,kBAAkB,IAAI,CAACJ,MAAMK,kBAAkB,EAAE;QACjE,oFAAoF;QACpF,iFAAiF;QACjF,wFAAwF;QACxF,6FAA6F;QAC7F,2BAA2B;QAC3B,OAAON;IACT,OAAO;QACL,2FAA2F;QAC3F,sEAAsE;QACtE,OAAO,IAAIO,MAAM,CAAC,GAAqB;YACrCC,KAAIC,MAAM,EAAEC,IAAI,EAAEC,QAAQ;gBACxB,IAAI,OAAOD,SAAS,UAAU;oBAC5Bb,sDAAAA,CAAyBI,OAAO,kBAAgBS;gBAClD;gBACA,OAAOZ,6BAAAA,CAAeU,GAAG,CAACC,QAAQC,MAAMC;YAC1C;YACAC,KAAIH,MAAM,EAAEC,IAAI;gBACd,IAAI,OAAOA,SAAS,UAAU;oBAC5Bb,sDAAAA,CAAyBI,OAAO,kBAAgBS;gBAClD;gBACA,OAAOG,QAAQD,GAAG,CAACH,QAAQC;YAC7B;YACAI,SAAQL,MAAM;gBACZZ,sDAAAA,CAAyBI,OAAO;gBAChC,OAAOY,QAAQC,OAAO,CAACL;YACzB;QACF;IACF;AACF;;;oECvE6C;AAQ5C;AAN8B,SAC7BM,eAD6BC,KAAA;IAO7B,MAAAD,SAAA,EAAAE,KAAA,KAAAD;IACA,sFAAqF;IACrF,qFAAoF;IACpF;IACA,uFAAsF;IACtF,sFAA+C;IAC/CC,+CAAqBb;IAGrBa,MAAAjB,YAAA,GAAOI,oCAAAA,CAACW,MAAAA,YAAAA,IAAAA,CAAAA;WAAcE,WAAK,GAAAC,mBAAAA,CAAAH,WAAA;;IAC7BÀ÷ÿÿº÷ÿÿ`nùÿÿoùÿÿpùÿÿqùÿÿÜøÿÿrùÿÿsùÿÿtùÿÿuùÿÿvùÿÿwùÿÿxùÿÿ>ùÿÿëøÿÿyùÿÿzùÿÿùÿÿ{ùÿÿ|ùÿÿJøÿÿ¤øÿÿ`øÿÿCÿÿÿ`÷ÿÿ}ùÿÿ÷ÿÿ]  // ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ClientPageRoot: () => (/* binding */ ClientPageRoot)
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5486);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/static-generation-async-storage.external.js + 1 modules
var static_generation_async_storage_external = __webpack_require__(1548);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/app-render/dynamic-rendering.js
var dynamic_rendering = __webpack_require__(8255);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/web/spec-extension/adapters/reflect.js
var reflect = __webpack_require__(8491);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/search-params.js
~ùÿÿ‡ùÿÿíúÿÿîúÿÿÆ  false089undefined91175undefined177258undefined590596undefined12011207undefined12881315__WEBPACK_MODULE_REFERENCE__1_5b2273746174696347656e65726174696f6e4173796e6353746f72616765225d_call_asiSafe1__._undefined25602583__WEBPACK_MODULE_REFERENCE__2_5b22747261636b44796e616d6963446174614163636573736564225d_call_directImport_asiSafe1__._undefined26582671__WEBPACK_MODULE_REFERENCE__3_5b225265666c65637441646170746572225d_call_asiSafe1__._undefined28182841__WEBPACK_MODULE_REFERENCE__2_5b22747261636b44796e616d6963446174614163636573736564225d_call_directImport_asiSafe1__._undefined30053028__WEBPACK_MODULE_REFERENCE__2_5b22747261636b44796e616d6963446174614163636573736564225d_call_directImport_asiSafe1__._undefinedi  10171128static_generation_async_storage_external/* staticGenerationAsyncStorage */.Aundefined23732489(0,dynamic_rendering/* trackDynamicDataAccessed */.TP)undefined25642647reflect/* ReflectAdapter */.gundefined27942910(0,dynamic_rendering/* trackDynamicDataAccessed */.TP)undefined30743190(0,dynamic_rendering/* trackDynamicDataAccessed */.TP)undefinedRawSourceX   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/client-page.js
{ùÿÿ„ùÿÿË  /* __next_internal_client_entry_do_not_use__ ClientPageRoot auto */ import { jsx as _jsx } from "react/jsx-runtime";
import { createDynamicallyTrackedSearchParams } from "./search-params";
export function ClientPageRoot(param) {
    let { Component, props } = param;
    // We expect to be passed searchParams but even if we aren't we can construct one from
    // an empty object. We only do this if we are in a static generation as a performance
    // optimization. Ideally we'd unconditionally construct the tracked params but since
    // this creates a proxy which is slow and this would happen even for client navigations
    // that are done entirely dynamically and we know there the dynamic tracking is a noop
    // in this dynamic case we can safely elide it.
    props.searchParams = createDynamicallyTrackedSearchParams(props.searchParams || {});
    return /*#__PURE__*/ _jsx(Component, {
        ...props
    });
} //# sourceMappingURL=client-page.js.map
ý  {"version":3,"sources":["webpack://../../../src/client/components/client-page.tsx"],"names":["createDynamicallyTrackedSearchParams","Component","param","props","searchParams","_jsx"],"mappings":"oEACA,SAASA,OAAAA,IAAAA,QAAAA,oBAAoC;AAE7C,SAAOA,oCAMN,QAAA,kBAAA;OAN8B,SAC7BC,eAD6BC,KAAA;IAO7B,IAAA,EAAAD,SAAA,EAAAE,KAAA,EAAA,GAAAD;IACA,sFAAqF;IACrF,qFAAoF;IACpF,oFAAA;IACA,uFAAsF;IACtF,sFAA+C;IAC/CC,+CAAqBH;IAGrBG,MAAAC,YAAA,GAAOJ,qCAACC,MAAAA,YAAAA,IAAAA,CAAAA;WAAcE,WAAK,GAAAE,KAAAJ,WAAA;;IAC7B","file":"x"}'  false68115undefined117187undefined189195undefined797832__WEBPACK_MODULE_REFERENCE__4_5b2263726561746544796e616d6963616c6c79547261636b6564536561726368506172616d73225d_call_directImport_asiSafe1__._undefined886889__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefinedU   671811createDynamicallyTrackedSearchParamsundefined865939(0,jsx_runtime.jsx)undefined;÷ÿÿ÷ÿÿ   ,

/***/ 6120:
   Hñ  «webpack/lib/util/registerExternalSerializerœwebpack-sources/ConcatSource€«webpack/lib/util/registerExternalSerializer™webpack-sources/RawSource_   /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
«webpack/lib/util/registerExternalSerializerœwebpack-sources/CachedSource   ‡Ž  «webpack/lib/util/registerExternalSerializerœwebpack-sources/ConcatSource€«webpack/lib/util/registerExternalSerializer™webpack-sources/RawSource  // ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ErrorBoundary: () => (/* binding */ ErrorBoundary),
  ErrorBoundaryHandler: () => (/* binding */ ErrorBoundaryHandler),
  GlobalError: () => (/* binding */ GlobalError),
  "default": () => (/* binding */ error_boundary)
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5486);
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__(2428);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/navigation.js + 1 modules
var navigation = __webpack_require__(7303);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/not-found.js
var not_found = __webpack_require__(5254);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/redirect.js
var redirect = __webpack_require__(3925);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/is-next-router-error.js
«webpack/lib/util/registerExternalSerializerwebpack-sources/ReplaceSource«webpack/lib/util/registerExternalSerializerœwebpack-sources/CachedSource   3  «webpack/lib/util/registerExternalSerializerwebpack-sources/ReplaceSource«webpack/lib/util/registerExternalSerializerŸwebpack-sources/SourceMapSource€  import { isNotFoundError } from "./not-found";
import { isRedirectError } from "./redirect";
export function isNextRouterError(error) {
    return error && error.digest && (isRedirectError(error) || isNotFoundError(error));
} //# sourceMappingURL=is-next-router-error.js.map
  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/client/components/is-next-router-error.js|ssre  {"version":3,"sources":["webpack://../../../src/client/components/is-next-router-error.ts"],"names":["isNotFoundError","isRedirectError","isNextRouterError","error","digest"],"mappings":"AAAA,SAASA,eAAe,QAAQ,cAAa;AAC7C,SAASC,eAAe,QAAQ,aAAY;AAE5C,OAAO,SAASC,kBAAkBC,KAAU;IAC1C,OACEA,SAASA,MAAMC,MAAM,IAAKH,CAAAA,gBAAgBE,UAAUH,gBAAgBG,MAAAA;AAExE","file":"x"} d-/[]cC­   »   Ç   Õ   €€€ã__WEBPACK_MODULE_REFERENCE__4_5b22697352656469726563744572726f72225d_call_directImport_asiSafe1__._ã__WEBPACK_MODULE_REFERENCE__3_5b2269734e6f74466f756e644572726f72225d_call_directImport_asiSafe1__._€†buffer†source„size„maps„hashY  

function isNextRouterError(error) {
    return error && error.digest && (__WEBPACK_MODULE_REFERENCE__4_5b22697352656469726563744572726f72225d_call_directImport_asiSafe1__._(error) || __WEBPACK_MODULE_REFERENCE__3_5b2269734e6f74466f756e644572726f72225d_call_directImport_asiSafe1__._(error));
} //# sourceMappingURL=is-next-router-error.js.map
€•{"finalSource":false}ƒmap‹bufferedMap‡version„fileˆmappings‡sourcesŽsourcesContent…namesxz   AAA6C;AACD;AAErC,SAASE,kBAAkBC,KAAU;IAC1C,OACEA,SAASA,MAAMC,MAAM,IAAKH,CAAAA,mGAAAA,CAAgBE,UAAUH,mGAAAA,CAAgBG,MAAAA;AAExEÀwebpack://../../../src/client/components/is-next-router-error.tsisNotFoundErrorisRedirectError‘isNextRouterError…error†digest   ReplaceSourceSourceMapSource  import { isNotFoundError } from "./not-found";
import { isRedirectError } from "./redirect";
export function isNextRouterError(error) {
    return error && error.digest && (isRedirectError(error) || isNotFoundError(error));
} //# sourceMappingURL=is-next-router-error.js.map
e  {"version":3,"sources":["webpack://../../../src/client/components/is-next-router-error.ts"],"names":["isNotFoundError","isRedirectError","isNextRouterError","error","digest"],"mappings":"AAAA,SAASA,eAAe,QAAQ,cAAa;AAC7C,SAASC,eAAe,QAAQ,aAAY;AAE5C,OAAO,SAASC,kBAAkBC,KAAU;IAC1C,OACEA,SAASA,MAAMC,MAAM,IAAKH,CAAAA,gBAAgBE,UAAUH,gBAAgBG,MAAAA;AAExE","file":"x"}  false045undefined4791undefined9399undefined173187__WEBPACK_MODULE_REFERENCE__4_5b22697352656469726563744572726f72225d_call_directImport_asiSafe1__._undefined199213__WEBPACK_MODULE_REFERENCE__3_5b2269734e6f74466f756e644572726f72225d_call_directImport_asiSafe1__._undefined`KB­   ¹     ¤(0,redirect/* isRedirectError */.eo)¤(0,not_found/* isNotFoundError */.X)   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/static-generation-async-storage.external.js + 1 modules
var static_generation_async_storage_external = __webpack_require__(1548);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/error-boundary.js
   ¨(  «webpack/lib/util/registerExternalSerializerwebpack-sources/ReplaceSource«webpack/lib/util/registerExternalSerializerŸwebpack-sources/SourceMapSource€³  /* __next_internal_client_entry_do_not_use__ ErrorBoundaryHandler,GlobalError,default,ErrorBoundary auto */ import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React from "react";
import { usePathname } from "./navigation";
import { isNextRouterError } from "./is-next-router-error";
import { staticGenerationAsyncStorage } from "./static-generation-async-storage.external";
const styles = {
    error: {
        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52
        fontFamily: 'system-ui,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"',
        height: "100vh",
        textAlign: "center",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center"
    },
    text: {
        fontSize: "14px",
        fontWeight: 400,
        lineHeight: "28px",
        margin: "0 8px"
    }
};
// if we are revalidating we want to re-throw the error so the
// function crashes so we can maintain our previous cache
// instead of caching the error page
function HandleISRError(param) {
    let { error } = param;
    const store = staticGenerationAsyncStorage.getStore();
    if ((store == null ? void 0 : store.isRevalidate) || (store == null ? void 0 : store.isStaticGeneration)) {
        console.error(error);
        throw error;
    }
    return null;
}
export class ErrorBoundaryHandler extends React.Component {
    static getDerivedStateFromError(error) {
        if (isNextRouterError(error)) {
            // Re-throw if an expected internal Next.js router error occurs
            // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)
            throw error;
        }
        return {
            error
        };
    }
    static getDerivedStateFromProps(props, state) {
        /**
     * Handles reset of the error boundary when a navigation happens.
     * Ensures the error boundary does not stay enabled when navigating to a new page.
     * Approach of setState in render is safe as it checks the previous pathname and then overrides
     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders
     */ if (props.pathname !== state.previousPathname && state.error) {
            return {
                error: null,
                previousPathname: props.pathname
            };
        }
        return {
            error: state.error,
            previousPathname: props.pathname
        };
    }
    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific the the `@types/react` version.
    render() {
        if (this.state.error) {
            return /*#__PURE__*/ _jsxs(_Fragment, {
                children: [
                    /*#__PURE__*/ _jsx(HandleISRError, {
                        error: this.state.error
                    }),
                    this.props.errorStyles,
                    this.props.errorScripts,
                    /*#__PURE__*/ _jsx(this.props.errorComponent, {
                        error: this.state.error,
                        reset: this.reset
                    })
                ]
            });
        }
        return this.props.children;
    }
    constructor(props){
        super(props);
        this.reset = ()=>{
            this.setState({
                error: null
            });
        };
        this.state = {
            error: null,
            previousPathname: this.props.pathname
        };
    }
}
export function GlobalError(param) {
    let { error } = param;
    const digest = error == null ? void 0 : error.digest;
    return /*#__PURE__*/ _jsxs("html", {
        id: "__next_error__",
        children: [
            /*#__PURE__*/ _jsx("head", {}),
            /*#__PURE__*/ _jsxs("body", {
                children: [
                    /*#__PURE__*/ _jsx(HandleISRError, {
                        error: error
                    }),
                    /*#__PURE__*/ _jsx("div", {
                        style: styles.error,
                        children: /*#__PURE__*/ _jsxs("div", {
                            children: [
                                /*#__PURE__*/ _jsx("h2", {
                                    style: styles.text,
                                    children: "Application error: a " + (digest ? "server" : "client") + "-side exception has occurred (see the " + (digest ? "server logs" : "browser console") + " for more information)."
                                }),
                                digest ? /*#__PURE__*/ _jsx("p", {
                                    style: styles.text,
                                    children: "Digest: " + digest
                                }) : null
                            ]
                        })
                    })
                ]
            })
        ]
    });
}
// Exported so that the import signature in the loaders can be identical to user
// supplied custom global error signatures.
export default GlobalError;
/**
 * Handles errors through `getDerivedStateFromError`.
 * Renders the provided error component and provides a way to `reset` the error boundary state.
 */ /**
 * Renders error boundary with the provided "errorComponent" property as the fallback.
 * If no "errorComponent" property is provided it renders the children without an error boundary.
 */ export function ErrorBoundary(param) {
    let { errorComponent, errorStyles, errorScripts, children } = param;
    const pathname = usePathname();
    if (errorComponent) {
        return /*#__PURE__*/ _jsx(ErrorBoundaryHandler, {
            pathname: pathname,
            errorComponent: errorComponent,
            errorStyles: errorStyles,
            errorScripts: errorScripts,
            children: children
        });
    }
    return /*#__PURE__*/ _jsx(_Fragment, {
        children: children
    });
} //# sourceMappingURL=error-boundary.js.map
  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/client/components/error-boundary.js|ssr4  {"version":3,"sources":["webpack://../../../src/client/components/error-boundary.tsx"],"names":["React","jsxs","_jsxs","Fragment","_Fragment","usePathname","isNextRouterError","staticGenerationAsyncStorage","styles","error","fontFamily","height","textAlign","display","flexDirection","alignItems","justifyContent","text","fontSize","fontWeight","lineHeight","margin","HandleISRError","param","store","isRevalidate","console","getDerivedStateFromError","Component","getDerivedStateFromProps","props","state","pathname","previousPathname","render","_jsx","errorScripts","errorComponent","reset","children","constructor","setState","GlobalError","digest","html","id","body","style","errorStyles"],"mappings":"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","file":"x"}al_Á   Ã   Ü   Þ     
  D  F  Ÿ  ³  Î  ˜  ž  Â  Ð        
      W  Z  1  4  ,  2  ¿  Ã      G  OK  •  ˜      v  z  Û  Þ  X  [  
    
    $       €$´@I…  ‹  
    P  S  Q  T  V  ^  €€€€€ð__WEBPACK_MODULE_REFERENCE__6_5b2273746174696347656e65726174696f6e4173796e6353746f72616765225d_call_asiSafe1__._€Ù__WEBPACK_MODULE_REFERENCE__1_5b2264656661756c74222c22436f6d706f6e656e74225d_asiSafe1__._ç__WEBPACK_MODULE_REFERENCE__5_5b2269734e657874526f757465724572726f72225d_call_directImport_asiSafe1__._Í__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._Ð__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._Ë__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._ÿ€ýÿýÿÿýÿÿÁ/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (€‚);€Û__WEBPACK_MODULE_REFERENCE__2_5b22757365506174686e616d65225d_call_directImport_asiSafe1__._üüûÛ  /* __next_internal_client_entry_do_not_use__ ErrorBoundaryHandler,GlobalError,default,ErrorBoundary auto */ 




const styles = {
    error: {
        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52
        fontFamily: 'system-ui,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"',
        height: "100vh",
        textAlign: "center",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center"
    },
    text: {
        fontSize: "14px",
        fontWeight: 400,
        lineHeight: "28px",
        margin: "0 8px"
    }
};
// if we are revalidating we want to re-throw the error so the
// function crashes so we can maintain our previous cache
// instead of caching the error page
function HandleISRError(param) {
    let { error } = param;
    const store = __WEBPACK_MODULE_REFERENCE__6_5b2273746174696347656e65726174696f6e4173796e6353746f72616765225d_call_asiSafe1__._.getStore();
    if ((store == null ? void 0 : store.isRevalidate) || (store == null ? void 0 : store.isStaticGeneration)) {
        console.error(error);
        throw error;
    }
    return null;
}
class ErrorBoundaryHandler extends __WEBPACK_MODULE_REFERENCE__1_5b2264656661756c74222c22436f6d706f6e656e74225d_asiSafe1__._ {
    static getDerivedStateFromError(error) {
        if (__WEBPACK_MODULE_REFERENCE__5_5b2269734e657874526f757465724572726f72225d_call_directImport_asiSafe1__._(error)) {
            // Re-throw if an expected internal Next.js router error occurs
            // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)
            throw error;
        }
        return {
            error
        };
    }
    static getDerivedStateFromProps(props, state) {
        /**
     * Handles reset of the error boundary when a navigation happens.
     * Ensures the error boundary does not stay enabled when navigating to a new page.
     * Approach of setState in render is safe as it checks the previous pathname and then overrides
     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders
     */ if (props.pathname !== state.previousPathname && state.error) {
            return {
                error: null,
                previousPathname: props.pathname
            };
        }
        return {
            error: state.error,
            previousPathname: props.pathname
        };
    }
    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific the the `@types/react` version.
    render() {
        if (this.state.error) {
            return /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._(__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._, {
                children: [
                    /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._(HandleISRError, {
                        error: this.state.error
                    }),
                    this.props.errorStyles,
                    this.props.errorScripts,
                    /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._(this.props.errorComponent, {
                        error: this.state.error,
                        reset: this.reset
                    })
                ]
            });
        }
        return this.props.children;
    }
    constructor(props){
        super(props);
        this.reset = ()=>{
            this.setState({
                error: null
            });
        };
        this.state = {
            error: null,
            previousPathname: this.props.pathname
        };
    }
}
function GlobalError(param) {
    let { error } = param;
    const digest = error == null ? void 0 : error.digest;
    return /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._("html", {
        id: "__next_error__",
        children: [
            /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._("head", {}),
            /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._("body", {
                children: [
                    /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._(HandleISRError, {
                        error: error
                    }),
                    /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._("div", {
                        style: styles.error,
                        children: /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._("div", {
                            children: [
                                /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._("h2", {
                                    style: styles.text,
                                    children: "Application error: a " + (digest ? "server" : "client") + "-side exception has occurred (see the " + (digest ? "server logs" : "browser console") + " for more information)."
                                }),
                                digest ? /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._("p", {
                                    style: styles.text,
                                    children: "Digest: " + digest
                                }) : null
                            ]
                        })
                    })
                ]
            })
        ]
    });
}
// Exported so that the import signature in the loaders can be identical to user
// supplied custom global error signatures.
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GlobalError);
/**
 * Handles errors through `getDerivedStateFromError`.
 * Renders the provided error component and provides a way to `reset` the error boundary state.
 */ /**
 * Renders error boundary with the provided "errorComponent" property as the fallback.
 * If no "errorComponent" property is provided it renders the children without an error boundary.
 */ function ErrorBoundary(param) {
    let { errorComponent, errorStyles, errorScripts, children } = param;
    const pathname = __WEBPACK_MODULE_REFERENCE__2_5b22757365506174686e616d65225d_call_directImport_asiSafe1__._();
    if (errorComponent) {
        return /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._(ErrorBoundaryHandler, {
            pathname: pathname,
            errorComponent: errorComponent,
            errorStyles: errorStyles,
            errorScripts: errorScripts,
            children: children
        });
    }
    return /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._(__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._, {
        children: children
    });
} //# sourceMappingURL=error-boundary.js.map
ÜßæxÑ  4GAEyB;AACL;AACc;AACW;AAE9B;MACbS,SAAO;WACL;QACAC,0FACE;QACFC,YAAQ;QACRC,QAAAA;QACAC,WAAS;QACTC,SAAAA;QACAC,eAAY;QACZC,YAAAA;QACFA,gBAAA;IACAC;UACEC;QACAC,UAAAA;QACAC,YAAY;QACZC,YAAQ;QACVA,QAAA;IACF;AAwBA;AACA,8DAAyD;AACzD,yDAAoC;AACpC,oCAAiD;SAAzBC,eAAAC,KAAA;IACtB,MAAMC,KAAAA,EAAAA,GAAQjB;IACd,MAAIiB,QAAAA,gHAAAA,CAAOC,QAAY;QACrBC,CAAAA,SAAQjB,OAAMA,KAAAA,IAAAA,MAAAA,YAAAA,KAAAA,CAAAA,SAAAA,OAAAA,KAAAA,IAAAA,MAAAA,kBAAAA,GAAAA;QACdiB,QAAMjB,KAAAA,CAAAA;QACR,MAAAA;IAEA;IACF;AAEA;AASE,MAAOkB,6BAAqC3B,yFAAE;WAC5C2B,yBAAsBlB,KAAQ;YAC5BH,uGAAAA,CAAAG,QAAA;YACA;YACA,4GAAMA;YACR,MAAAA;QAEA;eAASA;YAAMA;QACjB;IAEA;WAIEoB,yBAAAC,KAAA,EAAAC,KAAA;;;;;;YAOED,MAAAE,QAAO,KAAAD,MAAAE,gBAAA,IAAAF,MAAAtB,KAAA;mBACLA;gBACAwB,OAAAA;gBACFA,kBAAAH,MAAAE,QAAA;YACF;QACA;eACEvB;YACAwB,OAAAA,MAAAA,KAAkBH;YACpBG,kBAAAH,MAAAE,QAAA;QACF;IAMA;IACAE,0IAA0B;aACpB;YACF,KAAAH,KAAA,CAAAtB,KAAA;;;+BAE2B,GAAA0B,2EAAAA,CAAKJ,gBAAW;;oBACtC;oBACA,IAAI,CAACD,KAAK,CAACM,WAAAA;2CACP;+BACI,GAAAD,2EAAAA,CAAKJ,IAAMtB,CAAAA,KAAK,CAAA4B,cAAA;wBACvBC,OAAO,IAAI,CAACA,KAAK,CAAA7B,KAAA;;;;YAIzB;QAEA;QACF,YAAAqB,KAAA,CAAAS,QAAA;IA1DAC;gBACQV,KAAAA,CAAAA;aAoCRQ,CAAAA;YACE,CAAAA,KAAKG,GAAAA;gBAAWhC,CAAAA,QAAO;gBAAKA,OAAA;YAC9B;QArCE;YAAeA,CAAAA,KAAAA,GAAO;YAAMwB,OAAAA;YAAsCA,kBAAA,KAAAH,KAAA,CAAAE,QAAA;QACpE;IAwDF;AAEA;AAA4B,SAAOU,YAAPnB,KAAA;IAC1B,MAAMoB,KAAAA,EAAAA,GAA6BlC;IACnC,MAAAkC,SAAAlC,SACE,OAACmC,KAAAA,IAAAA,MAAAA,MAAAA;WAAKC,WAAG,GAAA3C,6EAAAA,CAAA;;;0BAEPiC,2EAAAA,CAAA,QAACW,CAAAA;;;+BACwBrC,GAAAA,2EAAAA,CAAAA,gBAAAA;;;+BACXD,GAAAA,2EAAAA,CAAOC,OAAK;sCACtBA,KAAA;;;2CACaD,GAAAA,2EAAAA,CAAOS,MAAI;kDAClBA,IAAA;;gCAMH0B;yCAAYI,WAAc9B,GAAIkB,2EAAAA,CAAA;kDAAIlB,IAAA;8CAA0B,aAAA0B;;;;;;;;IAMzE;AAEA;AACA,gFAA2C;AAC3C,2CAA0B;AAE1B,iEAAAD,WAAAA,EAAA;;;;;;;IAUEL,SAAAA,cACAW,KACAZ;IAGA,MAAMJ,cAAW3B,EAAAA,WAAAA,EAAAA,YAAAA,EAAAA,QAAAA,EAAAA,GAAAA;IACjB,MAAIgC,WAAAA,2FAAAA;QACFA,gBAAA;eAEIL,WAAUA,GAAAA,2EAAAA,CAAAA,sBAAAA;YACVK,UAAAA;YACAW,gBAAaA;YACbZ,aAAAA;0BAECG;;QAGP;IAEA;sBAAUA,GAAAA,2EAAAA,CAAAA,gFAAAA,EAAAA;;IACZ»webpack://../../../src/client/components/error-boundary.tsx`1…React„jsxs…_jsxsˆFragment‰_Fragment‹usePathnameãœstaticGenerationAsyncStorage†stylesâŠfontFamily†height‰textAlign‡displayflexDirectionŠalignItemsŽjustifyContent„textˆfontSizeŠfontWeightŠlineHeight†marginŽHandleISRError…param…storeŒisRevalidate‡console˜getDerivedStateFromError‰Component˜getDerivedStateFromProps…props…stateˆpathnamepreviousPathname†render„_jsxŒerrorScriptsŽerrorComponent…resetˆchildren‹constructorˆsetState‹GlobalErrorÂ„html‚id„body…style‹errorStyles¾³  /* __next_internal_client_entry_do_not_use__ ErrorBoundaryHandler,GlobalError,default,ErrorBoundary auto */ import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React from "react";
import { usePathname } from "./navigation";
import { isNextRouterError } from "./is-next-router-error";
import { staticGenerationAsyncStorage } from "./static-generation-async-storage.external";
const styles = {
    error: {
        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52
        fontFamily: 'system-ui,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"',
        height: "100vh",
        textAlign: "center",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center"
    },
    text: {
        fontSize: "14px",
        fontWeight: 400,
        lineHeight: "28px",
        margin: "0 8px"
    }
};
// if we are revalidating we want to re-throw the error so the
// function crashes so we can maintain our previous cache
// instead of caching the error page
function HandleISRError(param) {
    let { error } = param;
    const store = staticGenerationAsyncStorage.getStore();
    if ((store == null ? void 0 : store.isRevalidate) || (store == null ? void 0 : store.isStaticGeneration)) {
        console.error(error);
        throw error;
    }
    return null;
}
export class ErrorBoundaryHandler extends React.Component {
    static getDerivedStateFromError(error) {
        if (isNextRouterError(error)) {
            // Re-throw if an expected internal Next.js router error occurs
            // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)
            throw error;
        }
        return {
            error
        };
    }
    static getDerivedStateFromProps(props, state) {
        /**
     * Handles reset of the error boundary when a navigation happens.
     * Ensures the error boundary does not stay enabled when navigating to a new page.
     * Approach of setState in render is safe as it checks the previous pathname and then overrides
     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders
     */ if (props.pathname !== state.previousPathname && state.error) {
            return {
                error: null,
                previousPathname: props.pathname
            };
        }
        return {
            error: state.error,
            previousPathname: props.pathname
        };
    }
    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific the the `@types/react` version.
    render() {
        if (this.state.error) {
            return /*#__PURE__*/ _jsxs(_Fragment, {
                children: [
                    /*#__PURE__*/ _jsx(HandleISRError, {
                        error: this.state.error
                    }),
                    this.props.errorStyles,
                    this.props.errorScripts,
                    /*#__PURE__*/ _jsx(this.props.errorComponent, {
                        error: this.state.error,
                        reset: this.reset
                    })
                ]
            });
        }
        return this.props.children;
    }
    constructor(props){
        super(props);
        this.reset = ()=>{
            this.setState({
                error: null
            });
        };
        this.state = {
            error: null,
            previousPathname: this.props.pathname
        };
    }
}
export function GlobalError(param) {
    let { error } = param;
    const digest = error == null ? void 0 : error.digest;
    return /*#__PURE__*/ _jsxs("html", {
        id: "__next_error__",
        children: [
            /*#__PURE__*/ _jsx("head", {}),
            /*#__PURE__*/ _jsxs("body", {
                children: [
                    /*#__PURE__*/ _jsx(HandleISRError, {
                        error: error
                    }),
                    /*#__PURE__*/ _jsx("div", {
                        style: styles.error,
                        children: /*#__PURE__*/ _jsxs("div", {
                            children: [
                                /*#__PURE__*/ _jsx("h2", {
                                    style: styles.text,
                                    children: "Application error: a " + (digest ? "server" : "client") + "-side exception has occurred (see the " + (digest ? "server logs" : "browser console") + " for more information)."
                                }),
                                digest ? /*#__PURE__*/ _jsx("p", {
                                    style: styles.text,
                                    children: "Digest: " + digest
                                }) : null
                            ]
                        })
                    })
                ]
            })
        ]
    });
}
// Exported so that the import signature in the loaders can be identical to user
// supplied custom global error signatures.
export default GlobalError;
/**
 * Handles errors through `getDerivedStateFromError`.
 * Renders the provided error component and provides a way to `reset` the error boundary state.
 */ /**
 * Renders error boundary with the provided "errorComponent" property as the fallback.
 * If no "errorComponent" property is provided it renders the children without an error boundary.
 */ export function ErrorBoundary(param) {
    let { errorComponent, errorStyles, errorScripts, children } = param;
    const pathname = usePathname();
    if (errorComponent) {
        return /*#__PURE__*/ _jsx(ErrorBoundaryHandler, {
            pathname: pathname,
            errorComponent: errorComponent,
            errorStyles: errorStyles,
            errorScripts: errorScripts,
            children: children
        });
    }
    return /*#__PURE__*/ _jsx(_Fragment, {
        children: children
    });
} //# sourceMappingURL=error-boundary.js.map
4  {"version":3,"sources":["webpack://../../../src/client/components/error-boundary.tsx"],"names":["React","jsxs","_jsxs","Fragment","_Fragment","usePathname","isNextRouterError","staticGenerationAsyncStorage","styles","error","fontFamily","height","textAlign","display","flexDirection","alignItems","justifyContent","text","fontSize","fontWeight","lineHeight","margin","HandleISRError","param","store","isRevalidate","console","getDerivedStateFromError","Component","getDerivedStateFromProps","props","state","pathname","previousPathname","render","_jsx","errorScripts","errorComponent","reset","children","constructor","setState","GlobalError","digest","html","id","body","style","errorStyles"],"mappings":"4GAEA,SAAOA,OAAAA,IAAW,EAAAC,QAAOC,KAAA,EAAAC,YAAAC,SAAA,QAAA,oBAAA;AACzB,OAAAJ,WAASK,QAAW;AACpB,SAASC,WAAAA,QAAiB,eAAQ;AAClC,SAASC,iBAAAA,QAAAA,yBAAoC;AAE7C,SAAMC,4BAAS,QAAA,6CAAA;MACbC,SAAO;WACL;QACAC,0FACE;QACFC,YAAQ;QACRC,QAAAA;QACAC,WAAS;QACTC,SAAAA;QACAC,eAAY;QACZC,YAAAA;QACFA,gBAAA;IACAC;UACEC;QACAC,UAAAA;QACAC,YAAY;QACZC,YAAQ;QACVA,QAAA;IACF;AAwBA;AACA,8DAAyD;AACzD,yDAAoC;AACpC,oCAAiD;SAAzBC,eAAAC,KAAA;IACtB,IAAA,EAAMC,KAAAA,EAAAA,GAAQjB;IACd,MAAIiB,QAAAA,6BAAOC,QAAY;QACrBC,CAAAA,SAAQjB,OAAMA,KAAAA,IAAAA,MAAAA,YAAAA,KAAAA,CAAAA,SAAAA,OAAAA,KAAAA,IAAAA,MAAAA,kBAAAA,GAAAA;QACdiB,QAAMjB,KAAAA,CAAAA;QACR,MAAAA;IAEA;IACF,OAAA;AAEA;OASE,MAAOkB,6BAAqC3B,MAAE4B,SAAA;WAC5CD,yBAAsBlB,KAAQ,EAAA;YAC5BH,kBAAAG,QAAA;YACA,+DAAA;YACA,4GAAMA;YACR,MAAAA;QAEA;eAASA;YAAMA;QACjB;IAEA;WAIEoB,yBAAAC,KAAA,EAAAC,KAAA,EAAA;;;;;;YAOED,MAAAE,QAAO,KAAAD,MAAAE,gBAAA,IAAAF,MAAAtB,KAAA,EAAA;mBACLA;gBACAwB,OAAAA;gBACFA,kBAAAH,MAAAE,QAAA;YACF;QACA;eACEvB;YACAwB,OAAAA,MAAAA,KAAkBH;YACpBG,kBAAAH,MAAAE,QAAA;QACF;IAMA;IACAE,0IAA0B;aACpB;YACF,IAAA,CAAAH,KAAA,CAAAtB,KAAA,EAAA;;;+BAE2B,GAAA0B,KAAKJ,gBAAW;;oBACtC;oBACA,IAAI,CAACD,KAAK,CAACM,WAAAA;2CACP;+BACI,GAAAD,KAAKJ,IAAMtB,CAAAA,KAAK,CAAA4B,cAAA,EAAA;wBACvBC,OAAO,IAAI,CAACA,KAAK,CAAA7B,KAAA;;;;YAIzB;QAEA;QACF,OAAA,IAAA,CAAAqB,KAAA,CAAAS,QAAA;IA1DAC;gBACQV,KAAAA,CAAAA;aAoCRQ,CAAAA;YACE,CAAAA,KAAKG,GAAAA;gBAAWhC,CAAAA,QAAO,CAAA;gBAAKA,OAAA;YAC9B;QArCE;YAAeA,CAAAA,KAAAA,GAAO;YAAMwB,OAAAA;YAAsCA,kBAAA,IAAA,CAAAH,KAAA,CAAAE,QAAA;QACpE;IAwDF;AAEA;OAA4B,SAAOU,YAAPnB,KAAA;IAC1B,IAAA,EAAMoB,KAAAA,EAAAA,GAA6BlC;IACnC,MAAAkC,SAAAlC,SACE,OAACmC,KAAAA,IAAAA,MAAAA,MAAAA;WAAKC,WAAG,GAAA3C,MAAA,QAAA;;;0BAEPiC,KAAA,QAACW,CAAAA;;;+BACwBrC,GAAAA,KAAAA,gBAAAA;;;+BACXD,GAAAA,KAAOC,OAAK;sCACtBA,KAAA;;;2CACaD,GAAAA,KAAOS,MAAI;kDAClBA,IAAA;;gCAMH0B;yCAAYI,WAAc9B,GAAIkB,KAAA,KAAA;kDAAIlB,IAAA;8CAA0B,aAAA0B;;;;;;;;IAMzE;AAEA;AACA,gFAA2C;AAC3C,2CAA0B;AAE1B,eAAAD,YAAA;;;;;;;IAS8B,OAC5BL,SAAAA,cACAW,KACAZ;IAGA,IAAA,EAAMJ,cAAW3B,EAAAA,WAAAA,EAAAA,YAAAA,EAAAA,QAAAA,EAAAA,GAAAA;IACjB,MAAIgC,WAAAA;QACFA,gBAAA;eAEIL,WAAUA,GAAAA,KAAAA,sBAAAA;YACVK,UAAAA;YACAW,gBAAaA;YACbZ,aAAAA;0BAECG;;QAGP;IAEA;sBAAUA,GAAAA,KAAAA,WAAAA;;IACZ","file":"x"}@  false108193undefined195220undefined222264undefined266324undefined326415undefined12031230__WEBPACK_MODULE_REFERENCE__6_5b2273746174696347656e65726174696f6e4173796e6353746f72616765225d_call_asiSafe1__._undefined14321438undefined14741488__WEBPACK_MODULE_REFERENCE__1_5b2264656661756c74222c22436f6d706f6e656e74225d_asiSafe1__._undefined15491565__WEBPACK_MODULE_REFERENCE__5_5b2269734e657874526f757465724572726f72225d_call_directImport_asiSafe1__._undefined28222826__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined28282836__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined29032906__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined31213124__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined36283634undefined37753779__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined38673870__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined39113915__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined39893992__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined41074110__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined42144218__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined43154318__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined46964699__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined51305144/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (undefined51305144undefined51565156.5);undefined55095515undefined56425652__WEBPACK_MODULE_REFERENCE__2_5b22757365506174686e616d65225d_call_directImport_asiSafe1__._undefined57125715__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined59695972__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined59745982__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined`_ƒ  ò  ß  7  t  Ú  Ã
      `  £  í  Ä    ’  Þ  6  €  ©  õ  ?  ‰  ü  F  ®  ú  [  ¥    i  ;  T  GD  ž  Ú  $  "  l  n  ½  Ìstatic_generation_async_storage_external/* staticGenerationAsyncStorage */.Areact.Component¯”(0,jsx_runtime.jsxs)”jsx_runtime.Fragment“(0,jsx_runtime.jsx)ÿýÿýÿÿýÿÿŽerror_boundary¢(0,navigation/* usePathname */.jD)ýýü€†buffer†source„size„maps„hashÌ  // ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ErrorBoundary: () => (/* binding */ ErrorBoundary),
  ErrorBoundaryHandler: () => (/* binding */ ErrorBoundaryHandler),
  GlobalError: () => (/* binding */ GlobalError),
  "default": () => (/* binding */ error_boundary)
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5486);
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__(2428);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/navigation.js + 1 modules
var navigation = __webpack_require__(7303);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/not-found.js
var not_found = __webpack_require__(5254);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/redirect.js
var redirect = __webpack_require__(3925);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/is-next-router-error.js


function isNextRouterError(error) {
    return error && error.digest && ((0,redirect/* isRedirectError */.eo)(error) || (0,not_found/* isNotFoundError */.X)(error));
} //# sourceMappingURL=is-next-router-error.js.map

// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/static-generation-async-storage.external.js + 1 modules
var static_generation_async_storage_external = __webpack_require__(1548);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/error-boundary.js
/* __next_internal_client_entry_do_not_use__ ErrorBoundaryHandler,GlobalError,default,ErrorBoundary auto */ 




const styles = {
    error: {
        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52
        fontFamily: 'system-ui,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"',
        height: "100vh",
        textAlign: "center",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center"
    },
    text: {
        fontSize: "14px",
        fontWeight: 400,
        lineHeight: "28px",
        margin: "0 8px"
    }
};
// if we are revalidating we want to re-throw the error so the
// function crashes so we can maintain our previous cache
// instead of caching the error page
function HandleISRError(param) {
    let { error } = param;
    const store = static_generation_async_storage_external/* staticGenerationAsyncStorage */.A.getStore();
    if ((store == null ? void 0 : store.isRevalidate) || (store == null ? void 0 : store.isStaticGeneration)) {
        console.error(error);
        throw error;
    }
    return null;
}
class ErrorBoundaryHandler extends react.Component {
    static getDerivedStateFromError(error) {
        if (isNextRouterError(error)) {
            // Re-throw if an expected internal Next.js router error occurs
            // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)
            throw error;
        }
        return {
            error
        };
    }
    static getDerivedStateFromProps(props, state) {
        /**
     * Handles reset of the error boundary when a navigation happens.
     * Ensures the error boundary does not stay enabled when navigating to a new page.
     * Approach of setState in render is safe as it checks the previous pathname and then overrides
     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders
     */ if (props.pathname !== state.previousPathname && state.error) {
            return {
                error: null,
                previousPathname: props.pathname
            };
        }
        return {
            error: state.error,
            previousPathname: props.pathname
        };
    }
    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific the the `@types/react` version.
    render() {
        if (this.state.error) {
            return /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
                children: [
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(HandleISRError, {
                        error: this.state.error
                    }),
                    this.props.errorStyles,
                    this.props.errorScripts,
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(this.props.errorComponent, {
                        error: this.state.error,
                        reset: this.reset
                    })
                ]
            });
        }
        return this.props.children;
    }
    constructor(props){
        super(props);
        this.reset = ()=>{
            this.setState({
                error: null
            });
        };
        this.state = {
            error: null,
            previousPathname: this.props.pathname
        };
    }
}
function GlobalError(param) {
    let { error } = param;
    const digest = error == null ? void 0 : error.digest;
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("html", {
        id: "__next_error__",
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)("head", {}),
            /*#__PURE__*/ (0,jsx_runtime.jsxs)("body", {
                children: [
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(HandleISRError, {
                        error: error
                    }),
                    /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                        style: styles.error,
                        children: /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
                            children: [
                                /*#__PURE__*/ (0,jsx_runtime.jsx)("h2", {
                                    style: styles.text,
                                    children: "Application error: a " + (digest ? "server" : "client") + "-side exception has occurred (see the " + (digest ? "server logs" : "browser console") + " for more information)."
                                }),
                                digest ? /*#__PURE__*/ (0,jsx_runtime.jsx)("p", {
                                    style: styles.text,
                                    children: "Digest: " + digest
                                }) : null
                            ]
                        })
                    })
                ]
            })
        ]
    });
}
// Exported so that the import signature in the loaders can be identical to user
// supplied custom global error signatures.
/* harmony default export */ const error_boundary = (GlobalError);
/**
 * Handles errors through `getDerivedStateFromError`.
 * Renders the provided error component and provides a way to `reset` the error boundary state.
 */ /**
 * Renders error boundary with the provided "errorComponent" property as the fallback.
 * If no "errorComponent" property is provided it renders the children without an error boundary.
 */ function ErrorBoundary(param) {
    let { errorComponent, errorStyles, errorScripts, children } = param;
    const pathname = (0,navigation/* usePathname */.jD)();
    if (errorComponent) {
        return /*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorBoundaryHandler, {
            pathname: pathname,
            errorComponent: errorComponent,
            errorStyles: errorStyles,
            errorScripts: errorScripts,
            children: children
        });
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
        children: children
    });
} //# sourceMappingURL=error-boundary.js.map
€”{"finalSource":true}ƒmap‹bufferedMap‡version„fileˆmappings‡sourcesŽsourcesContent…namesxd  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Àwebpack://../../../src/client/components/is-next-router-error.ts»webpack://../../../src/client/components/error-boundary.tsx`3isNotFoundErrorisRedirectError‘isNextRouterError…error†digest…React„jsxs…_jsxsˆFragment‰_Fragment‹usePathnameœstaticGenerationAsyncStorage†stylesŠfontFamily†height‰textAlign‡displayflexDirectionŠalignItemsŽjustifyContent„textˆfontSizeŠfontWeightŠlineHeight†marginŽHandleISRError…param…storeŒisRevalidate‡console˜getDerivedStateFromError‰Component˜getDerivedStateFromProps…props…stateˆpathnamepreviousPathname†render„_jsxŒerrorScriptsŽerrorComponent…resetˆchildren‹constructorˆsetState‹GlobalError„html‚id„body…style‹errorStyles`   ConcatSourceRawSource  // ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ErrorBoundary: () => (/* binding */ ErrorBoundary),
  ErrorBoundaryHandler: () => (/* binding */ ErrorBoundaryHandler),
  GlobalError: () => (/* binding */ GlobalError),
  "default": () => (/* binding */ error_boundary)
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5486);
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__(2428);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/navigation.js + 1 modules
var navigation = __webpack_require__(7303);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/not-found.js
var not_found = __webpack_require__(5254);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/redirect.js
var redirect = __webpack_require__(3925);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/is-next-router-error.js
   ReplaceSource   ReplaceSourceSourceMapSource  import { isNotFoundError } from "./not-found";
import { isRedirectError } from "./redirect";
export function isNextRouterError(error) {
    return error && error.digest && (isRedirectError(error) || isNotFoundError(error));
} //# sourceMappingURL=is-next-router-error.js.map
e  {"version":3,"sources":["webpack://../../../src/client/components/is-next-router-error.ts"],"names":["isNotFoundError","isRedirectError","isNextRouterError","error","digest"],"mappings":"AAAA,SAASA,eAAe,QAAQ,cAAa;AAC7C,SAASC,eAAe,QAAQ,aAAY;AAE5C,OAAO,SAASC,kBAAkBC,KAAU;IAC1C,OACEA,SAASA,MAAMC,MAAM,IAAKH,CAAAA,gBAAgBE,UAAUH,gBAAgBG,MAAAA;AAExE","file":"x"}  false045undefined4791undefined9399undefined173187__WEBPACK_MODULE_REFERENCE__4_5b22697352656469726563744572726f72225d_call_directImport_asiSafe1__._undefined199213__WEBPACK_MODULE_REFERENCE__3_5b2269734e6f74466f756e644572726f72225d_call_directImport_asiSafe1__._undefinedn   75173(0,redirect/* isRedirectError */.eo)undefined185283(0,not_found/* isNotFoundError */.X)undefinedRawSource   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/static-generation-async-storage.external.js + 1 modules
var static_generation_async_storage_external = __webpack_require__(1548);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/error-boundary.js
ùú³  /* __next_internal_client_entry_do_not_use__ ErrorBoundaryHandler,GlobalError,default,ErrorBoundary auto */ import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React from "react";
import { usePathname } from "./navigation";
import { isNextRouterError } from "./is-next-router-error";
import { staticGenerationAsyncStorage } from "./static-generation-async-storage.external";
const styles = {
    error: {
        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52
        fontFamily: 'system-ui,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"',
        height: "100vh",
        textAlign: "center",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center"
    },
    text: {
        fontSize: "14px",
        fontWeight: 400,
        lineHeight: "28px",
        margin: "0 8px"
    }
};
// if we are revalidating we want to re-throw the error so the
// function crashes so we can maintain our previous cache
// instead of caching the error page
function HandleISRError(param) {
    let { error } = param;
    const store = staticGenerationAsyncStorage.getStore();
    if ((store == null ? void 0 : store.isRevalidate) || (store == null ? void 0 : store.isStaticGeneration)) {
        console.error(error);
        throw error;
    }
    return null;
}
export class ErrorBoundaryHandler extends React.Component {
    static getDerivedStateFromError(error) {
        if (isNextRouterError(error)) {
            // Re-throw if an expected internal Next.js router error occurs
            // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)
            throw error;
        }
        return {
            error
        };
    }
    static getDerivedStateFromProps(props, state) {
        /**
     * Handles reset of the error boundary when a navigation happens.
     * Ensures the error boundary does not stay enabled when navigating to a new page.
     * Approach of setState in render is safe as it checks the previous pathname and then overrides
     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders
     */ if (props.pathname !== state.previousPathname && state.error) {
            return {
                error: null,
                previousPathname: props.pathname
            };
        }
        return {
            error: state.error,
            previousPathname: props.pathname
        };
    }
    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific the the `@types/react` version.
    render() {
        if (this.state.error) {
            return /*#__PURE__*/ _jsxs(_Fragment, {
                children: [
                    /*#__PURE__*/ _jsx(HandleISRError, {
                        error: this.state.error
                    }),
                    this.props.errorStyles,
                    this.props.errorScripts,
                    /*#__PURE__*/ _jsx(this.props.errorComponent, {
                        error: this.state.error,
                        reset: this.reset
                    })
                ]
            });
        }
        return this.props.children;
    }
    constructor(props){
        super(props);
        this.reset = ()=>{
            this.setState({
                error: null
            });
        };
        this.state = {
            error: null,
            previousPathname: this.props.pathname
        };
    }
}
export function GlobalError(param) {
    let { error } = param;
    const digest = error == null ? void 0 : error.digest;
    return /*#__PURE__*/ _jsxs("html", {
        id: "__next_error__",
        children: [
            /*#__PURE__*/ _jsx("head", {}),
            /*#__PURE__*/ _jsxs("body", {
                children: [
                    /*#__PURE__*/ _jsx(HandleISRError, {
                        error: error
                    }),
                    /*#__PURE__*/ _jsx("div", {
                        style: styles.error,
                        children: /*#__PURE__*/ _jsxs("div", {
                            children: [
                                /*#__PURE__*/ _jsx("h2", {
                                    style: styles.text,
                                    children: "Application error: a " + (digest ? "server" : "client") + "-side exception has occurred (see the " + (digest ? "server logs" : "browser console") + " for more information)."
                                }),
                                digest ? /*#__PURE__*/ _jsx("p", {
                                    style: styles.text,
                                    children: "Digest: " + digest
                                }) : null
                            ]
                        })
                    })
                ]
            })
        ]
    });
}
// Exported so that the import signature in the loaders can be identical to user
// supplied custom global error signatures.
export default GlobalError;
/**
 * Handles errors through `getDerivedStateFromError`.
 * Renders the provided error component and provides a way to `reset` the error boundary state.
 */ /**
 * Renders error boundary with the provided "errorComponent" property as the fallback.
 * If no "errorComponent" property is provided it renders the children without an error boundary.
 */ export function ErrorBoundary(param) {
    let { errorComponent, errorStyles, errorScripts, children } = param;
    const pathname = usePathname();
    if (errorComponent) {
        return /*#__PURE__*/ _jsx(ErrorBoundaryHandler, {
            pathname: pathname,
            errorComponent: errorComponent,
            errorStyles: errorStyles,
            errorScripts: errorScripts,
            children: children
        });
    }
    return /*#__PURE__*/ _jsx(_Fragment, {
        children: children
    });
} //# sourceMappingURL=error-boundary.js.map
4  {"version":3,"sources":["webpack://../../../src/client/components/error-boundary.tsx"],"names":["React","jsxs","_jsxs","Fragment","_Fragment","usePathname","isNextRouterError","staticGenerationAsyncStorage","styles","error","fontFamily","height","textAlign","display","flexDirection","alignItems","justifyContent","text","fontSize","fontWeight","lineHeight","margin","HandleISRError","param","store","isRevalidate","console","getDerivedStateFromError","Component","getDerivedStateFromProps","props","state","pathname","previousPathname","render","_jsx","errorScripts","errorComponent","reset","children","constructor","setState","GlobalError","digest","html","id","body","style","errorStyles"],"mappings":"4GAEA,SAAOA,OAAAA,IAAW,EAAAC,QAAOC,KAAA,EAAAC,YAAAC,SAAA,QAAA,oBAAA;AACzB,OAAAJ,WAASK,QAAW;AACpB,SAASC,WAAAA,QAAiB,eAAQ;AAClC,SAASC,iBAAAA,QAAAA,yBAAoC;AAE7C,SAAMC,4BAAS,QAAA,6CAAA;MACbC,SAAO;WACL;QACAC,0FACE;QACFC,YAAQ;QACRC,QAAAA;QACAC,WAAS;QACTC,SAAAA;QACAC,eAAY;QACZC,YAAAA;QACFA,gBAAA;IACAC;UACEC;QACAC,UAAAA;QACAC,YAAY;QACZC,YAAQ;QACVA,QAAA;IACF;AAwBA;AACA,8DAAyD;AACzD,yDAAoC;AACpC,oCAAiD;SAAzBC,eAAAC,KAAA;IACtB,IAAA,EAAMC,KAAAA,EAAAA,GAAQjB;IACd,MAAIiB,QAAAA,6BAAOC,QAAY;QACrBC,CAAAA,SAAQjB,OAAMA,KAAAA,IAAAA,MAAAA,YAAAA,KAAAA,CAAAA,SAAAA,OAAAA,KAAAA,IAAAA,MAAAA,kBAAAA,GAAAA;QACdiB,QAAMjB,KAAAA,CAAAA;QACR,MAAAA;IAEA;IACF,OAAA;AAEA;OASE,MAAOkB,6BAAqC3B,MAAE4B,SAAA;WAC5CD,yBAAsBlB,KAAQ,EAAA;YAC5BH,kBAAAG,QAAA;YACA,+DAAA;YACA,4GAAMA;YACR,MAAAA;QAEA;eAASA;YAAMA;QACjB;IAEA;WAIEoB,yBAAAC,KAAA,EAAAC,KAAA,EAAA;;;;;;YAOED,MAAAE,QAAO,KAAAD,MAAAE,gBAAA,IAAAF,MAAAtB,KAAA,EAAA;mBACLA;gBACAwB,OAAAA;gBACFA,kBAAAH,MAAAE,QAAA;YACF;QACA;eACEvB;YACAwB,OAAAA,MAAAA,KAAkBH;YACpBG,kBAAAH,MAAAE,QAAA;QACF;IAMA;IACAE,0IAA0B;aACpB;YACF,IAAA,CAAAH,KAAA,CAAAtB,KAAA,EAAA;;;+BAE2B,GAAA0B,KAAKJ,gBAAW;;oBACtC;oBACA,IAAI,CAACD,KAAK,CAACM,WAAAA;2CACP;+BACI,GAAAD,KAAKJ,IAAMtB,CAAAA,KAAK,CAAA4B,cAAA,EAAA;wBACvBC,OAAO,IAAI,CAACA,KAAK,CAAA7B,KAAA;;;;YAIzB;QAEA;QACF,OAAA,IAAA,CAAAqB,KAAA,CAAAS,QAAA;IA1DAC;gBACQV,KAAAA,CAAAA;aAoCRQ,CAAAA;YACE,CAAAA,KAAKG,GAAAA;gBAAWhC,CAAAA,QAAO,CAAA;gBAAKA,OAAA;YAC9B;QArCE;YAAeA,CAAAA,KAAAA,GAAO;YAAMwB,OAAAA;YAAsCA,kBAAA,IAAA,CAAAH,KAAA,CAAAE,QAAA;QACpE;IAwDF;AAEA;OAA4B,SAAOU,YAAPnB,KAAA;IAC1B,IAAA,EAAMoB,KAAAA,EAAAA,GAA6BlC;IACnC,MAAAkC,SAAAlC,SACE,OAACmC,KAAAA,IAAAA,MAAAA,MAAAA;WAAKC,WAAG,GAAA3C,MAAA,QAAA;;;0BAEPiC,KAAA,QAACW,CAAAA;;;+BACwBrC,GAAAA,KAAAA,gBAAAA;;;+BACXD,GAAAA,KAAOC,OAAK;sCACtBA,KAAA;;;2CACaD,GAAAA,KAAOS,MAAI;kDAClBA,IAAA;;gCAMH0B;yCAAYI,WAAc9B,GAAIkB,KAAA,KAAA;kDAAIlB,IAAA;8CAA0B,aAAA0B;;;;;;;;IAMzE;AAEA;AACA,gFAA2C;AAC3C,2CAA0B;AAE1B,eAAAD,YAAA;;;;;;;IAS8B,OAC5BL,SAAAA,cACAW,KACAZ;IAGA,IAAA,EAAMJ,cAAW3B,EAAAA,WAAAA,EAAAA,YAAAA,EAAAA,QAAAA,EAAAA,GAAAA;IACjB,MAAIgC,WAAAA;QACFA,gBAAA;eAEIL,WAAUA,GAAAA,KAAAA,sBAAAA;YACVK,UAAAA;YACAW,gBAAaA;YACbZ,aAAAA;0BAECG;;QAGP;IAEA;sBAAUA,GAAAA,KAAAA,WAAAA;;IACZ","file":"x"}@  false108193undefined195220undefined222264undefined266324undefined326415undefined12031230__WEBPACK_MODULE_REFERENCE__6_5b2273746174696347656e65726174696f6e4173796e6353746f72616765225d_call_asiSafe1__._undefined14321438undefined14741488__WEBPACK_MODULE_REFERENCE__1_5b2264656661756c74222c22436f6d706f6e656e74225d_asiSafe1__._undefined15491565__WEBPACK_MODULE_REFERENCE__5_5b2269734e657874526f757465724572726f72225d_call_directImport_asiSafe1__._undefined28222826__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined28282836__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined29032906__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined31213124__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined36283634undefined37753779__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined38673870__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined39113915__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined39893992__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined41074110__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined42144218__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined43154318__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined46964699__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined51305144/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (undefined51305144undefined51565156.5);undefined55095515undefined56425652__WEBPACK_MODULE_REFERENCE__2_5b22757365506174686e616d65225d_call_directImport_asiSafe1__._undefined57125715__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined59695972__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined59745982__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined  8991010static_generation_async_storage_external/* staticGenerationAsyncStorage */.Aundefined12471335react.Componentundefined13961498isNextRouterErrorundefined27552831(0,jsx_runtime.jsxs)undefined28332912jsx_runtime.Fragmentundefined29793053(0,jsx_runtime.jsx)undefined32683342(0,jsx_runtime.jsx)undefined39864062(0,jsx_runtime.jsxs)undefined41504224(0,jsx_runtime.jsx)undefined42654341(0,jsx_runtime.jsxs)undefined44154489(0,jsx_runtime.jsx)undefined46044678(0,jsx_runtime.jsx)undefined47824858(0,jsx_runtime.jsxs)undefined49555029(0,jsx_runtime.jsx)undefined54075481(0,jsx_runtime.jsx)undefined59475972error_boundaryundefined64686558(0,navigation/* usePathname */.jD)undefined66186692(0,jsx_runtime.jsx)undefined69467020(0,jsx_runtime.jsx)undefined70227101jsx_runtime.Fragmentundefined
   

/***/ })ùöÿÿ5  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ErrorBoundary: () => (/* binding */ ErrorBoundary),
  ErrorBoundaryHandler: () => (/* binding */ ErrorBoundaryHandler),
  GlobalError: () => (/* binding */ GlobalError),
  "default": () => (/* binding */ error_boundary)
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5486);
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__(2428);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/navigation.js + 1 modules
var navigation = __webpack_require__(7303);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/not-found.js
var not_found = __webpack_require__(5254);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/redirect.js
var redirect = __webpack_require__(3925);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/is-next-router-error.js


function isNextRouterError(error) {
    return error && error.digest && ((0,redirect/* isRedirectError */.eo)(error) || (0,not_found/* isNotFoundError */.X)(error));
} //# sourceMappingURL=is-next-router-error.js.map

// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/static-generation-async-storage.external.js + 1 modules
var static_generation_async_storage_external = __webpack_require__(1548);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/error-boundary.js
/* __next_internal_client_entry_do_not_use__ ErrorBoundaryHandler,GlobalError,default,ErrorBoundary auto */ 




const styles = {
    error: {
        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52
        fontFamily: 'system-ui,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"',
        height: "100vh",
        textAlign: "center",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center"
    },
    text: {
        fontSize: "14px",
        fontWeight: 400,
        lineHeight: "28px",
        margin: "0 8px"
    }
};
// if we are revalidating we want to re-throw the error so the
// function crashes so we can maintain our previous cache
// instead of caching the error page
function HandleISRError(param) {
    let { error } = param;
    const store = static_generation_async_storage_external/* staticGenerationAsyncStorage */.A.getStore();
    if ((store == null ? void 0 : store.isRevalidate) || (store == null ? void 0 : store.isStaticGeneration)) {
        console.error(error);
        throw error;
    }
    return null;
}
class ErrorBoundaryHandler extends react.Component {
    static getDerivedStateFromError(error) {
        if (isNextRouterError(error)) {
            // Re-throw if an expected internal Next.js router error occurs
            // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)
            throw error;
        }
        return {
            error
        };
    }
    static getDerivedStateFromProps(props, state) {
        /**
     * Handles reset of the error boundary when a navigation happens.
     * Ensures the error boundary does not stay enabled when navigating to a new page.
     * Approach of setState in render is safe as it checks the previous pathname and then overrides
     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders
     */ if (props.pathname !== state.previousPathname && state.error) {
            return {
                error: null,
                previousPathname: props.pathname
            };
        }
        return {
            error: state.error,
            previousPathname: props.pathname
        };
    }
    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific the the `@types/react` version.
    render() {
        if (this.state.error) {
            return /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
                children: [
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(HandleISRError, {
                        error: this.state.error
                    }),
                    this.props.errorStyles,
                    this.props.errorScripts,
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(this.props.errorComponent, {
                        error: this.state.error,
                        reset: this.reset
                    })
                ]
            });
        }
        return this.props.children;
    }
    constructor(props){
        super(props);
        this.reset = ()=>{
            this.setState({
                error: null
            });
        };
        this.state = {
            error: null,
            previousPathname: this.props.pathname
        };
    }
}
function GlobalError(param) {
    let { error } = param;
    const digest = error == null ? void 0 : error.digest;
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("html", {
        id: "__next_error__",
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)("head", {}),
            /*#__PURE__*/ (0,jsx_runtime.jsxs)("body", {
                children: [
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(HandleISRError, {
                        error: error
                    }),
                    /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                        style: styles.error,
                        children: /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
                            children: [
                                /*#__PURE__*/ (0,jsx_runtime.jsx)("h2", {
                                    style: styles.text,
                                    children: "Application error: a " + (digest ? "server" : "client") + "-side exception has occurred (see the " + (digest ? "server logs" : "browser console") + " for more information)."
                                }),
                                digest ? /*#__PURE__*/ (0,jsx_runtime.jsx)("p", {
                                    style: styles.text,
                                    children: "Digest: " + digest
                                }) : null
                            ]
                        })
                    })
                ]
            })
        ]
    });
}
// Exported so that the import signature in the loaders can be identical to user
// supplied custom global error signatures.
/* harmony default export */ const error_boundary = (GlobalError);
/**
 * Handles errors through `getDerivedStateFromError`.
 * Renders the provided error component and provides a way to `reset` the error boundary state.
 */ /**
 * Renders error boundary with the provided "errorComponent" property as the fallback.
 * If no "errorComponent" property is provided it renders the children without an error boundary.
 */ function ErrorBoundary(param) {
    let { errorComponent, errorStyles, errorScripts, children } = param;
    const pathname = (0,navigation/* usePathname */.jD)();
    if (errorComponent) {
        return /*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorBoundaryHandler, {
            pathname: pathname,
            errorComponent: errorComponent,
            errorStyles: errorStyles,
            errorScripts: errorScripts,
            children: children
        });
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
        children: children
    });
} //# sourceMappingURL=error-boundary.js.map


/***/ })úöÿÿýöÿÿ÷ÿÿxg  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Àwebpack://../../../src/client/components/is-next-router-error.ts¡÷ÿÿ`3isNotFoundErrorisRedirectError‘isNextRouterError[øÿÿQùÿÿ|þÿÿ„jsxsêþÿÿˆFragment‰_Fragment‹usePathnameRùÿÿ†stylesŠfontFamily†height‰textAlign‡displayflexDirectionŠalignItemsŽjustifyContent„textˆfontSizeŠfontWeightŠlineHeight†marginŽHandleISRErrorzøÿÿHùÿÿŒisRevalidate8øÿÿ˜getDerivedStateFromErrorøÿÿ˜getDerivedStateFromProps3øÿÿUýÿÿiøÿÿpreviousPathname†renderÿÿÿŒerrorScriptsÿÿÿ…resetùÿÿ<øÿÿiþÿÿ‹GlobalError„htmlÎûÿÿ5üÿÿºþÿÿ‹errorStyles`èöÿÿIùÿÿèöÿÿ  // ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ErrorBoundary: () => (/* binding */ ErrorBoundary),
  ErrorBoundaryHandler: () => (/* binding */ ErrorBoundaryHandler),
  GlobalError: () => (/* binding */ GlobalError),
  "default": () => (/* binding */ error_boundary)
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5486);
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__(2428);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/navigation.js + 1 modules
var navigation = __webpack_require__(7303);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/not-found.js
var not_found = __webpack_require__(5254);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/redirect.js
var redirect = __webpack_require__(3925);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/is-next-router-error.js
JùÿÿSùÿÿ  import { isNotFoundError } from "./not-found";
import { isRedirectError } from "./redirect";
export function isNextRouterError(error) {
    return error && error.digest && (isRedirectError(error) || isNotFoundError(error));
} //# sourceMappingURL=is-next-router-error.js.map
e  {"version":3,"sources":["webpack://../../../src/client/components/is-next-router-error.ts"],"names":["isNotFoundError","isRedirectError","isNextRouterError","error","digest"],"mappings":"AAAA,SAASA,eAAe,QAAQ,cAAa;AAC7C,SAASC,eAAe,QAAQ,aAAY;AAE5C,OAAO,SAASC,kBAAkBC,KAAU;IAC1C,OACEA,SAASA,MAAMC,MAAM,IAAKH,CAAAA,gBAAgBE,UAAUH,gBAAgBG,MAAAA;AAExE","file":"x"}  false045undefined4791undefined9399undefined173187__WEBPACK_MODULE_REFERENCE__4_5b22697352656469726563744572726f72225d_call_directImport_asiSafe1__._undefined199213__WEBPACK_MODULE_REFERENCE__3_5b2269734e6f74466f756e644572726f72225d_call_directImport_asiSafe1__._undefinedn   75173(0,redirect/* isRedirectError */.eo)undefined185283(0,not_found/* isNotFoundError */.X)undefinedRawSource   
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/static-generation-async-storage.external.js + 1 modules
var static_generation_async_storage_external = __webpack_require__(1548);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/error-boundary.js
EùÿÿNùÿÿ³  /* __next_internal_client_entry_do_not_use__ ErrorBoundaryHandler,GlobalError,default,ErrorBoundary auto */ import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React from "react";
import { usePathname } from "./navigation";
import { isNextRouterError } from "./is-next-router-error";
import { staticGenerationAsyncStorage } from "./static-generation-async-storage.external";
const styles = {
    error: {
        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52
        fontFamily: 'system-ui,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji"',
        height: "100vh",
        textAlign: "center",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center"
    },
    text: {
        fontSize: "14px",
        fontWeight: 400,
        lineHeight: "28px",
        margin: "0 8px"
    }
};
// if we are revalidating we want to re-throw the error so the
// function crashes so we can maintain our previous cache
// instead of caching the error page
function HandleISRError(param) {
    let { error } = param;
    const store = staticGenerationAsyncStorage.getStore();
    if ((store == null ? void 0 : store.isRevalidate) || (store == null ? void 0 : store.isStaticGeneration)) {
        console.error(error);
        throw error;
    }
    return null;
}
export class ErrorBoundaryHandler extends React.Component {
    static getDerivedStateFromError(error) {
        if (isNextRouterError(error)) {
            // Re-throw if an expected internal Next.js router error occurs
            // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)
            throw error;
        }
        return {
            error
        };
    }
    static getDerivedStateFromProps(props, state) {
        /**
     * Handles reset of the error boundary when a navigation happens.
     * Ensures the error boundary does not stay enabled when navigating to a new page.
     * Approach of setState in render is safe as it checks the previous pathname and then overrides
     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders
     */ if (props.pathname !== state.previousPathname && state.error) {
            return {
                error: null,
                previousPathname: props.pathname
            };
        }
        return {
            error: state.error,
            previousPathname: props.pathname
        };
    }
    // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific the the `@types/react` version.
    render() {
        if (this.state.error) {
            return /*#__PURE__*/ _jsxs(_Fragment, {
                children: [
                    /*#__PURE__*/ _jsx(HandleISRError, {
                        error: this.state.error
                    }),
                    this.props.errorStyles,
                    this.props.errorScripts,
                    /*#__PURE__*/ _jsx(this.props.errorComponent, {
                        error: this.state.error,
                        reset: this.reset
                    })
                ]
            });
        }
        return this.props.children;
    }
    constructor(props){
        super(props);
        this.reset = ()=>{
            this.setState({
                error: null
            });
        };
        this.state = {
            error: null,
            previousPathname: this.props.pathname
        };
    }
}
export function GlobalError(param) {
    let { error } = param;
    const digest = error == null ? void 0 : error.digest;
    return /*#__PURE__*/ _jsxs("html", {
        id: "__next_error__",
        children: [
            /*#__PURE__*/ _jsx("head", {}),
            /*#__PURE__*/ _jsxs("body", {
                children: [
                    /*#__PURE__*/ _jsx(HandleISRError, {
                        error: error
                    }),
                    /*#__PURE__*/ _jsx("div", {
                        style: styles.error,
                        children: /*#__PURE__*/ _jsxs("div", {
                            children: [
                                /*#__PURE__*/ _jsx("h2", {
                                    style: styles.text,
                                    children: "Application error: a " + (digest ? "server" : "client") + "-side exception has occurred (see the " + (digest ? "server logs" : "browser console") + " for more information)."
                                }),
                                digest ? /*#__PURE__*/ _jsx("p", {
                                    style: styles.text,
                                    children: "Digest: " + digest
                                }) : null
                            ]
                        })
                    })
                ]
            })
        ]
    });
}
// Exported so that the import signature in the loaders can be identical to user
// supplied custom global error signatures.
export default GlobalError;
/**
 * Handles errors through `getDerivedStateFromError`.
 * Renders the provided error component and provides a way to `reset` the error boundary state.
 */ /**
 * Renders error boundary with the provided "errorComponent" property as the fallback.
 * If no "errorComponent" property is provided it renders the children without an error boundary.
 */ export function ErrorBoundary(param) {
    let { errorComponent, errorStyles, errorScripts, children } = param;
    const pathname = usePathname();
    if (errorComponent) {
        return /*#__PURE__*/ _jsx(ErrorBoundaryHandler, {
            pathname: pathname,
            errorComponent: errorComponent,
            errorStyles: errorStyles,
            errorScripts: errorScripts,
            children: children
        });
    }
    return /*#__PURE__*/ _jsx(_Fragment, {
        children: children
    });
} //# sourceMappingURL=error-boundary.js.map
4  {"version":3,"sources":["webpack://../../../src/client/components/error-boundary.tsx"],"names":["React","jsxs","_jsxs","Fragment","_Fragment","usePathname","isNextRouterError","staticGenerationAsyncStorage","styles","error","fontFamily","height","textAlign","display","flexDirection","alignItems","justifyContent","text","fontSize","fontWeight","lineHeight","margin","HandleISRError","param","store","isRevalidate","console","getDerivedStateFromError","Component","getDerivedStateFromProps","props","state","pathname","previousPathname","render","_jsx","errorScripts","errorComponent","reset","children","constructor","setState","GlobalError","digest","html","id","body","style","errorStyles"],"mappings":"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","file":"x"}@  false108193undefined195220undefined222264undefined266324undefined326415undefined12031230__WEBPACK_MODULE_REFERENCE__6_5b2273746174696347656e65726174696f6e4173796e6353746f72616765225d_call_asiSafe1__._undefined14321438undefined14741488__WEBPACK_MODULE_REFERENCE__1_5b2264656661756c74222c22436f6d706f6e656e74225d_asiSafe1__._undefined15491565__WEBPACK_MODULE_REFERENCE__5_5b2269734e657874526f757465724572726f72225d_call_directImport_asiSafe1__._undefined28222826__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined28282836__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined29032906__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined31213124__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined36283634undefined37753779__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined38673870__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined39113915__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined39893992__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined41074110__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined42144218__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined43154318__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined46964699__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined51305144/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (undefined51305144undefined51565156.5);undefined55095515undefined56425652__WEBPACK_MODULE_REFERENCE__2_5b22757365506174686e616d65225d_call_directImport_asiSafe1__._undefined57125715__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined59695972__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined59745982__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined  8991010static_generation_async_storage_external/* staticGenerationAsyncStorage */.Aundefined12471335react.Componentundefined13961498isNextRouterErrorundefined27552831(0,jsx_runtime.jsxs)undefined28332912jsx_runtime.Fragmentundefined29793053(0,jsx_runtime.jsx)undefined32683342(0,jsx_runtime.jsx)undefined39864062(0,jsx_runtime.jsxs)undefined41504224(0,jsx_runtime.jsx)undefined42654341(0,jsx_runtime.jsxs)undefined44154489(0,jsx_runtime.jsx)undefined46044678(0,jsx_runtime.jsx)undefined47824858(0,jsx_runtime.jsxs)undefined49555029(0,jsx_runtime.jsx)undefined54075481(0,jsx_runtime.jsx)undefined59475972error_boundaryundefined64686558(0,navigation/* usePathname */.jD)undefined66186692(0,jsx_runtime.jsx)undefined69467020(0,jsx_runtime.jsx)undefined70227101jsx_runtime.Fragmentundefined÷ÿÿâöÿÿ   ,

/***/ 2726:
   4  «webpack/lib/util/registerExternalSerializerœwebpack-sources/ConcatSource€«webpack/lib/util/registerExternalSerializer™webpack-sources/RawSource_   /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
«webpack/lib/util/registerExternalSerializerœwebpack-sources/CachedSource   ³  «webpack/lib/util/registerExternalSerializerœwebpack-sources/ConcatSource€«webpack/lib/util/registerExternalSerializer™webpack-sources/RawSourceä   /* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ DynamicServerError),
/* harmony export */   j: () => (/* binding */ isDynamicServerError)
/* harmony export */ });
«webpack/lib/util/registerExternalSerializerwebpack-sources/ReplaceSource«webpack/lib/util/registerExternalSerializerŸwebpack-sources/SourceMapSource&  const DYNAMIC_ERROR_CODE = "DYNAMIC_SERVER_USAGE";
export class DynamicServerError extends Error {
    constructor(description){
        super("Dynamic server usage: " + description);
        this.description = description;
        this.digest = DYNAMIC_ERROR_CODE;
    }
}
export function isDynamicServerError(err) {
    if (typeof err !== "object" || err === null || !("digest" in err) || typeof err.digest !== "string") {
        return false;
    }
    return err.digest === DYNAMIC_ERROR_CODE;
} //# sourceMappingURL=hooks-server-context.js.map
  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/client/components/hooks-server-context.js|ssr)  {"version":3,"sources":["webpack://../../../src/client/components/hooks-server-context.ts"],"names":["DYNAMIC_ERROR_CODE","DynamicServerError","Error","constructor","description","digest","isDynamicServerError","err"],"mappings":"AAAA,MAAMA,qBAAqB;AAE3B,OAAO,MAAMC,2BAA2BC;IAGtCC,YAAYC,WAAmC,CAAE;QAC/C,KAAK,CAAC,2BAAyBA;aADLA,WAAAA,GAAAA;aAF5BC,MAAAA,GAAoCL;IAIpC;AACF;AAEA,OAAO,SAASM,qBAAqBC,GAAY;IAC/C,IACE,OAAOA,QAAQ,YACfA,QAAQ,QACR,CAAE,CAAA,YAAYA,GAAAA,KACd,OAAOA,IAAIF,MAAM,KAAK,UACtB;QACA,OAAO;IACT;IAEA,OAAOE,IAAIF,MAAM,KAAKL;AACxB","file":"x"}a39A    €€€†buffer†source„size„maps„hashü  /* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ DynamicServerError),
/* harmony export */   j: () => (/* binding */ isDynamicServerError)
/* harmony export */ });
const DYNAMIC_ERROR_CODE = "DYNAMIC_SERVER_USAGE";
class DynamicServerError extends Error {
    constructor(description){
        super("Dynamic server usage: " + description);
        this.description = description;
        this.digest = DYNAMIC_ERROR_CODE;
    }
}
function isDynamicServerError(err) {
    if (typeof err !== "object" || err === null || !("digest" in err) || typeof err.digest !== "string") {
        return false;
    }
    return err.digest === DYNAMIC_ERROR_CODE;
} //# sourceMappingURL=hooks-server-context.js.map
€”{"finalSource":true}ƒmap‹bufferedMap‡version„fileˆmappings‡sourcesŽsourcesContent…namesx+  ;;;;AAAA,MAAMA,qBAAqB;AAEpB,MAAMC,2BAA2BC;IAGtCC,YAAYC,WAAmC,CAAE;QAC/C,KAAK,CAAC,2BAAyBA;aADLA,WAAAA,GAAAA;aAF5BC,MAAAA,GAAoCL;IAIpC;AACF;AAEO,SAASM,qBAAqBC,GAAY;IAC/C,IACE,OAAOA,QAAQ,YACfA,QAAQ,QACR,CAAE,aAAYA,GAAAA,KACd,OAAOA,IAAIF,MAAM,KAAK,UACtB;QACA,OAAO;IACT;IAEA,OAAOE,IAAIF,MAAM,KAAKL;AACxBÀwebpack://../../../src/client/components/hooks-server-context.ts’DYNAMIC_ERROR_CODE’DynamicServerError…Error‹constructor‹description†digest”isDynamicServerErrorƒerr   ConcatSourceRawSourceä   /* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ DynamicServerError),
/* harmony export */   j: () => (/* binding */ isDynamicServerError)
/* harmony export */ });
   ReplaceSourceSourceMapSource&  const DYNAMIC_ERROR_CODE = "DYNAMIC_SERVER_USAGE";
export class DynamicServerError extends Error {
    constructor(description){
        super("Dynamic server usage: " + description);
        this.description = description;
        this.digest = DYNAMIC_ERROR_CODE;
    }
}
export function isDynamicServerError(err) {
    if (typeof err !== "object" || err === null || !("digest" in err) || typeof err.digest !== "string") {
        return false;
    }
    return err.digest === DYNAMIC_ERROR_CODE;
} //# sourceMappingURL=hooks-server-context.js.map
)  {"version":3,"sources":["webpack://../../../src/client/components/hooks-server-context.ts"],"names":["DYNAMIC_ERROR_CODE","DynamicServerError","Error","constructor","description","digest","isDynamicServerError","err"],"mappings":"AAAA,MAAMA,qBAAqB;AAE3B,OAAO,MAAMC,2BAA2BC;IAGtCC,YAAYC,WAAmC,CAAE;QAC/C,KAAK,CAAC,2BAAyBA;aADLA,WAAAA,GAAAA;aAF5BC,MAAAA,GAAoCL;IAIpC;AACF;AAEA,OAAO,SAASM,qBAAqBC,GAAY;IAC/C,IACE,OAAOA,QAAQ,YACfA,QAAQ,QACR,CAAE,CAAA,YAAYA,GAAAA,KACd,OAAOA,IAAIF,MAAM,KAAK,UACtB;QACA,OAAO;IACT;IAEA,OAAOE,IAAIF,MAAM,KAAKL;AACxB","file":"x"}!   false5157undefined274280undefined
   

/***/ })Ãöÿÿe  /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ DynamicServerError),
/* harmony export */   j: () => (/* binding */ isDynamicServerError)
/* harmony export */ });
const DYNAMIC_ERROR_CODE = "DYNAMIC_SERVER_USAGE";
class DynamicServerError extends Error {
    constructor(description){
        super("Dynamic server usage: " + description);
        this.description = description;
        this.digest = DYNAMIC_ERROR_CODE;
    }
}
function isDynamicServerError(err) {
    if (typeof err !== "object" || err === null || !("digest" in err) || typeof err.digest !== "string") {
        return false;
    }
    return err.digest === DYNAMIC_ERROR_CODE;
} //# sourceMappingURL=hooks-server-context.js.map


/***/ })ÄöÿÿÇöÿÿÎöÿÿx.  ;;;;;;;AAAA,MAAMA,qBAAqB;AAEpB,MAAMC,2BAA2BC;IAGtCC,YAAYC,WAAmC,CAAE;QAC/C,KAAK,CAAC,2BAAyBA;aADLA,WAAAA,GAAAA;aAF5BC,MAAAA,GAAoCL;IAIpC;AACF;AAEO,SAASM,qBAAqBC,GAAY;IAC/C,IACE,OAAOA,QAAQ,YACfA,QAAQ,QACR,CAAE,aAAYA,GAAAA,KACd,OAAOA,IAAIF,MAAM,KAAK,UACtB;QACA,OAAO;IACT;IAEA,OAAOE,IAAIF,MAAM,KAAKL;AACxBq÷ÿÿùÿÿùÿÿøÿÿ#øÿÿùÿÿùÿÿ ùÿÿßøÿÿ
Òöÿÿ3ùÿÿÒöÿÿä   /* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ DynamicServerError),
/* harmony export */   j: () => (/* binding */ isDynamicServerError)
/* harmony export */ });
=ùÿÿ‘úÿÿ’úÿÿ“úÿÿøöÿÿÕöÿÿ   ,

/***/ 8213:
    «webpack/lib/util/registerExternalSerializerœwebpack-sources/ConcatSource€«webpack/lib/util/registerExternalSerializer™webpack-sources/RawSource_   /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
«webpack/lib/util/registerExternalSerializerœwebpack-sources/CachedSource    Û «webpack/lib/util/registerExternalSerializerœwebpack-sources/ConcatSource€«webpack/lib/util/registerExternalSerializer™webpack-sources/RawSourcet  // ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ OuterLayoutRouter)
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5486);
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__(2428);
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react-dom/server-rendering-stub.js
var server_rendering_stub = __webpack_require__(8754);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/app-router-context.shared-runtime.js
var app_router_context_shared_runtime = __webpack_require__(6099);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/fetch-server-response.js
var fetch_server_response = __webpack_require__(10);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/unresolved-thenable.js
var unresolved_thenable = __webpack_require__(3654);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/error-boundary.js + 1 modules
var error_boundary = __webpack_require__(6120);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/match-segments.js
var match_segments = __webpack_require__(393);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/handle-smooth-scroll.js
«webpack/lib/util/registerExternalSerializerwebpack-sources/ReplaceSource«webpack/lib/util/registerExternalSerializerœwebpack-sources/CachedSource   à  «webpack/lib/util/registerExternalSerializerwebpack-sources/ReplaceSource«webpack/lib/util/registerExternalSerializerŸwebpack-sources/SourceMapSource€2  /**
 * Run function with `scroll-behavior: auto` applied to `<html/>`.
 * This css change will be reverted after the function finishes.
 */ export function handleSmoothScroll(fn, options) {
    if (options === void 0) options = {};
    // if only the hash is changed, we don't need to disable smooth scrolling
    // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX
    if (options.onlyHashChange) {
        fn();
        return;
    }
    const htmlElement = document.documentElement;
    const existing = htmlElement.style.scrollBehavior;
    htmlElement.style.scrollBehavior = "auto";
    if (!options.dontForceLayout) {
        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.
        // Otherwise it will not pickup the change in scrollBehavior
        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042
        htmlElement.getClientRects();
    }
    fn();
    htmlElement.style.scrollBehavior = existing;
} //# sourceMappingURL=handle-smooth-scroll.js.map
%  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/shared/lib/router/utils/handle-smooth-scroll.js|ssrÊ  {"version":3,"sources":["webpack://../../../../../src/shared/lib/router/utils/handle-smooth-scroll.ts"],"names":["handleSmoothScroll","fn","options","onlyHashChange","htmlElement","document","documentElement","existing","style","scrollBehavior","dontForceLayout","getClientRects"],"mappings":"AAAA;;;CAGC,GACD,OAAO,SAASA,mBACdC,EAAc,EACdC,OAAqE;IAArEA,IAAAA,YAAAA,KAAAA,GAAAA,UAAmE,CAAC;IAEpE,yEAAyE;IACzE,6FAA6F;IAC7F,IAAIA,QAAQC,cAAc,EAAE;QAC1BF;QACA;IACF;IACA,MAAMG,cAAcC,SAASC,eAAe;IAC5C,MAAMC,WAAWH,YAAYI,KAAK,CAACC,cAAc;IACjDL,YAAYI,KAAK,CAACC,cAAc,GAAG;IACnC,IAAI,CAACP,QAAQQ,eAAe,EAAE;QAC5B,8EAA8E;QAC9E,4DAA4D;QAC5D,yFAAyF;QACzFN,YAAYO,cAAc;IAC5B;IACAV;IACAG,YAAYI,KAAK,CAACC,cAAc,GAAGF;AACrC","file":"x"}AŒ   ’   €€†buffer†source„size„maps„hash+  /**
 * Run function with `scroll-behavior: auto` applied to `<html/>`.
 * This css change will be reverted after the function finishes.
 */ function handleSmoothScroll(fn, options) {
    if (options === void 0) options = {};
    // if only the hash is changed, we don't need to disable smooth scrolling
    // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX
    if (options.onlyHashChange) {
        fn();
        return;
    }
    const htmlElement = document.documentElement;
    const existing = htmlElement.style.scrollBehavior;
    htmlElement.style.scrollBehavior = "auto";
    if (!options.dontForceLayout) {
        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.
        // Otherwise it will not pickup the change in scrollBehavior
        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042
        htmlElement.getClientRects();
    }
    fn();
    htmlElement.style.scrollBehavior = existing;
} //# sourceMappingURL=handle-smooth-scroll.js.map
€•{"finalSource":false}ƒmap‹bufferedMap‡version„fileˆmappings‡sourcesŽsourcesContent…namesx“  AAAA;;;CAGC,GACM,SAASA,mBACdC,EAAc,EACdC,OAAqE;IAArEA,IAAAA,YAAAA,KAAAA,GAAAA,UAAmE,CAAC;IAEpE,yEAAyE;IACzE,6FAA6F;IAC7F,IAAIA,QAAQC,cAAc,EAAE;QAC1BF;QACA;IACF;IACA,MAAMG,cAAcC,SAASC,eAAe;IAC5C,MAAMC,WAAWH,YAAYI,KAAK,CAACC,cAAc;IACjDL,YAAYI,KAAK,CAACC,cAAc,GAAG;IACnC,IAAI,CAACP,QAAQQ,eAAe,EAAE;QAC5B,8EAA8E;QAC9E,4DAA4D;QAC5D,yFAAyF;QACzFN,YAAYO,cAAc;IAC5B;IACAV;IACAG,YAAYI,KAAK,CAACC,cAAc,GAAGF;AACrCÌwebpack://../../../../../src/shared/lib/router/utils/handle-smooth-scroll.ts`’handleSmoothScroll‚fn‡optionsŽonlyHashChange‹htmlElementˆdocumentdocumentElementˆexisting…styleŽscrollBehaviordontForceLayoutŽgetClientRects   ReplaceSourceSourceMapSource2  /**
 * Run function with `scroll-behavior: auto` applied to `<html/>`.
 * This css change will be reverted after the function finishes.
 */ export function handleSmoothScroll(fn, options) {
    if (options === void 0) options = {};
    // if only the hash is changed, we don't need to disable smooth scrolling
    // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX
    if (options.onlyHashChange) {
        fn();
        return;
    }
    const htmlElement = document.documentElement;
    const existing = htmlElement.style.scrollBehavior;
    htmlElement.style.scrollBehavior = "auto";
    if (!options.dontForceLayout) {
        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.
        // Otherwise it will not pickup the change in scrollBehavior
        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042
        htmlElement.getClientRects();
    }
    fn();
    htmlElement.style.scrollBehavior = existing;
} //# sourceMappingURL=handle-smooth-scroll.js.map
Ê  {"version":3,"sources":["webpack://../../../../../src/shared/lib/router/utils/handle-smooth-scroll.ts"],"names":["handleSmoothScroll","fn","options","onlyHashChange","htmlElement","document","documentElement","existing","style","scrollBehavior","dontForceLayout","getClientRects"],"mappings":"AAAA;;;CAGC,GACD,OAAO,SAASA,mBACdC,EAAc,EACdC,OAAqE;IAArEA,IAAAA,YAAAA,KAAAA,GAAAA,UAAmE,CAAC;IAEpE,yEAAyE;IACzE,6FAA6F;IAC7F,IAAIA,QAAQC,cAAc,EAAE;QAC1BF;QACA;IACF;IACA,MAAMG,cAAcC,SAASC,eAAe;IAC5C,MAAMC,WAAWH,YAAYI,KAAK,CAACC,cAAc;IACjDL,YAAYI,KAAK,CAACC,cAAc,GAAG;IACnC,IAAI,CAACP,QAAQQ,eAAe,EAAE;QAC5B,8EAA8E;QAC9E,4DAA4D;QAC5D,yFAAyF;QACzFN,YAAYO,cAAc;IAC5B;IACAV;IACAG,YAAYI,KAAK,CAACC,cAAc,GAAGF;AACrC","file":"x"}   false140146undefined Ž  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/redirect-boundary.js
var redirect_boundary = __webpack_require__(7017);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/not-found-boundary.js
var not_found_boundary = __webpack_require__(6212);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/get-segment-value.js
   ¤  «webpack/lib/util/registerExternalSerializerwebpack-sources/ReplaceSource«webpack/lib/util/registerExternalSerializerŸwebpack-sources/SourceMapSource€•   export function getSegmentValue(segment) {
    return Array.isArray(segment) ? segment[1] : segment;
} //# sourceMappingURL=get-segment-value.js.map
4  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/client/components/router-reducer/reducers/get-segment-value.js|ssr#  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/get-segment-value.ts"],"names":["getSegmentValue","segment","Array","isArray"],"mappings":"AAEA,OAAO,SAASA,gBAAgBC,OAAgB;IAC9C,OAAOC,MAAMC,OAAO,CAACF,WAAWA,OAAO,CAAC,EAAE,GAAGA;AAC/C","file":"x"} €ÖŽ   function getSegmentValue(segment) {
    return Array.isArray(segment) ? segment[1] : segment;
} //# sourceMappingURL=get-segment-value.js.map
×ÚáxV   AAEO,SAASA,gBAAgBC,OAAgB;IAC9C,OAAOC,MAAMC,OAAO,CAACF,WAAWA,OAAO,CAAC,EAAE,GAAGA;AAC/CÛwebpack://../../../../../src/client/components/router-reducer/reducers/get-segment-value.tsgetSegmentValue‡segment…Array‡isArrayê•   export function getSegmentValue(segment) {
    return Array.isArray(segment) ? segment[1] : segment;
} //# sourceMappingURL=get-segment-value.js.map
#  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/get-segment-value.ts"],"names":["getSegmentValue","segment","Array","isArray"],"mappings":"AAEA,OAAO,SAASA,gBAAgBC,OAAgB;IAC9C,OAAOC,MAAMC,OAAO,CAACF,WAAWA,OAAO,CAAC,EAAE,GAAGA;AAC/C","file":"x"}   false06undefined Ã  
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/create-router-cache-key.js
var create_router_cache_key = __webpack_require__(2505);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/future/helpers/interception-routes.js
var interception_routes = __webpack_require__(117);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js
   	  «webpack/lib/util/registerExternalSerializerwebpack-sources/ReplaceSource«webpack/lib/util/registerExternalSerializerŸwebpack-sources/SourceMapSource€ª  import { isInterceptionRouteAppPath } from "../../../../server/future/helpers/interception-routes";
export function hasInterceptionRouteInCurrentTree(param) {
    let [segment, parallelRoutes] = param;
    // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.
    if (Array.isArray(segment) && (segment[2] === "di" || segment[2] === "ci")) {
        return true;
    }
    // If segment is not an array, apply the existing string-based check
    if (typeof segment === "string" && isInterceptionRouteAppPath(segment)) {
        return true;
    }
    // Iterate through parallelRoutes if they exist
    if (parallelRoutes) {
        for(const key in parallelRoutes){
            if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {
                return true;
            }
        }
    }
    return false;
} //# sourceMappingURL=has-interception-route-in-current-tree.js.map
I  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js|ssrÞ  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/has-interception-route-in-current-tree.ts"],"names":["isInterceptionRouteAppPath","hasInterceptionRouteInCurrentTree","param","segment","parallelRoutes","Array","isArray","key"],"mappings":"AACA,SAASA,0BAA0B,QAAQ,wDAAuD;AAElG,OAAO,SAASC,kCAAkCC,KAG9B;IAH8B,IAAA,CAChDC,SACAC,eACkB,GAH8BF;IAIhD,wGAAwG;IACxG,IAAIG,MAAMC,OAAO,CAACH,YAAaA,CAAAA,OAAO,CAAC,EAAE,KAAK,QAAQA,OAAO,CAAC,EAAE,KAAK,IAAA,GAAO;QAC1E,OAAO;IACT;IAEA,oEAAoE;IACpE,IAAI,OAAOA,YAAY,YAAYH,2BAA2BG,UAAU;QACtE,OAAO;IACT;IAEA,+CAA+C;IAC/C,IAAIC,gBAAgB;QAClB,IAAK,MAAMG,OAAOH,eAAgB;YAChC,IAAIH,kCAAkCG,cAAc,CAACG,IAAI,GAAG;gBAC1D,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACT","file":"x"} bbdjA  -  €€ú__WEBPACK_MODULE_REFERENCE__13_5b226973496e74657263657074696f6e526f75746541707050617468225d_call_directImport_asiSafe1__._Á   
function hasInterceptionRouteInCurrentTree(param) {
    let [segment, parallelRoutes] = param;
    // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.
    if (Array.isArray(segment) && (segment[2] === "di" || segment[2] === "ci")) {
        return true;
    }
    // If segment is not an array, apply the existing string-based check
    if (typeof segment === "string" && __WEBPACK_MODULE_REFERENCE__13_5b226973496e74657263657074696f6e526f75746541707050617468225d_call_directImport_asiSafe1__._(segment)) {
        return true;
    }
    // Iterate through parallelRoutes if they exist
    if (parallelRoutes) {
        for(const key in parallelRoutes){
            if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {
                return true;
            }
        }
    }
    return false;
} //# sourceMappingURL=has-interception-route-in-current-tree.js.map
ÂÅÌx’  AACkG;AAE3F,SAASC,kCAAkCC,KAG9B;IAH8B,KAChDC,SACAC,eACkB,GAH8BF;IAIhD,wGAAwG;IACxG,IAAIG,MAAMC,OAAO,CAACH,YAAaA,CAAAA,OAAO,CAAC,EAAE,KAAK,QAAQA,OAAO,CAAC,EAAE,KAAK,OAAO;QAC1E,OAAO;IACT;IAEA,oEAAoE;IACpE,IAAI,OAAOA,YAAY,YAAYH,0HAAAA,CAA2BG,UAAU;QACtE,OAAO;IACT;IAEA,+CAA+C;IAC/C,IAAIC,gBAAgB;QAClB,IAAK,MAAMG,OAAOH,eAAgB;YAChC,IAAIH,kCAAkCG,cAAc,CAACG,IAAI,GAAG;gBAC1D,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACTðwebpack://../../../../../src/client/components/router-reducer/reducers/has-interception-route-in-current-tree.tsšisInterceptionRouteAppPath¡hasInterceptionRouteInCurrentTree…paraméŽparallelRouteséêƒkeyÔª  import { isInterceptionRouteAppPath } from "../../../../server/future/helpers/interception-routes";
export function hasInterceptionRouteInCurrentTree(param) {
    let [segment, parallelRoutes] = param;
    // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.
    if (Array.isArray(segment) && (segment[2] === "di" || segment[2] === "ci")) {
        return true;
    }
    // If segment is not an array, apply the existing string-based check
    if (typeof segment === "string" && isInterceptionRouteAppPath(segment)) {
        return true;
    }
    // Iterate through parallelRoutes if they exist
    if (parallelRoutes) {
        for(const key in parallelRoutes){
            if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {
                return true;
            }
        }
    }
    return false;
} //# sourceMappingURL=has-interception-route-in-current-tree.js.map
Þ  {"version":3,"sources":["webpack://../../../../../src/client/components/router-reducer/reducers/has-interception-route-in-current-tree.ts"],"names":["isInterceptionRouteAppPath","hasInterceptionRouteInCurrentTree","param","segment","parallelRoutes","Array","isArray","key"],"mappings":"AACA,SAASA,0BAA0B,QAAQ,wDAAuD;AAElG,OAAO,SAASC,kCAAkCC,KAG9B;IAH8B,IAAA,CAChDC,SACAC,eACkB,GAH8BF;IAIhD,wGAAwG;IACxG,IAAIG,MAAMC,OAAO,CAACH,YAAaA,CAAAA,OAAO,CAAC,EAAE,KAAK,QAAQA,OAAO,CAAC,EAAE,KAAK,IAAA,GAAO;QAC1E,OAAO;IACT;IAEA,oEAAoE;IACpE,IAAI,OAAOA,YAAY,YAAYH,2BAA2BG,UAAU;QACtE,OAAO;IACT;IAEA,+CAA+C;IAC/C,IAAIC,gBAAgB;QAClB,IAAK,MAAMG,OAAOH,eAAgB;YAChC,IAAIH,kCAAkCG,cAAc,CAACG,IAAI,GAAG;gBAC1D,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACT","file":"x"}©   false098undefined100106undefined532557__WEBPACK_MODULE_REFERENCE__13_5b226973496e74657263657074696f6e526f75746541707050617468225d_call_directImport_asiSafe1__._undefinedAª  #  º(0,interception_routes/* isInterceptionRouteAppPath */.Ag)Z   
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/layout-router.js
   ¸‰  «webpack/lib/util/registerExternalSerializerwebpack-sources/ReplaceSource«webpack/lib/util/registerExternalSerializerŸwebpack-sources/SourceMapSource€pV  /* __next_internal_client_entry_do_not_use__ default auto */ import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React, { useContext, use, startTransition, Suspense, useDeferredValue } from "react";
import ReactDOM from "react-dom";
import { LayoutRouterContext, GlobalLayoutRouterContext, TemplateContext } from "../../shared/lib/app-router-context.shared-runtime";
import { fetchServerResponse } from "./router-reducer/fetch-server-response";
import { unresolvedThenable } from "./unresolved-thenable";
import { ErrorBoundary } from "./error-boundary";
import { matchSegment } from "./match-segments";
import { handleSmoothScroll } from "../../shared/lib/router/utils/handle-smooth-scroll";
import { RedirectBoundary } from "./redirect-boundary";
import { NotFoundBoundary } from "./not-found-boundary";
import { getSegmentValue } from "./router-reducer/reducers/get-segment-value";
import { createRouterCacheKey } from "./router-reducer/create-router-cache-key";
import { hasInterceptionRouteInCurrentTree } from "./router-reducer/reducers/has-interception-route-in-current-tree";
/**
 * Add refetch marker to router state at the point of the current layout segment.
 * This ensures the response returned is not further down than the current layout segment.
 */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {
    if (segmentPathToWalk) {
        const [segment, parallelRouteKey] = segmentPathToWalk;
        const isLast = segmentPathToWalk.length === 2;
        if (matchSegment(treeToRecreate[0], segment)) {
            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {
                if (isLast) {
                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);
                    return [
                        treeToRecreate[0],
                        {
                            ...treeToRecreate[1],
                            [parallelRouteKey]: [
                                subTree[0],
                                subTree[1],
                                subTree[2],
                                "refetch"
                            ]
                        }
                    ];
                }
                return [
                    treeToRecreate[0],
                    {
                        ...treeToRecreate[1],
                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])
                    }
                ];
            }
        }
    }
    return treeToRecreate;
}
// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available
/**
 * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning
 */ function findDOMNode(instance) {
    // Tree-shake for server bundle
    if ("undefined" === "undefined") return null;
    // Only apply strict mode warning when not in production
    if ("production" !== "production") {
        const originalConsoleError = console.error;
        try {
            console.error = function() {
                for(var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++){
                    messages[_key] = arguments[_key];
                }
                // Ignore strict mode warning for the findDomNode call below
                if (!messages[0].includes("Warning: %s is deprecated in StrictMode.")) {
                    originalConsoleError(...messages);
                }
            };
            return ReactDOM.findDOMNode(instance);
        } finally{
            console.error = originalConsoleError;
        }
    }
    return ReactDOM.findDOMNode(instance);
}
const rectProperties = [
    "bottom",
    "height",
    "left",
    "right",
    "top",
    "width",
    "x",
    "y"
];
/**
 * Check if a HTMLElement is hidden or fixed/sticky position
 */ function shouldSkipElement(element) {
    // we ignore fixed or sticky positioned elements since they'll likely pass the "in-viewport" check
    // and will result in a situation we bail on scroll because of something like a fixed nav,
    // even though the actual page content is offscreen
    if ([
        "sticky",
        "fixed"
    ].includes(getComputedStyle(element).position)) {
        if ("production" === "development") {
            console.warn("Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:", element);
        }
        return true;
    }
    // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`
    // because `offsetParent` doesn't consider document/body
    const rect = element.getBoundingClientRect();
    return rectProperties.every((item)=>rect[item] === 0);
}
/**
 * Check if the top corner of the HTMLElement is in the viewport.
 */ function topOfElementInViewport(element, viewportHeight) {
    const rect = element.getBoundingClientRect();
    return rect.top >= 0 && rect.top <= viewportHeight;
}
/**
 * Find the DOM node for a hash fragment.
 * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.
 * If the hash fragment is an id, the page has to scroll to the element with that id.
 * If the hash fragment is a name, the page has to scroll to the first element with that name.
 */ function getHashFragmentDomNode(hashFragment) {
    // If the hash fragment is `top` the page has to scroll to the top of the page.
    if (hashFragment === "top") {
        return document.body;
    }
    var _document_getElementById;
    // If the hash fragment is an id, the page has to scroll to the element with that id.
    return (_document_getElementById = document.getElementById(hashFragment)) != null ? _document_getElementById : document.getElementsByName(hashFragment)[0];
}
class InnerScrollAndFocusHandler extends React.Component {
    componentDidMount() {
        this.handlePotentialScroll();
    }
    componentDidUpdate() {
        // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.
        if (this.props.focusAndScrollRef.apply) {
            this.handlePotentialScroll();
        }
    }
    render() {
        return this.props.children;
    }
    constructor(...args){
        super(...args);
        this.handlePotentialScroll = ()=>{
            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.
            const { focusAndScrollRef, segmentPath } = this.props;
            if (focusAndScrollRef.apply) {
                // segmentPaths is an array of segment paths that should be scrolled to
                // if the current segment path is not in the array, the scroll is not applied
                // unless the array is empty, in which case the scroll is always applied
                if (focusAndScrollRef.segmentPaths.length !== 0 && !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath)=>segmentPath.every((segment, index)=>matchSegment(segment, scrollRefSegmentPath[index])))) {
                    return;
                }
                let domNode = null;
                const hashFragment = focusAndScrollRef.hashFragment;
                if (hashFragment) {
                    domNode = getHashFragmentDomNode(hashFragment);
                }
                // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.
                // This already caused a bug where the first child was a <link/> in head.
                if (!domNode) {
                    domNode = findDOMNode(this);
                }
                // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.
                if (!(domNode instanceof Element)) {
                    return;
                }
                // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.
                // If the element is skipped, try to select the next sibling and try again.
                while(!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)){
                    // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.
                    if (domNode.nextElementSibling === null) {
                        return;
                    }
                    domNode = domNode.nextElementSibling;
                }
                // State is mutated to ensure that the focus and scroll is applied only once.
                focusAndScrollRef.apply = false;
                focusAndScrollRef.hashFragment = null;
                focusAndScrollRef.segmentPaths = [];
                handleSmoothScroll(()=>{
                    // In case of hash scroll, we only need to scroll the element into view
                    if (hashFragment) {
                        domNode.scrollIntoView();
                        return;
                    }
                    // Store the current viewport height because reading `clientHeight` causes a reflow,
                    // and it won't change during this function.
                    const htmlElement = document.documentElement;
                    const viewportHeight = htmlElement.clientHeight;
                    // If the element's top edge is already in the viewport, exit early.
                    if (topOfElementInViewport(domNode, viewportHeight)) {
                        return;
                    }
                    // Otherwise, try scrolling go the top of the document to be backward compatible with pages
                    // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)
                    // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left
                    // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically
                    htmlElement.scrollTop = 0;
                    // Scroll to domNode if domNode is not in viewport when scrolled to top of document
                    if (!topOfElementInViewport(domNode, viewportHeight)) {
                        domNode.scrollIntoView();
                    }
                }, {
                    // We will force layout by querying domNode position
                    dontForceLayout: true,
                    onlyHashChange: focusAndScrollRef.onlyHashChange
                });
                // Mutate after scrolling so that it can be read by `handleSmoothScroll`
                focusAndScrollRef.onlyHashChange = false;
                // Set focus on the element
                domNode.focus();
            }
        };
    }
}
function ScrollAndFocusHandler(param) {
    let { segmentPath, children } = param;
    const context = useContext(GlobalLayoutRouterContext);
    if (!context) {
        throw new Error("invariant global layout router not mounted");
    }
    return /*#__PURE__*/ _jsx(InnerScrollAndFocusHandler, {
        segmentPath: segmentPath,
        focusAndScrollRef: context.focusAndScrollRef,
        children: children
    });
}
/**
 * InnerLayoutRouter handles rendering the provided segment based on the cache.
 */ function InnerLayoutRouter(param) {
    let { parallelRouterKey, url, childNodes, segmentPath, tree, // isActive,
    cacheKey } = param;
    const context = useContext(GlobalLayoutRouterContext);
    if (!context) {
        throw new Error("invariant global layout router not mounted");
    }
    const { buildId, changeByServerResponse, tree: fullTree } = context;
    // Read segment path from the parallel router cache node.
    let childNode = childNodes.get(cacheKey);
    // When data is not available during rendering client-side we need to fetch
    // it from the server.
    if (childNode === undefined) {
        const newLazyCacheNode = {
            lazyData: null,
            rsc: null,
            prefetchRsc: null,
            head: null,
            prefetchHead: null,
            parallelRoutes: new Map(),
            lazyDataResolved: false,
            loading: null
        };
        /**
     * Flight data fetch kicked off during render and put into the cache.
     */ childNode = newLazyCacheNode;
        childNodes.set(cacheKey, newLazyCacheNode);
    }
    // `rsc` represents the renderable node for this segment.
    // If this segment has a `prefetchRsc`, it's the statically prefetched data.
    // We should use that on initial render instead of `rsc`. Then we'll switch
    // to `rsc` when the dynamic response streams in.
    //
    // If no prefetch data is available, then we go straight to rendering `rsc`.
    const resolvedPrefetchRsc = childNode.prefetchRsc !== null ? childNode.prefetchRsc : childNode.rsc;
    // We use `useDeferredValue` to handle switching between the prefetched and
    // final values. The second argument is returned on initial render, then it
    // re-renders with the first argument.
    //
    // @ts-expect-error The second argument to `useDeferredValue` is only
    // available in the experimental builds. When its disabled, it will always
    // return `rsc`.
    const rsc = useDeferredValue(childNode.rsc, resolvedPrefetchRsc);
    // `rsc` is either a React node or a promise for a React node, except we
    // special case `null` to represent that this segment's data is missing. If
    // it's a promise, we need to unwrap it so we can determine whether or not the
    // data is missing.
    const resolvedRsc = typeof rsc === "object" && rsc !== null && typeof rsc.then === "function" ? use(rsc) : rsc;
    if (!resolvedRsc) {
        // The data for this segment is not available, and there's no pending
        // navigation that will be able to fulfill it. We need to fetch more from
        // the server and patch the cache.
        // Check if there's already a pending request.
        let lazyData = childNode.lazyData;
        if (lazyData === null) {
            /**
       * Router state with refetch marker added
       */ // TODO-APP: remove ''
            const refetchTree = walkAddRefetch([
                "",
                ...segmentPath
            ], fullTree);
            const includeNextUrl = hasInterceptionRouteInCurrentTree(fullTree);
            childNode.lazyData = lazyData = fetchServerResponse(new URL(url, location.origin), refetchTree, includeNextUrl ? context.nextUrl : null, buildId);
            childNode.lazyDataResolved = false;
        }
        /**
     * Flight response data
     */ // When the data has not resolved yet `use` will suspend here.
        const serverResponse = use(lazyData);
        if (!childNode.lazyDataResolved) {
            // setTimeout is used to start a new transition during render, this is an intentional hack around React.
            setTimeout(()=>{
                startTransition(()=>{
                    changeByServerResponse({
                        previousTree: fullTree,
                        serverResponse
                    });
                });
            });
            // It's important that we mark this as resolved, in case this branch is replayed, we don't want to continously re-apply
            // the patch to the tree.
            childNode.lazyDataResolved = true;
        }
        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.
        // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.
        use(unresolvedThenable);
    }
    // If we get to this point, then we know we have something we can render.
    const subtree = /*#__PURE__*/ _jsx(LayoutRouterContext.Provider, {
        value: {
            tree: tree[1][parallelRouterKey],
            childNodes: childNode.parallelRoutes,
            // TODO-APP: overriding of url for parallel routes
            url: url,
            loading: childNode.loading
        },
        children: resolvedRsc
    });
    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`
    return subtree;
}
/**
 * Renders suspense boundary with the provided "loading" property as the fallback.
 * If no loading property is provided it renders the children without a suspense boundary.
 */ function LoadingBoundary(param) {
    let { children, hasLoading, loading, loadingStyles, loadingScripts } = param;
    // We have an explicit prop for checking if `loading` is provided, to disambiguate between a loading
    // component that returns `null` / `undefined`, vs not having a loading component at all.
    if (hasLoading) {
        return /*#__PURE__*/ _jsx(Suspense, {
            fallback: /*#__PURE__*/ _jsxs(_Fragment, {
                children: [
                    loadingStyles,
                    loadingScripts,
                    loading
                ]
            }),
            children: children
        });
    }
    return /*#__PURE__*/ _jsx(_Fragment, {
        children: children
    });
}
/**
 * OuterLayoutRouter handles the current segment as well as <Offscreen> rendering of other segments.
 * It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.
 */ export default function OuterLayoutRouter(param) {
    let { parallelRouterKey, segmentPath, error, errorStyles, errorScripts, templateStyles, templateScripts, template, notFound, notFoundStyles, styles } = param;
    const context = useContext(LayoutRouterContext);
    if (!context) {
        throw new Error("invariant expected layout router to be mounted");
    }
    const { childNodes, tree, url, loading } = context;
    // Get the current parallelRouter cache node
    let childNodesForParallelRouter = childNodes.get(parallelRouterKey);
    // If the parallel router cache node does not exist yet, create it.
    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.
    if (!childNodesForParallelRouter) {
        childNodesForParallelRouter = new Map();
        childNodes.set(parallelRouterKey, childNodesForParallelRouter);
    }
    // Get the active segment in the tree
    // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.
    const treeSegment = tree[1][parallelRouterKey][0];
    // If segment is an array it's a dynamic route and we want to read the dynamic route value as the segment to get from the cache.
    const currentChildSegmentValue = getSegmentValue(treeSegment);
    /**
   * Decides which segments to keep rendering, all segments that are not active will be wrapped in `<Offscreen>`.
   */ // TODO-APP: Add handling of `<Offscreen>` when it's available.
    const preservedSegments = [
        treeSegment
    ];
    return /*#__PURE__*/ _jsxs(_Fragment, {
        children: [
            styles,
            preservedSegments.map((preservedSegment)=>{
                const preservedSegmentValue = getSegmentValue(preservedSegment);
                const cacheKey = createRouterCacheKey(preservedSegment);
                return(/*
            - Error boundary
              - Only renders error boundary if error component is provided.
              - Rendered for each segment to ensure they have their own error state.
            - Loading boundary
              - Only renders suspense boundary if loading components is provided.
              - Rendered for each segment to ensure they have their own loading state.
              - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.
          */ /*#__PURE__*/ _jsxs(TemplateContext.Provider, {
                    value: /*#__PURE__*/ _jsx(ScrollAndFocusHandler, {
                        segmentPath: segmentPath,
                        children: /*#__PURE__*/ _jsx(ErrorBoundary, {
                            errorComponent: error,
                            errorStyles: errorStyles,
                            errorScripts: errorScripts,
                            children: /*#__PURE__*/ _jsx(LoadingBoundary, {
                                hasLoading: Boolean(loading),
                                loading: loading == null ? void 0 : loading[0],
                                loadingStyles: loading == null ? void 0 : loading[1],
                                loadingScripts: loading == null ? void 0 : loading[2],
                                children: /*#__PURE__*/ _jsx(NotFoundBoundary, {
                                    notFound: notFound,
                                    notFoundStyles: notFoundStyles,
                                    children: /*#__PURE__*/ _jsx(RedirectBoundary, {
                                        children: /*#__PURE__*/ _jsx(InnerLayoutRouter, {
                                            parallelRouterKey: parallelRouterKey,
                                            url: url,
                                            tree: tree,
                                            childNodes: childNodesForParallelRouter,
                                            segmentPath: segmentPath,
                                            cacheKey: cacheKey,
                                            isActive: currentChildSegmentValue === preservedSegmentValue
                                        })
                                    })
                                })
                            })
                        })
                    }),
                    children: [
                        templateStyles,
                        templateScripts,
                        template
                    ]
                }, createRouterCacheKey(preservedSegment, true)));
            })
        ]
    });
} //# sourceMappingURL=layout-router.js.map
  webpack://javascript/auto|./node_modules/next/dist/build/webpack/loaders/next-flight-client-module-loader.js!./node_modules/next/dist/build/webpack/loaders/next-swc-loader.js??ruleSet[1].rules[20].oneOf[6].use[1]!./node_modules/next/dist/esm/client/components/layout-router.js|ssrú%  {"version":3,"sources":["webpack://../../../src/client/components/layout-router.tsx"],"names":["React","useContext","use","startTransition","_Fragment","useDeferredValue","ReactDOM","Suspense","LayoutRouterContext","GlobalLayoutRouterContext","fetchServerResponse","TemplateContext","unresolvedThenable","ErrorBoundary","matchSegment","handleSmoothScroll","RedirectBoundary","NotFoundBoundary","getSegmentValue","createRouterCacheKey","hasInterceptionRouteInCurrentTree","segmentPathToWalk","treeToRecreate","parallelRouteKey","isLast","length","segment","hasOwnProperty","subTree","walkAddRefetch","undefined","slice","findDOMNode","instance","process","originalConsoleError","error","console","messages","rectProperties","shouldSkipElement","element","includes","position","warn","rect","item","every","getBoundingClientRect","top","viewportHeight","getHashFragmentDomNode","hashFragment","body","document","_document_getElementById","getElementById","getElementsByName","componentDidMount","Component","handlePotentialScroll","componentDidUpdate","apply","render","props","children","focusAndScrollRef","segmentPath","segmentPaths","some","scrollRefSegmentPath","index","domNode","Element","HTMLElement","nextElementSibling","scrollIntoView","htmlElement","clientHeight","topOfElementInViewport","scrollTop","dontForceLayout","onlyHashChange","focus","ScrollAndFocusHandler","param","context","Error","parallelRouterKey","url","childNodes","tree","cacheKey","buildId","changeByServerResponse","fullTree","childNode","get","newLazyCacheNode","lazyData","rsc","prefetchRsc","head","prefetchHead","parallelRoutes","lazyDataResolved","Map","loading","set","resolvedPrefetchRsc","resolvedRsc","then","refetchTree","URL","location","origin","includeNextUrl","nextUrl","setTimeout","serverResponse","_jsx","Provider","subtree","hasLoading","loadingStyles","loadingScripts","fallback","OuterLayoutRouter","errorStyles","childNodesForParallelRouter","treeSegment","currentChildSegmentValue","styles","preservedSegments","preservedSegmentValue","preservedSegment","value","errorComponent","errorScripts","Boolean","notFound","notFoundStyles","InnerLayoutRouter","isActive","templateStyles","templateScripts","template"],"mappings":"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","file":"x"}aA=_’   ”   ï   ñ       —  ™  å  ç  !  #  S  U  „  †  Ý  ß      N  P    Ÿ  î  ð  d  ÷    ,  F  ›  _·  º  `  m  t  à  ý     ‰  û  	  ¢  ­  _"  p"  ÷*   +  +  +  ˜+  ›+  .-  7-  9-  Q-  24  A4  Ô5  Ö5  L8  l8  ¥8  _·8  à9  â9  ¼:  Ê:  y=  {=  }=  Ž=  >  >  >  >  ÛA  ÞA  àA  çA  B  B  B  B  C  C  C  C  D  -D  	E  E  E  &E  lI  _zI  žJ  ¢J  ¤J  ¬J  ?K  MK  ƒK  –K  èM  ìM  îM  üM  3N  6N  ³N  ¶N  ¸N  ÄN  žO  ¡O  )Q  ,Q  .Q  =Q  úQ  ýQ  ÿQ  R  SR  VR  óU  @V  €€€€€€€€€€€€€€Ý__WEBPACK_MODULE_REFERENCE__7_5b226d617463685365676d656e74225d_call_directImport_asiSafe1__._„true…false‚{}Æ__WEBPACK_MODULE_REFERENCE__2_5b2264656661756c74225d_call_asiSafe1__._ýþÙ__WEBPACK_MODULE_REFERENCE__1_5b2264656661756c74222c22436f6d706f6e656e74225d_asiSafe1__._úé__WEBPACK_MODULE_REFERENCE__8_5b2268616e646c65536d6f6f74685363726f6c6c225d_call_directImport_asiSafe1__._Ù__WEBPACK_MODULE_REFERENCE__1_5b22757365436f6e74657874225d_call_directImport_asiSafe1__._ò__WEBPACK_MODULE_REFERENCE__3_5b22476c6f62616c4c61796f7574526f75746572436f6e74657874225d_directImport_asiSafe1__._Ë__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._ýþå__WEBPACK_MODULE_REFERENCE__1_5b22757365446566657272656456616c7565225d_call_directImport_asiSafe1__._Ë__WEBPACK_MODULE_REFERENCE__1_5b22757365225d_call_directImport_asiSafe1__._ˆ   __WEBPACK_MODULE_REFERENCE__14_5b22686173496e74657263657074696f6e526f757465496e43757272656e7454726565225d_call_directImport_asiSafe1__._ë__WEBPACK_MODULE_REFERENCE__4_5b226665746368536572766572526573706f6e7365225d_call_directImport_asiSafe1__._ýã__WEBPACK_MODULE_REFERENCE__1_5b2273746172745472616e736974696f6e225d_call_directImport_asiSafe1__._üä__WEBPACK_MODULE_REFERENCE__5_5b22756e7265736f6c7665645468656e61626c65225d_directImport_asiSafe1__._ùÙ__WEBPACK_MODULE_REFERENCE__3_5b224c61796f7574526f75746572436f6e74657874225d_asiSafe1__._øÐ__WEBPACK_MODULE_REFERENCE__1_5b2253757370656e7365225d_directImport_asiSafe1__._Í__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._Ð__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._õÿ€óæ__WEBPACK_MODULE_REFERENCE__3_5b224c61796f7574526f75746572436f6e74657874225d_directImport_asiSafe1__._ä__WEBPACK_MODULE_REFERENCE__11_5b226765745365676d656e7456616c7565225d_call_directImport_asiSafe1__._üýÿî__WEBPACK_MODULE_REFERENCE__12_5b22637265617465526f7574657243616368654b6579225d_call_directImport_asiSafe1__._ûÑ__WEBPACK_MODULE_REFERENCE__3_5b2254656d706c617465436f6e74657874225d_asiSafe1__._ññÚ__WEBPACK_MODULE_REFERENCE__6_5b224572726f72426f756e64617279225d_directImport_asiSafe1__._ððá__WEBPACK_MODULE_REFERENCE__10_5b224e6f74466f756e64426f756e64617279225d_directImport_asiSafe1__._ïà__WEBPACK_MODULE_REFERENCE__9_5b225265646972656374426f756e64617279225d_directImport_asiSafe1__._îûªe\  /* __next_internal_client_entry_do_not_use__ default auto */ 













/**
 * Add refetch marker to router state at the point of the current layout segment.
 * This ensures the response returned is not further down than the current layout segment.
 */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {
    if (segmentPathToWalk) {
        const [segment, parallelRouteKey] = segmentPathToWalk;
        const isLast = segmentPathToWalk.length === 2;
        if (__WEBPACK_MODULE_REFERENCE__7_5b226d617463685365676d656e74225d_call_directImport_asiSafe1__._(treeToRecreate[0], segment)) {
            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {
                if (isLast) {
                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);
                    return [
                        treeToRecreate[0],
                        {
                            ...treeToRecreate[1],
                            [parallelRouteKey]: [
                                subTree[0],
                                subTree[1],
                                subTree[2],
                                "refetch"
                            ]
                        }
                    ];
                }
                return [
                    treeToRecreate[0],
                    {
                        ...treeToRecreate[1],
                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])
                    }
                ];
            }
        }
    }
    return treeToRecreate;
}
// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available
/**
 * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning
 */ function findDOMNode(instance) {
    // Tree-shake for server bundle
    if (true) return null;
    // Only apply strict mode warning when not in production
    if (false) {}
    return __WEBPACK_MODULE_REFERENCE__2_5b2264656661756c74225d_call_asiSafe1__._.findDOMNode(instance);
}
const rectProperties = [
    "bottom",
    "height",
    "left",
    "right",
    "top",
    "width",
    "x",
    "y"
];
/**
 * Check if a HTMLElement is hidden or fixed/sticky position
 */ function shouldSkipElement(element) {
    // we ignore fixed or sticky positioned elements since they'll likely pass the "in-viewport" check
    // and will result in a situation we bail on scroll because of something like a fixed nav,
    // even though the actual page content is offscreen
    if ([
        "sticky",
        "fixed"
    ].includes(getComputedStyle(element).position)) {
        if (false) {}
        return true;
    }
    // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`
    // because `offsetParent` doesn't consider document/body
    const rect = element.getBoundingClientRect();
    return rectProperties.every((item)=>rect[item] === 0);
}
/**
 * Check if the top corner of the HTMLElement is in the viewport.
 */ function topOfElementInViewport(element, viewportHeight) {
    const rect = element.getBoundingClientRect();
    return rect.top >= 0 && rect.top <= viewportHeight;
}
/**
 * Find the DOM node for a hash fragment.
 * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.
 * If the hash fragment is an id, the page has to scroll to the element with that id.
 * If the hash fragment is a name, the page has to scroll to the first element with that name.
 */ function getHashFragmentDomNode(hashFragment) {
    // If the hash fragment is `top` the page has to scroll to the top of the page.
    if (hashFragment === "top") {
        return document.body;
    }
    var _document_getElementById;
    // If the hash fragment is an id, the page has to scroll to the element with that id.
    return (_document_getElementById = document.getElementById(hashFragment)) != null ? _document_getElementById : document.getElementsByName(hashFragment)[0];
}
class InnerScrollAndFocusHandler extends __WEBPACK_MODULE_REFERENCE__1_5b2264656661756c74222c22436f6d706f6e656e74225d_asiSafe1__._ {
    componentDidMount() {
        this.handlePotentialScroll();
    }
    componentDidUpdate() {
        // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.
        if (this.props.focusAndScrollRef.apply) {
            this.handlePotentialScroll();
        }
    }
    render() {
        return this.props.children;
    }
    constructor(...args){
        super(...args);
        this.handlePotentialScroll = ()=>{
            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.
            const { focusAndScrollRef, segmentPath } = this.props;
            if (focusAndScrollRef.apply) {
                // segmentPaths is an array of segment paths that should be scrolled to
                // if the current segment path is not in the array, the scroll is not applied
                // unless the array is empty, in which case the scroll is always applied
                if (focusAndScrollRef.segmentPaths.length !== 0 && !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath)=>segmentPath.every((segment, index)=>__WEBPACK_MODULE_REFERENCE__7_5b226d617463685365676d656e74225d_call_directImport_asiSafe1__._(segment, scrollRefSegmentPath[index])))) {
                    return;
                }
                let domNode = null;
                const hashFragment = focusAndScrollRef.hashFragment;
                if (hashFragment) {
                    domNode = getHashFragmentDomNode(hashFragment);
                }
                // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.
                // This already caused a bug where the first child was a <link/> in head.
                if (!domNode) {
                    domNode = findDOMNode(this);
                }
                // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.
                if (!(domNode instanceof Element)) {
                    return;
                }
                // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.
                // If the element is skipped, try to select the next sibling and try again.
                while(!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)){
                    // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.
                    if (domNode.nextElementSibling === null) {
                        return;
                    }
                    domNode = domNode.nextElementSibling;
                }
                // State is mutated to ensure that the focus and scroll is applied only once.
                focusAndScrollRef.apply = false;
                focusAndScrollRef.hashFragment = null;
                focusAndScrollRef.segmentPaths = [];
                __WEBPACK_MODULE_REFERENCE__8_5b2268616e646c65536d6f6f74685363726f6c6c225d_call_directImport_asiSafe1__._(()=>{
                    // In case of hash scroll, we only need to scroll the element into view
                    if (hashFragment) {
                        domNode.scrollIntoView();
                        return;
                    }
                    // Store the current viewport height because reading `clientHeight` causes a reflow,
                    // and it won't change during this function.
                    const htmlElement = document.documentElement;
                    const viewportHeight = htmlElement.clientHeight;
                    // If the element's top edge is already in the viewport, exit early.
                    if (topOfElementInViewport(domNode, viewportHeight)) {
                        return;
                    }
                    // Otherwise, try scrolling go the top of the document to be backward compatible with pages
                    // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)
                    // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left
                    // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically
                    htmlElement.scrollTop = 0;
                    // Scroll to domNode if domNode is not in viewport when scrolled to top of document
                    if (!topOfElementInViewport(domNode, viewportHeight)) {
                        domNode.scrollIntoView();
                    }
                }, {
                    // We will force layout by querying domNode position
                    dontForceLayout: true,
                    onlyHashChange: focusAndScrollRef.onlyHashChange
                });
                // Mutate after scrolling so that it can be read by `handleSmoothScroll`
                focusAndScrollRef.onlyHashChange = false;
                // Set focus on the element
                domNode.focus();
            }
        };
    }
}
function ScrollAndFocusHandler(param) {
    let { segmentPath, children } = param;
    const context = __WEBPACK_MODULE_REFERENCE__1_5b22757365436f6e74657874225d_call_directImport_asiSafe1__._(__WEBPACK_MODULE_REFERENCE__3_5b22476c6f62616c4c61796f7574526f75746572436f6e74657874225d_directImport_asiSafe1__._);
    if (!context) {
        throw new Error("invariant global layout router not mounted");
    }
    return /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._(InnerScrollAndFocusHandler, {
        segmentPath: segmentPath,
        focusAndScrollRef: context.focusAndScrollRef,
        children: children
    });
}
/**
 * InnerLayoutRouter handles rendering the provided segment based on the cache.
 */ function InnerLayoutRouter(param) {
    let { parallelRouterKey, url, childNodes, segmentPath, tree, // isActive,
    cacheKey } = param;
    const context = __WEBPACK_MODULE_REFERENCE__1_5b22757365436f6e74657874225d_call_directImport_asiSafe1__._(__WEBPACK_MODULE_REFERENCE__3_5b22476c6f62616c4c61796f7574526f75746572436f6e74657874225d_directImport_asiSafe1__._);
    if (!context) {
        throw new Error("invariant global layout router not mounted");
    }
    const { buildId, changeByServerResponse, tree: fullTree } = context;
    // Read segment path from the parallel router cache node.
    let childNode = childNodes.get(cacheKey);
    // When data is not available during rendering client-side we need to fetch
    // it from the server.
    if (childNode === undefined) {
        const newLazyCacheNode = {
            lazyData: null,
            rsc: null,
            prefetchRsc: null,
            head: null,
            prefetchHead: null,
            parallelRoutes: new Map(),
            lazyDataResolved: false,
            loading: null
        };
        /**
     * Flight data fetch kicked off during render and put into the cache.
     */ childNode = newLazyCacheNode;
        childNodes.set(cacheKey, newLazyCacheNode);
    }
    // `rsc` represents the renderable node for this segment.
    // If this segment has a `prefetchRsc`, it's the statically prefetched data.
    // We should use that on initial render instead of `rsc`. Then we'll switch
    // to `rsc` when the dynamic response streams in.
    //
    // If no prefetch data is available, then we go straight to rendering `rsc`.
    const resolvedPrefetchRsc = childNode.prefetchRsc !== null ? childNode.prefetchRsc : childNode.rsc;
    // We use `useDeferredValue` to handle switching between the prefetched and
    // final values. The second argument is returned on initial render, then it
    // re-renders with the first argument.
    //
    // @ts-expect-error The second argument to `useDeferredValue` is only
    // available in the experimental builds. When its disabled, it will always
    // return `rsc`.
    const rsc = __WEBPACK_MODULE_REFERENCE__1_5b22757365446566657272656456616c7565225d_call_directImport_asiSafe1__._(childNode.rsc, resolvedPrefetchRsc);
    // `rsc` is either a React node or a promise for a React node, except we
    // special case `null` to represent that this segment's data is missing. If
    // it's a promise, we need to unwrap it so we can determine whether or not the
    // data is missing.
    const resolvedRsc = typeof rsc === "object" && rsc !== null && typeof rsc.then === "function" ? __WEBPACK_MODULE_REFERENCE__1_5b22757365225d_call_directImport_asiSafe1__._(rsc) : rsc;
    if (!resolvedRsc) {
        // The data for this segment is not available, and there's no pending
        // navigation that will be able to fulfill it. We need to fetch more from
        // the server and patch the cache.
        // Check if there's already a pending request.
        let lazyData = childNode.lazyData;
        if (lazyData === null) {
            /**
       * Router state with refetch marker added
       */ // TODO-APP: remove ''
            const refetchTree = walkAddRefetch([
                "",
                ...segmentPath
            ], fullTree);
            const includeNextUrl = __WEBPACK_MODULE_REFERENCE__14_5b22686173496e74657263657074696f6e526f757465496e43757272656e7454726565225d_call_directImport_asiSafe1__._(fullTree);
            childNode.lazyData = lazyData = __WEBPACK_MODULE_REFERENCE__4_5b226665746368536572766572526573706f6e7365225d_call_directImport_asiSafe1__._(new URL(url, location.origin), refetchTree, includeNextUrl ? context.nextUrl : null, buildId);
            childNode.lazyDataResolved = false;
        }
        /**
     * Flight response data
     */ // When the data has not resolved yet `use` will suspend here.
        const serverResponse = __WEBPACK_MODULE_REFERENCE__1_5b22757365225d_call_directImport_asiSafe1__._(lazyData);
        if (!childNode.lazyDataResolved) {
            // setTimeout is used to start a new transition during render, this is an intentional hack around React.
            setTimeout(()=>{
                __WEBPACK_MODULE_REFERENCE__1_5b2273746172745472616e736974696f6e225d_call_directImport_asiSafe1__._(()=>{
                    changeByServerResponse({
                        previousTree: fullTree,
                        serverResponse
                    });
                });
            });
            // It's important that we mark this as resolved, in case this branch is replayed, we don't want to continously re-apply
            // the patch to the tree.
            childNode.lazyDataResolved = true;
        }
        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.
        // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.
        __WEBPACK_MODULE_REFERENCE__1_5b22757365225d_call_directImport_asiSafe1__._(__WEBPACK_MODULE_REFERENCE__5_5b22756e7265736f6c7665645468656e61626c65225d_directImport_asiSafe1__._);
    }
    // If we get to this point, then we know we have something we can render.
    const subtree = /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._(__WEBPACK_MODULE_REFERENCE__3_5b224c61796f7574526f75746572436f6e74657874225d_asiSafe1__._.Provider, {
        value: {
            tree: tree[1][parallelRouterKey],
            childNodes: childNode.parallelRoutes,
            // TODO-APP: overriding of url for parallel routes
            url: url,
            loading: childNode.loading
        },
        children: resolvedRsc
    });
    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`
    return subtree;
}
/**
 * Renders suspense boundary with the provided "loading" property as the fallback.
 * If no loading property is provided it renders the children without a suspense boundary.
 */ function LoadingBoundary(param) {
    let { children, hasLoading, loading, loadingStyles, loadingScripts } = param;
    // We have an explicit prop for checking if `loading` is provided, to disambiguate between a loading
    // component that returns `null` / `undefined`, vs not having a loading component at all.
    if (hasLoading) {
        return /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._(__WEBPACK_MODULE_REFERENCE__1_5b2253757370656e7365225d_directImport_asiSafe1__._, {
            fallback: /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._(__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._, {
                children: [
                    loadingStyles,
                    loadingScripts,
                    loading
                ]
            }),
            children: children
        });
    }
    return /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._(__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._, {
        children: children
    });
}
/**
 * OuterLayoutRouter handles the current segment as well as <Offscreen> rendering of other segments.
 * It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.
 */ function OuterLayoutRouter(param) {
    let { parallelRouterKey, segmentPath, error, errorStyles, errorScripts, templateStyles, templateScripts, template, notFound, notFoundStyles, styles } = param;
    const context = __WEBPACK_MODULE_REFERENCE__1_5b22757365436f6e74657874225d_call_directImport_asiSafe1__._(__WEBPACK_MODULE_REFERENCE__3_5b224c61796f7574526f75746572436f6e74657874225d_directImport_asiSafe1__._);
    if (!context) {
        throw new Error("invariant expected layout router to be mounted");
    }
    const { childNodes, tree, url, loading } = context;
    // Get the current parallelRouter cache node
    let childNodesForParallelRouter = childNodes.get(parallelRouterKey);
    // If the parallel router cache node does not exist yet, create it.
    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.
    if (!childNodesForParallelRouter) {
        childNodesForParallelRouter = new Map();
        childNodes.set(parallelRouterKey, childNodesForParallelRouter);
    }
    // Get the active segment in the tree
    // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.
    const treeSegment = tree[1][parallelRouterKey][0];
    // If segment is an array it's a dynamic route and we want to read the dynamic route value as the segment to get from the cache.
    const currentChildSegmentValue = __WEBPACK_MODULE_REFERENCE__11_5b226765745365676d656e7456616c7565225d_call_directImport_asiSafe1__._(treeSegment);
    /**
   * Decides which segments to keep rendering, all segments that are not active will be wrapped in `<Offscreen>`.
   */ // TODO-APP: Add handling of `<Offscreen>` when it's available.
    const preservedSegments = [
        treeSegment
    ];
    return /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._(__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._, {
        children: [
            styles,
            preservedSegments.map((preservedSegment)=>{
                const preservedSegmentValue = __WEBPACK_MODULE_REFERENCE__11_5b226765745365676d656e7456616c7565225d_call_directImport_asiSafe1__._(preservedSegment);
                const cacheKey = __WEBPACK_MODULE_REFERENCE__12_5b22637265617465526f7574657243616368654b6579225d_call_directImport_asiSafe1__._(preservedSegment);
                return(/*
            - Error boundary
              - Only renders error boundary if error component is provided.
              - Rendered for each segment to ensure they have their own error state.
            - Loading boundary
              - Only renders suspense boundary if loading components is provided.
              - Rendered for each segment to ensure they have their own loading state.
              - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.
          */ /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._(__WEBPACK_MODULE_REFERENCE__3_5b2254656d706c617465436f6e74657874225d_asiSafe1__._.Provider, {
                    value: /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._(ScrollAndFocusHandler, {
                        segmentPath: segmentPath,
                        children: /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._(__WEBPACK_MODULE_REFERENCE__6_5b224572726f72426f756e64617279225d_directImport_asiSafe1__._, {
                            errorComponent: error,
                            errorStyles: errorStyles,
                            errorScripts: errorScripts,
                            children: /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._(LoadingBoundary, {
                                hasLoading: Boolean(loading),
                                loading: loading == null ? void 0 : loading[0],
                                loadingStyles: loading == null ? void 0 : loading[1],
                                loadingScripts: loading == null ? void 0 : loading[2],
                                children: /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._(__WEBPACK_MODULE_REFERENCE__10_5b224e6f74466f756e64426f756e64617279225d_directImport_asiSafe1__._, {
                                    notFound: notFound,
                                    notFoundStyles: notFoundStyles,
                                    children: /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._(__WEBPACK_MODULE_REFERENCE__9_5b225265646972656374426f756e64617279225d_directImport_asiSafe1__._, {
                                        children: /*#__PURE__*/ __WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._(InnerLayoutRouter, {
                                            parallelRouterKey: parallelRouterKey,
                                            url: url,
                                            tree: tree,
                                            childNodes: childNodesForParallelRouter,
                                            segmentPath: segmentPath,
                                            cacheKey: cacheKey,
                                            isActive: currentChildSegmentValue === preservedSegmentValue
                                        })
                                    })
                                })
                            })
                        })
                    }),
                    children: [
                        templateStyles,
                        templateScripts,
                        template
                    ]
                }, __WEBPACK_MODULE_REFERENCE__12_5b22637265617465526f7574657243616368654b6579225d_call_directImport_asiSafe1__._(preservedSegment, true)));
            })
        ]
    });
} //# sourceMappingURL=layout-router.js.map
«®µxO  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ºwebpack://../../../src/client/components/layout-router.tsx@“   …ReactŠuseContextƒusestartTransition‰_FragmentuseDeferredValueˆReactDOMˆSuspense“LayoutRouterContext™GlobalLayoutRouterContext“fetchServerResponseTemplateContext’unresolvedThenableErrorBoundaryŒmatchSegment§RedirectBoundaryNotFoundBoundaryÃ”createRouterCacheKeyØ‘segmentPathToWalkŽtreeToRecreateparallelRouteKey†isLast†length¾ŽhasOwnProperty‡subTreeŽwalkAddRefetch‰undefined…slice‹findDOMNodeˆinstance‡process”originalConsoleError…error‡consoleˆmessagesŽrectProperties‘shouldSkipElement‡elementˆincludesˆposition„warn„rect„item…every•getBoundingClientRectƒtopŽviewportHeight–getHashFragmentDomNodeŒhashFragment„body‰˜_document_getElementByIdŽgetElementById‘getElementsByName‘componentDidMount‰Component•handlePotentialScroll’componentDidUpdate…apply†render…propsˆchildren‘focusAndScrollRef‹segmentPathŒsegmentPaths„some”scrollRefSegmentPath…index‡domNode‡Element‹HTMLElement’nextElementSiblingŽscrollIntoViewrÿÿÿŒclientHeight–topOfElementInViewport‰scrollTopuÿÿÿnÿÿÿ…focus•ScrollAndFocusHandlerž‡context…Error‘parallelRouterKeyƒurlŠchildNodes„treeˆcacheKey‡buildId–changeByServerResponseˆfullTree‰childNodeƒgetnewLazyCacheNodeˆlazyDataƒrsc‹prefetchRsc„headŒprefetchHeadlazyDataResolvedƒMap‡loadingƒset“resolvedPrefetchRsc‹resolvedRsc„then‹refetchTreeƒURLˆlocation†originŽincludeNextUrl‡nextUrlŠsetTimeoutŽserverResponse„_jsxˆProvider‡subtreeŠhasLoadingloadingStylesŽloadingScriptsˆfallback‘OuterLayoutRouter‹errorStyles›childNodesForParallelRouter‹treeSegment˜currentChildSegmentValue†styles‘preservedSegments•preservedSegmentValuepreservedSegment…valueŽerrorComponentŒerrorScripts‡BooleanˆnotFoundŽnotFoundStyles‘InnerLayoutRouterˆisActiveŽtemplateStylestemplateScriptsˆtemplate9ÿÿÿpV  /* __next_internal_client_entry_do_not_use__ default auto */ import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import React, { useContext, use, startTransition, Suspense, useDeferredValue } from "react";
import ReactDOM from "react-dom";
import { LayoutRouterContext, GlobalLayoutRouterContext, TemplateContext } from "../../shared/lib/app-router-context.shared-runtime";
import { fetchServerResponse } from "./router-reducer/fetch-server-response";
import { unresolvedThenable } from "./unresolved-thenable";
import { ErrorBoundary } from "./error-boundary";
import { matchSegment } from "./match-segments";
import { handleSmoothScroll } from "../../shared/lib/router/utils/handle-smooth-scroll";
import { RedirectBoundary } from "./redirect-boundary";
import { NotFoundBoundary } from "./not-found-boundary";
import { getSegmentValue } from "./router-reducer/reducers/get-segment-value";
import { createRouterCacheKey } from "./router-reducer/create-router-cache-key";
import { hasInterceptionRouteInCurrentTree } from "./router-reducer/reducers/has-interception-route-in-current-tree";
/**
 * Add refetch marker to router state at the point of the current layout segment.
 * This ensures the response returned is not further down than the current layout segment.
 */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {
    if (segmentPathToWalk) {
        const [segment, parallelRouteKey] = segmentPathToWalk;
        const isLast = segmentPathToWalk.length === 2;
        if (matchSegment(treeToRecreate[0], segment)) {
            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {
                if (isLast) {
                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);
                    return [
                        treeToRecreate[0],
                        {
                            ...treeToRecreate[1],
                            [parallelRouteKey]: [
                                subTree[0],
                                subTree[1],
                                subTree[2],
                                "refetch"
                            ]
                        }
                    ];
                }
                return [
                    treeToRecreate[0],
                    {
                        ...treeToRecreate[1],
                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])
                    }
                ];
            }
        }
    }
    return treeToRecreate;
}
// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available
/**
 * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning
 */ function findDOMNode(instance) {
    // Tree-shake for server bundle
    if ("undefined" === "undefined") return null;
    // Only apply strict mode warning when not in production
    if ("production" !== "production") {
        const originalConsoleError = console.error;
        try {
            console.error = function() {
                for(var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++){
                    messages[_key] = arguments[_key];
                }
                // Ignore strict mode warning for the findDomNode call below
                if (!messages[0].includes("Warning: %s is deprecated in StrictMode.")) {
                    originalConsoleError(...messages);
                }
            };
            return ReactDOM.findDOMNode(instance);
        } finally{
            console.error = originalConsoleError;
        }
    }
    return ReactDOM.findDOMNode(instance);
}
const rectProperties = [
    "bottom",
    "height",
    "left",
    "right",
    "top",
    "width",
    "x",
    "y"
];
/**
 * Check if a HTMLElement is hidden or fixed/sticky position
 */ function shouldSkipElement(element) {
    // we ignore fixed or sticky positioned elements since they'll likely pass the "in-viewport" check
    // and will result in a situation we bail on scroll because of something like a fixed nav,
    // even though the actual page content is offscreen
    if ([
        "sticky",
        "fixed"
    ].includes(getComputedStyle(element).position)) {
        if ("production" === "development") {
            console.warn("Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:", element);
        }
        return true;
    }
    // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`
    // because `offsetParent` doesn't consider document/body
    const rect = element.getBoundingClientRect();
    return rectProperties.every((item)=>rect[item] === 0);
}
/**
 * Check if the top corner of the HTMLElement is in the viewport.
 */ function topOfElementInViewport(element, viewportHeight) {
    const rect = element.getBoundingClientRect();
    return rect.top >= 0 && rect.top <= viewportHeight;
}
/**
 * Find the DOM node for a hash fragment.
 * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.
 * If the hash fragment is an id, the page has to scroll to the element with that id.
 * If the hash fragment is a name, the page has to scroll to the first element with that name.
 */ function getHashFragmentDomNode(hashFragment) {
    // If the hash fragment is `top` the page has to scroll to the top of the page.
    if (hashFragment === "top") {
        return document.body;
    }
    var _document_getElementById;
    // If the hash fragment is an id, the page has to scroll to the element with that id.
    return (_document_getElementById = document.getElementById(hashFragment)) != null ? _document_getElementById : document.getElementsByName(hashFragment)[0];
}
class InnerScrollAndFocusHandler extends React.Component {
    componentDidMount() {
        this.handlePotentialScroll();
    }
    componentDidUpdate() {
        // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.
        if (this.props.focusAndScrollRef.apply) {
            this.handlePotentialScroll();
        }
    }
    render() {
        return this.props.children;
    }
    constructor(...args){
        super(...args);
        this.handlePotentialScroll = ()=>{
            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.
            const { focusAndScrollRef, segmentPath } = this.props;
            if (focusAndScrollRef.apply) {
                // segmentPaths is an array of segment paths that should be scrolled to
                // if the current segment path is not in the array, the scroll is not applied
                // unless the array is empty, in which case the scroll is always applied
                if (focusAndScrollRef.segmentPaths.length !== 0 && !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath)=>segmentPath.every((segment, index)=>matchSegment(segment, scrollRefSegmentPath[index])))) {
                    return;
                }
                let domNode = null;
                const hashFragment = focusAndScrollRef.hashFragment;
                if (hashFragment) {
                    domNode = getHashFragmentDomNode(hashFragment);
                }
                // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.
                // This already caused a bug where the first child was a <link/> in head.
                if (!domNode) {
                    domNode = findDOMNode(this);
                }
                // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.
                if (!(domNode instanceof Element)) {
                    return;
                }
                // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.
                // If the element is skipped, try to select the next sibling and try again.
                while(!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)){
                    // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.
                    if (domNode.nextElementSibling === null) {
                        return;
                    }
                    domNode = domNode.nextElementSibling;
                }
                // State is mutated to ensure that the focus and scroll is applied only once.
                focusAndScrollRef.apply = false;
                focusAndScrollRef.hashFragment = null;
                focusAndScrollRef.segmentPaths = [];
                handleSmoothScroll(()=>{
                    // In case of hash scroll, we only need to scroll the element into view
                    if (hashFragment) {
                        domNode.scrollIntoView();
                        return;
                    }
                    // Store the current viewport height because reading `clientHeight` causes a reflow,
                    // and it won't change during this function.
                    const htmlElement = document.documentElement;
                    const viewportHeight = htmlElement.clientHeight;
                    // If the element's top edge is already in the viewport, exit early.
                    if (topOfElementInViewport(domNode, viewportHeight)) {
                        return;
                    }
                    // Otherwise, try scrolling go the top of the document to be backward compatible with pages
                    // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)
                    // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left
                    // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically
                    htmlElement.scrollTop = 0;
                    // Scroll to domNode if domNode is not in viewport when scrolled to top of document
                    if (!topOfElementInViewport(domNode, viewportHeight)) {
                        domNode.scrollIntoView();
                    }
                }, {
                    // We will force layout by querying domNode position
                    dontForceLayout: true,
                    onlyHashChange: focusAndScrollRef.onlyHashChange
                });
                // Mutate after scrolling so that it can be read by `handleSmoothScroll`
                focusAndScrollRef.onlyHashChange = false;
                // Set focus on the element
                domNode.focus();
            }
        };
    }
}
function ScrollAndFocusHandler(param) {
    let { segmentPath, children } = param;
    const context = useContext(GlobalLayoutRouterContext);
    if (!context) {
        throw new Error("invariant global layout router not mounted");
    }
    return /*#__PURE__*/ _jsx(InnerScrollAndFocusHandler, {
        segmentPath: segmentPath,
        focusAndScrollRef: context.focusAndScrollRef,
        children: children
    });
}
/**
 * InnerLayoutRouter handles rendering the provided segment based on the cache.
 */ function InnerLayoutRouter(param) {
    let { parallelRouterKey, url, childNodes, segmentPath, tree, // isActive,
    cacheKey } = param;
    const context = useContext(GlobalLayoutRouterContext);
    if (!context) {
        throw new Error("invariant global layout router not mounted");
    }
    const { buildId, changeByServerResponse, tree: fullTree } = context;
    // Read segment path from the parallel router cache node.
    let childNode = childNodes.get(cacheKey);
    // When data is not available during rendering client-side we need to fetch
    // it from the server.
    if (childNode === undefined) {
        const newLazyCacheNode = {
            lazyData: null,
            rsc: null,
            prefetchRsc: null,
            head: null,
            prefetchHead: null,
            parallelRoutes: new Map(),
            lazyDataResolved: false,
            loading: null
        };
        /**
     * Flight data fetch kicked off during render and put into the cache.
     */ childNode = newLazyCacheNode;
        childNodes.set(cacheKey, newLazyCacheNode);
    }
    // `rsc` represents the renderable node for this segment.
    // If this segment has a `prefetchRsc`, it's the statically prefetched data.
    // We should use that on initial render instead of `rsc`. Then we'll switch
    // to `rsc` when the dynamic response streams in.
    //
    // If no prefetch data is available, then we go straight to rendering `rsc`.
    const resolvedPrefetchRsc = childNode.prefetchRsc !== null ? childNode.prefetchRsc : childNode.rsc;
    // We use `useDeferredValue` to handle switching between the prefetched and
    // final values. The second argument is returned on initial render, then it
    // re-renders with the first argument.
    //
    // @ts-expect-error The second argument to `useDeferredValue` is only
    // available in the experimental builds. When its disabled, it will always
    // return `rsc`.
    const rsc = useDeferredValue(childNode.rsc, resolvedPrefetchRsc);
    // `rsc` is either a React node or a promise for a React node, except we
    // special case `null` to represent that this segment's data is missing. If
    // it's a promise, we need to unwrap it so we can determine whether or not the
    // data is missing.
    const resolvedRsc = typeof rsc === "object" && rsc !== null && typeof rsc.then === "function" ? use(rsc) : rsc;
    if (!resolvedRsc) {
        // The data for this segment is not available, and there's no pending
        // navigation that will be able to fulfill it. We need to fetch more from
        // the server and patch the cache.
        // Check if there's already a pending request.
        let lazyData = childNode.lazyData;
        if (lazyData === null) {
            /**
       * Router state with refetch marker added
       */ // TODO-APP: remove ''
            const refetchTree = walkAddRefetch([
                "",
                ...segmentPath
            ], fullTree);
            const includeNextUrl = hasInterceptionRouteInCurrentTree(fullTree);
            childNode.lazyData = lazyData = fetchServerResponse(new URL(url, location.origin), refetchTree, includeNextUrl ? context.nextUrl : null, buildId);
            childNode.lazyDataResolved = false;
        }
        /**
     * Flight response data
     */ // When the data has not resolved yet `use` will suspend here.
        const serverResponse = use(lazyData);
        if (!childNode.lazyDataResolved) {
            // setTimeout is used to start a new transition during render, this is an intentional hack around React.
            setTimeout(()=>{
                startTransition(()=>{
                    changeByServerResponse({
                        previousTree: fullTree,
                        serverResponse
                    });
                });
            });
            // It's important that we mark this as resolved, in case this branch is replayed, we don't want to continously re-apply
            // the patch to the tree.
            childNode.lazyDataResolved = true;
        }
        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.
        // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.
        use(unresolvedThenable);
    }
    // If we get to this point, then we know we have something we can render.
    const subtree = /*#__PURE__*/ _jsx(LayoutRouterContext.Provider, {
        value: {
            tree: tree[1][parallelRouterKey],
            childNodes: childNode.parallelRoutes,
            // TODO-APP: overriding of url for parallel routes
            url: url,
            loading: childNode.loading
        },
        children: resolvedRsc
    });
    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`
    return subtree;
}
/**
 * Renders suspense boundary with the provided "loading" property as the fallback.
 * If no loading property is provided it renders the children without a suspense boundary.
 */ function LoadingBoundary(param) {
    let { children, hasLoading, loading, loadingStyles, loadingScripts } = param;
    // We have an explicit prop for checking if `loading` is provided, to disambiguate between a loading
    // component that returns `null` / `undefined`, vs not having a loading component at all.
    if (hasLoading) {
        return /*#__PURE__*/ _jsx(Suspense, {
            fallback: /*#__PURE__*/ _jsxs(_Fragment, {
                children: [
                    loadingStyles,
                    loadingScripts,
                    loading
                ]
            }),
            children: children
        });
    }
    return /*#__PURE__*/ _jsx(_Fragment, {
        children: children
    });
}
/**
 * OuterLayoutRouter handles the current segment as well as <Offscreen> rendering of other segments.
 * It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.
 */ export default function OuterLayoutRouter(param) {
    let { parallelRouterKey, segmentPath, error, errorStyles, errorScripts, templateStyles, templateScripts, template, notFound, notFoundStyles, styles } = param;
    const context = useContext(LayoutRouterContext);
    if (!context) {
        throw new Error("invariant expected layout router to be mounted");
    }
    const { childNodes, tree, url, loading } = context;
    // Get the current parallelRouter cache node
    let childNodesForParallelRouter = childNodes.get(parallelRouterKey);
    // If the parallel router cache node does not exist yet, create it.
    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.
    if (!childNodesForParallelRouter) {
        childNodesForParallelRouter = new Map();
        childNodes.set(parallelRouterKey, childNodesForParallelRouter);
    }
    // Get the active segment in the tree
    // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.
    const treeSegment = tree[1][parallelRouterKey][0];
    // If segment is an array it's a dynamic route and we want to read the dynamic route value as the segment to get from the cache.
    const currentChildSegmentValue = getSegmentValue(treeSegment);
    /**
   * Decides which segments to keep rendering, all segments that are not active will be wrapped in `<Offscreen>`.
   */ // TODO-APP: Add handling of `<Offscreen>` when it's available.
    const preservedSegments = [
        treeSegment
    ];
    return /*#__PURE__*/ _jsxs(_Fragment, {
        children: [
            styles,
            preservedSegments.map((preservedSegment)=>{
                const preservedSegmentValue = getSegmentValue(preservedSegment);
                const cacheKey = createRouterCacheKey(preservedSegment);
                return(/*
            - Error boundary
              - Only renders error boundary if error component is provided.
              - Rendered for each segment to ensure they have their own error state.
            - Loading boundary
              - Only renders suspense boundary if loading components is provided.
              - Rendered for each segment to ensure they have their own loading state.
              - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.
          */ /*#__PURE__*/ _jsxs(TemplateContext.Provider, {
                    value: /*#__PURE__*/ _jsx(ScrollAndFocusHandler, {
                        segmentPath: segmentPath,
                        children: /*#__PURE__*/ _jsx(ErrorBoundary, {
                            errorComponent: error,
                            errorStyles: errorStyles,
                            errorScripts: errorScripts,
                            children: /*#__PURE__*/ _jsx(LoadingBoundary, {
                                hasLoading: Boolean(loading),
                                loading: loading == null ? void 0 : loading[0],
                                loadingStyles: loading == null ? void 0 : loading[1],
                                loadingScripts: loading == null ? void 0 : loading[2],
                                children: /*#__PURE__*/ _jsx(NotFoundBoundary, {
                                    notFound: notFound,
                                    notFoundStyles: notFoundStyles,
                                    children: /*#__PURE__*/ _jsx(RedirectBoundary, {
                                        children: /*#__PURE__*/ _jsx(InnerLayoutRouter, {
                                            parallelRouterKey: parallelRouterKey,
                                            url: url,
                                            tree: tree,
                                            childNodes: childNodesForParallelRouter,
                                            segmentPath: segmentPath,
                                            cacheKey: cacheKey,
                                            isActive: currentChildSegmentValue === preservedSegmentValue
                                        })
                                    })
                                })
                            })
                        })
                    }),
                    children: [
                        templateStyles,
                        templateScripts,
                        template
                    ]
                }, createRouterCacheKey(preservedSegment, true)));
            })
        ]
    });
} //# sourceMappingURL=layout-router.js.map
ú%  {"version":3,"sources":["webpack://../../../src/client/components/layout-router.tsx"],"names":["React","useContext","use","startTransition","_Fragment","useDeferredValue","ReactDOM","Suspense","LayoutRouterContext","GlobalLayoutRouterContext","fetchServerResponse","TemplateContext","unresolvedThenable","ErrorBoundary","matchSegment","handleSmoothScroll","RedirectBoundary","NotFoundBoundary","getSegmentValue","createRouterCacheKey","hasInterceptionRouteInCurrentTree","segmentPathToWalk","treeToRecreate","parallelRouteKey","isLast","length","segment","hasOwnProperty","subTree","walkAddRefetch","undefined","slice","findDOMNode","instance","process","originalConsoleError","error","console","messages","rectProperties","shouldSkipElement","element","includes","position","warn","rect","item","every","getBoundingClientRect","top","viewportHeight","getHashFragmentDomNode","hashFragment","body","document","_document_getElementById","getElementById","getElementsByName","componentDidMount","Component","handlePotentialScroll","componentDidUpdate","apply","render","props","children","focusAndScrollRef","segmentPath","segmentPaths","some","scrollRefSegmentPath","index","domNode","Element","HTMLElement","nextElementSibling","scrollIntoView","htmlElement","clientHeight","topOfElementInViewport","scrollTop","dontForceLayout","onlyHashChange","focus","ScrollAndFocusHandler","param","context","Error","parallelRouterKey","url","childNodes","tree","cacheKey","buildId","changeByServerResponse","fullTree","childNode","get","newLazyCacheNode","lazyData","rsc","prefetchRsc","head","prefetchHead","parallelRoutes","lazyDataResolved","Map","loading","set","resolvedPrefetchRsc","resolvedRsc","then","refetchTree","URL","location","origin","includeNextUrl","nextUrl","setTimeout","serverResponse","_jsx","Provider","subtree","hasLoading","loadingStyles","loadingScripts","fallback","OuterLayoutRouter","errorStyles","childNodesForParallelRouter","treeSegment","currentChildSegmentValue","styles","preservedSegments","preservedSegmentValue","preservedSegment","value","errorComponent","errorScripts","Boolean","notFound","notFoundStyles","InnerLayoutRouter","isActive","templateStyles","templateScripts","template"],"mappings":"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","file":"x"}5  false61146undefined148239undefined241273undefined275407undefined409485undefined487545undefined547595undefined597644undefined646733undefined735789undefined791846undefined848925undefined9271006undefined10081124undefined15271538__WEBPACK_MODULE_REFERENCE__7_5b226d617463685365676d656e74225d_call_directImport_asiSafe1__._undefined28602886trueundefined29712999falseundefined30023680{}undefined36933700__WEBPACK_MODULE_REFERENCE__2_5b2264656661756c74225d_call_asiSafe1__._undefined43204349falseundefined43524489{}undefined58835897__WEBPACK_MODULE_REFERENCE__1_5b2264656661756c74222c22436f6d706f6e656e74225d_asiSafe1__._undefined70747085__WEBPACK_MODULE_REFERENCE__7_5b226d617463685365676d656e74225d_call_directImport_asiSafe1__._undefined87998816__WEBPACK_MODULE_REFERENCE__8_5b2268616e646c65536d6f6f74685363726f6c6c225d_call_directImport_asiSafe1__._undefined1099911008__WEBPACK_MODULE_REFERENCE__1_5b22757365436f6e74657874225d_call_directImport_asiSafe1__._undefined1101011034__WEBPACK_MODULE_REFERENCE__3_5b22476c6f62616c4c61796f7574526f75746572436f6e74657874225d_directImport_asiSafe1__._undefined1116011163__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1156611575__WEBPACK_MODULE_REFERENCE__1_5b22757365436f6e74657874225d_call_directImport_asiSafe1__._undefined1157711601__WEBPACK_MODULE_REFERENCE__3_5b22476c6f62616c4c61796f7574526f75746572436f6e74657874225d_directImport_asiSafe1__._undefined1336213377__WEBPACK_MODULE_REFERENCE__1_5b22757365446566657272656456616c7565225d_call_directImport_asiSafe1__._undefined1378013782__WEBPACK_MODULE_REFERENCE__1_5b22757365225d_call_directImport_asiSafe1__._undefined1441214444__WEBPACK_MODULE_REFERENCE__14_5b22686173496e74657263657074696f6e526f757465496e43757272656e7454726565225d_call_directImport_asiSafe1__._undefined1450114519__WEBPACK_MODULE_REFERENCE__4_5b226665746368536572766572526573706f6e7365225d_call_directImport_asiSafe1__._undefined1481614818__WEBPACK_MODULE_REFERENCE__1_5b22757365225d_call_directImport_asiSafe1__._undefined1503615050__WEBPACK_MODULE_REFERENCE__1_5b2273746172745472616e736974696f6e225d_call_directImport_asiSafe1__._undefined1573715739__WEBPACK_MODULE_REFERENCE__1_5b22757365225d_call_directImport_asiSafe1__._undefined1574115758__WEBPACK_MODULE_REFERENCE__5_5b22756e7265736f6c7665645468656e61626c65225d_directImport_asiSafe1__._undefined1588015883__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1588515903__WEBPACK_MODULE_REFERENCE__3_5b224c61796f7574526f75746572436f6e74657874225d_asiSafe1__._undefined1685916862__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1686416871__WEBPACK_MODULE_REFERENCE__1_5b2253757370656e7365225d_directImport_asiSafe1__._undefined1691216916__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined1691816926__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined1716617169__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined1717117179__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined1743917453undefined1767317682__WEBPACK_MODULE_REFERENCE__1_5b22757365436f6e74657874225d_call_directImport_asiSafe1__._undefined1768417702__WEBPACK_MODULE_REFERENCE__3_5b224c61796f7574526f75746572436f6e74657874225d_directImport_asiSafe1__._undefined1879618810__WEBPACK_MODULE_REFERENCE__11_5b226765745365676d656e7456616c7565225d_call_directImport_asiSafe1__._undefined1910219106__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined1910819116__WEBPACK_MODULE_REFERENCE__0_5b22467261676d656e74225d_directImport_asiSafe1__._undefined1926319277__WEBPACK_MODULE_REFERENCE__11_5b226765745365676d656e7456616c7565225d_call_directImport_asiSafe1__._undefined1933119350__WEBPACK_MODULE_REFERENCE__12_5b22637265617465526f7574657243616368654b6579225d_call_directImport_asiSafe1__._undefined1994419948__WEBPACK_MODULE_REFERENCE__0_5b226a737873225d_call_directImport_asiSafe1__._undefined1995019964__WEBPACK_MODULE_REFERENCE__3_5b2254656d706c617465436f6e74657874225d_asiSafe1__._undefined2001920022__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2014720150__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2015220164__WEBPACK_MODULE_REFERENCE__6_5b224572726f72426f756e64617279225d_directImport_asiSafe1__._undefined2038220385__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2077720780__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2078220797__WEBPACK_MODULE_REFERENCE__10_5b224e6f74466f756e64426f756e64617279225d_directImport_asiSafe1__._undefined2098620989__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2099121006__WEBPACK_MODULE_REFERENCE__9_5b225265646972656374426f756e64617279225d_directImport_asiSafe1__._undefined2107521078__WEBPACK_MODULE_REFERENCE__0_5b226a7378225d_call_directImport_asiSafe1__._undefined2200322022__WEBPACK_MODULE_REFERENCE__12_5b22637265617465526f7574657243616368654b6579225d_call_directImport_asiSafe1__._undefined`-_Ü  8  Ï    ú  R  ë  G  ù  a  è$  @%  B%  ³%  1&  {&  (  f(  h(  Ù(  º/  0  ±1  û1  q4  ø4  15  ›5  Ä6  7  è7  J8  _ù:  C;  E;  ¨;  "<  l<  n<  Æ<  ‚@  Ì@  Î@  A  FA  ’A  ”A  ãA  ÓB  C  C  nC  ME  ¥E  §E  F  RJ  µJ  ÙK  %L  'L  vL  	M  lM  Y¢M  N  aP  ­P  ¯P  ÿP  6Q  €Q  ýQ  GR  IR  ¢R  |S  ÆS  NU  ˜U  šU  úU  ·V  W  W  bW  §W  ñW  Ž[  û[  ¦(0,match_segments/* matchSegment */.j)•server_rendering_stubreact.Componentý ÿÿÿ”(0,react.useContext)»app_router_context_shared_runtime.GlobalLayoutRouterContext“(0,jsx_runtime.jsx)ýþš(0,react.useDeferredValue)(0,react.use)Oÿÿÿ´(0,fetch_server_response/* fetchServerResponse */.Y)þ™(0,react.startTransition)ý­unresolved_thenable/* unresolvedThenable */.cúµapp_router_context_shared_runtime.LayoutRouterContextùŽreact.Suspense”(0,jsx_runtime.jsxs)”jsx_runtime.Fragmentöÿôü2ÿÿÿþÿ2ÿÿÿ·(0,create_router_cache_key/* createRouterCacheKey */.d)ý±app_router_context_shared_runtime.TemplateContextôôœerror_boundary.ErrorBoundaryóó£not_found_boundary.NotFoundBoundaryò©redirect_boundary/* RedirectBoundary */.Iñû€†buffer†source„size„maps„hashëb  // ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ OuterLayoutRouter)
});

// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(5486);
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react/index.js
var react = __webpack_require__(2428);
// EXTERNAL MODULE: ./node_modules/next/dist/compiled/react-dom/server-rendering-stub.js
var server_rendering_stub = __webpack_require__(8754);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/shared/lib/app-router-context.shared-runtime.js
var app_router_context_shared_runtime = __webpack_require__(6099);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/fetch-server-response.js
var fetch_server_response = __webpack_require__(10);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/unresolved-thenable.js
var unresolved_thenable = __webpack_require__(3654);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/error-boundary.js + 1 modules
var error_boundary = __webpack_require__(6120);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/match-segments.js
var match_segments = __webpack_require__(393);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/shared/lib/router/utils/handle-smooth-scroll.js
/**
 * Run function with `scroll-behavior: auto` applied to `<html/>`.
 * This css change will be reverted after the function finishes.
 */ function handleSmoothScroll(fn, options) {
    if (options === void 0) options = {};
    // if only the hash is changed, we don't need to disable smooth scrolling
    // we only care to prevent smooth scrolling when navigating to a new page to avoid jarring UX
    if (options.onlyHashChange) {
        fn();
        return;
    }
    const htmlElement = document.documentElement;
    const existing = htmlElement.style.scrollBehavior;
    htmlElement.style.scrollBehavior = "auto";
    if (!options.dontForceLayout) {
        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.
        // Otherwise it will not pickup the change in scrollBehavior
        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042
        htmlElement.getClientRects();
    }
    fn();
    htmlElement.style.scrollBehavior = existing;
} //# sourceMappingURL=handle-smooth-scroll.js.map

// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/redirect-boundary.js
var redirect_boundary = __webpack_require__(7017);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/not-found-boundary.js
var not_found_boundary = __webpack_require__(6212);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/get-segment-value.js
function getSegmentValue(segment) {
    return Array.isArray(segment) ? segment[1] : segment;
} //# sourceMappingURL=get-segment-value.js.map

// EXTERNAL MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/create-router-cache-key.js
var create_router_cache_key = __webpack_require__(2505);
// EXTERNAL MODULE: ./node_modules/next/dist/esm/server/future/helpers/interception-routes.js
var interception_routes = __webpack_require__(117);
;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js

function hasInterceptionRouteInCurrentTree(param) {
    let [segment, parallelRoutes] = param;
    // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.
    if (Array.isArray(segment) && (segment[2] === "di" || segment[2] === "ci")) {
        return true;
    }
    // If segment is not an array, apply the existing string-based check
    if (typeof segment === "string" && (0,interception_routes/* isInterceptionRouteAppPath */.Ag)(segment)) {
        return true;
    }
    // Iterate through parallelRoutes if they exist
    if (parallelRoutes) {
        for(const key in parallelRoutes){
            if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {
                return true;
            }
        }
    }
    return false;
} //# sourceMappingURL=has-interception-route-in-current-tree.js.map

;// CONCATENATED MODULE: ./node_modules/next/dist/esm/client/components/layout-router.js
/* __next_internal_client_entry_do_not_use__ default auto */ 













/**
 * Add refetch marker to router state at the point of the current layout segment.
 * This ensures the response returned is not further down than the current layout segment.
 */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {
    if (segmentPathToWalk) {
        const [segment, parallelRouteKey] = segmentPathToWalk;
        const isLast = segmentPathToWalk.length === 2;
        if ((0,match_segments/* matchSegment */.j)(treeToRecreate[0], segment)) {
            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {
                if (isLast) {
                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);
                    return [
                        treeToRecreate[0],
                        {
                            ...treeToRecreate[1],
                            [parallelRouteKey]: [
                                subTree[0],
                                subTree[1],
                                subTree[2],
                                "refetch"
                            ]
                        }
                    ];
                }
                return [
                    treeToRecreate[0],
                    {
                        ...treeToRecreate[1],
                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])
                    }
                ];
            }
        }
    }
    return treeToRecreate;
}
// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available
/**
 * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning
 */ function findDOMNode(instance) {
    // Tree-shake for server bundle
    if (true) return null;
    // Only apply strict mode warning when not in production
    if (false) {}
    return server_rendering_stub.findDOMNode(instance);
}
const rectProperties = [
    "bottom",
    "height",
    "left",
    "right",
    "top",
    "width",
    "x",
    "y"
];
/**
 * Check if a HTMLElement is hidden or fixed/sticky position
 */ function shouldSkipElement(element) {
    // we ignore fixed or sticky positioned elements since they'll likely pass the "in-viewport" check
    // and will result in a situation we bail on scroll because of something like a fixed nav,
    // even though the actual page content is offscreen
    if ([
        "sticky",
        "fixed"
    ].includes(getComputedStyle(element).position)) {
        if (false) {}
        return true;
    }
    // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`
    // because `offsetParent` doesn't consider document/body
    const rect = element.getBoundingClientRect();
    return rectProperties.every((item)=>rect[item] === 0);
}
/**
 * Check if the top corner of the HTMLElement is in the viewport.
 */ function topOfElementInViewport(element, viewportHeight) {
    const rect = element.getBoundingClientRect();
    return rect.top >= 0 && rect.top <= viewportHeight;
}
/**
 * Find the DOM node for a hash fragment.
 * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.
 * If the hash fragment is an id, the page has to scroll to the element with that id.
 * If the hash fragment is a name, the page has to scroll to the first element with that name.
 */ function getHashFragmentDomNode(hashFragment) {
    // If the hash fragment is `top` the page has to scroll to the top of the page.
    if (hashFragment === "top") {
        return document.body;
    }
    var _document_getElementById;
    // If the hash fragment is an id, the page has to scroll to the element with that id.
    return (_document_getElementById = document.getElementById(hashFragment)) != null ? _document_getElementById : document.getElementsByName(hashFragment)[0];
}
class InnerScrollAndFocusHandler extends react.Component {
    componentDidMount() {
        this.handlePotentialScroll();
    }
    componentDidUpdate() {
        // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.
        if (this.props.focusAndScrollRef.apply) {
            this.handlePotentialScroll();
        }
    }
    render() {
        return this.props.children;
    }
    constructor(...args){
        super(...args);
        this.handlePotentialScroll = ()=>{
            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.
            const { focusAndScrollRef, segmentPath } = this.props;
            if (focusAndScrollRef.apply) {
                // segmentPaths is an array of segment paths that should be scrolled to
                // if the current segment path is not in the array, the scroll is not applied
                // unless the array is empty, in which case the scroll is always applied
                if (focusAndScrollRef.segmentPaths.length !== 0 && !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath)=>segmentPath.every((segment, index)=>(0,match_segments/* matchSegment */.j)(segment, scrollRefSegmentPath[index])))) {
                    return;
                }
                let domNode = null;
                const hashFragment = focusAndScrollRef.hashFragment;
                if (hashFragment) {
                    domNode = getHashFragmentDomNode(hashFragment);
                }
                // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.
                // This already caused a bug where the first child was a <link/> in head.
                if (!domNode) {
                    domNode = findDOMNode(this);
                }
                // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.
                if (!(domNode instanceof Element)) {
                    return;
                }
                // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.
                // If the element is skipped, try to select the next sibling and try again.
                while(!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)){
                    // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.
                    if (domNode.nextElementSibling === null) {
                        return;
                    }
                    domNode = domNode.nextElementSibling;
                }
                // State is mutated to ensure that the focus and scroll is applied only once.
                focusAndScrollRef.apply = false;
                focusAndScrollRef.hashFragment = null;
                focusAndScrollRef.segmentPaths = [];
                handleSmoothScroll(()=>{
                    // In case of hash scroll, we only need to scroll the element into view
                    if (hashFragment) {
                        domNode.scrollIntoView();
                        return;
                    }
                    // Store the current viewport height because reading `clientHeight` causes a reflow,
                    // and it won't change during this function.
                    const htmlElement = document.documentElement;
                    const viewportHeight = htmlElement.clientHeight;
                    // If the element's top edge is already in the viewport, exit early.
                    if (topOfElementInViewport(domNode, viewportHeight)) {
                        return;
                    }
                    // Otherwise, try scrolling go the top of the document to be backward compatible with pages
                    // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)
                    // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left
                    // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically
                    htmlElement.scrollTop = 0;
                    // Scroll to domNode if domNode is not in viewport when scrolled to top of document
                    if (!topOfElementInViewport(domNode, viewportHeight)) {
                        domNode.scrollIntoView();
                    }
                }, {
                    // We will force layout by querying domNode position
                    dontForceLayout: true,
                    onlyHashChange: focusAndScrollRef.onlyHashChange
                });
                // Mutate after scrolling so that it can be read by `handleSmoothScroll`
                focusAndScrollRef.onlyHashChange = false;
                // Set focus on the element
                domNode.focus();
            }
        };
    }
}
function ScrollAndFocusHandler(param) {
    let { segmentPath, children } = param;
    const context = (0,react.useContext)(app_router_context_shared_runtime.GlobalLayoutRouterContext);
    if (!context) {
        throw new Error("invariant global layout router not mounted");
    }
    return /*#